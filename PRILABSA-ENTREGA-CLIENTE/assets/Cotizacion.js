const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/CotizacionPDF.js","assets/index.js","assets/vendor.js","assets/react.js","assets/index.css","assets/oficinasData.js","assets/shopping-cart.js","assets/plus.js","assets/file-down.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
import { c as createLucideIcon, j as jsxRuntimeExports, v as useCotizacion, u as useLanguage, L as Layout, d as StaticHero, t as translations, B as Breadcrumbs, _ as __vitePreload } from "./index.js";
import { R as React, r as reactExports, L as Link$1 } from "./vendor.js";
import { g as getDefaultExportFromCjs$2, b as getAugmentedNamespace$2, c as commonjsGlobal$1 } from "./react.js";
import { o as oficinasData } from "./oficinasData.js";
import { S as ShoppingCart } from "./shopping-cart.js";
import { P as Plus } from "./plus.js";
import { F as FileDown } from "./file-down.js";
function _mergeNamespaces(n3, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n3)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n3, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n3, Symbol.toStringTag, { value: "Module" }));
}
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$2 = [["path", { d: "M5 12h14", key: "1ays0h" }]];
const Minus = createLucideIcon("minus", __iconNode$2);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$1 = [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
];
const Send = createLucideIcon("send", __iconNode$1);
/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode = [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
];
const Trash2 = createLucideIcon("trash-2", __iconNode);
const G = "G";
const Svg = "SVG";
const View = "VIEW";
const Text = "TEXT";
const Link = "LINK";
const Page = "PAGE";
const Note = "NOTE";
const Path = "PATH";
const Rect = "RECT";
const Line = "LINE";
const FieldSet = "FIELD_SET";
const TextInput = "TEXT_INPUT";
const Select = "SELECT";
const Checkbox = "CHECKBOX";
const List = "LIST";
const Defs = "DEFS";
const Image = "IMAGE";
const Tspan = "TSPAN";
const Canvas = "CANVAS";
const Circle = "CIRCLE";
const Ellipse = "ELLIPSE";
const Polygon = "POLYGON";
const Document = "DOCUMENT";
const Polyline = "POLYLINE";
const TextInstance = "TEXT_INSTANCE";
const LinearGradient = "LINEAR_GRADIENT";
const RadialGradient = "RADIAL_GRADIENT";
var queue$3 = { exports: {} };
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
var events$1 = { exports: {} };
var hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events$1.exports;
  hasRequiredEvents = 1;
  var R = typeof Reflect === "object" ? Reflect : null;
  var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };
  var ReflectOwnKeys;
  if (R && typeof R.ownKeys === "function") {
    ReflectOwnKeys = R.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target);
    };
  }
  function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
  }
  var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value2) {
    return value2 !== value2;
  };
  function EventEmitter2() {
    EventEmitter2.init.call(this);
  }
  events$1.exports = EventEmitter2;
  events$1.exports.once = once4;
  EventEmitter2.EventEmitter = EventEmitter2;
  EventEmitter2.prototype._events = void 0;
  EventEmitter2.prototype._eventsCount = 0;
  EventEmitter2.prototype._maxListeners = void 0;
  var defaultMaxListeners = 10;
  function checkListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }
  Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
      }
      defaultMaxListeners = arg;
    }
  });
  EventEmitter2.init = function() {
    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter2.prototype.setMaxListeners = function setMaxListeners3(n3) {
    if (typeof n3 !== "number" || n3 < 0 || NumberIsNaN(n3)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n3 + ".");
    }
    this._maxListeners = n3;
    return this;
  };
  function _getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter2.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter2.prototype.getMaxListeners = function getMaxListeners3() {
    return _getMaxListeners(this);
  };
  EventEmitter2.prototype.emit = function emit4(type) {
    var args = [];
    for (var i2 = 1; i2 < arguments.length; i2++) args.push(arguments[i2]);
    var doError = type === "error";
    var events2 = this._events;
    if (events2 !== void 0)
      doError = doError && events2.error === void 0;
    else if (!doError)
      return false;
    if (doError) {
      var er;
      if (args.length > 0)
        er = args[0];
      if (er instanceof Error) {
        throw er;
      }
      var err2 = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
      err2.context = er;
      throw err2;
    }
    var handler = events2[type];
    if (handler === void 0)
      return false;
    if (typeof handler === "function") {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners3 = arrayClone2(handler, len);
      for (var i2 = 0; i2 < len; ++i2)
        ReflectApply(listeners3[i2], this, args);
    }
    return true;
  };
  function _addListener2(target, type, listener, prepend) {
    var m2;
    var events2;
    var existing;
    checkListener(listener);
    events2 = target._events;
    if (events2 === void 0) {
      events2 = target._events = /* @__PURE__ */ Object.create(null);
      target._eventsCount = 0;
    } else {
      if (events2.newListener !== void 0) {
        target.emit(
          "newListener",
          type,
          listener.listener ? listener.listener : listener
        );
        events2 = target._events;
      }
      existing = events2[type];
    }
    if (existing === void 0) {
      existing = events2[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      m2 = _getMaxListeners(target);
      if (m2 > 0 && existing.length > m2 && !existing.warned) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        ProcessEmitWarning(w);
      }
    }
    return target;
  }
  EventEmitter2.prototype.addListener = function addListener4(type, listener) {
    return _addListener2(this, type, listener, false);
  };
  EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
  EventEmitter2.prototype.prependListener = function prependListener4(type, listener) {
    return _addListener2(this, type, listener, true);
  };
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }
  function _onceWrap2(target, type, listener) {
    var state2 = { fired: false, wrapFn: void 0, target, type, listener };
    var wrapped = onceWrapper.bind(state2);
    wrapped.listener = listener;
    state2.wrapFn = wrapped;
    return wrapped;
  }
  EventEmitter2.prototype.once = function once5(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap2(this, type, listener));
    return this;
  };
  EventEmitter2.prototype.prependOnceListener = function prependOnceListener3(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap2(this, type, listener));
    return this;
  };
  EventEmitter2.prototype.removeListener = function removeListener4(type, listener) {
    var list, events2, position, i2, originalListener;
    checkListener(listener);
    events2 = this._events;
    if (events2 === void 0)
      return this;
    list = events2[type];
    if (list === void 0)
      return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else {
        delete events2[type];
        if (events2.removeListener)
          this.emit("removeListener", type, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position = -1;
      for (i2 = list.length - 1; i2 >= 0; i2--) {
        if (list[i2] === listener || list[i2].listener === listener) {
          originalListener = list[i2].listener;
          position = i2;
          break;
        }
      }
      if (position < 0)
        return this;
      if (position === 0)
        list.shift();
      else {
        spliceOne2(list, position);
      }
      if (list.length === 1)
        events2[type] = list[0];
      if (events2.removeListener !== void 0)
        this.emit("removeListener", type, originalListener || listener);
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners4(type) {
    var listeners3, events2, i2;
    events2 = this._events;
    if (events2 === void 0)
      return this;
    if (events2.removeListener === void 0) {
      if (arguments.length === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      } else if (events2[type] !== void 0) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else
          delete events2[type];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys = Object.keys(events2);
      var key;
      for (i2 = 0; i2 < keys.length; ++i2) {
        key = keys[i2];
        if (key === "removeListener") continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
      return this;
    }
    listeners3 = events2[type];
    if (typeof listeners3 === "function") {
      this.removeListener(type, listeners3);
    } else if (listeners3 !== void 0) {
      for (i2 = listeners3.length - 1; i2 >= 0; i2--) {
        this.removeListener(type, listeners3[i2]);
      }
    }
    return this;
  };
  function _listeners(target, type, unwrap) {
    var events2 = target._events;
    if (events2 === void 0)
      return [];
    var evlistener = events2[type];
    if (evlistener === void 0)
      return [];
    if (typeof evlistener === "function")
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners2(evlistener) : arrayClone2(evlistener, evlistener.length);
  }
  EventEmitter2.prototype.listeners = function listeners3(type) {
    return _listeners(this, type, true);
  };
  EventEmitter2.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
  };
  EventEmitter2.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type);
    } else {
      return listenerCount2.call(emitter, type);
    }
  };
  EventEmitter2.prototype.listenerCount = listenerCount2;
  function listenerCount2(type) {
    var events2 = this._events;
    if (events2 !== void 0) {
      var evlistener = events2[type];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener !== void 0) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames3() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };
  function arrayClone2(arr, n3) {
    var copy5 = new Array(n3);
    for (var i2 = 0; i2 < n3; ++i2)
      copy5[i2] = arr[i2];
    return copy5;
  }
  function spliceOne2(list, index2) {
    for (; index2 + 1 < list.length; index2++)
      list[index2] = list[index2 + 1];
    list.pop();
  }
  function unwrapListeners2(arr) {
    var ret = new Array(arr.length);
    for (var i2 = 0; i2 < ret.length; ++i2) {
      ret[i2] = arr[i2].listener || arr[i2];
    }
    return ret;
  }
  function once4(emitter, name) {
    return new Promise(function(resolve2, reject) {
      function errorListener(err2) {
        emitter.removeListener(name, resolver);
        reject(err2);
      }
      function resolver() {
        if (typeof emitter.removeListener === "function") {
          emitter.removeListener("error", errorListener);
        }
        resolve2([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
      if (name !== "error") {
        addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
      }
    });
  }
  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") {
      eventTargetAgnosticAddListener(emitter, "error", handler, flags);
    }
  }
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, function wrapListener(arg) {
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }
        listener(arg);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  }
  return events$1.exports;
}
var hasRequiredQueue;
function requireQueue() {
  if (hasRequiredQueue) return queue$3.exports;
  hasRequiredQueue = 1;
  var inherits2 = requireInherits_browser();
  var EventEmitter2 = requireEvents().EventEmitter;
  queue$3.exports = Queue;
  queue$3.exports.default = Queue;
  function Queue(options) {
    if (!(this instanceof Queue)) {
      return new Queue(options);
    }
    EventEmitter2.call(this);
    options = options || {};
    this.concurrency = options.concurrency || Infinity;
    this.timeout = options.timeout || 0;
    this.autostart = options.autostart || false;
    this.results = options.results || null;
    this.pending = 0;
    this.session = 0;
    this.running = false;
    this.jobs = [];
    this.timers = {};
  }
  inherits2(Queue, EventEmitter2);
  var arrayMethods = [
    "pop",
    "shift",
    "indexOf",
    "lastIndexOf"
  ];
  arrayMethods.forEach(function(method) {
    Queue.prototype[method] = function() {
      return Array.prototype[method].apply(this.jobs, arguments);
    };
  });
  Queue.prototype.slice = function(begin, end2) {
    this.jobs = this.jobs.slice(begin, end2);
    return this;
  };
  Queue.prototype.reverse = function() {
    this.jobs.reverse();
    return this;
  };
  var arrayAddMethods = [
    "push",
    "unshift",
    "splice"
  ];
  arrayAddMethods.forEach(function(method) {
    Queue.prototype[method] = function() {
      var methodResult = Array.prototype[method].apply(this.jobs, arguments);
      if (this.autostart) {
        this.start();
      }
      return methodResult;
    };
  });
  Object.defineProperty(Queue.prototype, "length", {
    get: function() {
      return this.pending + this.jobs.length;
    }
  });
  Queue.prototype.start = function(cb) {
    if (cb) {
      callOnErrorOrEnd.call(this, cb);
    }
    this.running = true;
    if (this.pending >= this.concurrency) {
      return;
    }
    if (this.jobs.length === 0) {
      if (this.pending === 0) {
        done2.call(this);
      }
      return;
    }
    var self2 = this;
    var job = this.jobs.shift();
    var once4 = true;
    var session = this.session;
    var timeoutId = null;
    var didTimeout = false;
    var resultIndex = null;
    var timeout = job.hasOwnProperty("timeout") ? job.timeout : this.timeout;
    function next(err2, result) {
      if (once4 && self2.session === session) {
        once4 = false;
        self2.pending--;
        if (timeoutId !== null) {
          delete self2.timers[timeoutId];
          clearTimeout(timeoutId);
        }
        if (err2) {
          self2.emit("error", err2, job);
        } else if (didTimeout === false) {
          if (resultIndex !== null) {
            self2.results[resultIndex] = Array.prototype.slice.call(arguments, 1);
          }
          self2.emit("success", result, job);
        }
        if (self2.session === session) {
          if (self2.pending === 0 && self2.jobs.length === 0) {
            done2.call(self2);
          } else if (self2.running) {
            self2.start();
          }
        }
      }
    }
    if (timeout) {
      timeoutId = setTimeout(function() {
        didTimeout = true;
        if (self2.listeners("timeout").length > 0) {
          self2.emit("timeout", next, job);
        } else {
          next();
        }
      }, timeout);
      this.timers[timeoutId] = timeoutId;
    }
    if (this.results) {
      resultIndex = this.results.length;
      this.results[resultIndex] = null;
    }
    this.pending++;
    self2.emit("start", job);
    var promise = job(next);
    if (promise && promise.then && typeof promise.then === "function") {
      promise.then(function(result) {
        return next(null, result);
      }).catch(function(err2) {
        return next(err2 || true);
      });
    }
    if (this.running && this.jobs.length > 0) {
      this.start();
    }
  };
  Queue.prototype.stop = function() {
    this.running = false;
  };
  Queue.prototype.end = function(err2) {
    clearTimers.call(this);
    this.jobs.length = 0;
    this.pending = 0;
    done2.call(this, err2);
  };
  function clearTimers() {
    for (var key in this.timers) {
      var timeoutId = this.timers[key];
      delete this.timers[key];
      clearTimeout(timeoutId);
    }
  }
  function callOnErrorOrEnd(cb) {
    var self2 = this;
    this.on("error", onerror);
    this.on("end", onend2);
    function onerror(err2) {
      self2.end(err2);
    }
    function onend2(err2) {
      self2.removeListener("error", onerror);
      self2.removeListener("end", onend2);
      cb(err2, this.results);
    }
  }
  function done2(err2) {
    this.session++;
    this.running = false;
    this.emit("end", err2);
  }
  return queue$3.exports;
}
var queueExports = requireQueue();
const queue$2 = /* @__PURE__ */ getDefaultExportFromCjs$2(queueExports);
const ENCODING_MAPPING = {
  utf16le: "utf-16le",
  ucs2: "utf-16le",
  utf16be: "utf-16be"
};
class DecodeStream {
  constructor(buffer) {
    this.buffer = buffer;
    this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    this.pos = 0;
    this.length = this.buffer.length;
  }
  readString(length2, encoding = "ascii") {
    encoding = ENCODING_MAPPING[encoding] || encoding;
    let buf = this.readBuffer(length2);
    try {
      let decoder2 = new TextDecoder(encoding);
      return decoder2.decode(buf);
    } catch (err2) {
      return buf;
    }
  }
  readBuffer(length2) {
    return this.buffer.slice(this.pos, this.pos += length2);
  }
  readUInt24BE() {
    return (this.readUInt16BE() << 8) + this.readUInt8();
  }
  readUInt24LE() {
    return this.readUInt16LE() + (this.readUInt8() << 16);
  }
  readInt24BE() {
    return (this.readInt16BE() << 8) + this.readUInt8();
  }
  readInt24LE() {
    return this.readUInt16LE() + (this.readInt8() << 16);
  }
}
DecodeStream.TYPES = {
  UInt8: 1,
  UInt16: 2,
  UInt24: 3,
  UInt32: 4,
  Int8: 1,
  Int16: 2,
  Int24: 3,
  Int32: 4,
  Float: 4,
  Double: 8
};
for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
  if (key.slice(0, 3) === "get") {
    let type = key.slice(3).replace("Ui", "UI");
    if (type === "Float32") {
      type = "Float";
    } else if (type === "Float64") {
      type = "Double";
    }
    let bytes = DecodeStream.TYPES[type];
    DecodeStream.prototype["read" + type + (bytes === 1 ? "" : "BE")] = function() {
      const ret = this.view[key](this.pos, false);
      this.pos += bytes;
      return ret;
    };
    if (bytes !== 1) {
      DecodeStream.prototype["read" + type + "LE"] = function() {
        const ret = this.view[key](this.pos, true);
        this.pos += bytes;
        return ret;
      };
    }
  }
}
const textEncoder = new TextEncoder();
const isBigEndian = new Uint8Array(new Uint16Array([4660]).buffer)[0] == 18;
class EncodeStream {
  constructor(buffer) {
    this.buffer = buffer;
    this.view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
    this.pos = 0;
  }
  writeBuffer(buffer) {
    this.buffer.set(buffer, this.pos);
    this.pos += buffer.length;
  }
  writeString(string, encoding = "ascii") {
    let buf;
    switch (encoding) {
      case "utf16le":
      case "utf16-le":
      case "ucs2":
        buf = stringToUtf16(string, isBigEndian);
        break;
      case "utf16be":
      case "utf16-be":
        buf = stringToUtf16(string, !isBigEndian);
        break;
      case "utf8":
        buf = textEncoder.encode(string);
        break;
      case "ascii":
        buf = stringToAscii(string);
        break;
      default:
        throw new Error(`Unsupported encoding: ${encoding}`);
    }
    this.writeBuffer(buf);
  }
  writeUInt24BE(val) {
    this.buffer[this.pos++] = val >>> 16 & 255;
    this.buffer[this.pos++] = val >>> 8 & 255;
    this.buffer[this.pos++] = val & 255;
  }
  writeUInt24LE(val) {
    this.buffer[this.pos++] = val & 255;
    this.buffer[this.pos++] = val >>> 8 & 255;
    this.buffer[this.pos++] = val >>> 16 & 255;
  }
  writeInt24BE(val) {
    if (val >= 0) {
      this.writeUInt24BE(val);
    } else {
      this.writeUInt24BE(val + 16777215 + 1);
    }
  }
  writeInt24LE(val) {
    if (val >= 0) {
      this.writeUInt24LE(val);
    } else {
      this.writeUInt24LE(val + 16777215 + 1);
    }
  }
  fill(val, length2) {
    if (length2 < this.buffer.length) {
      this.buffer.fill(val, this.pos, this.pos + length2);
      this.pos += length2;
    } else {
      const buf = new Uint8Array(length2);
      buf.fill(val);
      this.writeBuffer(buf);
    }
  }
}
function stringToUtf16(string, swap2) {
  let buf = new Uint16Array(string.length);
  for (let i2 = 0; i2 < string.length; i2++) {
    let code = string.charCodeAt(i2);
    if (swap2) {
      code = code >> 8 | (code & 255) << 8;
    }
    buf[i2] = code;
  }
  return new Uint8Array(buf.buffer);
}
function stringToAscii(string) {
  let buf = new Uint8Array(string.length);
  for (let i2 = 0; i2 < string.length; i2++) {
    buf[i2] = string.charCodeAt(i2);
  }
  return buf;
}
for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
  if (key.slice(0, 3) === "set") {
    let type = key.slice(3).replace("Ui", "UI");
    if (type === "Float32") {
      type = "Float";
    } else if (type === "Float64") {
      type = "Double";
    }
    let bytes = DecodeStream.TYPES[type];
    EncodeStream.prototype["write" + type + (bytes === 1 ? "" : "BE")] = function(value2) {
      this.view[key](this.pos, value2, false);
      this.pos += bytes;
    };
    if (bytes !== 1) {
      EncodeStream.prototype["write" + type + "LE"] = function(value2) {
        this.view[key](this.pos, value2, true);
        this.pos += bytes;
      };
    }
  }
}
class Base {
  fromBuffer(buffer) {
    let stream2 = new DecodeStream(buffer);
    return this.decode(stream2);
  }
  toBuffer(value2) {
    let size = this.size(value2);
    let buffer = new Uint8Array(size);
    let stream2 = new EncodeStream(buffer);
    this.encode(stream2, value2);
    return buffer;
  }
}
class NumberT extends Base {
  constructor(type, endian = "BE") {
    super();
    this.type = type;
    this.endian = endian;
    this.fn = this.type;
    if (this.type[this.type.length - 1] !== "8") {
      this.fn += this.endian;
    }
  }
  size() {
    return DecodeStream.TYPES[this.type];
  }
  decode(stream2) {
    return stream2[`read${this.fn}`]();
  }
  encode(stream2, val) {
    return stream2[`write${this.fn}`](val);
  }
}
const uint8 = new NumberT("UInt8");
const uint16be = new NumberT("UInt16", "BE");
const uint16 = uint16be;
const uint16le = new NumberT("UInt16", "LE");
const uint24be = new NumberT("UInt24", "BE");
const uint24 = uint24be;
new NumberT("UInt24", "LE");
const uint32be = new NumberT("UInt32", "BE");
const uint32 = uint32be;
const uint32le = new NumberT("UInt32", "LE");
const int8 = new NumberT("Int8");
const int16be = new NumberT("Int16", "BE");
const int16 = int16be;
new NumberT("Int16", "LE");
new NumberT("Int24", "BE");
new NumberT("Int24", "LE");
const int32be = new NumberT("Int32", "BE");
const int32 = int32be;
new NumberT("Int32", "LE");
new NumberT("Float", "BE");
new NumberT("Float", "LE");
new NumberT("Double", "BE");
new NumberT("Double", "LE");
class Fixed extends NumberT {
  constructor(size, endian, fracBits = size >> 1) {
    super(`Int${size}`, endian);
    this._point = 1 << fracBits;
  }
  decode(stream2) {
    return super.decode(stream2) / this._point;
  }
  encode(stream2, val) {
    return super.encode(stream2, val * this._point | 0);
  }
}
const fixed16be = new Fixed(16, "BE");
const fixed16 = fixed16be;
new Fixed(16, "LE");
const fixed32be = new Fixed(32, "BE");
const fixed32 = fixed32be;
new Fixed(32, "LE");
function resolveLength(length2, stream2, parent) {
  let res;
  if (typeof length2 === "number") {
    res = length2;
  } else if (typeof length2 === "function") {
    res = length2.call(parent, parent);
  } else if (parent && typeof length2 === "string") {
    res = parent[length2];
  } else if (stream2 && length2 instanceof NumberT) {
    res = length2.decode(stream2);
  }
  if (isNaN(res)) {
    throw new Error("Not a fixed size");
  }
  return res;
}
class PropertyDescriptor {
  constructor(opts2 = {}) {
    this.enumerable = true;
    this.configurable = true;
    for (let key in opts2) {
      const val = opts2[key];
      this[key] = val;
    }
  }
}
class ArrayT extends Base {
  constructor(type, length2, lengthType = "count") {
    super();
    this.type = type;
    this.length = length2;
    this.lengthType = lengthType;
  }
  decode(stream2, parent) {
    let length2;
    const { pos } = stream2;
    const res = [];
    let ctx = parent;
    if (this.length != null) {
      length2 = resolveLength(this.length, stream2, parent);
    }
    if (this.length instanceof NumberT) {
      Object.defineProperties(res, {
        parent: { value: parent },
        _startOffset: { value: pos },
        _currentOffset: { value: 0, writable: true },
        _length: { value: length2 }
      });
      ctx = res;
    }
    if (length2 == null || this.lengthType === "bytes") {
      const target = length2 != null ? stream2.pos + length2 : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream2.length;
      while (stream2.pos < target) {
        res.push(this.type.decode(stream2, ctx));
      }
    } else {
      for (let i2 = 0, end2 = length2; i2 < end2; i2++) {
        res.push(this.type.decode(stream2, ctx));
      }
    }
    return res;
  }
  size(array, ctx, includePointers = true) {
    if (!array) {
      return this.type.size(null, ctx) * resolveLength(this.length, null, ctx);
    }
    let size = 0;
    if (this.length instanceof NumberT) {
      size += this.length.size();
      ctx = { parent: ctx, pointerSize: 0 };
    }
    for (let item of array) {
      size += this.type.size(item, ctx);
    }
    if (ctx && includePointers && this.length instanceof NumberT) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, array, parent) {
    let ctx = parent;
    if (this.length instanceof NumberT) {
      ctx = {
        pointers: [],
        startOffset: stream2.pos,
        parent
      };
      ctx.pointerOffset = stream2.pos + this.size(array, ctx, false);
      this.length.encode(stream2, array.length);
    }
    for (let item of array) {
      this.type.encode(stream2, item, ctx);
    }
    if (this.length instanceof NumberT) {
      let i2 = 0;
      while (i2 < ctx.pointers.length) {
        const ptr = ctx.pointers[i2++];
        ptr.type.encode(stream2, ptr.val, ptr.parent);
      }
    }
  }
}
class LazyArray extends ArrayT {
  decode(stream2, parent) {
    const { pos } = stream2;
    const length2 = resolveLength(this.length, stream2, parent);
    if (this.length instanceof NumberT) {
      parent = {
        parent,
        _startOffset: pos,
        _currentOffset: 0,
        _length: length2
      };
    }
    const res = new LazyArrayValue(this.type, length2, stream2, parent);
    stream2.pos += length2 * this.type.size(null, parent);
    return res;
  }
  size(val, ctx) {
    if (val instanceof LazyArrayValue) {
      val = val.toArray();
    }
    return super.size(val, ctx);
  }
  encode(stream2, val, ctx) {
    if (val instanceof LazyArrayValue) {
      val = val.toArray();
    }
    return super.encode(stream2, val, ctx);
  }
}
class LazyArrayValue {
  constructor(type, length2, stream2, ctx) {
    this.type = type;
    this.length = length2;
    this.stream = stream2;
    this.ctx = ctx;
    this.base = this.stream.pos;
    this.items = [];
  }
  get(index2) {
    if (index2 < 0 || index2 >= this.length) {
      return void 0;
    }
    if (this.items[index2] == null) {
      const { pos } = this.stream;
      this.stream.pos = this.base + this.type.size(null, this.ctx) * index2;
      this.items[index2] = this.type.decode(this.stream, this.ctx);
      this.stream.pos = pos;
    }
    return this.items[index2];
  }
  toArray() {
    const result = [];
    for (let i2 = 0, end2 = this.length; i2 < end2; i2++) {
      result.push(this.get(i2));
    }
    return result;
  }
}
class Bitfield extends Base {
  constructor(type, flags = []) {
    super();
    this.type = type;
    this.flags = flags;
  }
  decode(stream2) {
    const val = this.type.decode(stream2);
    const res = {};
    for (let i2 = 0; i2 < this.flags.length; i2++) {
      const flag = this.flags[i2];
      if (flag != null) {
        res[flag] = !!(val & 1 << i2);
      }
    }
    return res;
  }
  size() {
    return this.type.size();
  }
  encode(stream2, keys) {
    let val = 0;
    for (let i2 = 0; i2 < this.flags.length; i2++) {
      const flag = this.flags[i2];
      if (flag != null) {
        if (keys[flag]) {
          val |= 1 << i2;
        }
      }
    }
    return this.type.encode(stream2, val);
  }
}
class BufferT extends Base {
  constructor(length2) {
    super();
    this.length = length2;
  }
  decode(stream2, parent) {
    const length2 = resolveLength(this.length, stream2, parent);
    return stream2.readBuffer(length2);
  }
  size(val, parent) {
    if (!val) {
      return resolveLength(this.length, null, parent);
    }
    let len = val.length;
    if (this.length instanceof NumberT) {
      len += this.length.size();
    }
    return len;
  }
  encode(stream2, buf, parent) {
    if (this.length instanceof NumberT) {
      this.length.encode(stream2, buf.length);
    }
    return stream2.writeBuffer(buf);
  }
}
class Optional extends Base {
  constructor(type, condition = true) {
    super();
    this.type = type;
    this.condition = condition;
  }
  decode(stream2, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.decode(stream2, parent);
    }
  }
  size(val, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.size(val, parent);
    } else {
      return 0;
    }
  }
  encode(stream2, val, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.encode(stream2, val, parent);
    }
  }
}
class Reserved extends Base {
  constructor(type, count = 1) {
    super();
    this.type = type;
    this.count = count;
  }
  decode(stream2, parent) {
    stream2.pos += this.size(null, parent);
    return void 0;
  }
  size(data2, parent) {
    const count = resolveLength(this.count, null, parent);
    return this.type.size() * count;
  }
  encode(stream2, val, parent) {
    return stream2.fill(0, this.size(val, parent));
  }
}
class StringT extends Base {
  constructor(length2, encoding = "ascii") {
    super();
    this.length = length2;
    this.encoding = encoding;
  }
  decode(stream2, parent) {
    let length2, pos;
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent, parent) || "ascii";
    }
    let width = encodingWidth(encoding);
    if (this.length != null) {
      length2 = resolveLength(this.length, stream2, parent);
    } else {
      let buffer;
      ({ buffer, length: length2, pos } = stream2);
      while (pos < length2 - width + 1 && (buffer[pos] !== 0 || width === 2 && buffer[pos + 1] !== 0)) {
        pos += width;
      }
      length2 = pos - stream2.pos;
    }
    const string = stream2.readString(length2, encoding);
    if (this.length == null && stream2.pos < stream2.length) {
      stream2.pos += width;
    }
    return string;
  }
  size(val, parent) {
    if (val === void 0 || val === null) {
      return resolveLength(this.length, null, parent);
    }
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
    }
    if (encoding === "utf16be") {
      encoding = "utf16le";
    }
    let size = byteLength$3(val, encoding);
    if (this.length instanceof NumberT) {
      size += this.length.size();
    }
    if (this.length == null) {
      size += encodingWidth(encoding);
    }
    return size;
  }
  encode(stream2, val, parent) {
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
    }
    if (this.length instanceof NumberT) {
      this.length.encode(stream2, byteLength$3(val, encoding));
    }
    stream2.writeString(val, encoding);
    if (this.length == null) {
      return encodingWidth(encoding) == 2 ? stream2.writeUInt16LE(0) : stream2.writeUInt8(0);
    }
  }
}
function encodingWidth(encoding) {
  switch (encoding) {
    case "ascii":
    case "utf8":
      return 1;
    case "utf16le":
    case "utf16-le":
    case "utf-16be":
    case "utf-16le":
    case "utf16be":
    case "utf16-be":
    case "ucs2":
      return 2;
    default:
      return 1;
  }
}
function byteLength$3(string, encoding) {
  switch (encoding) {
    case "ascii":
      return string.length;
    case "utf8":
      let len = 0;
      for (let i2 = 0; i2 < string.length; i2++) {
        let c2 = string.charCodeAt(i2);
        if (c2 >= 55296 && c2 <= 56319 && i2 < string.length - 1) {
          let c22 = string.charCodeAt(++i2);
          if ((c22 & 64512) === 56320) {
            c2 = ((c2 & 1023) << 10) + (c22 & 1023) + 65536;
          } else {
            i2--;
          }
        }
        if ((c2 & 4294967168) === 0) {
          len++;
        } else if ((c2 & 4294965248) === 0) {
          len += 2;
        } else if ((c2 & 4294901760) === 0) {
          len += 3;
        } else if ((c2 & 4292870144) === 0) {
          len += 4;
        }
      }
      return len;
    case "utf16le":
    case "utf16-le":
    case "utf16be":
    case "utf16-be":
    case "ucs2":
      return string.length * 2;
    default:
      throw new Error("Unknown encoding " + encoding);
  }
}
class Struct extends Base {
  constructor(fields = {}) {
    super();
    this.fields = fields;
  }
  decode(stream2, parent, length2 = 0) {
    const res = this._setup(stream2, parent, length2);
    this._parseFields(stream2, res, this.fields);
    if (this.process != null) {
      this.process.call(res, stream2);
    }
    return res;
  }
  _setup(stream2, parent, length2) {
    const res = {};
    Object.defineProperties(res, {
      parent: { value: parent },
      _startOffset: { value: stream2.pos },
      _currentOffset: { value: 0, writable: true },
      _length: { value: length2 }
    });
    return res;
  }
  _parseFields(stream2, res, fields) {
    for (let key in fields) {
      var val;
      const type = fields[key];
      if (typeof type === "function") {
        val = type.call(res, res);
      } else {
        val = type.decode(stream2, res);
      }
      if (val !== void 0) {
        if (val instanceof PropertyDescriptor) {
          Object.defineProperty(res, key, val);
        } else {
          res[key] = val;
        }
      }
      res._currentOffset = stream2.pos - res._startOffset;
    }
  }
  size(val, parent, includePointers = true) {
    if (val == null) {
      val = {};
    }
    const ctx = {
      parent,
      val,
      pointerSize: 0
    };
    if (this.preEncode != null) {
      this.preEncode.call(val);
    }
    let size = 0;
    for (let key in this.fields) {
      const type = this.fields[key];
      if (type.size != null) {
        size += type.size(val[key], ctx);
      }
    }
    if (includePointers) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, val, parent) {
    let type;
    if (this.preEncode != null) {
      this.preEncode.call(val, stream2);
    }
    const ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
    for (let key in this.fields) {
      type = this.fields[key];
      if (type.encode != null) {
        type.encode(stream2, val[key], ctx);
      }
    }
    let i2 = 0;
    while (i2 < ctx.pointers.length) {
      const ptr = ctx.pointers[i2++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
  }
}
const getPath = (object, pathArray) => {
  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);
};
class VersionedStruct extends Struct {
  constructor(type, versions2 = {}) {
    super();
    this.type = type;
    this.versions = versions2;
    if (typeof type === "string") {
      this.versionPath = type.split(".");
    }
  }
  decode(stream2, parent, length2 = 0) {
    const res = this._setup(stream2, parent, length2);
    if (typeof this.type === "string") {
      res.version = getPath(parent, this.versionPath);
    } else {
      res.version = this.type.decode(stream2);
    }
    if (this.versions.header) {
      this._parseFields(stream2, res, this.versions.header);
    }
    const fields = this.versions[res.version];
    if (fields == null) {
      throw new Error(`Unknown version ${res.version}`);
    }
    if (fields instanceof VersionedStruct) {
      return fields.decode(stream2, parent);
    }
    this._parseFields(stream2, res, fields);
    if (this.process != null) {
      this.process.call(res, stream2);
    }
    return res;
  }
  size(val, parent, includePointers = true) {
    let key, type;
    if (!val) {
      throw new Error("Not a fixed size");
    }
    if (this.preEncode != null) {
      this.preEncode.call(val);
    }
    const ctx = {
      parent,
      val,
      pointerSize: 0
    };
    let size = 0;
    if (typeof this.type !== "string") {
      size += this.type.size(val.version, ctx);
    }
    if (this.versions.header) {
      for (key in this.versions.header) {
        type = this.versions.header[key];
        if (type.size != null) {
          size += type.size(val[key], ctx);
        }
      }
    }
    const fields = this.versions[val.version];
    if (fields == null) {
      throw new Error(`Unknown version ${val.version}`);
    }
    for (key in fields) {
      type = fields[key];
      if (type.size != null) {
        size += type.size(val[key], ctx);
      }
    }
    if (includePointers) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, val, parent) {
    let key, type;
    if (this.preEncode != null) {
      this.preEncode.call(val, stream2);
    }
    const ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
    if (typeof this.type !== "string") {
      this.type.encode(stream2, val.version);
    }
    if (this.versions.header) {
      for (key in this.versions.header) {
        type = this.versions.header[key];
        if (type.encode != null) {
          type.encode(stream2, val[key], ctx);
        }
      }
    }
    const fields = this.versions[val.version];
    for (key in fields) {
      type = fields[key];
      if (type.encode != null) {
        type.encode(stream2, val[key], ctx);
      }
    }
    let i2 = 0;
    while (i2 < ctx.pointers.length) {
      const ptr = ctx.pointers[i2++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
  }
}
class Pointer extends Base {
  constructor(offsetType, type, options = {}) {
    super();
    this.offsetType = offsetType;
    this.type = type;
    this.options = options;
    if (this.type === "void") {
      this.type = null;
    }
    if (this.options.type == null) {
      this.options.type = "local";
    }
    if (this.options.allowNull == null) {
      this.options.allowNull = true;
    }
    if (this.options.nullValue == null) {
      this.options.nullValue = 0;
    }
    if (this.options.lazy == null) {
      this.options.lazy = false;
    }
    if (this.options.relativeTo) {
      if (typeof this.options.relativeTo !== "function") {
        throw new Error("relativeTo option must be a function");
      }
      this.relativeToGetter = options.relativeTo;
    }
  }
  decode(stream2, ctx) {
    const offset2 = this.offsetType.decode(stream2, ctx);
    if (offset2 === this.options.nullValue && this.options.allowNull) {
      return null;
    }
    let relative;
    switch (this.options.type) {
      case "local":
        relative = ctx._startOffset;
        break;
      case "immediate":
        relative = stream2.pos - this.offsetType.size();
        break;
      case "parent":
        relative = ctx.parent._startOffset;
        break;
      default:
        var c2 = ctx;
        while (c2.parent) {
          c2 = c2.parent;
        }
        relative = c2._startOffset || 0;
    }
    if (this.options.relativeTo) {
      relative += this.relativeToGetter(ctx);
    }
    const ptr = offset2 + relative;
    if (this.type != null) {
      let val = null;
      const decodeValue = () => {
        if (val != null) {
          return val;
        }
        const { pos } = stream2;
        stream2.pos = ptr;
        val = this.type.decode(stream2, ctx);
        stream2.pos = pos;
        return val;
      };
      if (this.options.lazy) {
        return new PropertyDescriptor({
          get: decodeValue
        });
      }
      return decodeValue();
    } else {
      return ptr;
    }
  }
  size(val, ctx) {
    const parent = ctx;
    switch (this.options.type) {
      case "local":
      case "immediate":
        break;
      case "parent":
        ctx = ctx.parent;
        break;
      default:
        while (ctx.parent) {
          ctx = ctx.parent;
        }
    }
    let { type } = this;
    if (type == null) {
      if (!(val instanceof VoidPointer)) {
        throw new Error("Must be a VoidPointer");
      }
      ({ type } = val);
      val = val.value;
    }
    if (val && ctx) {
      let size = type.size(val, parent);
      ctx.pointerSize += size;
    }
    return this.offsetType.size();
  }
  encode(stream2, val, ctx) {
    let relative;
    const parent = ctx;
    if (val == null) {
      this.offsetType.encode(stream2, this.options.nullValue);
      return;
    }
    switch (this.options.type) {
      case "local":
        relative = ctx.startOffset;
        break;
      case "immediate":
        relative = stream2.pos + this.offsetType.size(val, parent);
        break;
      case "parent":
        ctx = ctx.parent;
        relative = ctx.startOffset;
        break;
      default:
        relative = 0;
        while (ctx.parent) {
          ctx = ctx.parent;
        }
    }
    if (this.options.relativeTo) {
      relative += this.relativeToGetter(parent.val);
    }
    this.offsetType.encode(stream2, ctx.pointerOffset - relative);
    let { type } = this;
    if (type == null) {
      if (!(val instanceof VoidPointer)) {
        throw new Error("Must be a VoidPointer");
      }
      ({ type } = val);
      val = val.value;
    }
    ctx.pointers.push({
      type,
      val,
      parent
    });
    return ctx.pointerOffset += type.size(val, parent);
  }
}
class VoidPointer {
  constructor(type, value2) {
    this.type = type;
    this.value = value2;
  }
}
function _define_property(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else obj[key] = value2;
  return obj;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
var fastDeepEqual;
var hasRequiredFastDeepEqual;
function requireFastDeepEqual() {
  if (hasRequiredFastDeepEqual) return fastDeepEqual;
  hasRequiredFastDeepEqual = 1;
  fastDeepEqual = function equal2(a2, b2) {
    if (a2 === b2) return true;
    if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
      if (a2.constructor !== b2.constructor) return false;
      var length2, i2, keys;
      if (Array.isArray(a2)) {
        length2 = a2.length;
        if (length2 != b2.length) return false;
        for (i2 = length2; i2-- !== 0; )
          if (!equal2(a2[i2], b2[i2])) return false;
        return true;
      }
      if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
      if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
      if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
      keys = Object.keys(a2);
      length2 = keys.length;
      if (length2 !== Object.keys(b2).length) return false;
      for (i2 = length2; i2-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b2, keys[i2])) return false;
      for (i2 = length2; i2-- !== 0; ) {
        var key = keys[i2];
        if (!equal2(a2[key], b2[key])) return false;
      }
      return true;
    }
    return a2 !== a2 && b2 !== b2;
  };
  return fastDeepEqual;
}
var fastDeepEqualExports = requireFastDeepEqual();
const $6uUbQ$fastdeepequal = /* @__PURE__ */ getDefaultExportFromCjs$2(fastDeepEqualExports);
var base64Js = {};
var hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js;
  hasRequiredBase64Js = 1;
  base64Js.byteLength = byteLength2;
  base64Js.toByteArray = toByteArray2;
  base64Js.fromByteArray = fromByteArray2;
  var lookup2 = [];
  var revLookup2 = [];
  var Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code.length; i2 < len; ++i2) {
    lookup2[i2] = code[i2];
    revLookup2[code.charCodeAt(i2)] = i2;
  }
  revLookup2["-".charCodeAt(0)] = 62;
  revLookup2["_".charCodeAt(0)] = 63;
  function getLens(b642) {
    var len2 = b642.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b642.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength2(b642) {
    var lens = getLens(b642);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b642, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray2(b642) {
    var tmp;
    var lens = getLens(b642);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr2(_byteLength(b642, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i3;
    for (i3 = 0; i3 < len2; i3 += 4) {
      tmp = revLookup2[b642.charCodeAt(i3)] << 18 | revLookup2[b642.charCodeAt(i3 + 1)] << 12 | revLookup2[b642.charCodeAt(i3 + 2)] << 6 | revLookup2[b642.charCodeAt(i3 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup2[b642.charCodeAt(i3)] << 2 | revLookup2[b642.charCodeAt(i3 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup2[b642.charCodeAt(i3)] << 10 | revLookup2[b642.charCodeAt(i3 + 1)] << 4 | revLookup2[b642.charCodeAt(i3 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase642(num) {
    return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
  }
  function encodeChunk2(uint82, start2, end2) {
    var tmp;
    var output = [];
    for (var i3 = start2; i3 < end2; i3 += 3) {
      tmp = (uint82[i3] << 16 & 16711680) + (uint82[i3 + 1] << 8 & 65280) + (uint82[i3 + 2] & 255);
      output.push(tripletToBase642(tmp));
    }
    return output.join("");
  }
  function fromByteArray2(uint82) {
    var tmp;
    var len2 = uint82.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
      parts.push(encodeChunk2(uint82, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint82[len2 - 1];
      parts.push(
        lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint82[len2 - 2] << 8) + uint82[len2 - 1];
      parts.push(
        lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  return base64Js;
}
var base64JsExports = requireBase64Js();
const $bdjGp$base64js = /* @__PURE__ */ getDefaultExportFromCjs$2(base64JsExports);
var tinyInflate;
var hasRequiredTinyInflate;
function requireTinyInflate() {
  if (hasRequiredTinyInflate) return tinyInflate;
  hasRequiredTinyInflate = 1;
  var TINF_OK = 0;
  var TINF_DATA_ERROR = -3;
  function Tree() {
    this.table = new Uint16Array(16);
    this.trans = new Uint16Array(288);
  }
  function Data(source, dest) {
    this.source = source;
    this.sourceIndex = 0;
    this.tag = 0;
    this.bitcount = 0;
    this.dest = dest;
    this.destLen = 0;
    this.ltree = new Tree();
    this.dtree = new Tree();
  }
  var sltree = new Tree();
  var sdtree = new Tree();
  var length_bits = new Uint8Array(30);
  var length_base = new Uint16Array(30);
  var dist_bits = new Uint8Array(30);
  var dist_base = new Uint16Array(30);
  var clcidx = new Uint8Array([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
  ]);
  var code_tree = new Tree();
  var lengths = new Uint8Array(288 + 32);
  function tinf_build_bits_base(bits, base, delta, first) {
    var i2, sum;
    for (i2 = 0; i2 < delta; ++i2) bits[i2] = 0;
    for (i2 = 0; i2 < 30 - delta; ++i2) bits[i2 + delta] = i2 / delta | 0;
    for (sum = first, i2 = 0; i2 < 30; ++i2) {
      base[i2] = sum;
      sum += 1 << bits[i2];
    }
  }
  function tinf_build_fixed_trees(lt, dt) {
    var i2;
    for (i2 = 0; i2 < 7; ++i2) lt.table[i2] = 0;
    lt.table[7] = 24;
    lt.table[8] = 152;
    lt.table[9] = 112;
    for (i2 = 0; i2 < 24; ++i2) lt.trans[i2] = 256 + i2;
    for (i2 = 0; i2 < 144; ++i2) lt.trans[24 + i2] = i2;
    for (i2 = 0; i2 < 8; ++i2) lt.trans[24 + 144 + i2] = 280 + i2;
    for (i2 = 0; i2 < 112; ++i2) lt.trans[24 + 144 + 8 + i2] = 144 + i2;
    for (i2 = 0; i2 < 5; ++i2) dt.table[i2] = 0;
    dt.table[5] = 32;
    for (i2 = 0; i2 < 32; ++i2) dt.trans[i2] = i2;
  }
  var offs = new Uint16Array(16);
  function tinf_build_tree(t2, lengths2, off2, num) {
    var i2, sum;
    for (i2 = 0; i2 < 16; ++i2) t2.table[i2] = 0;
    for (i2 = 0; i2 < num; ++i2) t2.table[lengths2[off2 + i2]]++;
    t2.table[0] = 0;
    for (sum = 0, i2 = 0; i2 < 16; ++i2) {
      offs[i2] = sum;
      sum += t2.table[i2];
    }
    for (i2 = 0; i2 < num; ++i2) {
      if (lengths2[off2 + i2]) t2.trans[offs[lengths2[off2 + i2]]++] = i2;
    }
  }
  function tinf_getbit(d2) {
    if (!d2.bitcount--) {
      d2.tag = d2.source[d2.sourceIndex++];
      d2.bitcount = 7;
    }
    var bit = d2.tag & 1;
    d2.tag >>>= 1;
    return bit;
  }
  function tinf_read_bits(d2, num, base) {
    if (!num)
      return base;
    while (d2.bitcount < 24) {
      d2.tag |= d2.source[d2.sourceIndex++] << d2.bitcount;
      d2.bitcount += 8;
    }
    var val = d2.tag & 65535 >>> 16 - num;
    d2.tag >>>= num;
    d2.bitcount -= num;
    return val + base;
  }
  function tinf_decode_symbol(d2, t2) {
    while (d2.bitcount < 24) {
      d2.tag |= d2.source[d2.sourceIndex++] << d2.bitcount;
      d2.bitcount += 8;
    }
    var sum = 0, cur = 0, len = 0;
    var tag = d2.tag;
    do {
      cur = 2 * cur + (tag & 1);
      tag >>>= 1;
      ++len;
      sum += t2.table[len];
      cur -= t2.table[len];
    } while (cur >= 0);
    d2.tag = tag;
    d2.bitcount -= len;
    return t2.trans[sum + cur];
  }
  function tinf_decode_trees(d2, lt, dt) {
    var hlit, hdist, hclen;
    var i2, num, length2;
    hlit = tinf_read_bits(d2, 5, 257);
    hdist = tinf_read_bits(d2, 5, 1);
    hclen = tinf_read_bits(d2, 4, 4);
    for (i2 = 0; i2 < 19; ++i2) lengths[i2] = 0;
    for (i2 = 0; i2 < hclen; ++i2) {
      var clen = tinf_read_bits(d2, 3, 0);
      lengths[clcidx[i2]] = clen;
    }
    tinf_build_tree(code_tree, lengths, 0, 19);
    for (num = 0; num < hlit + hdist; ) {
      var sym = tinf_decode_symbol(d2, code_tree);
      switch (sym) {
        case 16:
          var prev = lengths[num - 1];
          for (length2 = tinf_read_bits(d2, 2, 3); length2; --length2) {
            lengths[num++] = prev;
          }
          break;
        case 17:
          for (length2 = tinf_read_bits(d2, 3, 3); length2; --length2) {
            lengths[num++] = 0;
          }
          break;
        case 18:
          for (length2 = tinf_read_bits(d2, 7, 11); length2; --length2) {
            lengths[num++] = 0;
          }
          break;
        default:
          lengths[num++] = sym;
          break;
      }
    }
    tinf_build_tree(lt, lengths, 0, hlit);
    tinf_build_tree(dt, lengths, hlit, hdist);
  }
  function tinf_inflate_block_data(d2, lt, dt) {
    while (1) {
      var sym = tinf_decode_symbol(d2, lt);
      if (sym === 256) {
        return TINF_OK;
      }
      if (sym < 256) {
        d2.dest[d2.destLen++] = sym;
      } else {
        var length2, dist, offs2;
        var i2;
        sym -= 257;
        length2 = tinf_read_bits(d2, length_bits[sym], length_base[sym]);
        dist = tinf_decode_symbol(d2, dt);
        offs2 = d2.destLen - tinf_read_bits(d2, dist_bits[dist], dist_base[dist]);
        for (i2 = offs2; i2 < offs2 + length2; ++i2) {
          d2.dest[d2.destLen++] = d2.dest[i2];
        }
      }
    }
  }
  function tinf_inflate_uncompressed_block(d2) {
    var length2, invlength;
    var i2;
    while (d2.bitcount > 8) {
      d2.sourceIndex--;
      d2.bitcount -= 8;
    }
    length2 = d2.source[d2.sourceIndex + 1];
    length2 = 256 * length2 + d2.source[d2.sourceIndex];
    invlength = d2.source[d2.sourceIndex + 3];
    invlength = 256 * invlength + d2.source[d2.sourceIndex + 2];
    if (length2 !== (~invlength & 65535))
      return TINF_DATA_ERROR;
    d2.sourceIndex += 4;
    for (i2 = length2; i2; --i2)
      d2.dest[d2.destLen++] = d2.source[d2.sourceIndex++];
    d2.bitcount = 0;
    return TINF_OK;
  }
  function tinf_uncompress(source, dest) {
    var d2 = new Data(source, dest);
    var bfinal, btype, res;
    do {
      bfinal = tinf_getbit(d2);
      btype = tinf_read_bits(d2, 2, 0);
      switch (btype) {
        case 0:
          res = tinf_inflate_uncompressed_block(d2);
          break;
        case 1:
          res = tinf_inflate_block_data(d2, sltree, sdtree);
          break;
        case 2:
          tinf_decode_trees(d2, d2.ltree, d2.dtree);
          res = tinf_inflate_block_data(d2, d2.ltree, d2.dtree);
          break;
        default:
          res = TINF_DATA_ERROR;
      }
      if (res !== TINF_OK)
        throw new Error("Data error");
    } while (!bfinal);
    if (d2.destLen < d2.dest.length) {
      if (typeof d2.dest.slice === "function")
        return d2.dest.slice(0, d2.destLen);
      else
        return d2.dest.subarray(0, d2.destLen);
    }
    return d2.dest;
  }
  tinf_build_fixed_trees(sltree, sdtree);
  tinf_build_bits_base(length_bits, length_base, 4, 3);
  tinf_build_bits_base(dist_bits, dist_base, 2, 1);
  length_bits[28] = 0;
  length_base[28] = 258;
  tinyInflate = tinf_uncompress;
  return tinyInflate;
}
var swap_1;
var hasRequiredSwap;
function requireSwap() {
  if (hasRequiredSwap) return swap_1;
  hasRequiredSwap = 1;
  const isBigEndian2 = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18;
  const swap2 = (b2, n3, m2) => {
    let i2 = b2[n3];
    b2[n3] = b2[m2];
    b2[m2] = i2;
  };
  const swap324 = (array) => {
    const len = array.length;
    for (let i2 = 0; i2 < len; i2 += 4) {
      swap2(array, i2, i2 + 3);
      swap2(array, i2 + 1, i2 + 2);
    }
  };
  const swap32LE = (array) => {
    if (isBigEndian2) {
      swap324(array);
    }
  };
  swap_1 = {
    swap32LE
  };
  return swap_1;
}
var unicodeTrie;
var hasRequiredUnicodeTrie;
function requireUnicodeTrie() {
  if (hasRequiredUnicodeTrie) return unicodeTrie;
  hasRequiredUnicodeTrie = 1;
  const inflate2 = requireTinyInflate();
  const { swap32LE } = requireSwap();
  const SHIFT_1 = 6 + 5;
  const SHIFT_2 = 5;
  const SHIFT_1_2 = SHIFT_1 - SHIFT_2;
  const OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
  const INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
  const INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
  const INDEX_SHIFT = 2;
  const DATA_BLOCK_LENGTH = 1 << SHIFT_2;
  const DATA_MASK = DATA_BLOCK_LENGTH - 1;
  const LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
  const LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
  const INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
  const UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
  const UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
  const INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
  const DATA_GRANULARITY = 1 << INDEX_SHIFT;
  class UnicodeTrie {
    constructor(data2) {
      const isBuffer2 = typeof data2.readUInt32BE === "function" && typeof data2.slice === "function";
      if (isBuffer2 || data2 instanceof Uint8Array) {
        let uncompressedLength;
        if (isBuffer2) {
          this.highStart = data2.readUInt32LE(0);
          this.errorValue = data2.readUInt32LE(4);
          uncompressedLength = data2.readUInt32LE(8);
          data2 = data2.slice(12);
        } else {
          const view = new DataView(data2.buffer);
          this.highStart = view.getUint32(0, true);
          this.errorValue = view.getUint32(4, true);
          uncompressedLength = view.getUint32(8, true);
          data2 = data2.subarray(12);
        }
        data2 = inflate2(data2, new Uint8Array(uncompressedLength));
        data2 = inflate2(data2, new Uint8Array(uncompressedLength));
        swap32LE(data2);
        this.data = new Uint32Array(data2.buffer);
      } else {
        ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data2);
      }
    }
    get(codePoint) {
      let index2;
      if (codePoint < 0 || codePoint > 1114111) {
        return this.errorValue;
      }
      if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
        index2 = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
        return this.data[index2];
      }
      if (codePoint <= 65535) {
        index2 = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
        return this.data[index2];
      }
      if (codePoint < this.highStart) {
        index2 = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
        index2 = this.data[index2 + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
        index2 = (index2 << INDEX_SHIFT) + (codePoint & DATA_MASK);
        return this.data[index2];
      }
      return this.data[this.data.length - DATA_GRANULARITY];
    }
  }
  unicodeTrie = UnicodeTrie;
  return unicodeTrie;
}
var unicodeTrieExports = requireUnicodeTrie();
const $hJqJp$unicodetrie = /* @__PURE__ */ getDefaultExportFromCjs$2(unicodeTrieExports);
function $parcel$interopDefault$1(a2) {
  return a2 && a2.__esModule ? a2.default : a2;
}
var $f4087201da764553$exports = {};
$f4087201da764553$exports = JSON.parse('{"categories":["Cc","Zs","Po","Sc","Ps","Pe","Sm","Pd","Nd","Lu","Sk","Pc","Ll","So","Lo","Pi","Cf","No","Pf","Lt","Lm","Mn","Me","Mc","Nl","Zl","Zp","Cs","Co"],"combiningClasses":["Not_Reordered","Above","Above_Right","Below","Attached_Above_Right","Attached_Below","Overlay","Iota_Subscript","Double_Below","Double_Above","Below_Right","Above_Left","CCC10","CCC11","CCC12","CCC13","CCC14","CCC15","CCC16","CCC17","CCC18","CCC19","CCC20","CCC21","CCC22","CCC23","CCC24","CCC25","CCC30","CCC31","CCC32","CCC27","CCC28","CCC29","CCC33","CCC34","CCC35","CCC36","Nukta","Virama","CCC84","CCC91","CCC103","CCC107","CCC118","CCC122","CCC129","CCC130","CCC132","Attached_Above","Below_Left","Left","Kana_Voicing","CCC26","Right"],"scripts":["Common","Latin","Bopomofo","Inherited","Greek","Coptic","Cyrillic","Armenian","Hebrew","Arabic","Syriac","Thaana","Nko","Samaritan","Mandaic","Devanagari","Bengali","Gurmukhi","Gujarati","Oriya","Tamil","Telugu","Kannada","Malayalam","Sinhala","Thai","Lao","Tibetan","Myanmar","Georgian","Hangul","Ethiopic","Cherokee","Canadian_Aboriginal","Ogham","Runic","Tagalog","Hanunoo","Buhid","Tagbanwa","Khmer","Mongolian","Limbu","Tai_Le","New_Tai_Lue","Buginese","Tai_Tham","Balinese","Sundanese","Batak","Lepcha","Ol_Chiki","Braille","Glagolitic","Tifinagh","Han","Hiragana","Katakana","Yi","Lisu","Vai","Bamum","Syloti_Nagri","Phags_Pa","Saurashtra","Kayah_Li","Rejang","Javanese","Cham","Tai_Viet","Meetei_Mayek","null","Linear_B","Lycian","Carian","Old_Italic","Gothic","Old_Permic","Ugaritic","Old_Persian","Deseret","Shavian","Osmanya","Osage","Elbasan","Caucasian_Albanian","Linear_A","Cypriot","Imperial_Aramaic","Palmyrene","Nabataean","Hatran","Phoenician","Lydian","Meroitic_Hieroglyphs","Meroitic_Cursive","Kharoshthi","Old_South_Arabian","Old_North_Arabian","Manichaean","Avestan","Inscriptional_Parthian","Inscriptional_Pahlavi","Psalter_Pahlavi","Old_Turkic","Old_Hungarian","Hanifi_Rohingya","Old_Sogdian","Sogdian","Elymaic","Brahmi","Kaithi","Sora_Sompeng","Chakma","Mahajani","Sharada","Khojki","Multani","Khudawadi","Grantha","Newa","Tirhuta","Siddham","Modi","Takri","Ahom","Dogra","Warang_Citi","Nandinagari","Zanabazar_Square","Soyombo","Pau_Cin_Hau","Bhaiksuki","Marchen","Masaram_Gondi","Gunjala_Gondi","Makasar","Cuneiform","Egyptian_Hieroglyphs","Anatolian_Hieroglyphs","Mro","Bassa_Vah","Pahawh_Hmong","Medefaidrin","Miao","Tangut","Nushu","Duployan","SignWriting","Nyiakeng_Puachue_Hmong","Wancho","Mende_Kikakui","Adlam"],"eaw":["N","Na","A","W","H","F"]}');
const $747425b437e121da$var$trie = new $hJqJp$unicodetrie($bdjGp$base64js.toByteArray("AAARAAAAAADwfAEAZXl5ONRt+/5bPVFZimRfKoTQJNm37CGE7Iw0j3UsTWKsoyI7kwyyTiEUzSD7NiEzhWYijH0wMVkHE4Mx49fzfo+3nuP4/fdZjvv+XNd5n/d9nef1WZvmKhTxiZndzDQBSEYQqxqKwnsKvGQucFh+6t6cJ792ePQBZv5S9yXSwkyjf/P4T7mTNnIAv1dOVhMlR9lflbUL9JeJguqsjvG9NTj/wLb566VAURnLo2vvRi89S3gW/33ihh2eXpDn40BIW7REl/7coRKIhAFlAiOtbLDTt6mMb4GzMF1gNnvX/sBxtbsAIjfztCNcQjcNDtLThRvuXu5M5g/CBjaLBE4lJm4qy/oZD97+IJryApcXfgWYlkvWbhfXgujOJKVu8B+ozqTLbxyJ5kNiR75CxDqfBM9eOlDMmGeoZ0iQbbS5VUplIwI+ZNXEKQVJxlwqjhOY7w3XwPesbLK5JZE+Tt4X8q8km0dzInsPPzbscrjBMVjF5mOHSeRdJVgKUjLTHiHqXSPkep8N/zFk8167KLp75f6RndkvzdfB6Uz3MmqvRArzdCbs1/iRZjYPLLF3U8Qs+H+Rb8iK51a6NIV2V9+07uJsTGFWpPz8J++7iRu2B6eAKlK/kujrLthwaD/7a6J5w90TusnH1JMAc+gNrql4aspOUG/RrsxUKmPzhHgP4Bleru+6Vfc/MBjgXVx7who94nPn7MPFrnwQP7g0k0Dq0h2GSKO6fTZ8nLodN1SiOUj/5EL/Xo1DBvRm0wmrh3x6phcJ20/9CuMr5h8WPqXMSasLoLHoufTmE7mzYrs6B0dY7KjuCogKqsvxnxAwXWvd9Puc9PnE8DOHT2INHxRlIyVHrqZahtfV2E/A2PDdtA3ewlRHMtFIBKO/T4IozWTQZ+mb+gdKuk/ZHrqloucKdsOSJmlWTSntWjcxVMjUmroXLM10I6TwDLnBq4LP69TxgVeyGsd8yHvhF8ydPlrNRSNs9EP7WmeuSE7Lu10JbOuQcJw/63sDp68wB9iwP5AO+mBpV0R5VDDeyQUFCel1G+4KHBgEVFS0YK+m2sXLWLuGTlkVAd97WwKKdacjWElRCuDRauf33l/yVcDF6sVPKeTes99FC1NpNWcpieGSV/IbO8PCTy5pbUR1U8lxzf4T+y6fZMxOz3LshkQLeeDSd0WmUrQgajmbktrxsb2AZ0ACw2Vgni+gV/m+KvCRWLg08Clx7uhql+v9XySGcjjOHlsp8vBw/e8HS7dtiqF6T/XcSXuaMW66GF1g4q9YyBadHqy3Y5jin1c7yZos6BBr6dsomSHxiUHanYtcYQwnMMZhRhOnaYJeyJzaRuukyCUh48+e/BUvk/aEfDp8ag+jD64BHxNnQ5v/E7WRk7eLjGV13I3oqy45YNONi/1op1oDr7rPjkhPsTXgUpQtGDPlIs55KhQaic9kSGs/UrZ2QKQOflB8MTEQxRF9pullToWO7Eplan6mcMRFnUu2441yxi23x+KqKlr7RWWsi9ZXMWlr8vfP3llk1m2PRj0yudccxBuoa7VfIgRmnFPGX6Pm1WIfMm/Rm4n/xTn8IGqA0GWuqgu48pEUO0U9nN+ZdIvFpPb7VDPphIfRZxznlHeVFebkd9l+raXy9BpTMcIUIvBfgHEb6ndGo8VUkxpief14KjzFOcaANfgvFpvyY8lE8lE4raHizLpluPzMks1hx/e1Hok5yV0p7qQH7GaYeMzzZTFvRpv6k6iaJ4yNqzBvN8J7B430h2wFm1IBPcqbou33G7/NWPgopl4Mllla6e24L3TOTVNkza2zv3QKuDWTeDpClCEYgTQ+5vEBSQZs/rMF50+sm4jofTgWLqgX1x3TkrDEVaRqfY/xZizFZ3Y8/DFEFD31VSfBQ5raEB6nHnZh6ddehtclQJ8fBrldyIh99LNnV32HzKEej04hk6SYjdauCa4aYW0ru/QxvQRGzLKOAQszf3ixJypTW3WWL6BLSF2EMCMIw7OUvWBC6A/gDc2D1jvBapMCc7ztx6jYczwTKsRLL6dMNXb83HS8kdD0pTMMj161zbVHkU0mhSHo9SlBDDXdN6hDvRGizmohtIyR3ot8tF5iUG4GLNcXeGvBudSFrHu+bVZb9jirNVG+rQPI51A7Hu8/b0UeaIaZ4UgDO68PkYx3PE2HWpKapJ764Kxt5TFYpywMy4DLQqVRy11I7SOLhxUFmqiEK52NaijWArIfCg6qG8q5eSiwRCJb1R7GDJG74TrYgx/lVq7w9++Kh929xSJEaoSse5fUOQg9nMAnIZv+7fwVRcNv3gOHI46Vb5jYUC66PYHO6lS+TOmvEQjuYmx4RkffYGxqZIp/DPWNHAixbRBc+XKE3JEOgs4jIwu/dSAwhydruOGF39co91aTs85JJ3Z/LpXoF43hUwJsb/M1Chzdn8HX8vLXnqWUKvRhNLpfAF4PTFqva1sBQG0J+59HyYfmQ3oa4/sxZdapVLlo/fooxSXi/dOEQWIWq8E0FkttEyTFXR2aNMPINMIzZwCNEheYTVltsdaLkMyKoEUluPNAYCM2IG3br0DLy0fVNWKHtbSKbBjfiw7Lu06gQFalC7RC9BwRMSpLYDUo9pDtDfzwUiPJKLJ2LGcSphWBadOI/iJjNqUHV7ucG8yC6+iNM9QYElqBR7ECFXrcTgWQ3eG/tCWacT9bxIkfmxPmi3vOd36KxihAJA73vWNJ+Y9oapXNscVSVqS5g15xOWND/WuUCcA9YAAg6WFbjHamrblZ5c0L6Zx1X58ZittGcfDKU697QRSqW/g+RofNRyvrWMrBn44cPvkRe2HdTu/Cq01C5/riWPHZyXPKHuSDDdW8c1XPgd6ogvLh20qEIu8c19sqr4ufyHrwh37ZN5MkvY1dsGmEz9pUBTxWrvvhNyODyX2Q1k/fbX/T/vbHNcBrmjgDtvBdtZrVtiIg5iXQuzO/DEMvRX8Mi1zymSlt92BGILeKItjoShJXE/H7xwnf0Iewb8BFieJ9MflEBCQYEDm8eZniiEPfGoaYiiEdhQxHQNr2AuRdmbL9mcl18Kumh+HEZLp6z+j35ML9zTbUwahUZCyQQOgQrGfdfQtaR/OYJ/9dYXb2TWZFMijfCA8Nov4sa5FFDUe1T68h4q08WDE7JbbDiej4utRMR9ontevxlXv6LuJTXt1YEv8bDzEt683PuSsIN0afvu0rcBu9AbXZbkOG3K3AhtqQ28N23lXm7S3Yn6KXmAhBhz+GeorJJ4XxO/b3vZk2LXp42+QvsVxGSNVpfSctIFMTR1bD9t70i6sfNF3WKz/uKDEDCpzzztwhL45lsw89H2IpWN10sXHRlhDse9KCdpP5qNNpU84cTY+aiqswqR8XZ9ea0KbVRwRuOGQU3csAtV2fSbnq47U6es6rKlWLWhg3s/B9C9g+oTyp6RtIldR51OOkP5/6nSy6itUVPcMNOp4M/hDdKOz3uK6srbdxOrc2cJgr1Sg02oBxxSky6V7JaG+ziNwlfqnjnvh2/uq1lKfbp+qpwq/D/5OI5gkFl5CejKGxfc2YVJfGqc4E0x5e9PHK2ukbHNI7/RZV6LNe65apbTGjoCaQls0txPPbmQbCQn+/upCoXRZy9yzorWJvZ0KWcbXlBxU/d5I4ERUTxMuVWhSMmF677LNN7NnLwsmKawXkCgbrpcluOl0WChR1qhtSrxGXHu251dEItYhYX3snvn1gS2uXuzdTxCJjZtjsip0iT2sDC0qMS7Bk9su2NyXjFK5/f5ZoWwofg3DtTyjaFqspnOOTSh8xK/CKUFS57guVEkw9xoQuRCwwEO9Lu9z2vYxSa9NFV8DvSxv2C4WYLYF8Nrc4DzWkzNsk81JJOlZ/LYJrGCoj4MmZpnf3AXmzxT4rtl9jsqljEyedz468SGKdBiQzyz/qWKEhFg45ZczlZZ3KGL3l6sn+3TTa3zMVMhPa1obGp/z+fvY0QXTrJTf1XAT3EtQdUfYYlmWZyvPZ/6rWwU7UOQei7pVE0osgN94Iy+T1+omE6z4Rh2O20FjgBeK2y1mcoFiMDOJvuZPn5Moy9fmFH3wyfKvn4+TwfLvt/lHTTVnvrtoUWRBiQXhiNM8nE6ZoWeux/Z0b2unRcdUzdDpmL7CAgd1ToRXwgmHTZOgiGtVT+xr1QH9ObebRTT4NzL+XSpLuuWp62GqQvJVTPoZOeJCb6gIwd9XHMftQ+Kc08IKKdKQANSJ1a2gve3JdRhO0+tNiYzWAZfd7isoeBu67W7xuK8WX7nhJURld98Inb0t/dWOSau/kDvV4DJo/cImw9AO2Gvq0F2n0M7yIZKL8amMbjYld+qFls7hq8Acvq97K2PrCaomuUiesu7qNanGupEl6J/iem8lyr/NMnsTr6o41PO0yhQh3hPFN0wJP7S830je9iTBLzUNgYH+gUZpROo3rN2qgCI+6GewpX8w8CH+ro6QrWiStqmcMzVa3vEel+3/dDxMp0rDv1Q6wTMS3K64zTT6RWzK1y643im25Ja7X2ePCV2mTswd/4jshZPo4bLnerqIosq/hy2bKUAmVn9n4oun1+a0DIZ56UhVwmZHdUNpLa8gmPvxS1eNvCF1T0wo1wKPdCJi0qOrWz7oYRTzgTtkzEzZn308XSLwUog4OWGKJzCn/3FfF9iA32dZHSv30pRCM3KBY9WZoRhtdK/ChHk6DEQBsfV6tN2o1Cn0mLtPBfnkS+qy1L2xfFe9TQPtDE1Be44RTl82E9hPT2rS2+93LFbzhQQO3C/hD2jRFH3BWWbasAfuMhRJFcTri73eE835y016s22DjoFJ862WvLj69fu2TgSF3RHia9D5DSitlQAXYCnbdqjPkR287Lh6dCHDapos+eFDvcZPP2edPmTFxznJE/EBLoQQ0Qmn9EkZOyJmHxMbvKYb8o21ZHmv5YLqgsEPk9gWZwYQY9wLqGXuax/8QlV5qDaPbq9pLPT1yp+zOWKmraEy1OUJI7zdEcEmvBpbdwLrDCgEb2xX8S/nxZgjK4bRi+pbOmbh8bEeoPvU/L9ndx9kntlDALbdAvp0O8ZC3zSUnFg4cePsw7jxewWvL7HRSBLUn6J7vTH9uld5N76JFPgBCdXGF221oEJk++XfRwXplLSyrVO7HFWBEs99nTazKveW3HpbD4dH/YmdAl+lwbSt8BQWyTG7jAsACI7bPPUU9hI9XUHWqQOuezHzUjnx5Qqs6T1qNHfTTHleDtmqK7flA9a0gz2nycIpz1FHBuWxKNtUeTdqP29Fb3tv+tl5JyBqXoR+vCsdzZwZUhf6Lu8bvkB9yQP4x7GGegB0ym0Lpl03Q7e+C0cDsm9GSDepCDji7nUslLyYyluPfvLyKaDSX4xpR+nVYQjQQn5F8KbY1gbIVLiK1J3mW90zTyR1bqApX2BlWh7KG8LAY9/S9nWC0XXh9pZZo6xuir12T43rkaGfQssbQyIslA7uJnSHOV22NhlNtUo0czxPAsXhh8tIQYaTM4l/yAlZlydTcXhlG22Gs/n3BxKBd/3ZjYwg3NaUurVXhNB+afVnFfNr9TbC9ksNdvwpNfeHanyJ8M6GrIVfLlYAPv0ILe4dn0Z+BJSbJkN7eZY/c6+6ttDYcIDeUKIDXqUSE42Xdh5nRbuaObozjht0HJ5H1e+em+NJi/+8kQlyjCbJpPckwThZeIF9/u7lrVIKNeJLCN/TpPAeXxvd31/CUDWHK9MuP1V1TJgngzi4V0qzS3SW3Qy5UiGHqg02wQa5tsEl9s/X9nNMosgLlUgZSfCBj1DiypLfhr9/r0nR0XY2tmhDOcUS4E7cqa4EJBhzqvpbZa35Q5Iz5EqmhYiOGDAYk606Tv74+KGfPjKVuP15rIzgW0I7/niOu9el/sn2bRye0gV+GrePDRDMHjwO1lEdeXH8N+UTO3IoN18kpI3tPxz+fY+n2MGMSGFHAx/83tKeJOl+2i+f1O9v6FfEDBbqrw+lpM8Anav7zHNr7hE78nXUtPNodMbCnITWA7Ma/IHlZ50F9hWge/wzOvSbtqFVFtkS8Of2nssjZwbSFdU+VO8z6tCEc9UA9ACxT5zIUeSrkBB/v1krOpm7bVMrGxEKfI6LcnpB4D8bvn2hDKGqKrJaVAJuDaBEY3F7eXyqnFWlOoFV/8ZLspZiZd7orXLhd4mhHQgbuKbHjJWUzrnm0Dxw/LJLzXCkh7slMxKo8uxZIWZfdKHlfI7uj3LP6ARAuWdF7ZmZ7daOKqKGbz5LxOggTgS39oEioYmrqkCeUDvbxkBYKeHhcLmMN8dMF01ZMb32IpL/cH8R7VHQSI5I0YfL14g9d7P/6cjB1JXXxbozEDbsrPdmL8ph7QW10jio+v7YsqHKQ6xrBbOVtxU0/nFfzUGZwIBLwyUvg49ii+54nv9FyECBpURnQK4Ox6N7lw5fsjdd5l/2SwBcAHMJoyjO1Pifye2dagaOwCVMqdJWAo77pvBe0zdJcTWu5fdzPNfV2p1pc7/JKQ8zhKkwsOELUDhXygPJ5oR8Vpk2lsCen3D3QOQp2zdrSZHjVBstDF/wWO98rrkQ6/7zt/Drip7OHIug1lomNdmRaHRrjmqeodn22sesQQPgzimPOMqC60a5+i/UYh51uZm+ijWkkaI2xjrBO2558DZNZMiuDQlaVAvBy2wLn/bR3FrNzfnO/9oDztYqxZrr7JMIhqmrochbqmQnKowxW29bpqTaJu7kW1VotC72QkYX8OoDDdMDwV1kJRk3mufgJBzf+iwFRJ7XWQwO5ujVglgFgHtycWiMLx5N+6XU+TulLabWjOzoao03fniUW0xvIJNPbk7CQlFZd/RCOPvgQbLjh5ITE8NVJeKt3HGr6JTnFdIzcVOlEtwqbIIX0IM7saC+4N5047MTJ9+Wn11EhyEPIlwsHE5utCeXRjQzlrR+R1Cf/qDzcNbqLXdk3J7gQ39VUrrEkS/VMWjjg+t2oYrqB0tUZClcUF6+LBC3EQ7KnGIwm/qjZX4GKPtjTX1zQKV6nPAb2t/Rza5IqKRf8i2DFEhV/YSifX0YwsiF6TQnp48Gr65TFq0zUe6LGjiY7fq0LSGKL1VnC6ESI2yxvt3XqBx53B3gSlGFeJcPbUbonW1E9E9m4NfuwPh+t5QjRxX34lvBPVxwQd7aeTd+r9dw5CiP1pt8wMZoMdni7GapYdo6KPgeQKcmlFfq4UYhvV0IBgeiR3RnTMBaqDqpZrTRyLdsp4l0IXZTdErfH0sN3dqBG5vRIx3VgCYcHmmkqJ8Hyu3s9K9uBD1d8cZUEx3qYcF5vsqeRpF1GOg8emeWM2OmBlWPdZ6qAXwm3nENFyh+kvXk132PfWAlN0kb7yh4fz2T7VWUY/hEXX5DvxGABC03XRpyOG8t/u3Gh5tZdpsSV9AWaxJN7zwhVglgII1gV28tUViyqn4UMdIh5t+Ea2zo7PO48oba0TwQbiSZOH4YhD578kPF3reuaP7LujPMsjHmaDuId9XEaZBCJhbXJbRg5VCk3KJpryH/+8S3wdhR47pdFcmpZG2p0Bpjp/VbvalgIZMllYX5L31aMPdt1J7r/7wbixt0Mnz2ZvNGTARHPVD+2O1D8SGpWXlVnP2ekgon55YiinADDynyaXtZDXueVqbuTi8z8cHHK325pgqM+mWZwzHeEreMvhZopAScXM14SJHpGwZyRljMlDvcMm9FZ/1e9+r/puOnpXOtc9Iu2fmgBfEP9cGW1Fzb1rGlfJ08pACtq1ZW18bf2cevebzVeHbaA50G9qoUp39JWdPHbYkPCRXjt4gzlq3Cxge28Mky8MoS/+On72kc+ZI2xBtgJytpAQHQ1zrEddMIVyR5urX6yBNu8v5lKC8eLdGKTJtbgIZ3ZyTzSfWmx9f+cvcJe8yM39K/djkp2aUTE/9m2Lj5jg7b8vdRAer7DO3SyLNHs1CAm5x5iAdh2yGJYivArZbCBNY88Tw+w+C1Tbt7wK3zl2rzTHo/D8/gb3c3mYrnEIEipYqPUcdWjnTsSw471O3EUN7Gtg4NOAs9PJrxm03VuZKa5xwXAYCjt7Gs01Km6T2DhOYUMoFcCSu7Hk1p3yP1eG+M3v3Q5luAze6WwBnZIYO0TCucPWK+UJ36KoJ8Y+vpavhLO8g5ed704IjlQdfemrMu//EvPYXTQSGIPPfiagJS9nMqP5IvkxN9pvuJz7h8carPXTKMq8jnTeL0STan6dnLTAqwIswcIwWDR2KwbGddAVN8SYWRB7kfBfBRkSXzvHlIF8D6jo64kUzYk5o/n8oLjKqat0rdXvQ86MkwQGMnnlcasqPPT2+mVtUGb32KuH6cyZQenrRG11TArcAl27+nvOMBDe++EKHf4YdyGf7mznzOz33cFFGEcv329p4qG2hoaQ8ULiMyVz6ENcxhoqGnFIdupcn7GICQWuw3yO3W8S33mzCcMYJ8ywc7U7rmaQf/W5K63Gr4bVTpXOyOp4tbaPyIaatBNpXqlmQUTSZXjxPr19+73PSaT+QnI35YsWn6WpfJjRtK8vlJZoTSgjaRU39AGCkWOZtifJrnefCrqwTKDFmuWUCukEsYcRrMzCoit28wYpP7kSVjMD8WJYQiNc2blMjuqYegmf6SsfC1jqz8XzghMlOX+gn/MKZmgljszrmehEa4V98VreJDxYvHr3j7IeJB9/sBZV41BWT/AZAjuC5XorlIPnZgBAniBEhanp0/0+qZmEWDpu8ige1hUPIyTo6T6gDEcFhWSoduNh8YSu65KgMOGBw7VlNYzNIgwHtq9KP2yyTVysqX5v12sf7D+vQUdR2dRDvCV40rIInXSLWT/yrC6ExOQxBJwIDbeZcl3z1yR5Rj3l8IGpxspapnvBL+fwupA3b6fkFceID9wgiM1ILB0cHVdvo/R4xg8yqKXT8efl0GnGX1/27FUYeUW2L/GNRGGWVGp3i91oaJkb4rybENHre9a2P5viz/yqk8ngWUUS+Kv+fu+9BLFnfLiLXOFcIeBJLhnayCiuDRSqcx0Qu68gVsGYc6EHD500Fkt+gpDj6gvr884n8wZ5o6q7xtL5wA0beXQnffWYkZrs2NGIRgQbsc5NB302SVx+R4ROvmgZaR8wBcji128BMfJ9kcvJ4DC+bQ57kRmv5yxgU4ngZfn0/JNZ8JBwxjTqS+s9kjJFG1unGUGLwMiIuXUD9EFhNIJuyCEAmVZSIGKH4G6v1gRR1LyzQKH2ZqiI1DnHMoDEZspbDjTeaFIAbSvjSq3A+n46y9hhVM8wIpnARSXyzmOD96d9UXvFroSPgGw1dq2vdEqDq9fJN1EbL2WulNmHkFDvxSO9ZT/RX/Bw2gA/BrF90XrJACereVfbV/YXaKfp77Nmx5NjEIUlxojsy7iN7nBHSZigfsbFyVOX1ZTeCCxvqnRSExP4lk5ZeYlRu9caaa743TWNdchRIhEWwadsBIe245C8clpaZ4zrPsk+OwXzxWCvRRumyNSLW5KWaSJyJU95cwheK76gr7228spZ3hmTtLyrfM2QRFqZFMR8/Q6yWfVgwTdfX2Ry4w3+eAO/5VT5nFb5NlzXPvBEAWrNZ6Q3jbH0RF4vcbp+fDngf/ywpoyNQtjrfvcq93AVb1RDWRghvyqgI2BkMr1rwYi8gizZ0G9GmPpMeqPerAQ0dJbzx+KAFM4IBq6iSLpZHUroeyfd9o5o+4fR2EtsZBoJORQEA4SW0CmeXSnblx2e9QkCHIodyqV6+g5ETEpZsLqnd/Na60EKPX/tQpPEcO+COIBPcQdszDzSiHGyQFPly/7KciUh1u+mFfxTCHGv9nn2WqndGgeGjQ/kr02qmTBX7Hc1qiEvgiSz1Tz/sy7Es29wvn6FrDGPP7asXlhOaiHxOctPvTptFA1kHFUk8bME7SsTSnGbFbUrssxrq70LhoSh5OwvQna+w84XdXhZb2sloJ4ZsCg3j+PrjJL08/JBi5zGd6ud/ZxhmcGKLOXPcNunQq5ESW92iJvfsuRrNYtawWwSmNhPYoFj2QqWNF0ffLpGt/ad24RJ8vkb5sXkpyKXmvFG5Vcdzf/44k3PBL/ojJ52+kWGzOArnyp5f969oV3J2c4Li27Nkova9VwRNVKqN0V+gV+mTHitgkXV30aWd3A1RSildEleiNPA+5cp+3+T7X+xfHiRZXQ1s4FA9TxIcnveQs9JSZ5r5qNmgqlW4zMtZ6rYNvgmyVcywKtu8ZxnSbS5vXlBV+NXdIfi3+xzrnJ0TkFL+Un8v1PWOC2PPFCjVPq7qTH7mOpzOYj/b4h0ceT+eHgr97Jqhb1ziVfeANzfN8bFUhPKBi7hJBCukQnB0aGjFTYLJPXL26lQ2b80xrOD5cFWgA8hz3St0e69kwNnD3+nX3gy12FjrjO+ddRvvvfyV3SWbXcxqNHfmsb9u1TV+wHTb9B07/L2sB8WUHJ9eeNomDyysEWZ0deqEhH/oWI2oiEh526gvAK1Nx2kIhNvkYR+tPYHEa9j+nd1VBpQP1uzSjIDO+fDDB7uy029rRjDC5Sk6aKczyz1D5uA9Lu+Rrrapl8JXNL3VRllNQH2K1ZFxOpX8LprttfqQ56MbPM0IttUheXWD/mROOeFqGUbL+kUOVlXLTFX/525g4faLEFO4qWWdmOXMNvVjpIVTWt650HfQjX9oT3Dg5Au6+v1/Ci78La6ZOngYCFPT1AUwxQuZ0yt5xKdNXLaDTISMTeCj16XTryhM36K2mfGRIgot71voWs8tTpL/f1rvcwv3LSDf+/G8THCT7NpfHWcW+lsF/ol8q9Bi6MezNTqp0rpp/kJRiVfNrX/w27cRRTu8RIIqtUblBMkxy4jwAVqCjUJkiPBj2cAoVloG8B2/N5deLdMhDb7xs5nhd3dubJhuj8WbaFRyu1L678DHhhA+rMimNo4C1kGpp0tD/qnCfCFHejpf0LJX43OTr578PY0tnIIrlWyNYyuR/ie6j2xNb1OV6u0dOX/1Dtcd7+ya9W+rY2LmnyQMtk8SMLTon8RAdwOaN2tNg5zVnDKlmVeOxPV2vhHIo9QEPV7jc3f+zVDquiNg1OaHX3cZXJDRY5MJpo+VanAcmqp4oasYLG+wrXUL5vJU0kqk2hGEskhP+Jjigrz1l6QnEwp6n8PMVeJp70Ii6ppeaK9GhF6fJE00ceLyxv08tKiPat4QdxZFgSbQknnEiCLD8Qc1rjazVKM3r3gXnnMeONgdz/yFV1q+haaN+wnF3Fn4uYCI9XsKOuVwDD0LsCO/f0gj5cmxCFcr7sclIcefWjvore+3aSU474cyqDVxH7w1RX3CHsaqsMRX17ZLgjsDXws3kLm2XJdM3Ku383UXqaHqsywzPhx7NFir0Fqjym/w6cxD2U9ypa3dx7Z12w/fi3Jps8sqJ8f8Ah8aZAvkHXvIRyrsxK7rrFaNNdNvjI8+3Emri195DCNa858anj2Qdny6Czshkn4N2+1m+k5S8sunX3Ja7I+JutRzg1mc2e9Yc0Zv9PZn1SwhxIdU9sXwZRTd/J5FoUm0e+PYREeHg3oc2YYzGf2xfJxXExt4pT3RfDRHvMXLUmoXOy63xv5pLuhOEax0dRgSywZ/GH+YBXFgCeTU0hZ8SPEFsn8punp1Kurd1KgXxUZ+la3R5+4ePGR4ZF5UQtOa83+Vj8zh80dfzbhxWCeoJnQ4dkZJM4drzknZOOKx2n3WrvJnzFIS8p0xeic+M3ZRVXIp10tV2DyYKwRxLzulPwzHcLlYTxl4PF7v8l106Azr+6wBFejbq/3P72C/0j78cepY9990/d4eAurn2lqdGKLU8FffnMw7cY7pVeXJRMU73Oxwi2g2vh/+4gX8dvbjfojn/eLVhhYl8GthwCQ50KcZq4z2JeW5eeOnJWFQEnVxDoG459TaC4zXybECEoJ0V5q1tXrQbDMtUxeTV6Pdt1/zJuc7TJoV/9YZFWxUtCf6Ou3Vd/vR/vG0138hJQrHkNeoep5dLe+6umcSquKvMaFpm3EZHDBOvCi0XYyIFHMgX7Cqp3JVXlxJFwQfHSaIUEbI2u1lBVUdlNw4Qa9UsLPEK94Qiln3pyKxQVCeNlx8yd7EegVNQBkFLabKvnietYVB4IPZ1fSor82arbgYec8aSdFMaIluYTYuNx32SxfrjKUdPGq+UNp5YpydoEG3xVLixtmHO9zXxKAnHnPuH2fPGrjx0GcuCDEU+yXUtXh6nfUL+cykws1gJ5vkfYFaFBr9PdCXvVf35OJQxzUMmWjv0W6uGJK11uAGDqSpOwCf6rouSIjPVgw57cJCOQ4b9tkI/Y5WNon9Swe72aZryKo8d+HyHBEdWJKrkary0LIGczA4Irq353Wc0Zga3om7UQiAGCvIl8GGyaqz5zH+1gMP5phWUCpKtttWIyicz09vXg76GxkmiGSMQ06Z9X8BUwqOtauDbPIf4rpK/yYoeAHxJ9soXS9VDe1Aw+awOOxaN8foLrif0TXBvQ55dtRtulRq9emFDBxlQcqKCaD8NeTSE7FOHvcjf/+oKbbtRqz9gbofoc2EzQ3pL6W5JdfJzAWmOk8oeoECe90lVMruwl/ltM015P/zIPazqvdvFmLNVHMIZrwiQ2tIKtGh6PDVH+85ew3caqVt2BsDv5rOcu3G9srQWd7NmgtzCRUXLYknYRSwtH9oUtkqyN3CfP20xQ1faXQl4MEmjQehWR6GmGnkdpYNQYeIG408yAX7uCZmYUic9juOfb+Re28+OVOB+scYK4DaPcBe+5wmji9gymtkMpKo4UKqCz7yxzuN8VIlx9yNozpRJpNaWHtaZVEqP45n2JemTlYBSmNIK1FuSYAUQ1yBLnKxevrjayd+h2i8PjdB3YY6b0nr3JuOXGpPMyh4V2dslpR3DFEvgpsBLqhqLDOWP4yEvIL6f21PpA7/8B"));
const $747425b437e121da$var$log2 = Math.log2 || ((n3) => Math.log(n3) / Math.LN2);
const $747425b437e121da$var$bits = (n3) => $747425b437e121da$var$log2(n3) + 1 | 0;
const $747425b437e121da$var$CATEGORY_BITS = $747425b437e121da$var$bits((/* @__PURE__ */ $parcel$interopDefault$1($f4087201da764553$exports)).categories.length - 1);
const $747425b437e121da$var$COMBINING_BITS = $747425b437e121da$var$bits((/* @__PURE__ */ $parcel$interopDefault$1($f4087201da764553$exports)).combiningClasses.length - 1);
const $747425b437e121da$var$SCRIPT_BITS = $747425b437e121da$var$bits((/* @__PURE__ */ $parcel$interopDefault$1($f4087201da764553$exports)).scripts.length - 1);
const $747425b437e121da$var$EAW_BITS = $747425b437e121da$var$bits((/* @__PURE__ */ $parcel$interopDefault$1($f4087201da764553$exports)).eaw.length - 1);
const $747425b437e121da$var$NUMBER_BITS = 10;
const $747425b437e121da$var$CATEGORY_SHIFT = $747425b437e121da$var$COMBINING_BITS + $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
const $747425b437e121da$var$COMBINING_SHIFT = $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
const $747425b437e121da$var$SCRIPT_SHIFT = $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
const $747425b437e121da$var$EAW_SHIFT = $747425b437e121da$var$NUMBER_BITS;
const $747425b437e121da$var$CATEGORY_MASK = (1 << $747425b437e121da$var$CATEGORY_BITS) - 1;
const $747425b437e121da$var$COMBINING_MASK = (1 << $747425b437e121da$var$COMBINING_BITS) - 1;
const $747425b437e121da$var$SCRIPT_MASK = (1 << $747425b437e121da$var$SCRIPT_BITS) - 1;
const $747425b437e121da$var$EAW_MASK = (1 << $747425b437e121da$var$EAW_BITS) - 1;
const $747425b437e121da$var$NUMBER_MASK = (1 << $747425b437e121da$var$NUMBER_BITS) - 1;
function $747425b437e121da$export$410364bbb673ddbc(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (/* @__PURE__ */ $parcel$interopDefault$1($f4087201da764553$exports)).categories[val >> $747425b437e121da$var$CATEGORY_SHIFT & $747425b437e121da$var$CATEGORY_MASK];
}
function $747425b437e121da$export$c03b919c6651ed55(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (/* @__PURE__ */ $parcel$interopDefault$1($f4087201da764553$exports)).combiningClasses[val >> $747425b437e121da$var$COMBINING_SHIFT & $747425b437e121da$var$COMBINING_MASK];
}
function $747425b437e121da$export$941569448d136665(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (/* @__PURE__ */ $parcel$interopDefault$1($f4087201da764553$exports)).scripts[val >> $747425b437e121da$var$SCRIPT_SHIFT & $747425b437e121da$var$SCRIPT_MASK];
}
function $747425b437e121da$export$92f6187db8ca6d26(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (/* @__PURE__ */ $parcel$interopDefault$1($f4087201da764553$exports)).eaw[val >> $747425b437e121da$var$EAW_SHIFT & $747425b437e121da$var$EAW_MASK];
}
function $747425b437e121da$export$7d1258ebb7625a0d(codePoint) {
  let val = $747425b437e121da$var$trie.get(codePoint);
  let num = val & $747425b437e121da$var$NUMBER_MASK;
  if (num === 0) return null;
  else if (num <= 50) return num - 1;
  else if (num < 480) {
    const numerator = (num >> 4) - 12;
    const denominator = (num & 15) + 1;
    return numerator / denominator;
  } else if (num < 768) {
    val = (num >> 5) - 14;
    let exp = (num & 31) + 2;
    while (exp > 0) {
      val *= 10;
      exp--;
    }
    return val;
  } else {
    val = (num >> 2) - 191;
    let exp = (num & 3) + 1;
    while (exp > 0) {
      val *= 60;
      exp--;
    }
    return val;
  }
}
function $747425b437e121da$export$52c8ea63abd07594(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Nl";
}
function $747425b437e121da$export$727d9dbc4fbb948f(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Nd";
}
function $747425b437e121da$export$a5b49f4dc6a07d2c(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Pc" || category === "Pd" || category === "Pe" || category === "Pf" || category === "Pi" || category === "Po" || category === "Ps";
}
function $747425b437e121da$export$7b6804e8df61fcf5(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Ll";
}
function $747425b437e121da$export$aebd617640818cda(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lu";
}
function $747425b437e121da$export$de8b4ee23b2cf823(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lt";
}
function $747425b437e121da$export$3c52dd84024ae72c(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Zs" || category === "Zl" || category === "Zp";
}
function $747425b437e121da$export$a11bdcffe109e74b(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Nd" || category === "No" || category === "Nl" || category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Me" || category === "Mc";
}
function $747425b437e121da$export$e33ad6871e762338(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Mn" || category === "Me" || category === "Mc";
}
var $747425b437e121da$export$2e2bcd8739ae039 = {
  getCategory: $747425b437e121da$export$410364bbb673ddbc,
  getCombiningClass: $747425b437e121da$export$c03b919c6651ed55,
  getScript: $747425b437e121da$export$941569448d136665,
  getEastAsianWidth: $747425b437e121da$export$92f6187db8ca6d26,
  getNumericValue: $747425b437e121da$export$7d1258ebb7625a0d,
  isAlphabetic: $747425b437e121da$export$52c8ea63abd07594,
  isDigit: $747425b437e121da$export$727d9dbc4fbb948f,
  isPunctuation: $747425b437e121da$export$a5b49f4dc6a07d2c,
  isLowerCase: $747425b437e121da$export$7b6804e8df61fcf5,
  isUpperCase: $747425b437e121da$export$aebd617640818cda,
  isTitleCase: $747425b437e121da$export$de8b4ee23b2cf823,
  isWhiteSpace: $747425b437e121da$export$3c52dd84024ae72c,
  isBaseForm: $747425b437e121da$export$a11bdcffe109e74b,
  isMark: $747425b437e121da$export$e33ad6871e762338
};
var dfa;
var hasRequiredDfa;
function requireDfa() {
  if (hasRequiredDfa) return dfa;
  hasRequiredDfa = 1;
  var INITIAL_STATE = 1;
  var FAIL_STATE = 0;
  class StateMachine {
    constructor(dfa2) {
      this.stateTable = dfa2.stateTable;
      this.accepting = dfa2.accepting;
      this.tags = dfa2.tags;
    }
    /**
     * Returns an iterable object that yields pattern matches over the input sequence.
     * Matches are of the form [startIndex, endIndex, tags].
     */
    match(str) {
      var self2 = this;
      return {
        *[Symbol.iterator]() {
          var state2 = INITIAL_STATE;
          var startRun = null;
          var lastAccepting = null;
          var lastState = null;
          for (var p2 = 0; p2 < str.length; p2++) {
            var c2 = str[p2];
            lastState = state2;
            state2 = self2.stateTable[state2][c2];
            if (state2 === FAIL_STATE) {
              if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
                yield [startRun, lastAccepting, self2.tags[lastState]];
              }
              state2 = self2.stateTable[INITIAL_STATE][c2];
              startRun = null;
            }
            if (state2 !== FAIL_STATE && startRun == null) {
              startRun = p2;
            }
            if (self2.accepting[state2]) {
              lastAccepting = p2;
            }
            if (state2 === FAIL_STATE) {
              state2 = INITIAL_STATE;
            }
          }
          if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
            yield [startRun, lastAccepting, self2.tags[state2]];
          }
        }
      };
    }
    /**
     * For each match over the input sequence, action functions matching
     * the tag definitions in the input pattern are called with the startIndex,
     * endIndex, and sub-match sequence.
     */
    apply(str, actions) {
      for (var [start2, end2, tags2] of this.match(str)) {
        for (var tag of tags2) {
          if (typeof actions[tag] === "function") {
            actions[tag](start2, end2, str.slice(start2, end2 + 1));
          }
        }
      }
    }
  }
  dfa = StateMachine;
  return dfa;
}
var dfaExports = requireDfa();
const $6uUbQ$dfa = /* @__PURE__ */ getDefaultExportFromCjs$2(dfaExports);
var clone = { exports: {} };
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone.exports;
  hasRequiredClone = 1;
  (function(module) {
    var clone2 = function() {
      function _instanceof(obj, type) {
        return type != null && obj instanceof type;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_) {
        nativePromise = function() {
        };
      }
      function clone3(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve2, reject) {
              parent2.then(function(value2) {
                resolve2(_clone(value2, depth2 - 1));
              }, function(err2) {
                reject(_clone(err2, depth2 - 1));
              });
            });
          } else if (clone3.__isArray(parent2)) {
            child = [];
          } else if (clone3.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
          } else if (clone3.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index2 = allParents.indexOf(parent2);
            if (index2 != -1) {
              return allChildren[index2];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value2, key) {
              var keyChild = _clone(key, depth2 - 1);
              var valueChild = _clone(value2, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value2) {
              var entryChild = _clone(value2, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i2 in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i2);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i2] = _clone(parent2[i2], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent2);
            for (var i2 = 0; i2 < symbols.length; i2++) {
              var symbol = symbols[i2];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent2[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i2 = 0; i2 < allPropertyNames.length; i2++) {
              var propertyName = allPropertyNames[i2];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone3.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c2 = function() {
        };
        c2.prototype = parent;
        return new c2();
      };
      function __objToStr(o2) {
        return Object.prototype.toString.call(o2);
      }
      clone3.__objToStr = __objToStr;
      function __isDate(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object Date]";
      }
      clone3.__isDate = __isDate;
      function __isArray(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object Array]";
      }
      clone3.__isArray = __isArray;
      function __isRegExp(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object RegExp]";
      }
      clone3.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global) flags += "g";
        if (re.ignoreCase) flags += "i";
        if (re.multiline) flags += "m";
        return flags;
      }
      clone3.__getRegExpFlags = __getRegExpFlags;
      return clone3;
    }();
    if (module.exports) {
      module.exports = clone2;
    }
  })(clone);
  return clone.exports;
}
var cloneExports = requireClone();
const $6uUbQ$clone = /* @__PURE__ */ getDefaultExportFromCjs$2(cloneExports);
var tinyInflateExports = requireTinyInflate();
const $6uUbQ$tinyinflate = /* @__PURE__ */ getDefaultExportFromCjs$2(tinyInflateExports);
var decode$1 = {};
var streams = {};
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  function BrotliInput(buffer) {
    this.buffer = buffer;
    this.pos = 0;
  }
  BrotliInput.prototype.read = function(buf, i2, count) {
    if (this.pos + count > this.buffer.length) {
      count = this.buffer.length - this.pos;
    }
    for (var p2 = 0; p2 < count; p2++)
      buf[i2 + p2] = this.buffer[this.pos + p2];
    this.pos += count;
    return count;
  };
  streams.BrotliInput = BrotliInput;
  function BrotliOutput(buf) {
    this.buffer = buf;
    this.pos = 0;
  }
  BrotliOutput.prototype.write = function(buf, count) {
    if (this.pos + count > this.buffer.length)
      throw new Error("Output buffer is not large enough");
    this.buffer.set(buf.subarray(0, count), this.pos);
    this.pos += count;
    return count;
  };
  streams.BrotliOutput = BrotliOutput;
  return streams;
}
var bit_reader;
var hasRequiredBit_reader;
function requireBit_reader() {
  if (hasRequiredBit_reader) return bit_reader;
  hasRequiredBit_reader = 1;
  var BROTLI_READ_SIZE = 4096;
  var BROTLI_IBUF_SIZE = 2 * BROTLI_READ_SIZE + 32;
  var BROTLI_IBUF_MASK = 2 * BROTLI_READ_SIZE - 1;
  var kBitMask = new Uint32Array([
    0,
    1,
    3,
    7,
    15,
    31,
    63,
    127,
    255,
    511,
    1023,
    2047,
    4095,
    8191,
    16383,
    32767,
    65535,
    131071,
    262143,
    524287,
    1048575,
    2097151,
    4194303,
    8388607,
    16777215
  ]);
  function BrotliBitReader(input) {
    this.buf_ = new Uint8Array(BROTLI_IBUF_SIZE);
    this.input_ = input;
    this.reset();
  }
  BrotliBitReader.READ_SIZE = BROTLI_READ_SIZE;
  BrotliBitReader.IBUF_MASK = BROTLI_IBUF_MASK;
  BrotliBitReader.prototype.reset = function() {
    this.buf_ptr_ = 0;
    this.val_ = 0;
    this.pos_ = 0;
    this.bit_pos_ = 0;
    this.bit_end_pos_ = 0;
    this.eos_ = 0;
    this.readMoreInput();
    for (var i2 = 0; i2 < 4; i2++) {
      this.val_ |= this.buf_[this.pos_] << 8 * i2;
      ++this.pos_;
    }
    return this.bit_end_pos_ > 0;
  };
  BrotliBitReader.prototype.readMoreInput = function() {
    if (this.bit_end_pos_ > 256) {
      return;
    } else if (this.eos_) {
      if (this.bit_pos_ > this.bit_end_pos_)
        throw new Error("Unexpected end of input " + this.bit_pos_ + " " + this.bit_end_pos_);
    } else {
      var dst = this.buf_ptr_;
      var bytes_read = this.input_.read(this.buf_, dst, BROTLI_READ_SIZE);
      if (bytes_read < 0) {
        throw new Error("Unexpected end of input");
      }
      if (bytes_read < BROTLI_READ_SIZE) {
        this.eos_ = 1;
        for (var p2 = 0; p2 < 32; p2++)
          this.buf_[dst + bytes_read + p2] = 0;
      }
      if (dst === 0) {
        for (var p2 = 0; p2 < 32; p2++)
          this.buf_[(BROTLI_READ_SIZE << 1) + p2] = this.buf_[p2];
        this.buf_ptr_ = BROTLI_READ_SIZE;
      } else {
        this.buf_ptr_ = 0;
      }
      this.bit_end_pos_ += bytes_read << 3;
    }
  };
  BrotliBitReader.prototype.fillBitWindow = function() {
    while (this.bit_pos_ >= 8) {
      this.val_ >>>= 8;
      this.val_ |= this.buf_[this.pos_ & BROTLI_IBUF_MASK] << 24;
      ++this.pos_;
      this.bit_pos_ = this.bit_pos_ - 8 >>> 0;
      this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0;
    }
  };
  BrotliBitReader.prototype.readBits = function(n_bits) {
    if (32 - this.bit_pos_ < n_bits) {
      this.fillBitWindow();
    }
    var val = this.val_ >>> this.bit_pos_ & kBitMask[n_bits];
    this.bit_pos_ += n_bits;
    return val;
  };
  bit_reader = BrotliBitReader;
  return bit_reader;
}
var dictionary = {};
var dictionaryBrowser = {};
var dictionary_bin;
var hasRequiredDictionary_bin;
function requireDictionary_bin() {
  if (hasRequiredDictionary_bin) return dictionary_bin;
  hasRequiredDictionary_bin = 1;
  dictionary_bin = "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";
  return dictionary_bin;
}
var hasRequiredDictionaryBrowser;
function requireDictionaryBrowser() {
  if (hasRequiredDictionaryBrowser) return dictionaryBrowser;
  hasRequiredDictionaryBrowser = 1;
  var base64 = requireBase64Js();
  dictionaryBrowser.init = function() {
    var BrotliDecompressBuffer = requireDecode().BrotliDecompressBuffer;
    var compressed = base64.toByteArray(requireDictionary_bin());
    return BrotliDecompressBuffer(compressed);
  };
  return dictionaryBrowser;
}
var hasRequiredDictionary;
function requireDictionary() {
  if (hasRequiredDictionary) return dictionary;
  hasRequiredDictionary = 1;
  var data2 = requireDictionaryBrowser();
  dictionary.init = function() {
    dictionary.dictionary = data2.init();
  };
  dictionary.offsetsByLength = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    4096,
    9216,
    21504,
    35840,
    44032,
    53248,
    63488,
    74752,
    87040,
    93696,
    100864,
    104704,
    106752,
    108928,
    113536,
    115968,
    118528,
    119872,
    121280,
    122016
  ]);
  dictionary.sizeBitsByLength = new Uint8Array([
    0,
    0,
    0,
    0,
    10,
    10,
    11,
    11,
    10,
    10,
    10,
    10,
    10,
    9,
    9,
    8,
    7,
    7,
    8,
    7,
    7,
    6,
    6,
    5,
    5
  ]);
  dictionary.minDictionaryWordLength = 4;
  dictionary.maxDictionaryWordLength = 24;
  return dictionary;
}
var huffman = {};
var hasRequiredHuffman;
function requireHuffman() {
  if (hasRequiredHuffman) return huffman;
  hasRequiredHuffman = 1;
  function HuffmanCode(bits, value2) {
    this.bits = bits;
    this.value = value2;
  }
  huffman.HuffmanCode = HuffmanCode;
  var MAX_LENGTH = 15;
  function GetNextKey(key, len) {
    var step = 1 << len - 1;
    while (key & step) {
      step >>= 1;
    }
    return (key & step - 1) + step;
  }
  function ReplicateValue(table, i2, step, end2, code) {
    do {
      end2 -= step;
      table[i2 + end2] = new HuffmanCode(code.bits, code.value);
    } while (end2 > 0);
  }
  function NextTableBitSize(count, len, root_bits) {
    var left = 1 << len - root_bits;
    while (len < MAX_LENGTH) {
      left -= count[len];
      if (left <= 0) break;
      ++len;
      left <<= 1;
    }
    return len - root_bits;
  }
  huffman.BrotliBuildHuffmanTable = function(root_table, table, root_bits, code_lengths, code_lengths_size) {
    var start_table = table;
    var code;
    var len;
    var symbol;
    var key;
    var step;
    var low;
    var mask;
    var table_bits;
    var table_size;
    var total_size;
    var sorted;
    var count = new Int32Array(MAX_LENGTH + 1);
    var offset2 = new Int32Array(MAX_LENGTH + 1);
    sorted = new Int32Array(code_lengths_size);
    for (symbol = 0; symbol < code_lengths_size; symbol++) {
      count[code_lengths[symbol]]++;
    }
    offset2[1] = 0;
    for (len = 1; len < MAX_LENGTH; len++) {
      offset2[len + 1] = offset2[len] + count[len];
    }
    for (symbol = 0; symbol < code_lengths_size; symbol++) {
      if (code_lengths[symbol] !== 0) {
        sorted[offset2[code_lengths[symbol]]++] = symbol;
      }
    }
    table_bits = root_bits;
    table_size = 1 << table_bits;
    total_size = table_size;
    if (offset2[MAX_LENGTH] === 1) {
      for (key = 0; key < total_size; ++key) {
        root_table[table + key] = new HuffmanCode(0, sorted[0] & 65535);
      }
      return total_size;
    }
    key = 0;
    symbol = 0;
    for (len = 1, step = 2; len <= root_bits; ++len, step <<= 1) {
      for (; count[len] > 0; --count[len]) {
        code = new HuffmanCode(len & 255, sorted[symbol++] & 65535);
        ReplicateValue(root_table, table + key, step, table_size, code);
        key = GetNextKey(key, len);
      }
    }
    mask = total_size - 1;
    low = -1;
    for (len = root_bits + 1, step = 2; len <= MAX_LENGTH; ++len, step <<= 1) {
      for (; count[len] > 0; --count[len]) {
        if ((key & mask) !== low) {
          table += table_size;
          table_bits = NextTableBitSize(count, len, root_bits);
          table_size = 1 << table_bits;
          total_size += table_size;
          low = key & mask;
          root_table[start_table + low] = new HuffmanCode(table_bits + root_bits & 255, table - start_table - low & 65535);
        }
        code = new HuffmanCode(len - root_bits & 255, sorted[symbol++] & 65535);
        ReplicateValue(root_table, table + (key >> root_bits), step, table_size, code);
        key = GetNextKey(key, len);
      }
    }
    return total_size;
  };
  return huffman;
}
var context = {};
var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext) return context;
  hasRequiredContext = 1;
  context.lookup = new Uint8Array([
    /* CONTEXT_UTF8, last byte. */
    /* ASCII range. */
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    4,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8,
    12,
    16,
    12,
    12,
    20,
    12,
    16,
    24,
    28,
    12,
    12,
    32,
    12,
    36,
    12,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    32,
    32,
    24,
    40,
    28,
    12,
    12,
    48,
    52,
    52,
    52,
    48,
    52,
    52,
    52,
    48,
    52,
    52,
    52,
    52,
    52,
    48,
    52,
    52,
    52,
    52,
    52,
    48,
    52,
    52,
    52,
    52,
    52,
    24,
    12,
    28,
    12,
    12,
    12,
    56,
    60,
    60,
    60,
    56,
    60,
    60,
    60,
    56,
    60,
    60,
    60,
    60,
    60,
    56,
    60,
    60,
    60,
    60,
    60,
    56,
    60,
    60,
    60,
    60,
    60,
    24,
    12,
    28,
    12,
    0,
    /* UTF8 continuation byte range. */
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    /* UTF8 lead byte range. */
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    2,
    3,
    /* CONTEXT_UTF8 second last byte. */
    /* ASCII range. */
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    1,
    1,
    1,
    1,
    0,
    /* UTF8 continuation byte range. */
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    /* UTF8 lead byte range. */
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    /* CONTEXT_SIGNED, second last byte. */
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    7,
    /* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. */
    0,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    32,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    40,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    48,
    56,
    /* CONTEXT_LSB6, last byte. */
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    /* CONTEXT_MSB6, last byte. */
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    6,
    6,
    6,
    6,
    7,
    7,
    7,
    7,
    8,
    8,
    8,
    8,
    9,
    9,
    9,
    9,
    10,
    10,
    10,
    10,
    11,
    11,
    11,
    11,
    12,
    12,
    12,
    12,
    13,
    13,
    13,
    13,
    14,
    14,
    14,
    14,
    15,
    15,
    15,
    15,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    22,
    22,
    22,
    22,
    23,
    23,
    23,
    23,
    24,
    24,
    24,
    24,
    25,
    25,
    25,
    25,
    26,
    26,
    26,
    26,
    27,
    27,
    27,
    27,
    28,
    28,
    28,
    28,
    29,
    29,
    29,
    29,
    30,
    30,
    30,
    30,
    31,
    31,
    31,
    31,
    32,
    32,
    32,
    32,
    33,
    33,
    33,
    33,
    34,
    34,
    34,
    34,
    35,
    35,
    35,
    35,
    36,
    36,
    36,
    36,
    37,
    37,
    37,
    37,
    38,
    38,
    38,
    38,
    39,
    39,
    39,
    39,
    40,
    40,
    40,
    40,
    41,
    41,
    41,
    41,
    42,
    42,
    42,
    42,
    43,
    43,
    43,
    43,
    44,
    44,
    44,
    44,
    45,
    45,
    45,
    45,
    46,
    46,
    46,
    46,
    47,
    47,
    47,
    47,
    48,
    48,
    48,
    48,
    49,
    49,
    49,
    49,
    50,
    50,
    50,
    50,
    51,
    51,
    51,
    51,
    52,
    52,
    52,
    52,
    53,
    53,
    53,
    53,
    54,
    54,
    54,
    54,
    55,
    55,
    55,
    55,
    56,
    56,
    56,
    56,
    57,
    57,
    57,
    57,
    58,
    58,
    58,
    58,
    59,
    59,
    59,
    59,
    60,
    60,
    60,
    60,
    61,
    61,
    61,
    61,
    62,
    62,
    62,
    62,
    63,
    63,
    63,
    63,
    /* CONTEXT_{M,L}SB6, second last byte, */
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  context.lookupOffsets = new Uint16Array([
    /* CONTEXT_LSB6 */
    1024,
    1536,
    /* CONTEXT_MSB6 */
    1280,
    1536,
    /* CONTEXT_UTF8 */
    0,
    256,
    /* CONTEXT_SIGNED */
    768,
    512
  ]);
  return context;
}
var prefix = {};
var hasRequiredPrefix;
function requirePrefix() {
  if (hasRequiredPrefix) return prefix;
  hasRequiredPrefix = 1;
  function PrefixCodeRange(offset2, nbits) {
    this.offset = offset2;
    this.nbits = nbits;
  }
  prefix.kBlockLengthPrefixCode = [
    new PrefixCodeRange(1, 2),
    new PrefixCodeRange(5, 2),
    new PrefixCodeRange(9, 2),
    new PrefixCodeRange(13, 2),
    new PrefixCodeRange(17, 3),
    new PrefixCodeRange(25, 3),
    new PrefixCodeRange(33, 3),
    new PrefixCodeRange(41, 3),
    new PrefixCodeRange(49, 4),
    new PrefixCodeRange(65, 4),
    new PrefixCodeRange(81, 4),
    new PrefixCodeRange(97, 4),
    new PrefixCodeRange(113, 5),
    new PrefixCodeRange(145, 5),
    new PrefixCodeRange(177, 5),
    new PrefixCodeRange(209, 5),
    new PrefixCodeRange(241, 6),
    new PrefixCodeRange(305, 6),
    new PrefixCodeRange(369, 7),
    new PrefixCodeRange(497, 8),
    new PrefixCodeRange(753, 9),
    new PrefixCodeRange(1265, 10),
    new PrefixCodeRange(2289, 11),
    new PrefixCodeRange(4337, 12),
    new PrefixCodeRange(8433, 13),
    new PrefixCodeRange(16625, 24)
  ];
  prefix.kInsertLengthPrefixCode = [
    new PrefixCodeRange(0, 0),
    new PrefixCodeRange(1, 0),
    new PrefixCodeRange(2, 0),
    new PrefixCodeRange(3, 0),
    new PrefixCodeRange(4, 0),
    new PrefixCodeRange(5, 0),
    new PrefixCodeRange(6, 1),
    new PrefixCodeRange(8, 1),
    new PrefixCodeRange(10, 2),
    new PrefixCodeRange(14, 2),
    new PrefixCodeRange(18, 3),
    new PrefixCodeRange(26, 3),
    new PrefixCodeRange(34, 4),
    new PrefixCodeRange(50, 4),
    new PrefixCodeRange(66, 5),
    new PrefixCodeRange(98, 5),
    new PrefixCodeRange(130, 6),
    new PrefixCodeRange(194, 7),
    new PrefixCodeRange(322, 8),
    new PrefixCodeRange(578, 9),
    new PrefixCodeRange(1090, 10),
    new PrefixCodeRange(2114, 12),
    new PrefixCodeRange(6210, 14),
    new PrefixCodeRange(22594, 24)
  ];
  prefix.kCopyLengthPrefixCode = [
    new PrefixCodeRange(2, 0),
    new PrefixCodeRange(3, 0),
    new PrefixCodeRange(4, 0),
    new PrefixCodeRange(5, 0),
    new PrefixCodeRange(6, 0),
    new PrefixCodeRange(7, 0),
    new PrefixCodeRange(8, 0),
    new PrefixCodeRange(9, 0),
    new PrefixCodeRange(10, 1),
    new PrefixCodeRange(12, 1),
    new PrefixCodeRange(14, 2),
    new PrefixCodeRange(18, 2),
    new PrefixCodeRange(22, 3),
    new PrefixCodeRange(30, 3),
    new PrefixCodeRange(38, 4),
    new PrefixCodeRange(54, 4),
    new PrefixCodeRange(70, 5),
    new PrefixCodeRange(102, 5),
    new PrefixCodeRange(134, 6),
    new PrefixCodeRange(198, 7),
    new PrefixCodeRange(326, 8),
    new PrefixCodeRange(582, 9),
    new PrefixCodeRange(1094, 10),
    new PrefixCodeRange(2118, 24)
  ];
  prefix.kInsertRangeLut = [
    0,
    0,
    8,
    8,
    0,
    16,
    8,
    16,
    16
  ];
  prefix.kCopyRangeLut = [
    0,
    8,
    0,
    8,
    16,
    0,
    16,
    8,
    16
  ];
  return prefix;
}
var transform = {};
var hasRequiredTransform;
function requireTransform() {
  if (hasRequiredTransform) return transform;
  hasRequiredTransform = 1;
  var BrotliDictionary = requireDictionary();
  var kIdentity = 0;
  var kOmitLast1 = 1;
  var kOmitLast2 = 2;
  var kOmitLast3 = 3;
  var kOmitLast4 = 4;
  var kOmitLast5 = 5;
  var kOmitLast6 = 6;
  var kOmitLast7 = 7;
  var kOmitLast8 = 8;
  var kOmitLast9 = 9;
  var kUppercaseFirst = 10;
  var kUppercaseAll = 11;
  var kOmitFirst1 = 12;
  var kOmitFirst2 = 13;
  var kOmitFirst3 = 14;
  var kOmitFirst4 = 15;
  var kOmitFirst5 = 16;
  var kOmitFirst6 = 17;
  var kOmitFirst7 = 18;
  var kOmitFirst9 = 20;
  function Transform2(prefix2, transform2, suffix) {
    this.prefix = new Uint8Array(prefix2.length);
    this.transform = transform2;
    this.suffix = new Uint8Array(suffix.length);
    for (var i2 = 0; i2 < prefix2.length; i2++)
      this.prefix[i2] = prefix2.charCodeAt(i2);
    for (var i2 = 0; i2 < suffix.length; i2++)
      this.suffix[i2] = suffix.charCodeAt(i2);
  }
  var kTransforms = [
    new Transform2("", kIdentity, ""),
    new Transform2("", kIdentity, " "),
    new Transform2(" ", kIdentity, " "),
    new Transform2("", kOmitFirst1, ""),
    new Transform2("", kUppercaseFirst, " "),
    new Transform2("", kIdentity, " the "),
    new Transform2(" ", kIdentity, ""),
    new Transform2("s ", kIdentity, " "),
    new Transform2("", kIdentity, " of "),
    new Transform2("", kUppercaseFirst, ""),
    new Transform2("", kIdentity, " and "),
    new Transform2("", kOmitFirst2, ""),
    new Transform2("", kOmitLast1, ""),
    new Transform2(", ", kIdentity, " "),
    new Transform2("", kIdentity, ", "),
    new Transform2(" ", kUppercaseFirst, " "),
    new Transform2("", kIdentity, " in "),
    new Transform2("", kIdentity, " to "),
    new Transform2("e ", kIdentity, " "),
    new Transform2("", kIdentity, '"'),
    new Transform2("", kIdentity, "."),
    new Transform2("", kIdentity, '">'),
    new Transform2("", kIdentity, "\n"),
    new Transform2("", kOmitLast3, ""),
    new Transform2("", kIdentity, "]"),
    new Transform2("", kIdentity, " for "),
    new Transform2("", kOmitFirst3, ""),
    new Transform2("", kOmitLast2, ""),
    new Transform2("", kIdentity, " a "),
    new Transform2("", kIdentity, " that "),
    new Transform2(" ", kUppercaseFirst, ""),
    new Transform2("", kIdentity, ". "),
    new Transform2(".", kIdentity, ""),
    new Transform2(" ", kIdentity, ", "),
    new Transform2("", kOmitFirst4, ""),
    new Transform2("", kIdentity, " with "),
    new Transform2("", kIdentity, "'"),
    new Transform2("", kIdentity, " from "),
    new Transform2("", kIdentity, " by "),
    new Transform2("", kOmitFirst5, ""),
    new Transform2("", kOmitFirst6, ""),
    new Transform2(" the ", kIdentity, ""),
    new Transform2("", kOmitLast4, ""),
    new Transform2("", kIdentity, ". The "),
    new Transform2("", kUppercaseAll, ""),
    new Transform2("", kIdentity, " on "),
    new Transform2("", kIdentity, " as "),
    new Transform2("", kIdentity, " is "),
    new Transform2("", kOmitLast7, ""),
    new Transform2("", kOmitLast1, "ing "),
    new Transform2("", kIdentity, "\n	"),
    new Transform2("", kIdentity, ":"),
    new Transform2(" ", kIdentity, ". "),
    new Transform2("", kIdentity, "ed "),
    new Transform2("", kOmitFirst9, ""),
    new Transform2("", kOmitFirst7, ""),
    new Transform2("", kOmitLast6, ""),
    new Transform2("", kIdentity, "("),
    new Transform2("", kUppercaseFirst, ", "),
    new Transform2("", kOmitLast8, ""),
    new Transform2("", kIdentity, " at "),
    new Transform2("", kIdentity, "ly "),
    new Transform2(" the ", kIdentity, " of "),
    new Transform2("", kOmitLast5, ""),
    new Transform2("", kOmitLast9, ""),
    new Transform2(" ", kUppercaseFirst, ", "),
    new Transform2("", kUppercaseFirst, '"'),
    new Transform2(".", kIdentity, "("),
    new Transform2("", kUppercaseAll, " "),
    new Transform2("", kUppercaseFirst, '">'),
    new Transform2("", kIdentity, '="'),
    new Transform2(" ", kIdentity, "."),
    new Transform2(".com/", kIdentity, ""),
    new Transform2(" the ", kIdentity, " of the "),
    new Transform2("", kUppercaseFirst, "'"),
    new Transform2("", kIdentity, ". This "),
    new Transform2("", kIdentity, ","),
    new Transform2(".", kIdentity, " "),
    new Transform2("", kUppercaseFirst, "("),
    new Transform2("", kUppercaseFirst, "."),
    new Transform2("", kIdentity, " not "),
    new Transform2(" ", kIdentity, '="'),
    new Transform2("", kIdentity, "er "),
    new Transform2(" ", kUppercaseAll, " "),
    new Transform2("", kIdentity, "al "),
    new Transform2(" ", kUppercaseAll, ""),
    new Transform2("", kIdentity, "='"),
    new Transform2("", kUppercaseAll, '"'),
    new Transform2("", kUppercaseFirst, ". "),
    new Transform2(" ", kIdentity, "("),
    new Transform2("", kIdentity, "ful "),
    new Transform2(" ", kUppercaseFirst, ". "),
    new Transform2("", kIdentity, "ive "),
    new Transform2("", kIdentity, "less "),
    new Transform2("", kUppercaseAll, "'"),
    new Transform2("", kIdentity, "est "),
    new Transform2(" ", kUppercaseFirst, "."),
    new Transform2("", kUppercaseAll, '">'),
    new Transform2(" ", kIdentity, "='"),
    new Transform2("", kUppercaseFirst, ","),
    new Transform2("", kIdentity, "ize "),
    new Transform2("", kUppercaseAll, "."),
    new Transform2("", kIdentity, ""),
    new Transform2(" ", kIdentity, ","),
    new Transform2("", kUppercaseFirst, '="'),
    new Transform2("", kUppercaseAll, '="'),
    new Transform2("", kIdentity, "ous "),
    new Transform2("", kUppercaseAll, ", "),
    new Transform2("", kUppercaseFirst, "='"),
    new Transform2(" ", kUppercaseFirst, ","),
    new Transform2(" ", kUppercaseAll, '="'),
    new Transform2(" ", kUppercaseAll, ", "),
    new Transform2("", kUppercaseAll, ","),
    new Transform2("", kUppercaseAll, "("),
    new Transform2("", kUppercaseAll, ". "),
    new Transform2(" ", kUppercaseAll, "."),
    new Transform2("", kUppercaseAll, "='"),
    new Transform2(" ", kUppercaseAll, ". "),
    new Transform2(" ", kUppercaseFirst, '="'),
    new Transform2(" ", kUppercaseAll, "='"),
    new Transform2(" ", kUppercaseFirst, "='")
  ];
  transform.kTransforms = kTransforms;
  transform.kNumTransforms = kTransforms.length;
  function ToUpperCase(p2, i2) {
    if (p2[i2] < 192) {
      if (p2[i2] >= 97 && p2[i2] <= 122) {
        p2[i2] ^= 32;
      }
      return 1;
    }
    if (p2[i2] < 224) {
      p2[i2 + 1] ^= 32;
      return 2;
    }
    p2[i2 + 2] ^= 5;
    return 3;
  }
  transform.transformDictionaryWord = function(dst, idx, word, len, transform2) {
    var prefix2 = kTransforms[transform2].prefix;
    var suffix = kTransforms[transform2].suffix;
    var t2 = kTransforms[transform2].transform;
    var skip = t2 < kOmitFirst1 ? 0 : t2 - (kOmitFirst1 - 1);
    var i2 = 0;
    var start_idx = idx;
    var uppercase;
    if (skip > len) {
      skip = len;
    }
    var prefix_pos = 0;
    while (prefix_pos < prefix2.length) {
      dst[idx++] = prefix2[prefix_pos++];
    }
    word += skip;
    len -= skip;
    if (t2 <= kOmitLast9) {
      len -= t2;
    }
    for (i2 = 0; i2 < len; i2++) {
      dst[idx++] = BrotliDictionary.dictionary[word + i2];
    }
    uppercase = idx - len;
    if (t2 === kUppercaseFirst) {
      ToUpperCase(dst, uppercase);
    } else if (t2 === kUppercaseAll) {
      while (len > 0) {
        var step = ToUpperCase(dst, uppercase);
        uppercase += step;
        len -= step;
      }
    }
    var suffix_pos = 0;
    while (suffix_pos < suffix.length) {
      dst[idx++] = suffix[suffix_pos++];
    }
    return idx - start_idx;
  };
  return transform;
}
var hasRequiredDecode;
function requireDecode() {
  if (hasRequiredDecode) return decode$1;
  hasRequiredDecode = 1;
  var BrotliInput = requireStreams().BrotliInput;
  var BrotliOutput = requireStreams().BrotliOutput;
  var BrotliBitReader = requireBit_reader();
  var BrotliDictionary = requireDictionary();
  var HuffmanCode = requireHuffman().HuffmanCode;
  var BrotliBuildHuffmanTable = requireHuffman().BrotliBuildHuffmanTable;
  var Context = requireContext();
  var Prefix = requirePrefix();
  var Transform2 = requireTransform();
  var kDefaultCodeLength = 8;
  var kCodeLengthRepeatCode = 16;
  var kNumLiteralCodes = 256;
  var kNumInsertAndCopyCodes = 704;
  var kNumBlockLengthCodes = 26;
  var kLiteralContextBits = 6;
  var kDistanceContextBits = 2;
  var HUFFMAN_TABLE_BITS = 8;
  var HUFFMAN_TABLE_MASK = 255;
  var HUFFMAN_MAX_TABLE_SIZE = 1080;
  var CODE_LENGTH_CODES = 18;
  var kCodeLengthCodeOrder = new Uint8Array([
    1,
    2,
    3,
    4,
    0,
    5,
    17,
    6,
    16,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15
  ]);
  var NUM_DISTANCE_SHORT_CODES = 16;
  var kDistanceShortCodeIndexOffset = new Uint8Array([
    3,
    2,
    1,
    0,
    3,
    3,
    3,
    3,
    3,
    3,
    2,
    2,
    2,
    2,
    2,
    2
  ]);
  var kDistanceShortCodeValueOffset = new Int8Array([
    0,
    0,
    0,
    0,
    -1,
    1,
    -2,
    2,
    -3,
    3,
    -1,
    1,
    -2,
    2,
    -3,
    3
  ]);
  var kMaxHuffmanTableSize = new Uint16Array([
    256,
    402,
    436,
    468,
    500,
    534,
    566,
    598,
    630,
    662,
    694,
    726,
    758,
    790,
    822,
    854,
    886,
    920,
    952,
    984,
    1016,
    1048,
    1080
  ]);
  function DecodeWindowBits(br) {
    var n3;
    if (br.readBits(1) === 0) {
      return 16;
    }
    n3 = br.readBits(3);
    if (n3 > 0) {
      return 17 + n3;
    }
    n3 = br.readBits(3);
    if (n3 > 0) {
      return 8 + n3;
    }
    return 17;
  }
  function DecodeVarLenUint8(br) {
    if (br.readBits(1)) {
      var nbits = br.readBits(3);
      if (nbits === 0) {
        return 1;
      } else {
        return br.readBits(nbits) + (1 << nbits);
      }
    }
    return 0;
  }
  function MetaBlockLength() {
    this.meta_block_length = 0;
    this.input_end = 0;
    this.is_uncompressed = 0;
    this.is_metadata = false;
  }
  function DecodeMetaBlockLength(br) {
    var out = new MetaBlockLength();
    var size_nibbles;
    var size_bytes;
    var i2;
    out.input_end = br.readBits(1);
    if (out.input_end && br.readBits(1)) {
      return out;
    }
    size_nibbles = br.readBits(2) + 4;
    if (size_nibbles === 7) {
      out.is_metadata = true;
      if (br.readBits(1) !== 0)
        throw new Error("Invalid reserved bit");
      size_bytes = br.readBits(2);
      if (size_bytes === 0)
        return out;
      for (i2 = 0; i2 < size_bytes; i2++) {
        var next_byte = br.readBits(8);
        if (i2 + 1 === size_bytes && size_bytes > 1 && next_byte === 0)
          throw new Error("Invalid size byte");
        out.meta_block_length |= next_byte << i2 * 8;
      }
    } else {
      for (i2 = 0; i2 < size_nibbles; ++i2) {
        var next_nibble = br.readBits(4);
        if (i2 + 1 === size_nibbles && size_nibbles > 4 && next_nibble === 0)
          throw new Error("Invalid size nibble");
        out.meta_block_length |= next_nibble << i2 * 4;
      }
    }
    ++out.meta_block_length;
    if (!out.input_end && !out.is_metadata) {
      out.is_uncompressed = br.readBits(1);
    }
    return out;
  }
  function ReadSymbol(table, index2, br) {
    var nbits;
    br.fillBitWindow();
    index2 += br.val_ >>> br.bit_pos_ & HUFFMAN_TABLE_MASK;
    nbits = table[index2].bits - HUFFMAN_TABLE_BITS;
    if (nbits > 0) {
      br.bit_pos_ += HUFFMAN_TABLE_BITS;
      index2 += table[index2].value;
      index2 += br.val_ >>> br.bit_pos_ & (1 << nbits) - 1;
    }
    br.bit_pos_ += table[index2].bits;
    return table[index2].value;
  }
  function ReadHuffmanCodeLengths(code_length_code_lengths, num_symbols, code_lengths, br) {
    var symbol = 0;
    var prev_code_len = kDefaultCodeLength;
    var repeat2 = 0;
    var repeat_code_len = 0;
    var space = 32768;
    var table = [];
    for (var i2 = 0; i2 < 32; i2++)
      table.push(new HuffmanCode(0, 0));
    BrotliBuildHuffmanTable(table, 0, 5, code_length_code_lengths, CODE_LENGTH_CODES);
    while (symbol < num_symbols && space > 0) {
      var p2 = 0;
      var code_len;
      br.readMoreInput();
      br.fillBitWindow();
      p2 += br.val_ >>> br.bit_pos_ & 31;
      br.bit_pos_ += table[p2].bits;
      code_len = table[p2].value & 255;
      if (code_len < kCodeLengthRepeatCode) {
        repeat2 = 0;
        code_lengths[symbol++] = code_len;
        if (code_len !== 0) {
          prev_code_len = code_len;
          space -= 32768 >> code_len;
        }
      } else {
        var extra_bits = code_len - 14;
        var old_repeat;
        var repeat_delta;
        var new_len = 0;
        if (code_len === kCodeLengthRepeatCode) {
          new_len = prev_code_len;
        }
        if (repeat_code_len !== new_len) {
          repeat2 = 0;
          repeat_code_len = new_len;
        }
        old_repeat = repeat2;
        if (repeat2 > 0) {
          repeat2 -= 2;
          repeat2 <<= extra_bits;
        }
        repeat2 += br.readBits(extra_bits) + 3;
        repeat_delta = repeat2 - old_repeat;
        if (symbol + repeat_delta > num_symbols) {
          throw new Error("[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols");
        }
        for (var x = 0; x < repeat_delta; x++)
          code_lengths[symbol + x] = repeat_code_len;
        symbol += repeat_delta;
        if (repeat_code_len !== 0) {
          space -= repeat_delta << 15 - repeat_code_len;
        }
      }
    }
    if (space !== 0) {
      throw new Error("[ReadHuffmanCodeLengths] space = " + space);
    }
    for (; symbol < num_symbols; symbol++)
      code_lengths[symbol] = 0;
  }
  function ReadHuffmanCode(alphabet_size, tables, table, br) {
    var table_size = 0;
    var simple_code_or_skip;
    var code_lengths = new Uint8Array(alphabet_size);
    br.readMoreInput();
    simple_code_or_skip = br.readBits(2);
    if (simple_code_or_skip === 1) {
      var i2;
      var max_bits_counter = alphabet_size - 1;
      var max_bits = 0;
      var symbols = new Int32Array(4);
      var num_symbols = br.readBits(2) + 1;
      while (max_bits_counter) {
        max_bits_counter >>= 1;
        ++max_bits;
      }
      for (i2 = 0; i2 < num_symbols; ++i2) {
        symbols[i2] = br.readBits(max_bits) % alphabet_size;
        code_lengths[symbols[i2]] = 2;
      }
      code_lengths[symbols[0]] = 1;
      switch (num_symbols) {
        case 1:
          break;
        case 3:
          if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[1] === symbols[2]) {
            throw new Error("[ReadHuffmanCode] invalid symbols");
          }
          break;
        case 2:
          if (symbols[0] === symbols[1]) {
            throw new Error("[ReadHuffmanCode] invalid symbols");
          }
          code_lengths[symbols[1]] = 1;
          break;
        case 4:
          if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[0] === symbols[3] || symbols[1] === symbols[2] || symbols[1] === symbols[3] || symbols[2] === symbols[3]) {
            throw new Error("[ReadHuffmanCode] invalid symbols");
          }
          if (br.readBits(1)) {
            code_lengths[symbols[2]] = 3;
            code_lengths[symbols[3]] = 3;
          } else {
            code_lengths[symbols[0]] = 2;
          }
          break;
      }
    } else {
      var i2;
      var code_length_code_lengths = new Uint8Array(CODE_LENGTH_CODES);
      var space = 32;
      var num_codes = 0;
      var huff = [
        new HuffmanCode(2, 0),
        new HuffmanCode(2, 4),
        new HuffmanCode(2, 3),
        new HuffmanCode(3, 2),
        new HuffmanCode(2, 0),
        new HuffmanCode(2, 4),
        new HuffmanCode(2, 3),
        new HuffmanCode(4, 1),
        new HuffmanCode(2, 0),
        new HuffmanCode(2, 4),
        new HuffmanCode(2, 3),
        new HuffmanCode(3, 2),
        new HuffmanCode(2, 0),
        new HuffmanCode(2, 4),
        new HuffmanCode(2, 3),
        new HuffmanCode(4, 5)
      ];
      for (i2 = simple_code_or_skip; i2 < CODE_LENGTH_CODES && space > 0; ++i2) {
        var code_len_idx = kCodeLengthCodeOrder[i2];
        var p2 = 0;
        var v2;
        br.fillBitWindow();
        p2 += br.val_ >>> br.bit_pos_ & 15;
        br.bit_pos_ += huff[p2].bits;
        v2 = huff[p2].value;
        code_length_code_lengths[code_len_idx] = v2;
        if (v2 !== 0) {
          space -= 32 >> v2;
          ++num_codes;
        }
      }
      if (!(num_codes === 1 || space === 0))
        throw new Error("[ReadHuffmanCode] invalid num_codes or space");
      ReadHuffmanCodeLengths(code_length_code_lengths, alphabet_size, code_lengths, br);
    }
    table_size = BrotliBuildHuffmanTable(tables, table, HUFFMAN_TABLE_BITS, code_lengths, alphabet_size);
    if (table_size === 0) {
      throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
    }
    return table_size;
  }
  function ReadBlockLength(table, index2, br) {
    var code;
    var nbits;
    code = ReadSymbol(table, index2, br);
    nbits = Prefix.kBlockLengthPrefixCode[code].nbits;
    return Prefix.kBlockLengthPrefixCode[code].offset + br.readBits(nbits);
  }
  function TranslateShortCodes(code, ringbuffer, index2) {
    var val;
    if (code < NUM_DISTANCE_SHORT_CODES) {
      index2 += kDistanceShortCodeIndexOffset[code];
      index2 &= 3;
      val = ringbuffer[index2] + kDistanceShortCodeValueOffset[code];
    } else {
      val = code - NUM_DISTANCE_SHORT_CODES + 1;
    }
    return val;
  }
  function MoveToFront(v2, index2) {
    var value2 = v2[index2];
    var i2 = index2;
    for (; i2; --i2) v2[i2] = v2[i2 - 1];
    v2[0] = value2;
  }
  function InverseMoveToFrontTransform(v2, v_len) {
    var mtf = new Uint8Array(256);
    var i2;
    for (i2 = 0; i2 < 256; ++i2) {
      mtf[i2] = i2;
    }
    for (i2 = 0; i2 < v_len; ++i2) {
      var index2 = v2[i2];
      v2[i2] = mtf[index2];
      if (index2) MoveToFront(mtf, index2);
    }
  }
  function HuffmanTreeGroup(alphabet_size, num_htrees) {
    this.alphabet_size = alphabet_size;
    this.num_htrees = num_htrees;
    this.codes = new Array(num_htrees + num_htrees * kMaxHuffmanTableSize[alphabet_size + 31 >>> 5]);
    this.htrees = new Uint32Array(num_htrees);
  }
  HuffmanTreeGroup.prototype.decode = function(br) {
    var i2;
    var table_size;
    var next = 0;
    for (i2 = 0; i2 < this.num_htrees; ++i2) {
      this.htrees[i2] = next;
      table_size = ReadHuffmanCode(this.alphabet_size, this.codes, next, br);
      next += table_size;
    }
  };
  function DecodeContextMap(context_map_size, br) {
    var out = { num_htrees: null, context_map: null };
    var use_rle_for_zeros;
    var max_run_length_prefix = 0;
    var table;
    var i2;
    br.readMoreInput();
    var num_htrees = out.num_htrees = DecodeVarLenUint8(br) + 1;
    var context_map = out.context_map = new Uint8Array(context_map_size);
    if (num_htrees <= 1) {
      return out;
    }
    use_rle_for_zeros = br.readBits(1);
    if (use_rle_for_zeros) {
      max_run_length_prefix = br.readBits(4) + 1;
    }
    table = [];
    for (i2 = 0; i2 < HUFFMAN_MAX_TABLE_SIZE; i2++) {
      table[i2] = new HuffmanCode(0, 0);
    }
    ReadHuffmanCode(num_htrees + max_run_length_prefix, table, 0, br);
    for (i2 = 0; i2 < context_map_size; ) {
      var code;
      br.readMoreInput();
      code = ReadSymbol(table, 0, br);
      if (code === 0) {
        context_map[i2] = 0;
        ++i2;
      } else if (code <= max_run_length_prefix) {
        var reps = 1 + (1 << code) + br.readBits(code);
        while (--reps) {
          if (i2 >= context_map_size) {
            throw new Error("[DecodeContextMap] i >= context_map_size");
          }
          context_map[i2] = 0;
          ++i2;
        }
      } else {
        context_map[i2] = code - max_run_length_prefix;
        ++i2;
      }
    }
    if (br.readBits(1)) {
      InverseMoveToFrontTransform(context_map, context_map_size);
    }
    return out;
  }
  function DecodeBlockType(max_block_type, trees2, tree_type, block_types, ringbuffers, indexes, br) {
    var ringbuffer = tree_type * 2;
    var index2 = tree_type;
    var type_code = ReadSymbol(trees2, tree_type * HUFFMAN_MAX_TABLE_SIZE, br);
    var block_type;
    if (type_code === 0) {
      block_type = ringbuffers[ringbuffer + (indexes[index2] & 1)];
    } else if (type_code === 1) {
      block_type = ringbuffers[ringbuffer + (indexes[index2] - 1 & 1)] + 1;
    } else {
      block_type = type_code - 2;
    }
    if (block_type >= max_block_type) {
      block_type -= max_block_type;
    }
    block_types[tree_type] = block_type;
    ringbuffers[ringbuffer + (indexes[index2] & 1)] = block_type;
    ++indexes[index2];
  }
  function CopyUncompressedBlockToOutput(output, len, pos, ringbuffer, ringbuffer_mask, br) {
    var rb_size = ringbuffer_mask + 1;
    var rb_pos = pos & ringbuffer_mask;
    var br_pos = br.pos_ & BrotliBitReader.IBUF_MASK;
    var nbytes;
    if (len < 8 || br.bit_pos_ + (len << 3) < br.bit_end_pos_) {
      while (len-- > 0) {
        br.readMoreInput();
        ringbuffer[rb_pos++] = br.readBits(8);
        if (rb_pos === rb_size) {
          output.write(ringbuffer, rb_size);
          rb_pos = 0;
        }
      }
      return;
    }
    if (br.bit_end_pos_ < 32) {
      throw new Error("[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32");
    }
    while (br.bit_pos_ < 32) {
      ringbuffer[rb_pos] = br.val_ >>> br.bit_pos_;
      br.bit_pos_ += 8;
      ++rb_pos;
      --len;
    }
    nbytes = br.bit_end_pos_ - br.bit_pos_ >> 3;
    if (br_pos + nbytes > BrotliBitReader.IBUF_MASK) {
      var tail = BrotliBitReader.IBUF_MASK + 1 - br_pos;
      for (var x = 0; x < tail; x++)
        ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
      nbytes -= tail;
      rb_pos += tail;
      len -= tail;
      br_pos = 0;
    }
    for (var x = 0; x < nbytes; x++)
      ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
    rb_pos += nbytes;
    len -= nbytes;
    if (rb_pos >= rb_size) {
      output.write(ringbuffer, rb_size);
      rb_pos -= rb_size;
      for (var x = 0; x < rb_pos; x++)
        ringbuffer[x] = ringbuffer[rb_size + x];
    }
    while (rb_pos + len >= rb_size) {
      nbytes = rb_size - rb_pos;
      if (br.input_.read(ringbuffer, rb_pos, nbytes) < nbytes) {
        throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
      }
      output.write(ringbuffer, rb_size);
      len -= nbytes;
      rb_pos = 0;
    }
    if (br.input_.read(ringbuffer, rb_pos, len) < len) {
      throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
    }
    br.reset();
  }
  function JumpToByteBoundary(br) {
    var new_bit_pos = br.bit_pos_ + 7 & -8;
    var pad_bits = br.readBits(new_bit_pos - br.bit_pos_);
    return pad_bits == 0;
  }
  function BrotliDecompressedSize(buffer) {
    var input = new BrotliInput(buffer);
    var br = new BrotliBitReader(input);
    DecodeWindowBits(br);
    var out = DecodeMetaBlockLength(br);
    return out.meta_block_length;
  }
  decode$1.BrotliDecompressedSize = BrotliDecompressedSize;
  function BrotliDecompressBuffer(buffer, output_size) {
    var input = new BrotliInput(buffer);
    if (output_size == null) {
      output_size = BrotliDecompressedSize(buffer);
    }
    var output_buffer = new Uint8Array(output_size);
    var output = new BrotliOutput(output_buffer);
    BrotliDecompress(input, output);
    if (output.pos < output.buffer.length) {
      output.buffer = output.buffer.subarray(0, output.pos);
    }
    return output.buffer;
  }
  decode$1.BrotliDecompressBuffer = BrotliDecompressBuffer;
  function BrotliDecompress(input, output) {
    var i2;
    var pos = 0;
    var input_end = 0;
    var window_bits = 0;
    var max_backward_distance;
    var max_distance = 0;
    var ringbuffer_size;
    var ringbuffer_mask;
    var ringbuffer;
    var ringbuffer_end;
    var dist_rb = [16, 15, 11, 4];
    var dist_rb_idx = 0;
    var prev_byte1 = 0;
    var prev_byte2 = 0;
    var hgroup = [new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0)];
    var block_type_trees;
    var block_len_trees;
    var br;
    var kRingBufferWriteAheadSlack = 128 + BrotliBitReader.READ_SIZE;
    br = new BrotliBitReader(input);
    window_bits = DecodeWindowBits(br);
    max_backward_distance = (1 << window_bits) - 16;
    ringbuffer_size = 1 << window_bits;
    ringbuffer_mask = ringbuffer_size - 1;
    ringbuffer = new Uint8Array(ringbuffer_size + kRingBufferWriteAheadSlack + BrotliDictionary.maxDictionaryWordLength);
    ringbuffer_end = ringbuffer_size;
    block_type_trees = [];
    block_len_trees = [];
    for (var x = 0; x < 3 * HUFFMAN_MAX_TABLE_SIZE; x++) {
      block_type_trees[x] = new HuffmanCode(0, 0);
      block_len_trees[x] = new HuffmanCode(0, 0);
    }
    while (!input_end) {
      var meta_block_remaining_len = 0;
      var is_uncompressed;
      var block_length = [1 << 28, 1 << 28, 1 << 28];
      var block_type = [0];
      var num_block_types = [1, 1, 1];
      var block_type_rb = [0, 1, 0, 1, 0, 1];
      var block_type_rb_index = [0];
      var distance_postfix_bits;
      var num_direct_distance_codes;
      var distance_postfix_mask;
      var num_distance_codes;
      var context_map = null;
      var context_modes = null;
      var num_literal_htrees;
      var dist_context_map = null;
      var num_dist_htrees;
      var context_offset = 0;
      var context_map_slice = null;
      var literal_htree_index = 0;
      var dist_context_offset = 0;
      var dist_context_map_slice = null;
      var dist_htree_index = 0;
      var context_lookup_offset1 = 0;
      var context_lookup_offset2 = 0;
      var context_mode;
      var htree_command;
      for (i2 = 0; i2 < 3; ++i2) {
        hgroup[i2].codes = null;
        hgroup[i2].htrees = null;
      }
      br.readMoreInput();
      var _out = DecodeMetaBlockLength(br);
      meta_block_remaining_len = _out.meta_block_length;
      if (pos + meta_block_remaining_len > output.buffer.length) {
        var tmp = new Uint8Array(pos + meta_block_remaining_len);
        tmp.set(output.buffer);
        output.buffer = tmp;
      }
      input_end = _out.input_end;
      is_uncompressed = _out.is_uncompressed;
      if (_out.is_metadata) {
        JumpToByteBoundary(br);
        for (; meta_block_remaining_len > 0; --meta_block_remaining_len) {
          br.readMoreInput();
          br.readBits(8);
        }
        continue;
      }
      if (meta_block_remaining_len === 0) {
        continue;
      }
      if (is_uncompressed) {
        br.bit_pos_ = br.bit_pos_ + 7 & -8;
        CopyUncompressedBlockToOutput(
          output,
          meta_block_remaining_len,
          pos,
          ringbuffer,
          ringbuffer_mask,
          br
        );
        pos += meta_block_remaining_len;
        continue;
      }
      for (i2 = 0; i2 < 3; ++i2) {
        num_block_types[i2] = DecodeVarLenUint8(br) + 1;
        if (num_block_types[i2] >= 2) {
          ReadHuffmanCode(num_block_types[i2] + 2, block_type_trees, i2 * HUFFMAN_MAX_TABLE_SIZE, br);
          ReadHuffmanCode(kNumBlockLengthCodes, block_len_trees, i2 * HUFFMAN_MAX_TABLE_SIZE, br);
          block_length[i2] = ReadBlockLength(block_len_trees, i2 * HUFFMAN_MAX_TABLE_SIZE, br);
          block_type_rb_index[i2] = 1;
        }
      }
      br.readMoreInput();
      distance_postfix_bits = br.readBits(2);
      num_direct_distance_codes = NUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distance_postfix_bits);
      distance_postfix_mask = (1 << distance_postfix_bits) - 1;
      num_distance_codes = num_direct_distance_codes + (48 << distance_postfix_bits);
      context_modes = new Uint8Array(num_block_types[0]);
      for (i2 = 0; i2 < num_block_types[0]; ++i2) {
        br.readMoreInput();
        context_modes[i2] = br.readBits(2) << 1;
      }
      var _o1 = DecodeContextMap(num_block_types[0] << kLiteralContextBits, br);
      num_literal_htrees = _o1.num_htrees;
      context_map = _o1.context_map;
      var _o2 = DecodeContextMap(num_block_types[2] << kDistanceContextBits, br);
      num_dist_htrees = _o2.num_htrees;
      dist_context_map = _o2.context_map;
      hgroup[0] = new HuffmanTreeGroup(kNumLiteralCodes, num_literal_htrees);
      hgroup[1] = new HuffmanTreeGroup(kNumInsertAndCopyCodes, num_block_types[1]);
      hgroup[2] = new HuffmanTreeGroup(num_distance_codes, num_dist_htrees);
      for (i2 = 0; i2 < 3; ++i2) {
        hgroup[i2].decode(br);
      }
      context_map_slice = 0;
      dist_context_map_slice = 0;
      context_mode = context_modes[block_type[0]];
      context_lookup_offset1 = Context.lookupOffsets[context_mode];
      context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
      htree_command = hgroup[1].htrees[0];
      while (meta_block_remaining_len > 0) {
        var cmd_code;
        var range_idx;
        var insert_code;
        var copy_code;
        var insert_length;
        var copy_length;
        var distance_code;
        var distance;
        var context2;
        var j;
        var copy_dst;
        br.readMoreInput();
        if (block_length[1] === 0) {
          DecodeBlockType(
            num_block_types[1],
            block_type_trees,
            1,
            block_type,
            block_type_rb,
            block_type_rb_index,
            br
          );
          block_length[1] = ReadBlockLength(block_len_trees, HUFFMAN_MAX_TABLE_SIZE, br);
          htree_command = hgroup[1].htrees[block_type[1]];
        }
        --block_length[1];
        cmd_code = ReadSymbol(hgroup[1].codes, htree_command, br);
        range_idx = cmd_code >> 6;
        if (range_idx >= 2) {
          range_idx -= 2;
          distance_code = -1;
        } else {
          distance_code = 0;
        }
        insert_code = Prefix.kInsertRangeLut[range_idx] + (cmd_code >> 3 & 7);
        copy_code = Prefix.kCopyRangeLut[range_idx] + (cmd_code & 7);
        insert_length = Prefix.kInsertLengthPrefixCode[insert_code].offset + br.readBits(Prefix.kInsertLengthPrefixCode[insert_code].nbits);
        copy_length = Prefix.kCopyLengthPrefixCode[copy_code].offset + br.readBits(Prefix.kCopyLengthPrefixCode[copy_code].nbits);
        prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
        prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
        for (j = 0; j < insert_length; ++j) {
          br.readMoreInput();
          if (block_length[0] === 0) {
            DecodeBlockType(
              num_block_types[0],
              block_type_trees,
              0,
              block_type,
              block_type_rb,
              block_type_rb_index,
              br
            );
            block_length[0] = ReadBlockLength(block_len_trees, 0, br);
            context_offset = block_type[0] << kLiteralContextBits;
            context_map_slice = context_offset;
            context_mode = context_modes[block_type[0]];
            context_lookup_offset1 = Context.lookupOffsets[context_mode];
            context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
          }
          context2 = Context.lookup[context_lookup_offset1 + prev_byte1] | Context.lookup[context_lookup_offset2 + prev_byte2];
          literal_htree_index = context_map[context_map_slice + context2];
          --block_length[0];
          prev_byte2 = prev_byte1;
          prev_byte1 = ReadSymbol(hgroup[0].codes, hgroup[0].htrees[literal_htree_index], br);
          ringbuffer[pos & ringbuffer_mask] = prev_byte1;
          if ((pos & ringbuffer_mask) === ringbuffer_mask) {
            output.write(ringbuffer, ringbuffer_size);
          }
          ++pos;
        }
        meta_block_remaining_len -= insert_length;
        if (meta_block_remaining_len <= 0) break;
        if (distance_code < 0) {
          var context2;
          br.readMoreInput();
          if (block_length[2] === 0) {
            DecodeBlockType(
              num_block_types[2],
              block_type_trees,
              2,
              block_type,
              block_type_rb,
              block_type_rb_index,
              br
            );
            block_length[2] = ReadBlockLength(block_len_trees, 2 * HUFFMAN_MAX_TABLE_SIZE, br);
            dist_context_offset = block_type[2] << kDistanceContextBits;
            dist_context_map_slice = dist_context_offset;
          }
          --block_length[2];
          context2 = (copy_length > 4 ? 3 : copy_length - 2) & 255;
          dist_htree_index = dist_context_map[dist_context_map_slice + context2];
          distance_code = ReadSymbol(hgroup[2].codes, hgroup[2].htrees[dist_htree_index], br);
          if (distance_code >= num_direct_distance_codes) {
            var nbits;
            var postfix;
            var offset2;
            distance_code -= num_direct_distance_codes;
            postfix = distance_code & distance_postfix_mask;
            distance_code >>= distance_postfix_bits;
            nbits = (distance_code >> 1) + 1;
            offset2 = (2 + (distance_code & 1) << nbits) - 4;
            distance_code = num_direct_distance_codes + (offset2 + br.readBits(nbits) << distance_postfix_bits) + postfix;
          }
        }
        distance = TranslateShortCodes(distance_code, dist_rb, dist_rb_idx);
        if (distance < 0) {
          throw new Error("[BrotliDecompress] invalid distance");
        }
        if (pos < max_backward_distance && max_distance !== max_backward_distance) {
          max_distance = pos;
        } else {
          max_distance = max_backward_distance;
        }
        copy_dst = pos & ringbuffer_mask;
        if (distance > max_distance) {
          if (copy_length >= BrotliDictionary.minDictionaryWordLength && copy_length <= BrotliDictionary.maxDictionaryWordLength) {
            var offset2 = BrotliDictionary.offsetsByLength[copy_length];
            var word_id = distance - max_distance - 1;
            var shift = BrotliDictionary.sizeBitsByLength[copy_length];
            var mask = (1 << shift) - 1;
            var word_idx = word_id & mask;
            var transform_idx = word_id >> shift;
            offset2 += word_idx * copy_length;
            if (transform_idx < Transform2.kNumTransforms) {
              var len = Transform2.transformDictionaryWord(ringbuffer, copy_dst, offset2, copy_length, transform_idx);
              copy_dst += len;
              pos += len;
              meta_block_remaining_len -= len;
              if (copy_dst >= ringbuffer_end) {
                output.write(ringbuffer, ringbuffer_size);
                for (var _x = 0; _x < copy_dst - ringbuffer_end; _x++)
                  ringbuffer[_x] = ringbuffer[ringbuffer_end + _x];
              }
            } else {
              throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
            }
          } else {
            throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
          }
        } else {
          if (distance_code > 0) {
            dist_rb[dist_rb_idx & 3] = distance;
            ++dist_rb_idx;
          }
          if (copy_length > meta_block_remaining_len) {
            throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
          }
          for (j = 0; j < copy_length; ++j) {
            ringbuffer[pos & ringbuffer_mask] = ringbuffer[pos - distance & ringbuffer_mask];
            if ((pos & ringbuffer_mask) === ringbuffer_mask) {
              output.write(ringbuffer, ringbuffer_size);
            }
            ++pos;
            --meta_block_remaining_len;
          }
        }
        prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
        prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
      }
      pos &= 1073741823;
    }
    output.write(ringbuffer, pos & ringbuffer_mask);
  }
  decode$1.BrotliDecompress = BrotliDecompress;
  BrotliDictionary.init();
  return decode$1;
}
var decompress;
var hasRequiredDecompress;
function requireDecompress() {
  if (hasRequiredDecompress) return decompress;
  hasRequiredDecompress = 1;
  decompress = requireDecode().BrotliDecompressBuffer;
  return decompress;
}
var decompressExports = requireDecompress();
const $6uUbQ$brotlidecompressjs = /* @__PURE__ */ getDefaultExportFromCjs$2(decompressExports);
function $parcel$export(e2, n3, v2, s2) {
  Object.defineProperty(e2, n3, { get: v2, set: s2, enumerable: true, configurable: true });
}
function $parcel$interopDefault(a2) {
  return a2 && a2.__esModule ? a2.default : a2;
}
var $d636bc798e7178db$exports = {};
$parcel$export($d636bc798e7178db$exports, "logErrors", () => $d636bc798e7178db$export$bd5c5d8b8dcafd78);
$parcel$export($d636bc798e7178db$exports, "registerFormat", () => $d636bc798e7178db$export$36b2f24e97d43be);
$parcel$export($d636bc798e7178db$exports, "create", () => $d636bc798e7178db$export$185802fd694ee1f5);
$parcel$export($d636bc798e7178db$exports, "defaultLanguage", () => $d636bc798e7178db$export$42940898df819940);
$parcel$export($d636bc798e7178db$exports, "setDefaultLanguage", () => $d636bc798e7178db$export$5157e7780d44cc36);
let $d636bc798e7178db$export$bd5c5d8b8dcafd78 = false;
let $d636bc798e7178db$var$formats = [];
function $d636bc798e7178db$export$36b2f24e97d43be(format2) {
  $d636bc798e7178db$var$formats.push(format2);
}
function $d636bc798e7178db$export$185802fd694ee1f5(buffer, postscriptName) {
  for (let i2 = 0; i2 < $d636bc798e7178db$var$formats.length; i2++) {
    let format2 = $d636bc798e7178db$var$formats[i2];
    if (format2.probe(buffer)) {
      let font = new format2(new DecodeStream(buffer));
      if (postscriptName) return font.getFont(postscriptName);
      return font;
    }
  }
  throw new Error("Unknown font format");
}
let $d636bc798e7178db$export$42940898df819940 = "en";
function $d636bc798e7178db$export$5157e7780d44cc36(lang = "en") {
  $d636bc798e7178db$export$42940898df819940 = lang;
}
function $e71565f2ce09cb6b$export$69a3209f1a06c04d(target, key, descriptor) {
  if (descriptor.get) {
    let get14 = descriptor.get;
    descriptor.get = function() {
      let value2 = get14.call(this);
      Object.defineProperty(this, key, {
        value: value2
      });
      return value2;
    };
  } else if (typeof descriptor.value === "function") {
    let fn = descriptor.value;
    return {
      get() {
        let cache2 = /* @__PURE__ */ new Map();
        function memoized(...args) {
          let key2 = args.length > 0 ? args[0] : "value";
          if (cache2.has(key2)) return cache2.get(key2);
          let result = fn.apply(this, args);
          cache2.set(key2, result);
          return result;
        }
        Object.defineProperty(this, key, {
          value: memoized
        });
        return memoized;
      }
    };
  }
}
let $26a62205ad06574e$var$SubHeader = new Struct({
  firstCode: uint16,
  entryCount: uint16,
  idDelta: int16,
  idRangeOffset: uint16
});
let $26a62205ad06574e$var$CmapGroup = new Struct({
  startCharCode: uint32,
  endCharCode: uint32,
  glyphID: uint32
});
let $26a62205ad06574e$var$UnicodeValueRange = new Struct({
  startUnicodeValue: uint24,
  additionalCount: uint8
});
let $26a62205ad06574e$var$UVSMapping = new Struct({
  unicodeValue: uint24,
  glyphID: uint16
});
let $26a62205ad06574e$var$DefaultUVS = new ArrayT($26a62205ad06574e$var$UnicodeValueRange, uint32);
let $26a62205ad06574e$var$NonDefaultUVS = new ArrayT($26a62205ad06574e$var$UVSMapping, uint32);
let $26a62205ad06574e$var$VarSelectorRecord = new Struct({
  varSelector: uint24,
  defaultUVS: new Pointer(uint32, $26a62205ad06574e$var$DefaultUVS, {
    type: "parent"
  }),
  nonDefaultUVS: new Pointer(uint32, $26a62205ad06574e$var$NonDefaultUVS, {
    type: "parent"
  })
});
let $26a62205ad06574e$var$CmapSubtable = new VersionedStruct(uint16, {
  0: {
    length: uint16,
    language: uint16,
    codeMap: new LazyArray(uint8, 256)
  },
  2: {
    length: uint16,
    language: uint16,
    subHeaderKeys: new ArrayT(uint16, 256),
    subHeaderCount: (t2) => Math.max.apply(Math, t2.subHeaderKeys),
    subHeaders: new LazyArray($26a62205ad06574e$var$SubHeader, "subHeaderCount"),
    glyphIndexArray: new LazyArray(uint16, "subHeaderCount")
  },
  4: {
    length: uint16,
    language: uint16,
    segCountX2: uint16,
    segCount: (t2) => t2.segCountX2 >> 1,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16,
    endCode: new LazyArray(uint16, "segCount"),
    reservedPad: new Reserved(uint16),
    startCode: new LazyArray(uint16, "segCount"),
    idDelta: new LazyArray(int16, "segCount"),
    idRangeOffset: new LazyArray(uint16, "segCount"),
    glyphIndexArray: new LazyArray(uint16, (t2) => (t2.length - t2._currentOffset) / 2)
  },
  6: {
    length: uint16,
    language: uint16,
    firstCode: uint16,
    entryCount: uint16,
    glyphIndices: new LazyArray(uint16, "entryCount")
  },
  8: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint16,
    is32: new LazyArray(uint8, 8192),
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  10: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    firstCode: uint32,
    entryCount: uint32,
    glyphIndices: new LazyArray(uint16, "numChars")
  },
  12: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  13: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  14: {
    length: uint32,
    numRecords: uint32,
    varSelectors: new LazyArray($26a62205ad06574e$var$VarSelectorRecord, "numRecords")
  }
});
let $26a62205ad06574e$var$CmapEntry = new Struct({
  platformID: uint16,
  encodingID: uint16,
  table: new Pointer(uint32, $26a62205ad06574e$var$CmapSubtable, {
    type: "parent",
    lazy: true
  })
});
var $26a62205ad06574e$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numSubtables: uint16,
  tables: new ArrayT($26a62205ad06574e$var$CmapEntry, "numSubtables")
});
var $f2612a29f92ac062$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  revision: int32,
  checkSumAdjustment: uint32,
  magicNumber: uint32,
  flags: uint16,
  unitsPerEm: uint16,
  created: new ArrayT(int32, 2),
  modified: new ArrayT(int32, 2),
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16,
  macStyle: new Bitfield(uint16, [
    "bold",
    "italic",
    "underline",
    "outline",
    "shadow",
    "condensed",
    "extended"
  ]),
  lowestRecPPEM: uint16,
  fontDirectionHint: int16,
  indexToLocFormat: int16,
  glyphDataFormat: int16
  // 0 for current format
});
var $2c179dd593583073$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  ascent: int16,
  descent: int16,
  lineGap: int16,
  advanceWidthMax: uint16,
  minLeftSideBearing: int16,
  minRightSideBearing: int16,
  xMaxExtent: int16,
  caretSlopeRise: int16,
  caretSlopeRun: int16,
  caretOffset: int16,
  reserved: new Reserved(int16, 4),
  metricDataFormat: int16,
  numberOfMetrics: uint16
  // Number of advance widths in 'hmtx' table
});
let $bdc9060542264b85$var$HmtxEntry = new Struct({
  advance: uint16,
  bearing: int16
});
var $bdc9060542264b85$export$2e2bcd8739ae039 = new Struct({
  metrics: new LazyArray($bdc9060542264b85$var$HmtxEntry, (t2) => t2.parent.hhea.numberOfMetrics),
  bearings: new LazyArray(int16, (t2) => t2.parent.maxp.numGlyphs - t2.parent.hhea.numberOfMetrics)
});
var $dbf51cb3d3fe409d$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  numGlyphs: uint16,
  maxPoints: uint16,
  maxContours: uint16,
  maxComponentPoints: uint16,
  maxComponentContours: uint16,
  maxZones: uint16,
  maxTwilightPoints: uint16,
  maxStorage: uint16,
  maxFunctionDefs: uint16,
  maxInstructionDefs: uint16,
  maxStackElements: uint16,
  maxSizeOfInstructions: uint16,
  maxComponentElements: uint16,
  maxComponentDepth: uint16
  // Maximum levels of recursion; 1 for simple components
});
function $e449ad78d50845fe$export$badc544e0651b6b1(platformID, encodingID, languageID = 0) {
  if (platformID === 1 && $e449ad78d50845fe$export$479e671907f486d1[languageID]) return $e449ad78d50845fe$export$479e671907f486d1[languageID];
  return $e449ad78d50845fe$export$6fef87b7618bdf0b[platformID][encodingID];
}
const $e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS = /* @__PURE__ */ new Set([
  "x-mac-roman",
  "x-mac-cyrillic",
  "iso-8859-6",
  "iso-8859-8"
]);
const $e449ad78d50845fe$var$MAC_ENCODINGS = {
  "x-mac-croatian": " ",
  "x-mac-gaelic": " ",
  "x-mac-greek": " ",
  "x-mac-icelandic": " ",
  "x-mac-inuit": " ",
  "x-mac-ce": " ",
  "x-mac-romanian": " ",
  "x-mac-turkish": " "
};
const $e449ad78d50845fe$var$encodingCache = /* @__PURE__ */ new Map();
function $e449ad78d50845fe$export$1dceb3c14ed68bee(encoding) {
  let cached = $e449ad78d50845fe$var$encodingCache.get(encoding);
  if (cached) return cached;
  let mapping = $e449ad78d50845fe$var$MAC_ENCODINGS[encoding];
  if (mapping) {
    let res = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < mapping.length; i2++) res.set(mapping.charCodeAt(i2), 128 + i2);
    $e449ad78d50845fe$var$encodingCache.set(encoding, res);
    return res;
  }
  if ($e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS.has(encoding)) {
    let decoder2 = new TextDecoder(encoding);
    let mapping2 = new Uint8Array(128);
    for (let i2 = 0; i2 < 128; i2++) mapping2[i2] = 128 + i2;
    let res = /* @__PURE__ */ new Map();
    let s2 = decoder2.decode(mapping2);
    for (let i2 = 0; i2 < 128; i2++) res.set(s2.charCodeAt(i2), 128 + i2);
    $e449ad78d50845fe$var$encodingCache.set(encoding, res);
    return res;
  }
}
const $e449ad78d50845fe$export$6fef87b7618bdf0b = [
  // unicode
  [
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be",
    "utf-16be"
  ],
  // macintosh
  // Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/
  // 0	Roman                 17	Malayalam
  // 1	Japanese	            18	Sinhalese
  // 2	Traditional Chinese	  19	Burmese
  // 3	Korean	              20	Khmer
  // 4	Arabic	              21	Thai
  // 5	Hebrew	              22	Laotian
  // 6	Greek	                23	Georgian
  // 7	Russian	              24	Armenian
  // 8	RSymbol	              25	Simplified Chinese
  // 9	Devanagari	          26	Tibetan
  // 10	Gurmukhi	            27	Mongolian
  // 11	Gujarati	            28	Geez
  // 12	Oriya	                29	Slavic
  // 13	Bengali	              30	Vietnamese
  // 14	Tamil	                31	Sindhi
  // 15	Telugu	              32	(Uninterpreted)
  // 16	Kannada
  [
    "x-mac-roman",
    "shift-jis",
    "big5",
    "euc-kr",
    "iso-8859-6",
    "iso-8859-8",
    "x-mac-greek",
    "x-mac-cyrillic",
    "x-mac-symbol",
    "x-mac-devanagari",
    "x-mac-gurmukhi",
    "x-mac-gujarati",
    "Oriya",
    "Bengali",
    "Tamil",
    "Telugu",
    "Kannada",
    "Malayalam",
    "Sinhalese",
    "Burmese",
    "Khmer",
    "iso-8859-11",
    "Laotian",
    "Georgian",
    "Armenian",
    "gbk",
    "Tibetan",
    "Mongolian",
    "Geez",
    "x-mac-ce",
    "Vietnamese",
    "Sindhi"
  ],
  // ISO (deprecated)
  [
    "ascii",
    null,
    "iso-8859-1"
  ],
  // windows
  // Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx
  [
    "symbol",
    "utf-16be",
    "shift-jis",
    "gb18030",
    "big5",
    "euc-kr",
    "johab",
    null,
    null,
    null,
    "utf-16be"
  ]
];
const $e449ad78d50845fe$export$479e671907f486d1 = {
  15: "x-mac-icelandic",
  17: "x-mac-turkish",
  18: "x-mac-croatian",
  24: "x-mac-ce",
  25: "x-mac-ce",
  26: "x-mac-ce",
  27: "x-mac-ce",
  28: "x-mac-ce",
  30: "x-mac-icelandic",
  37: "x-mac-romanian",
  38: "x-mac-ce",
  39: "x-mac-ce",
  40: "x-mac-ce",
  143: "x-mac-inuit",
  146: "x-mac-gaelic"
};
const $e449ad78d50845fe$export$2092376fd002e13 = [
  // unicode
  [],
  {
    0: "en",
    30: "fo",
    60: "ks",
    90: "rw",
    1: "fr",
    31: "fa",
    61: "ku",
    91: "rn",
    2: "de",
    32: "ru",
    62: "sd",
    92: "ny",
    3: "it",
    33: "zh",
    63: "bo",
    93: "mg",
    4: "nl",
    34: "nl-BE",
    64: "ne",
    94: "eo",
    5: "sv",
    35: "ga",
    65: "sa",
    128: "cy",
    6: "es",
    36: "sq",
    66: "mr",
    129: "eu",
    7: "da",
    37: "ro",
    67: "bn",
    130: "ca",
    8: "pt",
    38: "cz",
    68: "as",
    131: "la",
    9: "no",
    39: "sk",
    69: "gu",
    132: "qu",
    10: "he",
    40: "si",
    70: "pa",
    133: "gn",
    11: "ja",
    41: "yi",
    71: "or",
    134: "ay",
    12: "ar",
    42: "sr",
    72: "ml",
    135: "tt",
    13: "fi",
    43: "mk",
    73: "kn",
    136: "ug",
    14: "el",
    44: "bg",
    74: "ta",
    137: "dz",
    15: "is",
    45: "uk",
    75: "te",
    138: "jv",
    16: "mt",
    46: "be",
    76: "si",
    139: "su",
    17: "tr",
    47: "uz",
    77: "my",
    140: "gl",
    18: "hr",
    48: "kk",
    78: "km",
    141: "af",
    19: "zh-Hant",
    49: "az-Cyrl",
    79: "lo",
    142: "br",
    20: "ur",
    50: "az-Arab",
    80: "vi",
    143: "iu",
    21: "hi",
    51: "hy",
    81: "id",
    144: "gd",
    22: "th",
    52: "ka",
    82: "tl",
    145: "gv",
    23: "ko",
    53: "mo",
    83: "ms",
    146: "ga",
    24: "lt",
    54: "ky",
    84: "ms-Arab",
    147: "to",
    25: "pl",
    55: "tg",
    85: "am",
    148: "el-polyton",
    26: "hu",
    56: "tk",
    86: "ti",
    149: "kl",
    27: "es",
    57: "mn-CN",
    87: "om",
    150: "az",
    28: "lv",
    58: "mn",
    88: "so",
    151: "nn",
    29: "se",
    59: "ps",
    89: "sw"
  },
  // ISO (deprecated)
  [],
  {
    1078: "af",
    16393: "en-IN",
    1159: "rw",
    1074: "tn",
    1052: "sq",
    6153: "en-IE",
    1089: "sw",
    1115: "si",
    1156: "gsw",
    8201: "en-JM",
    1111: "kok",
    1051: "sk",
    1118: "am",
    17417: "en-MY",
    1042: "ko",
    1060: "sl",
    5121: "ar-DZ",
    5129: "en-NZ",
    1088: "ky",
    11274: "es-AR",
    15361: "ar-BH",
    13321: "en-PH",
    1108: "lo",
    16394: "es-BO",
    3073: "ar",
    18441: "en-SG",
    1062: "lv",
    13322: "es-CL",
    2049: "ar-IQ",
    7177: "en-ZA",
    1063: "lt",
    9226: "es-CO",
    11265: "ar-JO",
    11273: "en-TT",
    2094: "dsb",
    5130: "es-CR",
    13313: "ar-KW",
    2057: "en-GB",
    1134: "lb",
    7178: "es-DO",
    12289: "ar-LB",
    1033: "en",
    1071: "mk",
    12298: "es-EC",
    4097: "ar-LY",
    12297: "en-ZW",
    2110: "ms-BN",
    17418: "es-SV",
    6145: "ary",
    1061: "et",
    1086: "ms",
    4106: "es-GT",
    8193: "ar-OM",
    1080: "fo",
    1100: "ml",
    18442: "es-HN",
    16385: "ar-QA",
    1124: "fil",
    1082: "mt",
    2058: "es-MX",
    1025: "ar-SA",
    1035: "fi",
    1153: "mi",
    19466: "es-NI",
    10241: "ar-SY",
    2060: "fr-BE",
    1146: "arn",
    6154: "es-PA",
    7169: "aeb",
    3084: "fr-CA",
    1102: "mr",
    15370: "es-PY",
    14337: "ar-AE",
    1036: "fr",
    1148: "moh",
    10250: "es-PE",
    9217: "ar-YE",
    5132: "fr-LU",
    1104: "mn",
    20490: "es-PR",
    1067: "hy",
    6156: "fr-MC",
    2128: "mn-CN",
    3082: "es",
    1101: "as",
    4108: "fr-CH",
    1121: "ne",
    1034: "es",
    2092: "az-Cyrl",
    1122: "fy",
    1044: "nb",
    21514: "es-US",
    1068: "az",
    1110: "gl",
    2068: "nn",
    14346: "es-UY",
    1133: "ba",
    1079: "ka",
    1154: "oc",
    8202: "es-VE",
    1069: "eu",
    3079: "de-AT",
    1096: "or",
    2077: "sv-FI",
    1059: "be",
    1031: "de",
    1123: "ps",
    1053: "sv",
    2117: "bn",
    5127: "de-LI",
    1045: "pl",
    1114: "syr",
    1093: "bn-IN",
    4103: "de-LU",
    1046: "pt",
    1064: "tg",
    8218: "bs-Cyrl",
    2055: "de-CH",
    2070: "pt-PT",
    2143: "tzm",
    5146: "bs",
    1032: "el",
    1094: "pa",
    1097: "ta",
    1150: "br",
    1135: "kl",
    1131: "qu-BO",
    1092: "tt",
    1026: "bg",
    1095: "gu",
    2155: "qu-EC",
    1098: "te",
    1027: "ca",
    1128: "ha",
    3179: "qu",
    1054: "th",
    3076: "zh-HK",
    1037: "he",
    1048: "ro",
    1105: "bo",
    5124: "zh-MO",
    1081: "hi",
    1047: "rm",
    1055: "tr",
    2052: "zh",
    1038: "hu",
    1049: "ru",
    1090: "tk",
    4100: "zh-SG",
    1039: "is",
    9275: "smn",
    1152: "ug",
    1028: "zh-TW",
    1136: "ig",
    4155: "smj-NO",
    1058: "uk",
    1155: "co",
    1057: "id",
    5179: "smj",
    1070: "hsb",
    1050: "hr",
    1117: "iu",
    3131: "se-FI",
    1056: "ur",
    4122: "hr-BA",
    2141: "iu-Latn",
    1083: "se",
    2115: "uz-Cyrl",
    1029: "cs",
    2108: "ga",
    2107: "se-SE",
    1091: "uz",
    1030: "da",
    1076: "xh",
    8251: "sms",
    1066: "vi",
    1164: "prs",
    1077: "zu",
    6203: "sma-NO",
    1106: "cy",
    1125: "dv",
    1040: "it",
    7227: "sms",
    1160: "wo",
    2067: "nl-BE",
    2064: "it-CH",
    1103: "sa",
    1157: "sah",
    1043: "nl",
    1041: "ja",
    7194: "sr-Cyrl-BA",
    1144: "ii",
    3081: "en-AU",
    1099: "kn",
    3098: "sr",
    1130: "yo",
    10249: "en-BZ",
    1087: "kk",
    6170: "sr-Latn-BA",
    4105: "en-CA",
    1107: "km",
    2074: "sr-Latn",
    9225: "en-029",
    1158: "quc",
    1132: "nso"
  }
];
let $2bcf221753ec8e32$var$NameRecord = new Struct({
  platformID: uint16,
  encodingID: uint16,
  languageID: uint16,
  nameID: uint16,
  length: uint16,
  string: new Pointer(uint16, new StringT("length", (t2) => $e449ad78d50845fe$export$badc544e0651b6b1(t2.platformID, t2.encodingID, t2.languageID)), {
    type: "parent",
    relativeTo: (ctx) => ctx.parent.stringOffset,
    allowNull: false
  })
});
let $2bcf221753ec8e32$var$LangTagRecord = new Struct({
  length: uint16,
  tag: new Pointer(uint16, new StringT("length", "utf16be"), {
    type: "parent",
    relativeTo: (ctx) => ctx.stringOffset
  })
});
var $2bcf221753ec8e32$var$NameTable = new VersionedStruct(uint16, {
  0: {
    count: uint16,
    stringOffset: uint16,
    records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count")
  },
  1: {
    count: uint16,
    stringOffset: uint16,
    records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count"),
    langTagCount: uint16,
    langTags: new ArrayT($2bcf221753ec8e32$var$LangTagRecord, "langTagCount")
  }
});
var $2bcf221753ec8e32$export$2e2bcd8739ae039 = $2bcf221753ec8e32$var$NameTable;
const $2bcf221753ec8e32$var$NAMES = [
  "copyright",
  "fontFamily",
  "fontSubfamily",
  "uniqueSubfamily",
  "fullName",
  "version",
  "postscriptName",
  "trademark",
  "manufacturer",
  "designer",
  "description",
  "vendorURL",
  "designerURL",
  "license",
  "licenseURL",
  null,
  "preferredFamily",
  "preferredSubfamily",
  "compatibleFull",
  "sampleText",
  "postscriptCIDFontName",
  "wwsFamilyName",
  "wwsSubfamilyName"
];
$2bcf221753ec8e32$var$NameTable.process = function(stream2) {
  var records = {};
  for (let record of this.records) {
    let language = $e449ad78d50845fe$export$2092376fd002e13[record.platformID][record.languageID];
    if (language == null && this.langTags != null && record.languageID >= 32768) language = this.langTags[record.languageID - 32768].tag;
    if (language == null) language = record.platformID + "-" + record.languageID;
    let key = record.nameID >= 256 ? "fontFeatures" : $2bcf221753ec8e32$var$NAMES[record.nameID] || record.nameID;
    if (records[key] == null) records[key] = {};
    let obj = records[key];
    if (record.nameID >= 256) obj = obj[record.nameID] || (obj[record.nameID] = {});
    if (typeof record.string === "string" || typeof obj[language] !== "string") obj[language] = record.string;
  }
  this.records = records;
};
$2bcf221753ec8e32$var$NameTable.preEncode = function() {
  if (Array.isArray(this.records)) return;
  this.version = 0;
  let records = [];
  for (let key in this.records) {
    let val = this.records[key];
    if (key === "fontFeatures") continue;
    records.push({
      platformID: 3,
      encodingID: 1,
      languageID: 1033,
      nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
      length: val.en.length * 2,
      string: val.en
    });
    if (key === "postscriptName") records.push({
      platformID: 1,
      encodingID: 0,
      languageID: 0,
      nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
      length: val.en.length,
      string: val.en
    });
  }
  this.records = records;
  this.count = records.length;
  this.stringOffset = $2bcf221753ec8e32$var$NameTable.size(this, null, false);
};
var $84b272aa31b70606$var$OS2 = new VersionedStruct(uint16, {
  header: {
    xAvgCharWidth: int16,
    usWeightClass: uint16,
    usWidthClass: uint16,
    fsType: new Bitfield(uint16, [
      null,
      "noEmbedding",
      "viewOnly",
      "editable",
      null,
      null,
      null,
      null,
      "noSubsetting",
      "bitmapOnly"
    ]),
    ySubscriptXSize: int16,
    ySubscriptYSize: int16,
    ySubscriptXOffset: int16,
    ySubscriptYOffset: int16,
    ySuperscriptXSize: int16,
    ySuperscriptYSize: int16,
    ySuperscriptXOffset: int16,
    ySuperscriptYOffset: int16,
    yStrikeoutSize: int16,
    yStrikeoutPosition: int16,
    sFamilyClass: int16,
    panose: new ArrayT(uint8, 10),
    ulCharRange: new ArrayT(uint32, 4),
    vendorID: new StringT(4),
    fsSelection: new Bitfield(uint16, [
      "italic",
      "underscore",
      "negative",
      "outlined",
      "strikeout",
      "bold",
      "regular",
      "useTypoMetrics",
      "wws",
      "oblique"
    ]),
    usFirstCharIndex: uint16,
    usLastCharIndex: uint16
    // The maximum Unicode index in this font
  },
  // The Apple version of this table ends here, but the Microsoft one continues on...
  0: {},
  1: {
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2)
  },
  2: {
    // these should be common with version 1 somehow
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2),
    xHeight: int16,
    capHeight: int16,
    defaultChar: uint16,
    breakChar: uint16,
    maxContent: uint16
  },
  5: {
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2),
    xHeight: int16,
    capHeight: int16,
    defaultChar: uint16,
    breakChar: uint16,
    maxContent: uint16,
    usLowerOpticalPointSize: uint16,
    usUpperOpticalPointSize: uint16
  }
});
let $84b272aa31b70606$var$versions = $84b272aa31b70606$var$OS2.versions;
$84b272aa31b70606$var$versions[3] = $84b272aa31b70606$var$versions[4] = $84b272aa31b70606$var$versions[2];
var $84b272aa31b70606$export$2e2bcd8739ae039 = $84b272aa31b70606$var$OS2;
var $32d9e2eb9565d93c$export$2e2bcd8739ae039 = new VersionedStruct(fixed32, {
  header: {
    italicAngle: fixed32,
    underlinePosition: int16,
    underlineThickness: int16,
    isFixedPitch: uint32,
    minMemType42: uint32,
    maxMemType42: uint32,
    minMemType1: uint32,
    maxMemType1: uint32
    // Maximum memory usage when a TrueType font is downloaded as a Type 1 font
  },
  1: {},
  2: {
    numberOfGlyphs: uint16,
    glyphNameIndex: new ArrayT(uint16, "numberOfGlyphs"),
    names: new ArrayT(new StringT(uint8))
  },
  2.5: {
    numberOfGlyphs: uint16,
    offsets: new ArrayT(uint8, "numberOfGlyphs")
  },
  3: {},
  4: {
    map: new ArrayT(uint32, (t2) => t2.parent.maxp.numGlyphs)
  }
});
var $5202bd9d9ad8eaac$export$2e2bcd8739ae039 = new Struct({
  controlValues: new ArrayT(int16)
});
var $5c0f37ca5ffb1850$export$2e2bcd8739ae039 = new Struct({
  instructions: new ArrayT(uint8)
});
let $2b2b260902b1c57e$var$loca = new VersionedStruct("head.indexToLocFormat", {
  0: {
    offsets: new ArrayT(uint16)
  },
  1: {
    offsets: new ArrayT(uint32)
  }
});
$2b2b260902b1c57e$var$loca.process = function() {
  if (this.version === 0 && !this._processed) {
    for (let i2 = 0; i2 < this.offsets.length; i2++) this.offsets[i2] <<= 1;
    this._processed = true;
  }
};
$2b2b260902b1c57e$var$loca.preEncode = function() {
  if (this.version === 0 && this._processed !== false) {
    for (let i2 = 0; i2 < this.offsets.length; i2++) this.offsets[i2] >>>= 1;
    this._processed = false;
  }
};
var $2b2b260902b1c57e$export$2e2bcd8739ae039 = $2b2b260902b1c57e$var$loca;
var $7afb878c7bea4f66$export$2e2bcd8739ae039 = new Struct({
  controlValueProgram: new ArrayT(uint8)
});
var $6c92b6371bce8bd9$export$2e2bcd8739ae039 = new ArrayT(new BufferT());
class $43e9821ef3717eec$export$2e2bcd8739ae039 {
  getCFFVersion(ctx) {
    while (ctx && !ctx.hdrSize) ctx = ctx.parent;
    return ctx ? ctx.version : -1;
  }
  decode(stream2, parent) {
    let version2 = this.getCFFVersion(parent);
    let count = version2 >= 2 ? stream2.readUInt32BE() : stream2.readUInt16BE();
    if (count === 0) return [];
    let offSize = stream2.readUInt8();
    let offsetType;
    if (offSize === 1) offsetType = uint8;
    else if (offSize === 2) offsetType = uint16;
    else if (offSize === 3) offsetType = uint24;
    else if (offSize === 4) offsetType = uint32;
    else throw new Error(`Bad offset size in CFFIndex: ${offSize} ${stream2.pos}`);
    let ret = [];
    let startPos = stream2.pos + (count + 1) * offSize - 1;
    let start2 = offsetType.decode(stream2);
    for (let i2 = 0; i2 < count; i2++) {
      let end2 = offsetType.decode(stream2);
      if (this.type != null) {
        let pos = stream2.pos;
        stream2.pos = startPos + start2;
        parent.length = end2 - start2;
        ret.push(this.type.decode(stream2, parent));
        stream2.pos = pos;
      } else ret.push({
        offset: startPos + start2,
        length: end2 - start2
      });
      start2 = end2;
    }
    stream2.pos = startPos + start2;
    return ret;
  }
  size(arr, parent) {
    let size = 2;
    if (arr.length === 0) return size;
    let type = this.type || new BufferT();
    let offset2 = 1;
    for (let i2 = 0; i2 < arr.length; i2++) {
      let item = arr[i2];
      offset2 += type.size(item, parent);
    }
    let offsetType;
    if (offset2 <= 255) offsetType = uint8;
    else if (offset2 <= 65535) offsetType = uint16;
    else if (offset2 <= 16777215) offsetType = uint24;
    else if (offset2 <= 4294967295) offsetType = uint32;
    else throw new Error("Bad offset in CFFIndex");
    size += 1 + offsetType.size() * (arr.length + 1);
    size += offset2 - 1;
    return size;
  }
  encode(stream2, arr, parent) {
    stream2.writeUInt16BE(arr.length);
    if (arr.length === 0) return;
    let type = this.type || new BufferT();
    let sizes = [];
    let offset2 = 1;
    for (let item of arr) {
      let s2 = type.size(item, parent);
      sizes.push(s2);
      offset2 += s2;
    }
    let offsetType;
    if (offset2 <= 255) offsetType = uint8;
    else if (offset2 <= 65535) offsetType = uint16;
    else if (offset2 <= 16777215) offsetType = uint24;
    else if (offset2 <= 4294967295) offsetType = uint32;
    else throw new Error("Bad offset in CFFIndex");
    stream2.writeUInt8(offsetType.size());
    offset2 = 1;
    offsetType.encode(stream2, offset2);
    for (let size of sizes) {
      offset2 += size;
      offsetType.encode(stream2, offset2);
    }
    for (let item of arr) type.encode(stream2, item, parent);
    return;
  }
  constructor(type) {
    this.type = type;
  }
}
const $c2d28e92708f99da$var$FLOAT_EOF = 15;
const $c2d28e92708f99da$var$FLOAT_LOOKUP = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  ".",
  "E",
  "E-",
  null,
  "-"
];
const $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP = {
  ".": 10,
  "E": 11,
  "E-": 12,
  "-": 14
};
class $c2d28e92708f99da$export$2e2bcd8739ae039 {
  static decode(stream2, value2) {
    if (32 <= value2 && value2 <= 246) return value2 - 139;
    if (247 <= value2 && value2 <= 250) return (value2 - 247) * 256 + stream2.readUInt8() + 108;
    if (251 <= value2 && value2 <= 254) return -(value2 - 251) * 256 - stream2.readUInt8() - 108;
    if (value2 === 28) return stream2.readInt16BE();
    if (value2 === 29) return stream2.readInt32BE();
    if (value2 === 30) {
      let str = "";
      while (true) {
        let b2 = stream2.readUInt8();
        let n1 = b2 >> 4;
        if (n1 === $c2d28e92708f99da$var$FLOAT_EOF) break;
        str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n1];
        let n22 = b2 & 15;
        if (n22 === $c2d28e92708f99da$var$FLOAT_EOF) break;
        str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n22];
      }
      return parseFloat(str);
    }
    return null;
  }
  static size(value2) {
    if (value2.forceLarge) value2 = 32768;
    if ((value2 | 0) !== value2) {
      let str = "" + value2;
      return 1 + Math.ceil((str.length + 1) / 2);
    } else if (-107 <= value2 && value2 <= 107) return 1;
    else if (108 <= value2 && value2 <= 1131 || -1131 <= value2 && value2 <= -108) return 2;
    else if (-32768 <= value2 && value2 <= 32767) return 3;
    else return 5;
  }
  static encode(stream2, value2) {
    let val = Number(value2);
    if (value2.forceLarge) {
      stream2.writeUInt8(29);
      return stream2.writeInt32BE(val);
    } else if ((val | 0) !== val) {
      stream2.writeUInt8(30);
      let str = "" + val;
      for (let i2 = 0; i2 < str.length; i2 += 2) {
        let c1 = str[i2];
        let n1 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c1] || +c1;
        if (i2 === str.length - 1) var n22 = $c2d28e92708f99da$var$FLOAT_EOF;
        else {
          let c2 = str[i2 + 1];
          var n22 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c2] || +c2;
        }
        stream2.writeUInt8(n1 << 4 | n22 & 15);
      }
      if (n22 !== $c2d28e92708f99da$var$FLOAT_EOF) return stream2.writeUInt8($c2d28e92708f99da$var$FLOAT_EOF << 4);
    } else if (-107 <= val && val <= 107) return stream2.writeUInt8(val + 139);
    else if (108 <= val && val <= 1131) {
      val -= 108;
      stream2.writeUInt8((val >> 8) + 247);
      return stream2.writeUInt8(val & 255);
    } else if (-1131 <= val && val <= -108) {
      val = -val - 108;
      stream2.writeUInt8((val >> 8) + 251);
      return stream2.writeUInt8(val & 255);
    } else if (-32768 <= val && val <= 32767) {
      stream2.writeUInt8(28);
      return stream2.writeInt16BE(val);
    } else {
      stream2.writeUInt8(29);
      return stream2.writeInt32BE(val);
    }
  }
}
class $61aa549f16d58b9b$export$2e2bcd8739ae039 {
  decodeOperands(type, stream2, ret, operands) {
    if (Array.isArray(type)) return operands.map((op, i2) => this.decodeOperands(type[i2], stream2, ret, [
      op
    ]));
    else if (type.decode != null) return type.decode(stream2, ret, operands);
    else switch (type) {
      case "number":
      case "offset":
      case "sid":
        return operands[0];
      case "boolean":
        return !!operands[0];
      default:
        return operands;
    }
  }
  encodeOperands(type, stream2, ctx, operands) {
    if (Array.isArray(type)) return operands.map((op, i2) => this.encodeOperands(type[i2], stream2, ctx, op)[0]);
    else if (type.encode != null) return type.encode(stream2, operands, ctx);
    else if (typeof operands === "number") return [
      operands
    ];
    else if (typeof operands === "boolean") return [
      +operands
    ];
    else if (Array.isArray(operands)) return operands;
    else return [
      operands
    ];
  }
  decode(stream2, parent) {
    let end2 = stream2.pos + parent.length;
    let ret = {};
    let operands = [];
    Object.defineProperties(ret, {
      parent: {
        value: parent
      },
      _startOffset: {
        value: stream2.pos
      }
    });
    for (let key in this.fields) {
      let field = this.fields[key];
      ret[field[1]] = field[3];
    }
    while (stream2.pos < end2) {
      let b2 = stream2.readUInt8();
      if (b2 < 28) {
        if (b2 === 12) b2 = b2 << 8 | stream2.readUInt8();
        let field = this.fields[b2];
        if (!field) throw new Error(`Unknown operator ${b2}`);
        let val = this.decodeOperands(field[2], stream2, ret, operands);
        if (val != null) {
          if (val instanceof PropertyDescriptor) Object.defineProperty(ret, field[1], val);
          else ret[field[1]] = val;
        }
        operands = [];
      } else operands.push($c2d28e92708f99da$export$2e2bcd8739ae039.decode(stream2, b2));
    }
    return ret;
  }
  size(dict, parent, includePointers = true) {
    let ctx = {
      parent,
      val: dict,
      pointerSize: 0,
      startOffset: parent.startOffset || 0
    };
    let len = 0;
    for (let k2 in this.fields) {
      let field = this.fields[k2];
      let val = dict[field[1]];
      if (val == null || $6uUbQ$fastdeepequal(val, field[3])) continue;
      let operands = this.encodeOperands(field[2], null, ctx, val);
      for (let op of operands) len += $c2d28e92708f99da$export$2e2bcd8739ae039.size(op);
      let key = Array.isArray(field[0]) ? field[0] : [
        field[0]
      ];
      len += key.length;
    }
    if (includePointers) len += ctx.pointerSize;
    return len;
  }
  encode(stream2, dict, parent) {
    let ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val: dict,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(dict, ctx, false);
    for (let field of this.ops) {
      let val = dict[field[1]];
      if (val == null || $6uUbQ$fastdeepequal(val, field[3])) continue;
      let operands = this.encodeOperands(field[2], stream2, ctx, val);
      for (let op of operands) $c2d28e92708f99da$export$2e2bcd8739ae039.encode(stream2, op);
      let key = Array.isArray(field[0]) ? field[0] : [
        field[0]
      ];
      for (let op of key) stream2.writeUInt8(op);
    }
    let i2 = 0;
    while (i2 < ctx.pointers.length) {
      let ptr = ctx.pointers[i2++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
    return;
  }
  constructor(ops = []) {
    this.ops = ops;
    this.fields = {};
    for (let field of ops) {
      let key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];
      this.fields[key] = field;
    }
  }
}
class $0e34a43d05bde82c$export$2e2bcd8739ae039 extends Pointer {
  decode(stream2, parent, operands) {
    this.offsetType = {
      decode: () => operands[0]
    };
    return super.decode(stream2, parent, operands);
  }
  encode(stream2, value2, ctx) {
    if (!stream2) {
      this.offsetType = {
        size: () => 0
      };
      this.size(value2, ctx);
      return [
        new $0e34a43d05bde82c$var$Ptr(0)
      ];
    }
    let ptr = null;
    this.offsetType = {
      encode: (stream3, val) => ptr = val
    };
    super.encode(stream2, value2, ctx);
    return [
      new $0e34a43d05bde82c$var$Ptr(ptr)
    ];
  }
  constructor(type, options = {}) {
    if (options.type == null) options.type = "global";
    super(null, type, options);
  }
}
class $0e34a43d05bde82c$var$Ptr {
  valueOf() {
    return this.val;
  }
  constructor(val) {
    this.val = val;
    this.forceLarge = true;
  }
}
class $6d59db2e29cc77b3$var$CFFBlendOp {
  static decode(stream2, parent, operands) {
    let numBlends = operands.pop();
    while (operands.length > numBlends) operands.pop();
  }
}
var $6d59db2e29cc77b3$export$2e2bcd8739ae039 = new $61aa549f16d58b9b$export$2e2bcd8739ae039([
  // key       name                    type                                          default
  [
    6,
    "BlueValues",
    "delta",
    null
  ],
  [
    7,
    "OtherBlues",
    "delta",
    null
  ],
  [
    8,
    "FamilyBlues",
    "delta",
    null
  ],
  [
    9,
    "FamilyOtherBlues",
    "delta",
    null
  ],
  [
    [
      12,
      9
    ],
    "BlueScale",
    "number",
    0.039625
  ],
  [
    [
      12,
      10
    ],
    "BlueShift",
    "number",
    7
  ],
  [
    [
      12,
      11
    ],
    "BlueFuzz",
    "number",
    1
  ],
  [
    10,
    "StdHW",
    "number",
    null
  ],
  [
    11,
    "StdVW",
    "number",
    null
  ],
  [
    [
      12,
      12
    ],
    "StemSnapH",
    "delta",
    null
  ],
  [
    [
      12,
      13
    ],
    "StemSnapV",
    "delta",
    null
  ],
  [
    [
      12,
      14
    ],
    "ForceBold",
    "boolean",
    false
  ],
  [
    [
      12,
      17
    ],
    "LanguageGroup",
    "number",
    0
  ],
  [
    [
      12,
      18
    ],
    "ExpansionFactor",
    "number",
    0.06
  ],
  [
    [
      12,
      19
    ],
    "initialRandomSeed",
    "number",
    0
  ],
  [
    20,
    "defaultWidthX",
    "number",
    0
  ],
  [
    21,
    "nominalWidthX",
    "number",
    0
  ],
  [
    22,
    "vsindex",
    "number",
    0
  ],
  [
    23,
    "blend",
    $6d59db2e29cc77b3$var$CFFBlendOp,
    null
  ],
  [
    19,
    "Subrs",
    new $0e34a43d05bde82c$export$2e2bcd8739ae039(new $43e9821ef3717eec$export$2e2bcd8739ae039(), {
      type: "local"
    }),
    null
  ]
]);
var $229224aec43783c5$export$2e2bcd8739ae039 = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall",
  "001.000",
  "001.001",
  "001.002",
  "001.003",
  "Black",
  "Bold",
  "Book",
  "Light",
  "Medium",
  "Regular",
  "Roman",
  "Semibold"
];
let $bc0433d9b7e41f5f$export$dee0027060fa13bd = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "",
  "questiondown",
  "",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "",
  "ring",
  "cedilla",
  "",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "AE",
  "",
  "ordfeminine",
  "",
  "",
  "",
  "",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "",
  "",
  "",
  "",
  "",
  "ae",
  "",
  "",
  "",
  "dotlessi",
  "",
  "",
  "lslash",
  "oslash",
  "oe",
  "germandbls"
];
let $bc0433d9b7e41f5f$export$4f58f497e14a53c3 = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "",
  "",
  "isuperior",
  "",
  "",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "",
  "",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "",
  "",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "",
  "Dotaccentsmall",
  "",
  "",
  "Macronsmall",
  "",
  "",
  "figuredash",
  "hypheninferior",
  "",
  "",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "",
  "",
  "",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "",
  "",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
let $ef658f5c9a1488b2$export$c33b50336c234f16 = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron"
];
let $ef658f5c9a1488b2$export$3ed0f9e1fee8d489 = [
  ".notdef",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
let $ef658f5c9a1488b2$export$dc28be11139d4120 = [
  ".notdef",
  "space",
  "dollaroldstyle",
  "dollarsuperior",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "hyphensuperior",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "centoldstyle",
  "figuredash",
  "hypheninferior",
  "onequarter",
  "onehalf",
  "threequarters",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior"
];
let $7cbbe4e24ef3cb75$var$LangSysTable = new Struct({
  reserved: new Reserved(uint16),
  reqFeatureIndex: uint16,
  featureCount: uint16,
  featureIndexes: new ArrayT(uint16, "featureCount")
});
let $7cbbe4e24ef3cb75$var$LangSysRecord = new Struct({
  tag: new StringT(4),
  langSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable, {
    type: "parent"
  })
});
let $7cbbe4e24ef3cb75$var$Script = new Struct({
  defaultLangSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable),
  count: uint16,
  langSysRecords: new ArrayT($7cbbe4e24ef3cb75$var$LangSysRecord, "count")
});
let $7cbbe4e24ef3cb75$var$ScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $7cbbe4e24ef3cb75$var$Script, {
    type: "parent"
  })
});
let $7cbbe4e24ef3cb75$export$3e15fc05ce864229 = new ArrayT($7cbbe4e24ef3cb75$var$ScriptRecord, uint16);
let $7cbbe4e24ef3cb75$var$FeatureParams = new Struct({
  version: uint16,
  nameID: uint16
});
let $7cbbe4e24ef3cb75$export$6e91cf7616333d5 = new Struct({
  featureParams: new Pointer(uint16, $7cbbe4e24ef3cb75$var$FeatureParams),
  lookupCount: uint16,
  lookupListIndexes: new ArrayT(uint16, "lookupCount")
});
let $7cbbe4e24ef3cb75$var$FeatureRecord = new Struct({
  tag: new StringT(4),
  feature: new Pointer(uint16, $7cbbe4e24ef3cb75$export$6e91cf7616333d5, {
    type: "parent"
  })
});
let $7cbbe4e24ef3cb75$export$aa18130def4b6cb4 = new ArrayT($7cbbe4e24ef3cb75$var$FeatureRecord, uint16);
let $7cbbe4e24ef3cb75$var$LookupFlags = new Struct({
  markAttachmentType: uint8,
  flags: new Bitfield(uint8, [
    "rightToLeft",
    "ignoreBaseGlyphs",
    "ignoreLigatures",
    "ignoreMarks",
    "useMarkFilteringSet"
  ])
});
function $7cbbe4e24ef3cb75$export$df0008c6ff2da22a(SubTable) {
  let Lookup = new Struct({
    lookupType: uint16,
    flags: $7cbbe4e24ef3cb75$var$LookupFlags,
    subTableCount: uint16,
    subTables: new ArrayT(new Pointer(uint16, SubTable), "subTableCount"),
    markFilteringSet: new Optional(uint16, (t2) => t2.flags.flags.useMarkFilteringSet)
  });
  return new LazyArray(new Pointer(uint16, Lookup), uint16);
}
let $7cbbe4e24ef3cb75$var$RangeRecord = new Struct({
  start: uint16,
  end: uint16,
  startCoverageIndex: uint16
});
let $7cbbe4e24ef3cb75$export$17608c3f81a6111 = new VersionedStruct(uint16, {
  1: {
    glyphCount: uint16,
    glyphs: new ArrayT(uint16, "glyphCount")
  },
  2: {
    rangeCount: uint16,
    rangeRecords: new ArrayT($7cbbe4e24ef3cb75$var$RangeRecord, "rangeCount")
  }
});
let $7cbbe4e24ef3cb75$var$ClassRangeRecord = new Struct({
  start: uint16,
  end: uint16,
  class: uint16
});
let $7cbbe4e24ef3cb75$export$843d551fbbafef71 = new VersionedStruct(uint16, {
  1: {
    startGlyph: uint16,
    glyphCount: uint16,
    classValueArray: new ArrayT(uint16, "glyphCount")
  },
  2: {
    classRangeCount: uint16,
    classRangeRecord: new ArrayT($7cbbe4e24ef3cb75$var$ClassRangeRecord, "classRangeCount")
  }
});
let $7cbbe4e24ef3cb75$export$8215d14a63d9fb10 = new Struct({
  a: uint16,
  b: uint16,
  deltaFormat: uint16
});
let $7cbbe4e24ef3cb75$var$LookupRecord = new Struct({
  sequenceIndex: uint16,
  lookupListIndex: uint16
});
let $7cbbe4e24ef3cb75$var$Rule = new Struct({
  glyphCount: uint16,
  lookupCount: uint16,
  input: new ArrayT(uint16, (t2) => t2.glyphCount - 1),
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
let $7cbbe4e24ef3cb75$var$RuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$Rule), uint16);
let $7cbbe4e24ef3cb75$var$ClassRule = new Struct({
  glyphCount: uint16,
  lookupCount: uint16,
  classes: new ArrayT(uint16, (t2) => t2.glyphCount - 1),
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
let $7cbbe4e24ef3cb75$var$ClassSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassRule), uint16);
let $7cbbe4e24ef3cb75$export$841858b892ce1f4c = new VersionedStruct(uint16, {
  1: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    ruleSetCount: uint16,
    ruleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$RuleSet), "ruleSetCount")
  },
  2: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    classDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    classSetCnt: uint16,
    classSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassSet), "classSetCnt")
  },
  3: {
    glyphCount: uint16,
    lookupCount: uint16,
    coverages: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "glyphCount"),
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  }
});
let $7cbbe4e24ef3cb75$var$ChainRule = new Struct({
  backtrackGlyphCount: uint16,
  backtrack: new ArrayT(uint16, "backtrackGlyphCount"),
  inputGlyphCount: uint16,
  input: new ArrayT(uint16, (t2) => t2.inputGlyphCount - 1),
  lookaheadGlyphCount: uint16,
  lookahead: new ArrayT(uint16, "lookaheadGlyphCount"),
  lookupCount: uint16,
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
let $7cbbe4e24ef3cb75$var$ChainRuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRule), uint16);
let $7cbbe4e24ef3cb75$export$5e6d09e6861162f6 = new VersionedStruct(uint16, {
  1: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    chainCount: uint16,
    chainRuleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
  },
  2: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    backtrackClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    inputClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    lookaheadClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    chainCount: uint16,
    chainClassSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
  },
  3: {
    backtrackGlyphCount: uint16,
    backtrackCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "backtrackGlyphCount"),
    inputGlyphCount: uint16,
    inputCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "inputGlyphCount"),
    lookaheadGlyphCount: uint16,
    lookaheadCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "lookaheadGlyphCount"),
    lookupCount: uint16,
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  }
});
let $1a47b0c45c1c22fe$var$F2DOT14 = new Fixed(16, "BE", 14);
let $1a47b0c45c1c22fe$var$RegionAxisCoordinates = new Struct({
  startCoord: $1a47b0c45c1c22fe$var$F2DOT14,
  peakCoord: $1a47b0c45c1c22fe$var$F2DOT14,
  endCoord: $1a47b0c45c1c22fe$var$F2DOT14
});
let $1a47b0c45c1c22fe$var$VariationRegionList = new Struct({
  axisCount: uint16,
  regionCount: uint16,
  variationRegions: new ArrayT(new ArrayT($1a47b0c45c1c22fe$var$RegionAxisCoordinates, "axisCount"), "regionCount")
});
let $1a47b0c45c1c22fe$var$DeltaSet = new Struct({
  shortDeltas: new ArrayT(int16, (t2) => t2.parent.shortDeltaCount),
  regionDeltas: new ArrayT(int8, (t2) => t2.parent.regionIndexCount - t2.parent.shortDeltaCount),
  deltas: (t2) => t2.shortDeltas.concat(t2.regionDeltas)
});
let $1a47b0c45c1c22fe$var$ItemVariationData = new Struct({
  itemCount: uint16,
  shortDeltaCount: uint16,
  regionIndexCount: uint16,
  regionIndexes: new ArrayT(uint16, "regionIndexCount"),
  deltaSets: new ArrayT($1a47b0c45c1c22fe$var$DeltaSet, "itemCount")
});
let $1a47b0c45c1c22fe$export$fe1b122a2710f241 = new Struct({
  format: uint16,
  variationRegionList: new Pointer(uint32, $1a47b0c45c1c22fe$var$VariationRegionList),
  variationDataCount: uint16,
  itemVariationData: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ItemVariationData), "variationDataCount")
});
let $1a47b0c45c1c22fe$var$ConditionTable = new VersionedStruct(uint16, {
  1: {
    axisIndex: uint16,
    axisIndex: uint16,
    filterRangeMinValue: $1a47b0c45c1c22fe$var$F2DOT14,
    filterRangeMaxValue: $1a47b0c45c1c22fe$var$F2DOT14
  }
});
let $1a47b0c45c1c22fe$var$ConditionSet = new Struct({
  conditionCount: uint16,
  conditionTable: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionTable), "conditionCount")
});
let $1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord = new Struct({
  featureIndex: uint16,
  alternateFeatureTable: new Pointer(uint32, $7cbbe4e24ef3cb75$export$6e91cf7616333d5, {
    type: "parent"
  })
});
let $1a47b0c45c1c22fe$var$FeatureTableSubstitution = new Struct({
  version: fixed32,
  substitutionCount: uint16,
  substitutions: new ArrayT($1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord, "substitutionCount")
});
let $1a47b0c45c1c22fe$var$FeatureVariationRecord = new Struct({
  conditionSet: new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionSet, {
    type: "parent"
  }),
  featureTableSubstitution: new Pointer(uint32, $1a47b0c45c1c22fe$var$FeatureTableSubstitution, {
    type: "parent"
  })
});
let $1a47b0c45c1c22fe$export$441b70b7971dd419 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  featureVariationRecordCount: uint32,
  featureVariationRecords: new ArrayT($1a47b0c45c1c22fe$var$FeatureVariationRecord, "featureVariationRecordCount")
});
class $b84fd3dd9d8eddb2$var$PredefinedOp {
  decode(stream2, parent, operands) {
    if (this.predefinedOps[operands[0]]) return this.predefinedOps[operands[0]];
    return this.type.decode(stream2, parent, operands);
  }
  size(value2, ctx) {
    return this.type.size(value2, ctx);
  }
  encode(stream2, value2, ctx) {
    let index2 = this.predefinedOps.indexOf(value2);
    if (index2 !== -1) return index2;
    return this.type.encode(stream2, value2, ctx);
  }
  constructor(predefinedOps, type) {
    this.predefinedOps = predefinedOps;
    this.type = type;
  }
}
class $b84fd3dd9d8eddb2$var$CFFEncodingVersion extends NumberT {
  decode(stream2) {
    return uint8.decode(stream2) & 127;
  }
  constructor() {
    super("UInt8");
  }
}
let $b84fd3dd9d8eddb2$var$Range1 = new Struct({
  first: uint16,
  nLeft: uint8
});
let $b84fd3dd9d8eddb2$var$Range2 = new Struct({
  first: uint16,
  nLeft: uint16
});
let $b84fd3dd9d8eddb2$var$CFFCustomEncoding = new VersionedStruct(new $b84fd3dd9d8eddb2$var$CFFEncodingVersion(), {
  0: {
    nCodes: uint8,
    codes: new ArrayT(uint8, "nCodes")
  },
  1: {
    nRanges: uint8,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$Range1, "nRanges")
  }
});
let $b84fd3dd9d8eddb2$var$CFFEncoding = new $b84fd3dd9d8eddb2$var$PredefinedOp([
  $bc0433d9b7e41f5f$export$dee0027060fa13bd,
  $bc0433d9b7e41f5f$export$4f58f497e14a53c3
], new $0e34a43d05bde82c$export$2e2bcd8739ae039($b84fd3dd9d8eddb2$var$CFFCustomEncoding, {
  lazy: true
}));
class $b84fd3dd9d8eddb2$var$RangeArray extends ArrayT {
  decode(stream2, parent) {
    let length2 = resolveLength(this.length, stream2, parent);
    let count = 0;
    let res = [];
    while (count < length2) {
      let range2 = this.type.decode(stream2, parent);
      range2.offset = count;
      count += range2.nLeft + 1;
      res.push(range2);
    }
    return res;
  }
}
let $b84fd3dd9d8eddb2$var$CFFCustomCharset = new VersionedStruct(uint8, {
  0: {
    glyphs: new ArrayT(uint16, (t2) => t2.parent.CharStrings.length - 1)
  },
  1: {
    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range1, (t2) => t2.parent.CharStrings.length - 1)
  },
  2: {
    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range2, (t2) => t2.parent.CharStrings.length - 1)
  }
});
let $b84fd3dd9d8eddb2$var$CFFCharset = new $b84fd3dd9d8eddb2$var$PredefinedOp([
  $ef658f5c9a1488b2$export$c33b50336c234f16,
  $ef658f5c9a1488b2$export$3ed0f9e1fee8d489,
  $ef658f5c9a1488b2$export$dc28be11139d4120
], new $0e34a43d05bde82c$export$2e2bcd8739ae039($b84fd3dd9d8eddb2$var$CFFCustomCharset, {
  lazy: true
}));
let $b84fd3dd9d8eddb2$var$FDRange3 = new Struct({
  first: uint16,
  fd: uint8
});
let $b84fd3dd9d8eddb2$var$FDRange4 = new Struct({
  first: uint32,
  fd: uint16
});
let $b84fd3dd9d8eddb2$var$FDSelect = new VersionedStruct(uint8, {
  0: {
    fds: new ArrayT(uint8, (t2) => t2.parent.CharStrings.length)
  },
  3: {
    nRanges: uint16,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange3, "nRanges"),
    sentinel: uint16
  },
  4: {
    nRanges: uint32,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange4, "nRanges"),
    sentinel: uint32
  }
});
let $b84fd3dd9d8eddb2$var$ptr = new $0e34a43d05bde82c$export$2e2bcd8739ae039($6d59db2e29cc77b3$export$2e2bcd8739ae039);
class $b84fd3dd9d8eddb2$var$CFFPrivateOp {
  decode(stream2, parent, operands) {
    parent.length = operands[0];
    return $b84fd3dd9d8eddb2$var$ptr.decode(stream2, parent, [
      operands[1]
    ]);
  }
  size(dict, ctx) {
    return [
      $6d59db2e29cc77b3$export$2e2bcd8739ae039.size(dict, ctx, false),
      $b84fd3dd9d8eddb2$var$ptr.size(dict, ctx)[0]
    ];
  }
  encode(stream2, dict, ctx) {
    return [
      $6d59db2e29cc77b3$export$2e2bcd8739ae039.size(dict, ctx, false),
      $b84fd3dd9d8eddb2$var$ptr.encode(stream2, dict, ctx)[0]
    ];
  }
}
let $b84fd3dd9d8eddb2$var$FontDict = new $61aa549f16d58b9b$export$2e2bcd8739ae039([
  // key       name                   type(s)                                 default
  [
    18,
    "Private",
    new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
    null
  ],
  [
    [
      12,
      38
    ],
    "FontName",
    "sid",
    null
  ],
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    [
      12,
      5
    ],
    "PaintType",
    "number",
    0
  ]
]);
let $b84fd3dd9d8eddb2$var$CFFTopDict = new $61aa549f16d58b9b$export$2e2bcd8739ae039([
  // key       name                   type(s)                                 default
  [
    [
      12,
      30
    ],
    "ROS",
    [
      "sid",
      "sid",
      "number"
    ],
    null
  ],
  [
    0,
    "version",
    "sid",
    null
  ],
  [
    1,
    "Notice",
    "sid",
    null
  ],
  [
    [
      12,
      0
    ],
    "Copyright",
    "sid",
    null
  ],
  [
    2,
    "FullName",
    "sid",
    null
  ],
  [
    3,
    "FamilyName",
    "sid",
    null
  ],
  [
    4,
    "Weight",
    "sid",
    null
  ],
  [
    [
      12,
      1
    ],
    "isFixedPitch",
    "boolean",
    false
  ],
  [
    [
      12,
      2
    ],
    "ItalicAngle",
    "number",
    0
  ],
  [
    [
      12,
      3
    ],
    "UnderlinePosition",
    "number",
    -100
  ],
  [
    [
      12,
      4
    ],
    "UnderlineThickness",
    "number",
    50
  ],
  [
    [
      12,
      5
    ],
    "PaintType",
    "number",
    0
  ],
  [
    [
      12,
      6
    ],
    "CharstringType",
    "number",
    2
  ],
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    13,
    "UniqueID",
    "number",
    null
  ],
  [
    5,
    "FontBBox",
    "array",
    [
      0,
      0,
      0,
      0
    ]
  ],
  [
    [
      12,
      8
    ],
    "StrokeWidth",
    "number",
    0
  ],
  [
    14,
    "XUID",
    "array",
    null
  ],
  [
    15,
    "charset",
    $b84fd3dd9d8eddb2$var$CFFCharset,
    $ef658f5c9a1488b2$export$c33b50336c234f16
  ],
  [
    16,
    "Encoding",
    $b84fd3dd9d8eddb2$var$CFFEncoding,
    $bc0433d9b7e41f5f$export$dee0027060fa13bd
  ],
  [
    17,
    "CharStrings",
    new $0e34a43d05bde82c$export$2e2bcd8739ae039(new $43e9821ef3717eec$export$2e2bcd8739ae039()),
    null
  ],
  [
    18,
    "Private",
    new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
    null
  ],
  [
    [
      12,
      20
    ],
    "SyntheticBase",
    "number",
    null
  ],
  [
    [
      12,
      21
    ],
    "PostScript",
    "sid",
    null
  ],
  [
    [
      12,
      22
    ],
    "BaseFontName",
    "sid",
    null
  ],
  [
    [
      12,
      23
    ],
    "BaseFontBlend",
    "delta",
    null
  ],
  // CID font specific
  [
    [
      12,
      31
    ],
    "CIDFontVersion",
    "number",
    0
  ],
  [
    [
      12,
      32
    ],
    "CIDFontRevision",
    "number",
    0
  ],
  [
    [
      12,
      33
    ],
    "CIDFontType",
    "number",
    0
  ],
  [
    [
      12,
      34
    ],
    "CIDCount",
    "number",
    8720
  ],
  [
    [
      12,
      35
    ],
    "UIDBase",
    "number",
    null
  ],
  [
    [
      12,
      37
    ],
    "FDSelect",
    new $0e34a43d05bde82c$export$2e2bcd8739ae039($b84fd3dd9d8eddb2$var$FDSelect),
    null
  ],
  [
    [
      12,
      36
    ],
    "FDArray",
    new $0e34a43d05bde82c$export$2e2bcd8739ae039(new $43e9821ef3717eec$export$2e2bcd8739ae039($b84fd3dd9d8eddb2$var$FontDict)),
    null
  ],
  [
    [
      12,
      38
    ],
    "FontName",
    "sid",
    null
  ]
]);
let $b84fd3dd9d8eddb2$var$VariationStore = new Struct({
  length: uint16,
  itemVariationStore: $1a47b0c45c1c22fe$export$fe1b122a2710f241
});
let $b84fd3dd9d8eddb2$var$CFF2TopDict = new $61aa549f16d58b9b$export$2e2bcd8739ae039([
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    17,
    "CharStrings",
    new $0e34a43d05bde82c$export$2e2bcd8739ae039(new $43e9821ef3717eec$export$2e2bcd8739ae039()),
    null
  ],
  [
    [
      12,
      37
    ],
    "FDSelect",
    new $0e34a43d05bde82c$export$2e2bcd8739ae039($b84fd3dd9d8eddb2$var$FDSelect),
    null
  ],
  [
    [
      12,
      36
    ],
    "FDArray",
    new $0e34a43d05bde82c$export$2e2bcd8739ae039(new $43e9821ef3717eec$export$2e2bcd8739ae039($b84fd3dd9d8eddb2$var$FontDict)),
    null
  ],
  [
    24,
    "vstore",
    new $0e34a43d05bde82c$export$2e2bcd8739ae039($b84fd3dd9d8eddb2$var$VariationStore),
    null
  ],
  [
    25,
    "maxstack",
    "number",
    193
  ]
]);
let $b84fd3dd9d8eddb2$var$CFFTop = new VersionedStruct(fixed16, {
  1: {
    hdrSize: uint8,
    offSize: uint8,
    nameIndex: new $43e9821ef3717eec$export$2e2bcd8739ae039(new StringT("length")),
    topDictIndex: new $43e9821ef3717eec$export$2e2bcd8739ae039($b84fd3dd9d8eddb2$var$CFFTopDict),
    stringIndex: new $43e9821ef3717eec$export$2e2bcd8739ae039(new StringT("length")),
    globalSubrIndex: new $43e9821ef3717eec$export$2e2bcd8739ae039()
  },
  2: {
    hdrSize: uint8,
    length: uint16,
    topDict: $b84fd3dd9d8eddb2$var$CFF2TopDict,
    globalSubrIndex: new $43e9821ef3717eec$export$2e2bcd8739ae039()
  }
});
var $b84fd3dd9d8eddb2$export$2e2bcd8739ae039 = $b84fd3dd9d8eddb2$var$CFFTop;
class $822ac0d589e4e237$var$CFFFont {
  static decode(stream2) {
    return new $822ac0d589e4e237$var$CFFFont(stream2);
  }
  decode() {
    this.stream.pos;
    let top = $b84fd3dd9d8eddb2$export$2e2bcd8739ae039.decode(this.stream);
    for (let key in top) {
      let val = top[key];
      this[key] = val;
    }
    if (this.version < 2) {
      if (this.topDictIndex.length !== 1) throw new Error("Only a single font is allowed in CFF");
      this.topDict = this.topDictIndex[0];
    }
    this.isCIDFont = this.topDict.ROS != null;
    return this;
  }
  string(sid) {
    if (this.version >= 2) return null;
    if (sid < $229224aec43783c5$export$2e2bcd8739ae039.length) return $229224aec43783c5$export$2e2bcd8739ae039[sid];
    return this.stringIndex[sid - $229224aec43783c5$export$2e2bcd8739ae039.length];
  }
  get postscriptName() {
    if (this.version < 2) return this.nameIndex[0];
    return null;
  }
  get fullName() {
    return this.string(this.topDict.FullName);
  }
  get familyName() {
    return this.string(this.topDict.FamilyName);
  }
  getCharString(glyph) {
    this.stream.pos = this.topDict.CharStrings[glyph].offset;
    return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);
  }
  getGlyphName(gid) {
    if (this.version >= 2) return null;
    if (this.isCIDFont) return null;
    let { charset } = this.topDict;
    if (Array.isArray(charset)) return charset[gid];
    if (gid === 0) return ".notdef";
    gid -= 1;
    switch (charset.version) {
      case 0:
        return this.string(charset.glyphs[gid]);
      case 1:
      case 2:
        for (let i2 = 0; i2 < charset.ranges.length; i2++) {
          let range2 = charset.ranges[i2];
          if (range2.offset <= gid && gid <= range2.offset + range2.nLeft) return this.string(range2.first + (gid - range2.offset));
        }
        break;
    }
    return null;
  }
  fdForGlyph(gid) {
    if (!this.topDict.FDSelect) return null;
    switch (this.topDict.FDSelect.version) {
      case 0:
        return this.topDict.FDSelect.fds[gid];
      case 3:
      case 4:
        let { ranges } = this.topDict.FDSelect;
        let low = 0;
        let high = ranges.length - 1;
        while (low <= high) {
          let mid = low + high >> 1;
          if (gid < ranges[mid].first) high = mid - 1;
          else if (mid < high && gid >= ranges[mid + 1].first) low = mid + 1;
          else return ranges[mid].fd;
        }
      default:
        throw new Error(`Unknown FDSelect version: ${this.topDict.FDSelect.version}`);
    }
  }
  privateDictForGlyph(gid) {
    if (this.topDict.FDSelect) {
      let fd = this.fdForGlyph(gid);
      if (this.topDict.FDArray[fd]) return this.topDict.FDArray[fd].Private;
      return null;
    }
    if (this.version < 2) return this.topDict.Private;
    return this.topDict.FDArray[0].Private;
  }
  constructor(stream2) {
    this.stream = stream2;
    this.decode();
  }
}
var $822ac0d589e4e237$export$2e2bcd8739ae039 = $822ac0d589e4e237$var$CFFFont;
let $2bbf2bc1ce37cd8f$var$VerticalOrigin = new Struct({
  glyphIndex: uint16,
  vertOriginY: int16
});
var $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  defaultVertOriginY: int16,
  numVertOriginYMetrics: uint16,
  metrics: new ArrayT($2bbf2bc1ce37cd8f$var$VerticalOrigin, "numVertOriginYMetrics")
});
let $0941618dc22a946d$export$16b227cb15d716a0 = new Struct({
  height: uint8,
  width: uint8,
  horiBearingX: int8,
  horiBearingY: int8,
  horiAdvance: uint8,
  vertBearingX: int8,
  vertBearingY: int8,
  vertAdvance: uint8
});
let $0941618dc22a946d$export$62c53e75f69bfe12 = new Struct({
  height: uint8,
  width: uint8,
  bearingX: int8,
  bearingY: int8,
  advance: uint8
});
let $0941618dc22a946d$var$EBDTComponent = new Struct({
  glyph: uint16,
  xOffset: int8,
  yOffset: int8
});
class $0941618dc22a946d$var$ByteAligned {
}
class $0941618dc22a946d$var$BitAligned {
}
new VersionedStruct("version", {
  1: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    data: $0941618dc22a946d$var$ByteAligned
  },
  2: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    data: $0941618dc22a946d$var$BitAligned
  },
  // format 3 is deprecated
  // format 4 is not supported by Microsoft
  5: {
    data: $0941618dc22a946d$var$BitAligned
  },
  6: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    data: $0941618dc22a946d$var$ByteAligned
  },
  7: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    data: $0941618dc22a946d$var$BitAligned
  },
  8: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    pad: new Reserved(uint8),
    numComponents: uint16,
    components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
  },
  9: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    pad: new Reserved(uint8),
    numComponents: uint16,
    components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
  },
  17: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    dataLen: uint32,
    data: new BufferT("dataLen")
  },
  18: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    dataLen: uint32,
    data: new BufferT("dataLen")
  },
  19: {
    dataLen: uint32,
    data: new BufferT("dataLen")
  }
});
let $9911c4c7201c13de$var$SBitLineMetrics = new Struct({
  ascender: int8,
  descender: int8,
  widthMax: uint8,
  caretSlopeNumerator: int8,
  caretSlopeDenominator: int8,
  caretOffset: int8,
  minOriginSB: int8,
  minAdvanceSB: int8,
  maxBeforeBL: int8,
  minAfterBL: int8,
  pad: new Reserved(int8, 2)
});
let $9911c4c7201c13de$var$CodeOffsetPair = new Struct({
  glyphCode: uint16,
  offset: uint16
});
let $9911c4c7201c13de$var$IndexSubtable = new VersionedStruct(uint16, {
  header: {
    imageFormat: uint16,
    imageDataOffset: uint32
  },
  1: {
    offsetArray: new ArrayT(uint32, (t2) => t2.parent.lastGlyphIndex - t2.parent.firstGlyphIndex + 1)
  },
  2: {
    imageSize: uint32,
    bigMetrics: $0941618dc22a946d$export$16b227cb15d716a0
  },
  3: {
    offsetArray: new ArrayT(uint16, (t2) => t2.parent.lastGlyphIndex - t2.parent.firstGlyphIndex + 1)
  },
  4: {
    numGlyphs: uint32,
    glyphArray: new ArrayT($9911c4c7201c13de$var$CodeOffsetPair, (t2) => t2.numGlyphs + 1)
  },
  5: {
    imageSize: uint32,
    bigMetrics: $0941618dc22a946d$export$16b227cb15d716a0,
    numGlyphs: uint32,
    glyphCodeArray: new ArrayT(uint16, "numGlyphs")
  }
});
let $9911c4c7201c13de$var$IndexSubtableArray = new Struct({
  firstGlyphIndex: uint16,
  lastGlyphIndex: uint16,
  subtable: new Pointer(uint32, $9911c4c7201c13de$var$IndexSubtable)
});
let $9911c4c7201c13de$var$BitmapSizeTable = new Struct({
  indexSubTableArray: new Pointer(uint32, new ArrayT($9911c4c7201c13de$var$IndexSubtableArray, 1), {
    type: "parent"
  }),
  indexTablesSize: uint32,
  numberOfIndexSubTables: uint32,
  colorRef: uint32,
  hori: $9911c4c7201c13de$var$SBitLineMetrics,
  vert: $9911c4c7201c13de$var$SBitLineMetrics,
  startGlyphIndex: uint16,
  endGlyphIndex: uint16,
  ppemX: uint8,
  ppemY: uint8,
  bitDepth: uint8,
  flags: new Bitfield(uint8, [
    "horizontal",
    "vertical"
  ])
});
var $9911c4c7201c13de$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  numSizes: uint32,
  sizes: new ArrayT($9911c4c7201c13de$var$BitmapSizeTable, "numSizes")
});
let $abb847051efd51b1$var$ImageTable = new Struct({
  ppem: uint16,
  resolution: uint16,
  imageOffsets: new ArrayT(new Pointer(uint32, "void"), (t2) => t2.parent.parent.maxp.numGlyphs + 1)
});
var $abb847051efd51b1$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  flags: new Bitfield(uint16, [
    "renderOutlines"
  ]),
  numImgTables: uint32,
  imageTables: new ArrayT(new Pointer(uint32, $abb847051efd51b1$var$ImageTable), "numImgTables")
});
let $eb629188f3dfefdd$var$LayerRecord = new Struct({
  gid: uint16,
  paletteIndex: uint16
  // Index value to use in the appropriate palette. This value must
});
let $eb629188f3dfefdd$var$BaseGlyphRecord = new Struct({
  gid: uint16,
  // and is not rendered for color.
  firstLayerIndex: uint16,
  // There will be numLayers consecutive entries for this base glyph.
  numLayers: uint16
});
var $eb629188f3dfefdd$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numBaseGlyphRecords: uint16,
  baseGlyphRecord: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$BaseGlyphRecord, "numBaseGlyphRecords")),
  layerRecords: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$LayerRecord, "numLayerRecords"), {
    lazy: true
  }),
  numLayerRecords: uint16
});
let $08734b8e7dc64587$var$ColorRecord = new Struct({
  blue: uint8,
  green: uint8,
  red: uint8,
  alpha: uint8
});
var $08734b8e7dc64587$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
  header: {
    numPaletteEntries: uint16,
    numPalettes: uint16,
    numColorRecords: uint16,
    colorRecords: new Pointer(uint32, new ArrayT($08734b8e7dc64587$var$ColorRecord, "numColorRecords")),
    colorRecordIndices: new ArrayT(uint16, "numPalettes")
  },
  0: {},
  1: {
    offsetPaletteTypeArray: new Pointer(uint32, new ArrayT(uint32, "numPalettes")),
    offsetPaletteLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPalettes")),
    offsetPaletteEntryLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPaletteEntries"))
  }
});
let $497cef411d884e34$var$BaseCoord = new VersionedStruct(uint16, {
  1: {
    coordinate: int16
    // X or Y value, in design units
  },
  2: {
    coordinate: int16,
    referenceGlyph: uint16,
    baseCoordPoint: uint16
    // Index of contour point on the referenceGlyph
  },
  3: {
    coordinate: int16,
    deviceTable: new Pointer(uint16, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10)
    // Device table for X or Y value
  }
});
let $497cef411d884e34$var$BaseValues = new Struct({
  defaultIndex: uint16,
  baseCoordCount: uint16,
  baseCoords: new ArrayT(new Pointer(uint16, $497cef411d884e34$var$BaseCoord), "baseCoordCount")
});
let $497cef411d884e34$var$FeatMinMaxRecord = new Struct({
  tag: new StringT(4),
  minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
    type: "parent"
  }),
  maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
    type: "parent"
  })
  // May be NULL
});
let $497cef411d884e34$var$MinMax = new Struct({
  minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
  maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
  featMinMaxCount: uint16,
  featMinMaxRecords: new ArrayT($497cef411d884e34$var$FeatMinMaxRecord, "featMinMaxCount")
  // In alphabetical order
});
let $497cef411d884e34$var$BaseLangSysRecord = new Struct({
  tag: new StringT(4),
  minMax: new Pointer(uint16, $497cef411d884e34$var$MinMax, {
    type: "parent"
  })
});
let $497cef411d884e34$var$BaseScript = new Struct({
  baseValues: new Pointer(uint16, $497cef411d884e34$var$BaseValues),
  defaultMinMax: new Pointer(uint16, $497cef411d884e34$var$MinMax),
  baseLangSysCount: uint16,
  baseLangSysRecords: new ArrayT($497cef411d884e34$var$BaseLangSysRecord, "baseLangSysCount")
  // in alphabetical order by BaseLangSysTag
});
let $497cef411d884e34$var$BaseScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $497cef411d884e34$var$BaseScript, {
    type: "parent"
  })
});
let $497cef411d884e34$var$BaseScriptList = new ArrayT($497cef411d884e34$var$BaseScriptRecord, uint16);
let $497cef411d884e34$var$BaseTagList = new ArrayT(new StringT(4), uint16);
let $497cef411d884e34$var$Axis = new Struct({
  baseTagList: new Pointer(uint16, $497cef411d884e34$var$BaseTagList),
  baseScriptList: new Pointer(uint16, $497cef411d884e34$var$BaseScriptList)
});
var $497cef411d884e34$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    horizAxis: new Pointer(uint16, $497cef411d884e34$var$Axis),
    vertAxis: new Pointer(uint16, $497cef411d884e34$var$Axis)
    // May be NULL
  },
  65536: {},
  65537: {
    itemVariationStore: new Pointer(uint32, $1a47b0c45c1c22fe$export$fe1b122a2710f241)
  }
});
let $cf5f33c63ef209e6$var$AttachPoint = new ArrayT(uint16, uint16);
let $cf5f33c63ef209e6$var$AttachList = new Struct({
  coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
  glyphCount: uint16,
  attachPoints: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$AttachPoint), "glyphCount")
});
let $cf5f33c63ef209e6$var$CaretValue = new VersionedStruct(uint16, {
  1: {
    coordinate: int16
  },
  2: {
    caretValuePoint: uint16
  },
  3: {
    coordinate: int16,
    deviceTable: new Pointer(uint16, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10)
  }
});
let $cf5f33c63ef209e6$var$LigGlyph = new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$CaretValue), uint16);
let $cf5f33c63ef209e6$var$LigCaretList = new Struct({
  coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
  ligGlyphCount: uint16,
  ligGlyphs: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$LigGlyph), "ligGlyphCount")
});
let $cf5f33c63ef209e6$var$MarkGlyphSetsDef = new Struct({
  markSetTableFormat: uint16,
  markSetCount: uint16,
  coverage: new ArrayT(new Pointer(uint32, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "markSetCount")
});
var $cf5f33c63ef209e6$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    glyphClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    attachList: new Pointer(uint16, $cf5f33c63ef209e6$var$AttachList),
    ligCaretList: new Pointer(uint16, $cf5f33c63ef209e6$var$LigCaretList),
    markAttachClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71)
  },
  65536: {},
  65538: {
    markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef)
  },
  65539: {
    markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef),
    itemVariationStore: new Pointer(uint32, $1a47b0c45c1c22fe$export$fe1b122a2710f241)
  }
});
let $47e0e8ef515d9903$var$ValueFormat = new Bitfield(uint16, [
  "xPlacement",
  "yPlacement",
  "xAdvance",
  "yAdvance",
  "xPlaDevice",
  "yPlaDevice",
  "xAdvDevice",
  "yAdvDevice"
]);
let $47e0e8ef515d9903$var$types = {
  xPlacement: int16,
  yPlacement: int16,
  xAdvance: int16,
  yAdvance: int16,
  xPlaDevice: new Pointer(uint16, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10, {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  }),
  yPlaDevice: new Pointer(uint16, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10, {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  }),
  xAdvDevice: new Pointer(uint16, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10, {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  }),
  yAdvDevice: new Pointer(uint16, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10, {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  })
};
class $47e0e8ef515d9903$var$ValueRecord {
  buildStruct(parent) {
    let struct = parent;
    while (!struct[this.key] && struct.parent) struct = struct.parent;
    if (!struct[this.key]) return;
    let fields = {};
    fields.rel = () => struct._startOffset;
    let format2 = struct[this.key];
    for (let key in format2) if (format2[key]) fields[key] = $47e0e8ef515d9903$var$types[key];
    return new Struct(fields);
  }
  size(val, ctx) {
    return this.buildStruct(ctx).size(val, ctx);
  }
  decode(stream2, parent) {
    let res = this.buildStruct(parent).decode(stream2, parent);
    delete res.rel;
    return res;
  }
  constructor(key = "valueFormat") {
    this.key = key;
  }
}
let $47e0e8ef515d9903$var$PairValueRecord = new Struct({
  secondGlyph: uint16,
  value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
  value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
});
let $47e0e8ef515d9903$var$PairSet = new ArrayT($47e0e8ef515d9903$var$PairValueRecord, uint16);
let $47e0e8ef515d9903$var$Class2Record = new Struct({
  value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
  value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
});
let $47e0e8ef515d9903$var$Anchor = new VersionedStruct(uint16, {
  1: {
    xCoordinate: int16,
    yCoordinate: int16
  },
  2: {
    xCoordinate: int16,
    yCoordinate: int16,
    anchorPoint: uint16
  },
  3: {
    xCoordinate: int16,
    yCoordinate: int16,
    xDeviceTable: new Pointer(uint16, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10),
    yDeviceTable: new Pointer(uint16, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10)
  }
});
let $47e0e8ef515d9903$var$EntryExitRecord = new Struct({
  entryAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  }),
  exitAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  })
});
let $47e0e8ef515d9903$var$MarkRecord = new Struct({
  class: uint16,
  markAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  })
});
let $47e0e8ef515d9903$var$MarkArray = new ArrayT($47e0e8ef515d9903$var$MarkRecord, uint16);
let $47e0e8ef515d9903$var$BaseRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t2) => t2.parent.classCount);
let $47e0e8ef515d9903$var$BaseArray = new ArrayT($47e0e8ef515d9903$var$BaseRecord, uint16);
let $47e0e8ef515d9903$var$ComponentRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t2) => t2.parent.parent.classCount);
let $47e0e8ef515d9903$var$LigatureAttach = new ArrayT($47e0e8ef515d9903$var$ComponentRecord, uint16);
let $47e0e8ef515d9903$var$LigatureArray = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$LigatureAttach), uint16);
let $47e0e8ef515d9903$export$73a8cfb19cd43a0f = new VersionedStruct("lookupType", {
  1: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
      valueFormat: $47e0e8ef515d9903$var$ValueFormat,
      value: new $47e0e8ef515d9903$var$ValueRecord()
    },
    2: {
      coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
      valueFormat: $47e0e8ef515d9903$var$ValueFormat,
      valueCount: uint16,
      values: new LazyArray(new $47e0e8ef515d9903$var$ValueRecord(), "valueCount")
    }
  }),
  2: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
      pairSetCount: uint16,
      pairSets: new LazyArray(new Pointer(uint16, $47e0e8ef515d9903$var$PairSet), "pairSetCount")
    },
    2: {
      coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
      classDef1: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
      classDef2: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
      class1Count: uint16,
      class2Count: uint16,
      classRecords: new LazyArray(new LazyArray($47e0e8ef515d9903$var$Class2Record, "class2Count"), "class1Count")
    }
  }),
  3: {
    format: uint16,
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    entryExitCount: uint16,
    entryExitRecords: new ArrayT($47e0e8ef515d9903$var$EntryExitRecord, "entryExitCount")
  },
  4: {
    format: uint16,
    markCoverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    baseCoverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    classCount: uint16,
    markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    baseArray: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
  },
  5: {
    format: uint16,
    markCoverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    ligatureCoverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    classCount: uint16,
    markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    ligatureArray: new Pointer(uint16, $47e0e8ef515d9903$var$LigatureArray)
  },
  6: {
    format: uint16,
    mark1Coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    mark2Coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    classCount: uint16,
    mark1Array: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    mark2Array: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
  },
  7: $7cbbe4e24ef3cb75$export$841858b892ce1f4c,
  8: $7cbbe4e24ef3cb75$export$5e6d09e6861162f6,
  9: {
    posFormat: uint16,
    lookupType: uint16,
    extension: new Pointer(uint32, null)
  }
});
$47e0e8ef515d9903$export$73a8cfb19cd43a0f.versions[9].extension.type = $47e0e8ef515d9903$export$73a8cfb19cd43a0f;
var $47e0e8ef515d9903$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    scriptList: new Pointer(uint16, $7cbbe4e24ef3cb75$export$3e15fc05ce864229),
    featureList: new Pointer(uint16, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4),
    lookupList: new Pointer(uint16, new $7cbbe4e24ef3cb75$export$df0008c6ff2da22a($47e0e8ef515d9903$export$73a8cfb19cd43a0f))
  },
  65536: {},
  65537: {
    featureVariations: new Pointer(uint32, $1a47b0c45c1c22fe$export$441b70b7971dd419)
  }
});
let $d3f442064af66e06$var$Sequence = new ArrayT(uint16, uint16);
let $d3f442064af66e06$var$AlternateSet = $d3f442064af66e06$var$Sequence;
let $d3f442064af66e06$var$Ligature = new Struct({
  glyph: uint16,
  compCount: uint16,
  components: new ArrayT(uint16, (t2) => t2.compCount - 1)
});
let $d3f442064af66e06$var$LigatureSet = new ArrayT(new Pointer(uint16, $d3f442064af66e06$var$Ligature), uint16);
let $d3f442064af66e06$var$GSUBLookup = new VersionedStruct("lookupType", {
  1: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
      deltaGlyphID: int16
    },
    2: {
      coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
      glyphCount: uint16,
      substitute: new LazyArray(uint16, "glyphCount")
    }
  }),
  2: {
    substFormat: uint16,
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    count: uint16,
    sequences: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$Sequence), "count")
  },
  3: {
    substFormat: uint16,
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    count: uint16,
    alternateSet: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$AlternateSet), "count")
  },
  4: {
    substFormat: uint16,
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    count: uint16,
    ligatureSets: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$LigatureSet), "count")
  },
  5: $7cbbe4e24ef3cb75$export$841858b892ce1f4c,
  6: $7cbbe4e24ef3cb75$export$5e6d09e6861162f6,
  7: {
    substFormat: uint16,
    lookupType: uint16,
    extension: new Pointer(uint32, null)
  },
  8: {
    substFormat: uint16,
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    backtrackCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "backtrackGlyphCount"),
    lookaheadGlyphCount: uint16,
    lookaheadCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "lookaheadGlyphCount"),
    glyphCount: uint16,
    substitutes: new ArrayT(uint16, "glyphCount")
  }
});
$d3f442064af66e06$var$GSUBLookup.versions[7].extension.type = $d3f442064af66e06$var$GSUBLookup;
var $d3f442064af66e06$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    scriptList: new Pointer(uint16, $7cbbe4e24ef3cb75$export$3e15fc05ce864229),
    featureList: new Pointer(uint16, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4),
    lookupList: new Pointer(uint16, new $7cbbe4e24ef3cb75$export$df0008c6ff2da22a($d3f442064af66e06$var$GSUBLookup))
  },
  65536: {},
  65537: {
    featureVariations: new Pointer(uint32, $1a47b0c45c1c22fe$export$441b70b7971dd419)
  }
});
let $71cfb3c4767fbd0c$var$JstfGSUBModList = new ArrayT(uint16, uint16);
let $71cfb3c4767fbd0c$var$JstfPriority = new Struct({
  shrinkageEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageJstfMax: new Pointer(uint16, new $7cbbe4e24ef3cb75$export$df0008c6ff2da22a($47e0e8ef515d9903$export$73a8cfb19cd43a0f)),
  extensionEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionJstfMax: new Pointer(uint16, new $7cbbe4e24ef3cb75$export$df0008c6ff2da22a($47e0e8ef515d9903$export$73a8cfb19cd43a0f))
});
let $71cfb3c4767fbd0c$var$JstfLangSys = new ArrayT(new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfPriority), uint16);
let $71cfb3c4767fbd0c$var$JstfLangSysRecord = new Struct({
  tag: new StringT(4),
  jstfLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys)
});
let $71cfb3c4767fbd0c$var$JstfScript = new Struct({
  extenderGlyphs: new Pointer(uint16, new ArrayT(uint16, uint16)),
  defaultLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys),
  langSysCount: uint16,
  langSysRecords: new ArrayT($71cfb3c4767fbd0c$var$JstfLangSysRecord, "langSysCount")
});
let $71cfb3c4767fbd0c$var$JstfScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfScript, {
    type: "parent"
  })
});
var $71cfb3c4767fbd0c$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  scriptCount: uint16,
  scriptList: new ArrayT($71cfb3c4767fbd0c$var$JstfScriptRecord, "scriptCount")
});
class $d059a6bd2d3b5b63$var$VariableSizeNumber {
  decode(stream2, parent) {
    switch (this.size(0, parent)) {
      case 1:
        return stream2.readUInt8();
      case 2:
        return stream2.readUInt16BE();
      case 3:
        return stream2.readUInt24BE();
      case 4:
        return stream2.readUInt32BE();
    }
  }
  size(val, parent) {
    return resolveLength(this._size, null, parent);
  }
  constructor(size) {
    this._size = size;
  }
}
let $d059a6bd2d3b5b63$var$MapDataEntry = new Struct({
  entry: new $d059a6bd2d3b5b63$var$VariableSizeNumber((t2) => ((t2.parent.entryFormat & 48) >> 4) + 1),
  outerIndex: (t2) => t2.entry >> (t2.parent.entryFormat & 15) + 1,
  innerIndex: (t2) => t2.entry & (1 << (t2.parent.entryFormat & 15) + 1) - 1
});
let $d059a6bd2d3b5b63$var$DeltaSetIndexMap = new Struct({
  entryFormat: uint16,
  mapCount: uint16,
  mapData: new ArrayT($d059a6bd2d3b5b63$var$MapDataEntry, "mapCount")
});
var $d059a6bd2d3b5b63$export$2e2bcd8739ae039 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  itemVariationStore: new Pointer(uint32, $1a47b0c45c1c22fe$export$fe1b122a2710f241),
  advanceWidthMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
  LSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
  RSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap)
});
let $dceeca3e1977ce30$var$Signature = new Struct({
  format: uint32,
  length: uint32,
  offset: uint32
});
let $dceeca3e1977ce30$var$SignatureBlock = new Struct({
  reserved: new Reserved(uint16, 2),
  cbSignature: uint32,
  signature: new BufferT("cbSignature")
});
var $dceeca3e1977ce30$export$2e2bcd8739ae039 = new Struct({
  ulVersion: uint32,
  usNumSigs: uint16,
  usFlag: uint16,
  signatures: new ArrayT($dceeca3e1977ce30$var$Signature, "usNumSigs"),
  signatureBlocks: new ArrayT($dceeca3e1977ce30$var$SignatureBlock, "usNumSigs")
});
let $8acd740a9435aad0$var$GaspRange = new Struct({
  rangeMaxPPEM: uint16,
  rangeGaspBehavior: new Bitfield(uint16, [
    "grayscale",
    "gridfit",
    "symmetricSmoothing",
    "symmetricGridfit"
    // only in version 1, for ClearType
  ])
});
var $8acd740a9435aad0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRanges: uint16,
  gaspRanges: new ArrayT($8acd740a9435aad0$var$GaspRange, "numRanges")
  // Sorted by ppem
});
let $b5f380243c34d6a0$var$DeviceRecord = new Struct({
  pixelSize: uint8,
  maximumWidth: uint8,
  widths: new ArrayT(uint8, (t2) => t2.parent.parent.maxp.numGlyphs)
});
var $b5f380243c34d6a0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRecords: int16,
  sizeDeviceRecord: int32,
  records: new ArrayT($b5f380243c34d6a0$var$DeviceRecord, "numRecords")
});
let $ca2df1256966e313$var$KernPair = new Struct({
  left: uint16,
  right: uint16,
  value: int16
});
let $ca2df1256966e313$var$ClassTable = new Struct({
  firstGlyph: uint16,
  nGlyphs: uint16,
  offsets: new ArrayT(uint16, "nGlyphs"),
  max: (t2) => t2.offsets.length && Math.max.apply(Math, t2.offsets)
});
let $ca2df1256966e313$var$Kern2Array = new Struct({
  off: (t2) => t2._startOffset - t2.parent.parent._startOffset,
  len: (t2) => ((t2.parent.leftTable.max - t2.off) / t2.parent.rowWidth + 1) * (t2.parent.rowWidth / 2),
  values: new LazyArray(int16, "len")
});
let $ca2df1256966e313$var$KernSubtable = new VersionedStruct("format", {
  0: {
    nPairs: uint16,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16,
    pairs: new ArrayT($ca2df1256966e313$var$KernPair, "nPairs")
  },
  2: {
    rowWidth: uint16,
    leftTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
      type: "parent"
    }),
    rightTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
      type: "parent"
    }),
    array: new Pointer(uint16, $ca2df1256966e313$var$Kern2Array, {
      type: "parent"
    })
  },
  3: {
    glyphCount: uint16,
    kernValueCount: uint8,
    leftClassCount: uint8,
    rightClassCount: uint8,
    flags: uint8,
    kernValue: new ArrayT(int16, "kernValueCount"),
    leftClass: new ArrayT(uint8, "glyphCount"),
    rightClass: new ArrayT(uint8, "glyphCount"),
    kernIndex: new ArrayT(uint8, (t2) => t2.leftClassCount * t2.rightClassCount)
  }
});
let $ca2df1256966e313$var$KernTable = new VersionedStruct("version", {
  0: {
    subVersion: uint16,
    length: uint16,
    format: uint8,
    coverage: new Bitfield(uint8, [
      "horizontal",
      "minimum",
      "crossStream",
      "override"
      // If set to 1 the value in this table replaces the accumulated value
    ]),
    subtable: $ca2df1256966e313$var$KernSubtable,
    padding: new Reserved(uint8, (t2) => t2.length - t2._currentOffset)
  },
  1: {
    length: uint32,
    coverage: new Bitfield(uint8, [
      null,
      null,
      null,
      null,
      null,
      "variation",
      "crossStream",
      "vertical"
      // Set if table has vertical kerning values
    ]),
    format: uint8,
    tupleIndex: uint16,
    subtable: $ca2df1256966e313$var$KernSubtable,
    padding: new Reserved(uint8, (t2) => t2.length - t2._currentOffset)
  }
});
var $ca2df1256966e313$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
  0: {
    nTables: uint16,
    tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
  },
  1: {
    reserved: new Reserved(uint16),
    nTables: uint32,
    tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
  }
});
var $7a9f92b0c46ebe33$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numGlyphs: uint16,
  yPels: new ArrayT(uint8, "numGlyphs")
});
var $2b2ccc419d152631$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  fontNumber: uint32,
  pitch: uint16,
  xHeight: uint16,
  style: uint16,
  typeFamily: uint16,
  capHeight: uint16,
  symbolSet: uint16,
  typeface: new StringT(16),
  characterComplement: new StringT(8),
  fileName: new StringT(6),
  strokeWeight: new StringT(1),
  widthType: new StringT(1),
  serifStyle: uint8,
  reserved: new Reserved(uint8)
});
let $ca5b40b9bcda9c9b$var$Ratio = new Struct({
  bCharSet: uint8,
  xRatio: uint8,
  yStartRatio: uint8,
  yEndRatio: uint8
  // Ending y-Ratio value
});
let $ca5b40b9bcda9c9b$var$vTable = new Struct({
  yPelHeight: uint16,
  yMax: int16,
  yMin: int16
  // Minimum value (in pels) for this yPelHeight
});
let $ca5b40b9bcda9c9b$var$VdmxGroup = new Struct({
  recs: uint16,
  startsz: uint8,
  endsz: uint8,
  entries: new ArrayT($ca5b40b9bcda9c9b$var$vTable, "recs")
  // The VDMX records
});
var $ca5b40b9bcda9c9b$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRecs: uint16,
  numRatios: uint16,
  ratioRanges: new ArrayT($ca5b40b9bcda9c9b$var$Ratio, "numRatios"),
  offsets: new ArrayT(uint16, "numRatios"),
  groups: new ArrayT($ca5b40b9bcda9c9b$var$VdmxGroup, "numRecs")
  // The actual VDMX groupings
});
var $69530a3c40755af0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  ascent: int16,
  descent: int16,
  lineGap: int16,
  advanceHeightMax: int16,
  minTopSideBearing: int16,
  minBottomSideBearing: int16,
  yMaxExtent: int16,
  caretSlopeRise: int16,
  caretSlopeRun: int16,
  caretOffset: int16,
  reserved: new Reserved(int16, 4),
  metricDataFormat: int16,
  numberOfMetrics: uint16
  // Number of advance heights in the Vertical Metrics table
});
let $344073dd270f0e62$var$VmtxEntry = new Struct({
  advance: uint16,
  bearing: int16
  // The top sidebearing of the glyph
});
var $344073dd270f0e62$export$2e2bcd8739ae039 = new Struct({
  metrics: new LazyArray($344073dd270f0e62$var$VmtxEntry, (t2) => t2.parent.vhea.numberOfMetrics),
  bearings: new LazyArray(int16, (t2) => t2.parent.maxp.numGlyphs - t2.parent.vhea.numberOfMetrics)
});
let $3793b781918cfced$var$shortFrac = new Fixed(16, "BE", 14);
let $3793b781918cfced$var$Correspondence = new Struct({
  fromCoord: $3793b781918cfced$var$shortFrac,
  toCoord: $3793b781918cfced$var$shortFrac
});
let $3793b781918cfced$var$Segment = new Struct({
  pairCount: uint16,
  correspondence: new ArrayT($3793b781918cfced$var$Correspondence, "pairCount")
});
var $3793b781918cfced$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  axisCount: uint32,
  segment: new ArrayT($3793b781918cfced$var$Segment, "axisCount")
});
class $6cb7dd5f47d82580$var$UnboundedArrayAccessor {
  getItem(index2) {
    if (this._items[index2] == null) {
      let pos = this.stream.pos;
      this.stream.pos = this.base + this.type.size(null, this.parent) * index2;
      this._items[index2] = this.type.decode(this.stream, this.parent);
      this.stream.pos = pos;
    }
    return this._items[index2];
  }
  inspect() {
    return `[UnboundedArray ${this.type.constructor.name}]`;
  }
  constructor(type, stream2, parent) {
    this.type = type;
    this.stream = stream2;
    this.parent = parent;
    this.base = this.stream.pos;
    this._items = [];
  }
}
class $6cb7dd5f47d82580$export$c5af1eebc882e39a extends ArrayT {
  decode(stream2, parent) {
    return new $6cb7dd5f47d82580$var$UnboundedArrayAccessor(this.type, stream2, parent);
  }
  constructor(type) {
    super(type, 0);
  }
}
let $6cb7dd5f47d82580$export$8351f8c2ae2f103c = function(ValueType = uint16) {
  class Shadow {
    decode(stream2, ctx) {
      ctx = ctx.parent.parent;
      return this.type.decode(stream2, ctx);
    }
    size(val, ctx) {
      ctx = ctx.parent.parent;
      return this.type.size(val, ctx);
    }
    encode(stream2, val, ctx) {
      ctx = ctx.parent.parent;
      return this.type.encode(stream2, val, ctx);
    }
    constructor(type) {
      this.type = type;
    }
  }
  ValueType = new Shadow(ValueType);
  let BinarySearchHeader = new Struct({
    unitSize: uint16,
    nUnits: uint16,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16
  });
  let LookupSegmentSingle = new Struct({
    lastGlyph: uint16,
    firstGlyph: uint16,
    value: ValueType
  });
  let LookupSegmentArray = new Struct({
    lastGlyph: uint16,
    firstGlyph: uint16,
    values: new Pointer(uint16, new ArrayT(ValueType, (t2) => t2.lastGlyph - t2.firstGlyph + 1), {
      type: "parent"
    })
  });
  let LookupSingle = new Struct({
    glyph: uint16,
    value: ValueType
  });
  return new VersionedStruct(uint16, {
    0: {
      values: new $6cb7dd5f47d82580$export$c5af1eebc882e39a(ValueType)
      // length == number of glyphs maybe?
    },
    2: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSegmentSingle, (t2) => t2.binarySearchHeader.nUnits)
    },
    4: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSegmentArray, (t2) => t2.binarySearchHeader.nUnits)
    },
    6: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSingle, (t2) => t2.binarySearchHeader.nUnits)
    },
    8: {
      firstGlyph: uint16,
      count: uint16,
      values: new ArrayT(ValueType, "count")
    }
  });
};
function $6cb7dd5f47d82580$export$79f7d93d790934ba(entryData = {}, lookupType = uint16) {
  let entry = Object.assign({
    newState: uint16,
    flags: uint16
  }, entryData);
  let Entry = new Struct(entry);
  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint16, (t2) => t2.nClasses));
  let StateHeader = new Struct({
    nClasses: uint32,
    classTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$8351f8c2ae2f103c(lookupType)),
    stateArray: new Pointer(uint32, StateArray),
    entryTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
  });
  return StateHeader;
}
function $6cb7dd5f47d82580$export$105027425199cc51(entryData = {}, lookupType = uint16) {
  let ClassLookupTable = new Struct({
    version() {
      return 8;
    },
    firstGlyph: uint16,
    values: new ArrayT(uint8, uint16)
  });
  let entry = Object.assign({
    newStateOffset: uint16,
    // convert offset to stateArray index
    newState: (t2) => (t2.newStateOffset - (t2.parent.stateArray.base - t2.parent._startOffset)) / t2.parent.nClasses,
    flags: uint16
  }, entryData);
  let Entry = new Struct(entry);
  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint8, (t2) => t2.nClasses));
  let StateHeader1 = new Struct({
    nClasses: uint16,
    classTable: new Pointer(uint16, ClassLookupTable),
    stateArray: new Pointer(uint16, StateArray),
    entryTable: new Pointer(uint16, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
  });
  return StateHeader1;
}
let $6a3746e8c708f5a3$var$BslnSubtable = new VersionedStruct("format", {
  0: {
    deltas: new ArrayT(int16, 32)
  },
  1: {
    deltas: new ArrayT(int16, 32),
    mappingData: new $6cb7dd5f47d82580$export$8351f8c2ae2f103c(uint16)
  },
  2: {
    standardGlyph: uint16,
    controlPoints: new ArrayT(uint16, 32)
  },
  3: {
    standardGlyph: uint16,
    controlPoints: new ArrayT(uint16, 32),
    mappingData: new $6cb7dd5f47d82580$export$8351f8c2ae2f103c(uint16)
  }
});
var $6a3746e8c708f5a3$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  format: uint16,
  defaultBaseline: uint16,
  subtable: $6a3746e8c708f5a3$var$BslnSubtable
});
let $d0c76fac617b308a$var$Setting = new Struct({
  setting: uint16,
  nameIndex: int16,
  name: (t2) => t2.parent.parent.parent.name.records.fontFeatures[t2.nameIndex]
});
let $d0c76fac617b308a$var$FeatureName = new Struct({
  feature: uint16,
  nSettings: uint16,
  settingTable: new Pointer(uint32, new ArrayT($d0c76fac617b308a$var$Setting, "nSettings"), {
    type: "parent"
  }),
  featureFlags: new Bitfield(uint8, [
    null,
    null,
    null,
    null,
    null,
    null,
    "hasDefault",
    "exclusive"
  ]),
  defaultSetting: uint8,
  nameIndex: int16,
  name: (t2) => t2.parent.parent.name.records.fontFeatures[t2.nameIndex]
});
var $d0c76fac617b308a$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  featureNameCount: uint16,
  reserved1: new Reserved(uint16),
  reserved2: new Reserved(uint32),
  featureNames: new ArrayT($d0c76fac617b308a$var$FeatureName, "featureNameCount")
});
let $e83fd065f00fcd01$var$Axis = new Struct({
  axisTag: new StringT(4),
  minValue: fixed32,
  defaultValue: fixed32,
  maxValue: fixed32,
  flags: uint16,
  nameID: uint16,
  name: (t2) => t2.parent.parent.name.records.fontFeatures[t2.nameID]
});
let $e83fd065f00fcd01$var$Instance = new Struct({
  nameID: uint16,
  name: (t2) => t2.parent.parent.name.records.fontFeatures[t2.nameID],
  flags: uint16,
  coord: new ArrayT(fixed32, (t2) => t2.parent.axisCount),
  postscriptNameID: new Optional(uint16, (t2) => t2.parent.instanceSize - t2._currentOffset > 0)
});
var $e83fd065f00fcd01$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  offsetToData: uint16,
  countSizePairs: uint16,
  axisCount: uint16,
  axisSize: uint16,
  instanceCount: uint16,
  instanceSize: uint16,
  axis: new ArrayT($e83fd065f00fcd01$var$Axis, "axisCount"),
  instance: new ArrayT($e83fd065f00fcd01$var$Instance, "instanceCount")
});
let $dbe33c8d3a7f131c$var$shortFrac = new Fixed(16, "BE", 14);
class $dbe33c8d3a7f131c$var$Offset {
  static decode(stream2, parent) {
    return parent.flags ? stream2.readUInt32BE() : stream2.readUInt16BE() * 2;
  }
}
let $dbe33c8d3a7f131c$var$gvar = new Struct({
  version: uint16,
  reserved: new Reserved(uint16),
  axisCount: uint16,
  globalCoordCount: uint16,
  globalCoords: new Pointer(uint32, new ArrayT(new ArrayT($dbe33c8d3a7f131c$var$shortFrac, "axisCount"), "globalCoordCount")),
  glyphCount: uint16,
  flags: uint16,
  offsetToData: uint32,
  offsets: new ArrayT(new Pointer($dbe33c8d3a7f131c$var$Offset, "void", {
    relativeTo: (ctx) => ctx.offsetToData,
    allowNull: false
  }), (t2) => t2.glyphCount + 1)
});
var $dbe33c8d3a7f131c$export$2e2bcd8739ae039 = $dbe33c8d3a7f131c$var$gvar;
let $05b01887df96c4ee$var$ClassTable = new Struct({
  length: uint16,
  coverage: uint16,
  subFeatureFlags: uint32,
  stateTable: new $6cb7dd5f47d82580$export$105027425199cc51()
});
let $05b01887df96c4ee$var$WidthDeltaRecord = new Struct({
  justClass: uint32,
  beforeGrowLimit: fixed32,
  beforeShrinkLimit: fixed32,
  afterGrowLimit: fixed32,
  afterShrinkLimit: fixed32,
  growFlags: uint16,
  shrinkFlags: uint16
});
let $05b01887df96c4ee$var$WidthDeltaCluster = new ArrayT($05b01887df96c4ee$var$WidthDeltaRecord, uint32);
let $05b01887df96c4ee$var$ActionData = new VersionedStruct("actionType", {
  0: {
    lowerLimit: fixed32,
    upperLimit: fixed32,
    order: uint16,
    glyphs: new ArrayT(uint16, uint16)
  },
  1: {
    addGlyph: uint16
  },
  2: {
    substThreshold: fixed32,
    addGlyph: uint16,
    substGlyph: uint16
  },
  3: {},
  4: {
    variationAxis: uint32,
    minimumLimit: fixed32,
    noStretchValue: fixed32,
    maximumLimit: fixed32
  },
  5: {
    flags: uint16,
    glyph: uint16
  }
});
let $05b01887df96c4ee$var$Action = new Struct({
  actionClass: uint16,
  actionType: uint16,
  actionLength: uint32,
  actionData: $05b01887df96c4ee$var$ActionData,
  padding: new Reserved(uint8, (t2) => t2.actionLength - t2._currentOffset)
});
let $05b01887df96c4ee$var$PostcompensationAction = new ArrayT($05b01887df96c4ee$var$Action, uint32);
let $05b01887df96c4ee$var$PostCompensationTable = new Struct({
  lookupTable: new $6cb7dd5f47d82580$export$8351f8c2ae2f103c(new Pointer(uint16, $05b01887df96c4ee$var$PostcompensationAction))
});
let $05b01887df96c4ee$var$JustificationTable = new Struct({
  classTable: new Pointer(uint16, $05b01887df96c4ee$var$ClassTable, {
    type: "parent"
  }),
  wdcOffset: uint16,
  postCompensationTable: new Pointer(uint16, $05b01887df96c4ee$var$PostCompensationTable, {
    type: "parent"
  }),
  widthDeltaClusters: new $6cb7dd5f47d82580$export$8351f8c2ae2f103c(new Pointer(uint16, $05b01887df96c4ee$var$WidthDeltaCluster, {
    type: "parent",
    relativeTo: (ctx) => ctx.wdcOffset
  }))
});
var $05b01887df96c4ee$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  format: uint16,
  horizontal: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable),
  vertical: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable)
});
let $03ee6ebd54db1053$var$LigatureData = {
  action: uint16
};
let $03ee6ebd54db1053$var$ContextualData = {
  markIndex: uint16,
  currentIndex: uint16
};
let $03ee6ebd54db1053$var$InsertionData = {
  currentInsertIndex: uint16,
  markedInsertIndex: uint16
};
let $03ee6ebd54db1053$var$SubstitutionTable = new Struct({
  items: new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new Pointer(uint32, new $6cb7dd5f47d82580$export$8351f8c2ae2f103c()))
});
let $03ee6ebd54db1053$var$SubtableData = new VersionedStruct("type", {
  0: {
    stateTable: new $6cb7dd5f47d82580$export$79f7d93d790934ba()
  },
  1: {
    stateTable: new $6cb7dd5f47d82580$export$79f7d93d790934ba($03ee6ebd54db1053$var$ContextualData),
    substitutionTable: new Pointer(uint32, $03ee6ebd54db1053$var$SubstitutionTable)
  },
  2: {
    stateTable: new $6cb7dd5f47d82580$export$79f7d93d790934ba($03ee6ebd54db1053$var$LigatureData),
    ligatureActions: new Pointer(uint32, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(uint32)),
    components: new Pointer(uint32, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(uint16)),
    ligatureList: new Pointer(uint32, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(uint16))
  },
  4: {
    lookupTable: new $6cb7dd5f47d82580$export$8351f8c2ae2f103c()
  },
  5: {
    stateTable: new $6cb7dd5f47d82580$export$79f7d93d790934ba($03ee6ebd54db1053$var$InsertionData),
    insertionActions: new Pointer(uint32, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(uint16))
  }
});
let $03ee6ebd54db1053$var$Subtable = new Struct({
  length: uint32,
  coverage: uint24,
  type: uint8,
  subFeatureFlags: uint32,
  table: $03ee6ebd54db1053$var$SubtableData,
  padding: new Reserved(uint8, (t2) => t2.length - t2._currentOffset)
});
let $03ee6ebd54db1053$var$FeatureEntry = new Struct({
  featureType: uint16,
  featureSetting: uint16,
  enableFlags: uint32,
  disableFlags: uint32
});
let $03ee6ebd54db1053$var$MorxChain = new Struct({
  defaultFlags: uint32,
  chainLength: uint32,
  nFeatureEntries: uint32,
  nSubtables: uint32,
  features: new ArrayT($03ee6ebd54db1053$var$FeatureEntry, "nFeatureEntries"),
  subtables: new ArrayT($03ee6ebd54db1053$var$Subtable, "nSubtables")
});
var $03ee6ebd54db1053$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  unused: new Reserved(uint16),
  nChains: uint32,
  chains: new ArrayT($03ee6ebd54db1053$var$MorxChain, "nChains")
});
let $b7492a80b0d1a056$var$OpticalBounds = new Struct({
  left: int16,
  top: int16,
  right: int16,
  bottom: int16
});
var $b7492a80b0d1a056$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  format: uint16,
  lookupTable: new $6cb7dd5f47d82580$export$8351f8c2ae2f103c($b7492a80b0d1a056$var$OpticalBounds)
});
let $c3395722bea751e2$var$tables = {};
var $c3395722bea751e2$export$2e2bcd8739ae039 = $c3395722bea751e2$var$tables;
$c3395722bea751e2$var$tables.cmap = $26a62205ad06574e$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.head = $f2612a29f92ac062$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.hhea = $2c179dd593583073$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.hmtx = $bdc9060542264b85$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.maxp = $dbf51cb3d3fe409d$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.name = $2bcf221753ec8e32$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables["OS/2"] = $84b272aa31b70606$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.post = $32d9e2eb9565d93c$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.fpgm = $5c0f37ca5ffb1850$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.loca = $2b2b260902b1c57e$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.prep = $7afb878c7bea4f66$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables["cvt "] = $5202bd9d9ad8eaac$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.glyf = $6c92b6371bce8bd9$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables["CFF "] = $822ac0d589e4e237$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables["CFF2"] = $822ac0d589e4e237$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.VORG = $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.EBLC = $9911c4c7201c13de$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.CBLC = $c3395722bea751e2$var$tables.EBLC;
$c3395722bea751e2$var$tables.sbix = $abb847051efd51b1$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.COLR = $eb629188f3dfefdd$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.CPAL = $08734b8e7dc64587$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.BASE = $497cef411d884e34$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.GDEF = $cf5f33c63ef209e6$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.GPOS = $47e0e8ef515d9903$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.GSUB = $d3f442064af66e06$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.JSTF = $71cfb3c4767fbd0c$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.HVAR = $d059a6bd2d3b5b63$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.DSIG = $dceeca3e1977ce30$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.gasp = $8acd740a9435aad0$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.hdmx = $b5f380243c34d6a0$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.kern = $ca2df1256966e313$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.LTSH = $7a9f92b0c46ebe33$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.PCLT = $2b2ccc419d152631$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.VDMX = $ca5b40b9bcda9c9b$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.vhea = $69530a3c40755af0$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.vmtx = $344073dd270f0e62$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.avar = $3793b781918cfced$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.bsln = $6a3746e8c708f5a3$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.feat = $d0c76fac617b308a$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.fvar = $e83fd065f00fcd01$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.gvar = $dbe33c8d3a7f131c$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.just = $05b01887df96c4ee$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.morx = $03ee6ebd54db1053$export$2e2bcd8739ae039;
$c3395722bea751e2$var$tables.opbd = $b7492a80b0d1a056$export$2e2bcd8739ae039;
let $816c07a04b6dba87$var$TableEntry = new Struct({
  tag: new StringT(4),
  checkSum: uint32,
  offset: new Pointer(uint32, "void", {
    type: "global"
  }),
  length: uint32
});
let $816c07a04b6dba87$var$Directory = new Struct({
  tag: new StringT(4),
  numTables: uint16,
  searchRange: uint16,
  entrySelector: uint16,
  rangeShift: uint16,
  tables: new ArrayT($816c07a04b6dba87$var$TableEntry, "numTables")
});
$816c07a04b6dba87$var$Directory.process = function() {
  let tables = {};
  for (let table of this.tables) tables[table.tag] = table;
  this.tables = tables;
};
$816c07a04b6dba87$var$Directory.preEncode = function() {
  if (!Array.isArray(this.tables)) {
    let tables = [];
    for (let tag in this.tables) {
      let table = this.tables[tag];
      if (table) tables.push({
        tag,
        checkSum: 0,
        offset: new VoidPointer($c3395722bea751e2$export$2e2bcd8739ae039[tag], table),
        length: $c3395722bea751e2$export$2e2bcd8739ae039[tag].size(table)
      });
    }
    this.tables = tables;
  }
  this.tag = "true";
  this.numTables = this.tables.length;
  let maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);
  let maxPowerOf2 = Math.pow(2, maxExponentFor2);
  this.searchRange = maxPowerOf2 * 16;
  this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;
  this.rangeShift = this.numTables * 16 - this.searchRange;
};
var $816c07a04b6dba87$export$2e2bcd8739ae039 = $816c07a04b6dba87$var$Directory;
function $12727730ddfc8bfe$export$2e0ae67339d5f1ac(arr, cmp) {
  let min2 = 0;
  let max2 = arr.length - 1;
  while (min2 <= max2) {
    let mid = min2 + max2 >> 1;
    let res = cmp(arr[mid]);
    if (res < 0) max2 = mid - 1;
    else if (res > 0) min2 = mid + 1;
    else return mid;
  }
  return -1;
}
function $12727730ddfc8bfe$export$d02631cccf789723(index2, end2) {
  let range2 = [];
  while (index2 < end2) range2.push(index2++);
  return range2;
}
const $12727730ddfc8bfe$export$3d28c1996ced1f14 = new TextDecoder("ascii");
const $12727730ddfc8bfe$var$CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const $12727730ddfc8bfe$var$LOOKUP = new Uint8Array(256);
for (let i2 = 0; i2 < $12727730ddfc8bfe$var$CHARS.length; i2++) $12727730ddfc8bfe$var$LOOKUP[$12727730ddfc8bfe$var$CHARS.charCodeAt(i2)] = i2;
function $12727730ddfc8bfe$export$94fdf11bafc8de6b(base64) {
  let bufferLength = base64.length * 0.75;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") bufferLength--;
  }
  let bytes = new Uint8Array(bufferLength);
  let p2 = 0;
  for (let i2 = 0, len = base64.length; i2 < len; i2 += 4) {
    let encoded1 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i2)];
    let encoded2 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i2 + 1)];
    let encoded3 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i2 + 2)];
    let encoded4 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i2 + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return bytes;
}
class $f08dd41ef10b694c$export$2e2bcd8739ae039 {
  findSubtable(cmapTable, pairs2) {
    for (let [platformID, encodingID] of pairs2) for (let cmap of cmapTable.tables) {
      if (cmap.platformID === platformID && cmap.encodingID === encodingID) return cmap.table;
    }
    return null;
  }
  lookup(codepoint, variationSelector) {
    if (this.encoding) codepoint = this.encoding.get(codepoint) || codepoint;
    else if (variationSelector) {
      let gid = this.getVariationSelector(codepoint, variationSelector);
      if (gid) return gid;
    }
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0:
        return cmap.codeMap.get(codepoint) || 0;
      case 4: {
        let min2 = 0;
        let max2 = cmap.segCount - 1;
        while (min2 <= max2) {
          let mid = min2 + max2 >> 1;
          if (codepoint < cmap.startCode.get(mid)) max2 = mid - 1;
          else if (codepoint > cmap.endCode.get(mid)) min2 = mid + 1;
          else {
            let rangeOffset = cmap.idRangeOffset.get(mid);
            let gid;
            if (rangeOffset === 0) gid = codepoint + cmap.idDelta.get(mid);
            else {
              let index2 = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);
              gid = cmap.glyphIndexArray.get(index2) || 0;
              if (gid !== 0) gid += cmap.idDelta.get(mid);
            }
            return gid & 65535;
          }
        }
        return 0;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;
      case 12:
      case 13: {
        let min2 = 0;
        let max2 = cmap.nGroups - 1;
        while (min2 <= max2) {
          let mid = min2 + max2 >> 1;
          let group = cmap.groups.get(mid);
          if (codepoint < group.startCharCode) max2 = mid - 1;
          else if (codepoint > group.endCharCode) min2 = mid + 1;
          else {
            if (cmap.version === 12) return group.glyphID + (codepoint - group.startCharCode);
            else return group.glyphID;
          }
        }
        return 0;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  getVariationSelector(codepoint, variationSelector) {
    if (!this.uvs) return 0;
    let selectors = this.uvs.varSelectors.toArray();
    let i2 = $12727730ddfc8bfe$export$2e0ae67339d5f1ac(selectors, (x) => variationSelector - x.varSelector);
    let sel = selectors[i2];
    if (i2 !== -1 && sel.defaultUVS) i2 = $12727730ddfc8bfe$export$2e0ae67339d5f1ac(sel.defaultUVS, (x) => codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? 1 : 0);
    if (i2 !== -1 && sel.nonDefaultUVS) {
      i2 = $12727730ddfc8bfe$export$2e0ae67339d5f1ac(sel.nonDefaultUVS, (x) => codepoint - x.unicodeValue);
      if (i2 !== -1) return sel.nonDefaultUVS[i2].glyphID;
    }
    return 0;
  }
  getCharacterSet() {
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0:
        return $12727730ddfc8bfe$export$d02631cccf789723(0, cmap.codeMap.length);
      case 4: {
        let res = [];
        let endCodes = cmap.endCode.toArray();
        for (let i2 = 0; i2 < endCodes.length; i2++) {
          let tail = endCodes[i2] + 1;
          let start2 = cmap.startCode.get(i2);
          res.push(...$12727730ddfc8bfe$export$d02631cccf789723(start2, tail));
        }
        return res;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return $12727730ddfc8bfe$export$d02631cccf789723(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);
      case 12:
      case 13: {
        let res = [];
        for (let group of cmap.groups.toArray()) res.push(...$12727730ddfc8bfe$export$d02631cccf789723(group.startCharCode, group.endCharCode + 1));
        return res;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  codePointsForGlyph(gid) {
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0: {
        let res = [];
        for (let i2 = 0; i2 < 256; i2++) if (cmap.codeMap.get(i2) === gid) res.push(i2);
        return res;
      }
      case 4: {
        let res = [];
        for (let i2 = 0; i2 < cmap.segCount; i2++) {
          let end2 = cmap.endCode.get(i2);
          let start2 = cmap.startCode.get(i2);
          let rangeOffset = cmap.idRangeOffset.get(i2);
          let delta = cmap.idDelta.get(i2);
          for (var c2 = start2; c2 <= end2; c2++) {
            let g = 0;
            if (rangeOffset === 0) g = c2 + delta;
            else {
              let index2 = rangeOffset / 2 + (c2 - start2) - (cmap.segCount - i2);
              g = cmap.glyphIndexArray.get(index2) || 0;
              if (g !== 0) g += delta;
            }
            if (g === gid) res.push(c2);
          }
        }
        return res;
      }
      case 12: {
        let res = [];
        for (let group of cmap.groups.toArray()) if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) res.push(group.startCharCode + (gid - group.glyphID));
        return res;
      }
      case 13: {
        let res = [];
        for (let group of cmap.groups.toArray()) if (gid === group.glyphID) res.push(...$12727730ddfc8bfe$export$d02631cccf789723(group.startCharCode, group.endCharCode + 1));
        return res;
      }
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  constructor(cmapTable) {
    this.encoding = null;
    this.cmap = this.findSubtable(cmapTable, [
      // 32-bit subtables
      [
        3,
        10
      ],
      [
        0,
        6
      ],
      [
        0,
        4
      ],
      // 16-bit subtables
      [
        3,
        1
      ],
      [
        0,
        3
      ],
      [
        0,
        2
      ],
      [
        0,
        1
      ],
      [
        0,
        0
      ]
    ]);
    if (!this.cmap) for (let cmap of cmapTable.tables) {
      let encoding = $e449ad78d50845fe$export$badc544e0651b6b1(cmap.platformID, cmap.encodingID, cmap.table.language - 1);
      let mapping = $e449ad78d50845fe$export$1dceb3c14ed68bee(encoding);
      if (mapping) {
        this.cmap = cmap.table;
        this.encoding = mapping;
      }
    }
    if (!this.cmap) throw new Error("Could not find a supported cmap table");
    this.uvs = this.findSubtable(cmapTable, [
      [
        0,
        5
      ]
    ]);
    if (this.uvs && this.uvs.version !== 14) this.uvs = null;
  }
}
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "getCharacterSet", null);
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "codePointsForGlyph", null);
class $0bba3a9db57637f3$export$2e2bcd8739ae039 {
  process(glyphs, positions) {
    for (let glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {
      let left = glyphs[glyphIndex].id;
      let right = glyphs[glyphIndex + 1].id;
      positions[glyphIndex].xAdvance += this.getKerning(left, right);
    }
  }
  getKerning(left, right) {
    let res = 0;
    for (let table of this.kern.tables) {
      if (table.coverage.crossStream) continue;
      switch (table.version) {
        case 0:
          if (!table.coverage.horizontal) continue;
          break;
        case 1:
          if (table.coverage.vertical || table.coverage.variation) continue;
          break;
        default:
          throw new Error(`Unsupported kerning table version ${table.version}`);
      }
      let val = 0;
      let s2 = table.subtable;
      switch (table.format) {
        case 0:
          let pairIdx = $12727730ddfc8bfe$export$2e0ae67339d5f1ac(s2.pairs, function(pair) {
            return left - pair.left || right - pair.right;
          });
          if (pairIdx >= 0) val = s2.pairs[pairIdx].value;
          break;
        case 2:
          let leftOffset = 0, rightOffset = 0;
          if (left >= s2.leftTable.firstGlyph && left < s2.leftTable.firstGlyph + s2.leftTable.nGlyphs) leftOffset = s2.leftTable.offsets[left - s2.leftTable.firstGlyph];
          else leftOffset = s2.array.off;
          if (right >= s2.rightTable.firstGlyph && right < s2.rightTable.firstGlyph + s2.rightTable.nGlyphs) rightOffset = s2.rightTable.offsets[right - s2.rightTable.firstGlyph];
          let index2 = (leftOffset + rightOffset - s2.array.off) / 2;
          val = s2.array.values.get(index2);
          break;
        case 3:
          if (left >= s2.glyphCount || right >= s2.glyphCount) return 0;
          val = s2.kernValue[s2.kernIndex[s2.leftClass[left] * s2.rightClassCount + s2.rightClass[right]]];
          break;
        default:
          throw new Error(`Unsupported kerning sub-table format ${table.format}`);
      }
      if (table.coverage.override) res = val;
      else res += val;
    }
    return res;
  }
  constructor(font) {
    this.kern = font.kern;
  }
}
class $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039 {
  positionGlyphs(glyphs, positions) {
    let clusterStart = 0;
    let clusterEnd = 0;
    for (let index2 = 0; index2 < glyphs.length; index2++) {
      let glyph = glyphs[index2];
      if (glyph.isMark) clusterEnd = index2;
      else {
        if (clusterStart !== clusterEnd) this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
        clusterStart = clusterEnd = index2;
      }
    }
    if (clusterStart !== clusterEnd) this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
    return positions;
  }
  positionCluster(glyphs, positions, clusterStart, clusterEnd) {
    let base = glyphs[clusterStart];
    let baseBox = base.cbox.copy();
    if (base.codePoints.length > 1)
      baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;
    let xOffset = -positions[clusterStart].xAdvance;
    let yOffset = 0;
    let yGap = this.font.unitsPerEm / 16;
    for (let index2 = clusterStart + 1; index2 <= clusterEnd; index2++) {
      let mark = glyphs[index2];
      let markBox = mark.cbox;
      let position = positions[index2];
      let combiningClass = this.getCombiningClass(mark.codePoints[0]);
      if (combiningClass !== "Not_Reordered") {
        position.xOffset = position.yOffset = 0;
        switch (combiningClass) {
          case "Double_Above":
          case "Double_Below":
            position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
            break;
          case "Attached_Below_Left":
          case "Below_Left":
          case "Above_Left":
            position.xOffset += baseBox.minX - markBox.minX;
            break;
          case "Attached_Above_Right":
          case "Below_Right":
          case "Above_Right":
            position.xOffset += baseBox.maxX - markBox.width - markBox.minX;
            break;
          default:
            position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;
        }
        switch (combiningClass) {
          case "Double_Below":
          case "Below_Left":
          case "Below":
          case "Below_Right":
          case "Attached_Below_Left":
          case "Attached_Below":
            if (combiningClass === "Attached_Below_Left" || combiningClass === "Attached_Below") baseBox.minY += yGap;
            position.yOffset = -baseBox.minY - markBox.maxY;
            baseBox.minY += markBox.height;
            break;
          case "Double_Above":
          case "Above_Left":
          case "Above":
          case "Above_Right":
          case "Attached_Above":
          case "Attached_Above_Right":
            if (combiningClass === "Attached_Above" || combiningClass === "Attached_Above_Right") baseBox.maxY += yGap;
            position.yOffset = baseBox.maxY - markBox.minY;
            baseBox.maxY += markBox.height;
            break;
        }
        position.xAdvance = position.yAdvance = 0;
        position.xOffset += xOffset;
        position.yOffset += yOffset;
      } else {
        xOffset -= position.xAdvance;
        yOffset -= position.yAdvance;
      }
    }
    return;
  }
  getCombiningClass(codePoint) {
    let combiningClass = $747425b437e121da$export$c03b919c6651ed55(codePoint);
    if ((codePoint & -256) === 3584) {
      if (combiningClass === "Not_Reordered") switch (codePoint) {
        case 3633:
        case 3636:
        case 3637:
        case 3638:
        case 3639:
        case 3655:
        case 3660:
        case 3645:
        case 3662:
          return "Above_Right";
        case 3761:
        case 3764:
        case 3765:
        case 3766:
        case 3767:
        case 3771:
        case 3788:
        case 3789:
          return "Above";
        case 3772:
          return "Below";
      }
      else if (codePoint === 3642) return "Below_Right";
    }
    switch (combiningClass) {
      // Hebrew
      case "CCC10":
      case "CCC11":
      case "CCC12":
      case "CCC13":
      case "CCC14":
      case "CCC15":
      case "CCC16":
      case "CCC17":
      case "CCC18":
      case "CCC20":
      case "CCC22":
        return "Below";
      case "CCC23":
        return "Attached_Above";
      case "CCC24":
        return "Above_Right";
      case "CCC25":
      case "CCC19":
        return "Above_Left";
      case "CCC26":
        return "Above";
      case "CCC21":
        break;
      // Arabic and Syriac
      case "CCC27":
      case "CCC28":
      case "CCC30":
      case "CCC31":
      case "CCC33":
      case "CCC34":
      case "CCC35":
      case "CCC36":
        return "Above";
      case "CCC29":
      case "CCC32":
        return "Below";
      // Thai
      case "CCC103":
        return "Below_Right";
      case "CCC107":
        return "Above_Right";
      // Lao
      case "CCC118":
        return "Below";
      case "CCC122":
        return "Above";
      // Tibetan
      case "CCC129":
      case "CCC132":
        return "Below";
      case "CCC130":
        return "Above";
    }
    return combiningClass;
  }
  constructor(font) {
    this.font = font;
  }
}
class $f34600ab9d7f70d8$export$2e2bcd8739ae039 {
  /**
  * The width of the bounding box
  * @type {number}
  */
  get width() {
    return this.maxX - this.minX;
  }
  /**
  * The height of the bounding box
  * @type {number}
  */
  get height() {
    return this.maxY - this.minY;
  }
  addPoint(x, y2) {
    if (Math.abs(x) !== Infinity) {
      if (x < this.minX) this.minX = x;
      if (x > this.maxX) this.maxX = x;
    }
    if (Math.abs(y2) !== Infinity) {
      if (y2 < this.minY) this.minY = y2;
      if (y2 > this.maxY) this.maxY = y2;
    }
  }
  copy() {
    return new $f34600ab9d7f70d8$export$2e2bcd8739ae039(this.minX, this.minY, this.maxX, this.maxY);
  }
  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
}
const $130d1a642ebcd2b7$var$UNICODE_SCRIPTS = {
  Caucasian_Albanian: "aghb",
  Arabic: "arab",
  Imperial_Aramaic: "armi",
  Armenian: "armn",
  Avestan: "avst",
  Balinese: "bali",
  Bamum: "bamu",
  Bassa_Vah: "bass",
  Batak: "batk",
  Bengali: [
    "bng2",
    "beng"
  ],
  Bopomofo: "bopo",
  Brahmi: "brah",
  Braille: "brai",
  Buginese: "bugi",
  Buhid: "buhd",
  Chakma: "cakm",
  Canadian_Aboriginal: "cans",
  Carian: "cari",
  Cham: "cham",
  Cherokee: "cher",
  Coptic: "copt",
  Cypriot: "cprt",
  Cyrillic: "cyrl",
  Devanagari: [
    "dev2",
    "deva"
  ],
  Deseret: "dsrt",
  Duployan: "dupl",
  Egyptian_Hieroglyphs: "egyp",
  Elbasan: "elba",
  Ethiopic: "ethi",
  Georgian: "geor",
  Glagolitic: "glag",
  Gothic: "goth",
  Grantha: "gran",
  Greek: "grek",
  Gujarati: [
    "gjr2",
    "gujr"
  ],
  Gurmukhi: [
    "gur2",
    "guru"
  ],
  Hangul: "hang",
  Han: "hani",
  Hanunoo: "hano",
  Hebrew: "hebr",
  Hiragana: "hira",
  Pahawh_Hmong: "hmng",
  Katakana_Or_Hiragana: "hrkt",
  Old_Italic: "ital",
  Javanese: "java",
  Kayah_Li: "kali",
  Katakana: "kana",
  Kharoshthi: "khar",
  Khmer: "khmr",
  Khojki: "khoj",
  Kannada: [
    "knd2",
    "knda"
  ],
  Kaithi: "kthi",
  Tai_Tham: "lana",
  Lao: "lao ",
  Latin: "latn",
  Lepcha: "lepc",
  Limbu: "limb",
  Linear_A: "lina",
  Linear_B: "linb",
  Lisu: "lisu",
  Lycian: "lyci",
  Lydian: "lydi",
  Mahajani: "mahj",
  Mandaic: "mand",
  Manichaean: "mani",
  Mende_Kikakui: "mend",
  Meroitic_Cursive: "merc",
  Meroitic_Hieroglyphs: "mero",
  Malayalam: [
    "mlm2",
    "mlym"
  ],
  Modi: "modi",
  Mongolian: "mong",
  Mro: "mroo",
  Meetei_Mayek: "mtei",
  Myanmar: [
    "mym2",
    "mymr"
  ],
  Old_North_Arabian: "narb",
  Nabataean: "nbat",
  Nko: "nko ",
  Ogham: "ogam",
  Ol_Chiki: "olck",
  Old_Turkic: "orkh",
  Oriya: [
    "ory2",
    "orya"
  ],
  Osmanya: "osma",
  Palmyrene: "palm",
  Pau_Cin_Hau: "pauc",
  Old_Permic: "perm",
  Phags_Pa: "phag",
  Inscriptional_Pahlavi: "phli",
  Psalter_Pahlavi: "phlp",
  Phoenician: "phnx",
  Miao: "plrd",
  Inscriptional_Parthian: "prti",
  Rejang: "rjng",
  Runic: "runr",
  Samaritan: "samr",
  Old_South_Arabian: "sarb",
  Saurashtra: "saur",
  Shavian: "shaw",
  Sharada: "shrd",
  Siddham: "sidd",
  Khudawadi: "sind",
  Sinhala: "sinh",
  Sora_Sompeng: "sora",
  Sundanese: "sund",
  Syloti_Nagri: "sylo",
  Syriac: "syrc",
  Tagbanwa: "tagb",
  Takri: "takr",
  Tai_Le: "tale",
  New_Tai_Lue: "talu",
  Tamil: [
    "tml2",
    "taml"
  ],
  Tai_Viet: "tavt",
  Telugu: [
    "tel2",
    "telu"
  ],
  Tifinagh: "tfng",
  Tagalog: "tglg",
  Thaana: "thaa",
  Thai: "thai",
  Tibetan: "tibt",
  Tirhuta: "tirh",
  Ugaritic: "ugar",
  Vai: "vai ",
  Warang_Citi: "wara",
  Old_Persian: "xpeo",
  Cuneiform: "xsux",
  Yi: "yi  ",
  Inherited: "zinh",
  Common: "zyyy",
  Unknown: "zzzz"
};
const $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS = {};
for (let script in $130d1a642ebcd2b7$var$UNICODE_SCRIPTS) {
  let tag = $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
  if (Array.isArray(tag)) for (let t2 of tag) $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[t2] = script;
  else $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag] = script;
}
function $130d1a642ebcd2b7$export$ce50e82f12a827a4(tag) {
  return $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag];
}
function $130d1a642ebcd2b7$export$e5cb25e204fb8450(string) {
  let len = string.length;
  let idx = 0;
  while (idx < len) {
    let code = string.charCodeAt(idx++);
    if (55296 <= code && code <= 56319 && idx < len) {
      let next = string.charCodeAt(idx);
      if (56320 <= next && next <= 57343) {
        idx++;
        code = ((code & 1023) << 10) + (next & 1023) + 65536;
      }
    }
    let script = $747425b437e121da$export$941569448d136665(code);
    if (script !== "Common" && script !== "Inherited" && script !== "Unknown") return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
  }
  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
}
function $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints) {
  for (let i2 = 0; i2 < codePoints.length; i2++) {
    let codePoint = codePoints[i2];
    let script = $747425b437e121da$export$941569448d136665(codePoint);
    if (script !== "Common" && script !== "Inherited" && script !== "Unknown") return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
  }
  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
}
const $130d1a642ebcd2b7$var$RTL = {
  arab: true,
  hebr: true,
  syrc: true,
  thaa: true,
  cprt: true,
  khar: true,
  phnx: true,
  "nko ": true,
  lydi: true,
  avst: true,
  armi: true,
  phli: true,
  prti: true,
  sarb: true,
  orkh: true,
  samr: true,
  mand: true,
  merc: true,
  mero: true,
  // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)
  mani: true,
  mend: true,
  nbat: true,
  narb: true,
  palm: true,
  phlp: true
  // Psalter Pahlavi
};
function $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script) {
  if ($130d1a642ebcd2b7$var$RTL[script]) return "rtl";
  return "ltr";
}
class $be07b3e97a42687a$export$2e2bcd8739ae039 {
  /**
  * The total advance width of the run.
  * @type {number}
  */
  get advanceWidth() {
    let width = 0;
    for (let position of this.positions) width += position.xAdvance;
    return width;
  }
  /**
  * The total advance height of the run.
  * @type {number}
  */
  get advanceHeight() {
    let height2 = 0;
    for (let position of this.positions) height2 += position.yAdvance;
    return height2;
  }
  /**
  * The bounding box containing all glyphs in the run.
  * @type {BBox}
  */
  get bbox() {
    let bbox = new $f34600ab9d7f70d8$export$2e2bcd8739ae039();
    let x = 0;
    let y2 = 0;
    for (let index2 = 0; index2 < this.glyphs.length; index2++) {
      let glyph = this.glyphs[index2];
      let p2 = this.positions[index2];
      let b2 = glyph.bbox;
      bbox.addPoint(b2.minX + x + p2.xOffset, b2.minY + y2 + p2.yOffset);
      bbox.addPoint(b2.maxX + x + p2.xOffset, b2.maxY + y2 + p2.yOffset);
      x += p2.xAdvance;
      y2 += p2.yAdvance;
    }
    return bbox;
  }
  constructor(glyphs, features, script, language, direction) {
    this.glyphs = glyphs;
    this.positions = null;
    this.script = script;
    this.language = language || null;
    this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
    this.features = {};
    if (Array.isArray(features)) for (let tag of features) this.features[tag] = true;
    else if (typeof features === "object") this.features = features;
  }
}
class $1ac75d9a55b67f01$export$2e2bcd8739ae039 {
  constructor(xAdvance = 0, yAdvance = 0, xOffset = 0, yOffset = 0) {
    this.xAdvance = xAdvance;
    this.yAdvance = yAdvance;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
  }
}
const $3b6302b64eccc32c$var$features = {
  allTypographicFeatures: {
    code: 0,
    exclusive: false,
    allTypeFeatures: 0
  },
  ligatures: {
    code: 1,
    exclusive: false,
    requiredLigatures: 0,
    commonLigatures: 2,
    rareLigatures: 4,
    // logos: 6
    rebusPictures: 8,
    diphthongLigatures: 10,
    squaredLigatures: 12,
    abbrevSquaredLigatures: 14,
    symbolLigatures: 16,
    contextualLigatures: 18,
    historicalLigatures: 20
  },
  cursiveConnection: {
    code: 2,
    exclusive: true,
    unconnected: 0,
    partiallyConnected: 1,
    cursive: 2
  },
  letterCase: {
    code: 3,
    exclusive: true
  },
  // upperAndLowerCase: 0          # deprecated
  // allCaps: 1                    # deprecated
  // allLowerCase: 2               # deprecated
  // smallCaps: 3                  # deprecated
  // initialCaps: 4                # deprecated
  // initialCapsAndSmallCaps: 5    # deprecated
  verticalSubstitution: {
    code: 4,
    exclusive: false,
    substituteVerticalForms: 0
  },
  linguisticRearrangement: {
    code: 5,
    exclusive: false,
    linguisticRearrangement: 0
  },
  numberSpacing: {
    code: 6,
    exclusive: true,
    monospacedNumbers: 0,
    proportionalNumbers: 1,
    thirdWidthNumbers: 2,
    quarterWidthNumbers: 3
  },
  smartSwash: {
    code: 8,
    exclusive: false,
    wordInitialSwashes: 0,
    wordFinalSwashes: 2,
    // lineInitialSwashes: 4
    // lineFinalSwashes: 6
    nonFinalSwashes: 8
  },
  diacritics: {
    code: 9,
    exclusive: true,
    showDiacritics: 0,
    hideDiacritics: 1,
    decomposeDiacritics: 2
  },
  verticalPosition: {
    code: 10,
    exclusive: true,
    normalPosition: 0,
    superiors: 1,
    inferiors: 2,
    ordinals: 3,
    scientificInferiors: 4
  },
  fractions: {
    code: 11,
    exclusive: true,
    noFractions: 0,
    verticalFractions: 1,
    diagonalFractions: 2
  },
  overlappingCharacters: {
    code: 13,
    exclusive: false,
    preventOverlap: 0
  },
  typographicExtras: {
    code: 14,
    exclusive: false,
    // hyphensToEmDash: 0
    // hyphenToEnDash: 2
    slashedZero: 4
  },
  // formInterrobang: 6
  // smartQuotes: 8
  // periodsToEllipsis: 10
  mathematicalExtras: {
    code: 15,
    exclusive: false,
    // hyphenToMinus: 0
    // asteristoMultiply: 2
    // slashToDivide: 4
    // inequalityLigatures: 6
    // exponents: 8
    mathematicalGreek: 10
  },
  ornamentSets: {
    code: 16,
    exclusive: true,
    noOrnaments: 0,
    dingbats: 1,
    piCharacters: 2,
    fleurons: 3,
    decorativeBorders: 4,
    internationalSymbols: 5,
    mathSymbols: 6
  },
  characterAlternatives: {
    code: 17,
    exclusive: true,
    noAlternates: 0
  },
  // user defined options
  designComplexity: {
    code: 18,
    exclusive: true,
    designLevel1: 0,
    designLevel2: 1,
    designLevel3: 2,
    designLevel4: 3,
    designLevel5: 4
  },
  styleOptions: {
    code: 19,
    exclusive: true,
    noStyleOptions: 0,
    displayText: 1,
    engravedText: 2,
    illuminatedCaps: 3,
    titlingCaps: 4,
    tallCaps: 5
  },
  characterShape: {
    code: 20,
    exclusive: true,
    traditionalCharacters: 0,
    simplifiedCharacters: 1,
    JIS1978Characters: 2,
    JIS1983Characters: 3,
    JIS1990Characters: 4,
    traditionalAltOne: 5,
    traditionalAltTwo: 6,
    traditionalAltThree: 7,
    traditionalAltFour: 8,
    traditionalAltFive: 9,
    expertCharacters: 10,
    JIS2004Characters: 11,
    hojoCharacters: 12,
    NLCCharacters: 13,
    traditionalNamesCharacters: 14
  },
  numberCase: {
    code: 21,
    exclusive: true,
    lowerCaseNumbers: 0,
    upperCaseNumbers: 1
  },
  textSpacing: {
    code: 22,
    exclusive: true,
    proportionalText: 0,
    monospacedText: 1,
    halfWidthText: 2,
    thirdWidthText: 3,
    quarterWidthText: 4,
    altProportionalText: 5,
    altHalfWidthText: 6
  },
  transliteration: {
    code: 23,
    exclusive: true,
    noTransliteration: 0
  },
  // hanjaToHangul: 1
  // hiraganaToKatakana: 2
  // katakanaToHiragana: 3
  // kanaToRomanization: 4
  // romanizationToHiragana: 5
  // romanizationToKatakana: 6
  // hanjaToHangulAltOne: 7
  // hanjaToHangulAltTwo: 8
  // hanjaToHangulAltThree: 9
  annotation: {
    code: 24,
    exclusive: true,
    noAnnotation: 0,
    boxAnnotation: 1,
    roundedBoxAnnotation: 2,
    circleAnnotation: 3,
    invertedCircleAnnotation: 4,
    parenthesisAnnotation: 5,
    periodAnnotation: 6,
    romanNumeralAnnotation: 7,
    diamondAnnotation: 8,
    invertedBoxAnnotation: 9,
    invertedRoundedBoxAnnotation: 10
  },
  kanaSpacing: {
    code: 25,
    exclusive: true,
    fullWidthKana: 0,
    proportionalKana: 1
  },
  ideographicSpacing: {
    code: 26,
    exclusive: true,
    fullWidthIdeographs: 0,
    proportionalIdeographs: 1,
    halfWidthIdeographs: 2
  },
  unicodeDecomposition: {
    code: 27,
    exclusive: false,
    canonicalComposition: 0,
    compatibilityComposition: 2,
    transcodingComposition: 4
  },
  rubyKana: {
    code: 28,
    exclusive: false,
    // noRubyKana: 0     # deprecated - use rubyKanaOff instead
    // rubyKana: 1     # deprecated - use rubyKanaOn instead
    rubyKana: 2
  },
  CJKSymbolAlternatives: {
    code: 29,
    exclusive: true,
    noCJKSymbolAlternatives: 0,
    CJKSymbolAltOne: 1,
    CJKSymbolAltTwo: 2,
    CJKSymbolAltThree: 3,
    CJKSymbolAltFour: 4,
    CJKSymbolAltFive: 5
  },
  ideographicAlternatives: {
    code: 30,
    exclusive: true,
    noIdeographicAlternatives: 0,
    ideographicAltOne: 1,
    ideographicAltTwo: 2,
    ideographicAltThree: 3,
    ideographicAltFour: 4,
    ideographicAltFive: 5
  },
  CJKVerticalRomanPlacement: {
    code: 31,
    exclusive: true,
    CJKVerticalRomanCentered: 0,
    CJKVerticalRomanHBaseline: 1
  },
  italicCJKRoman: {
    code: 32,
    exclusive: false,
    // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead
    // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead
    CJKItalicRoman: 2
  },
  caseSensitiveLayout: {
    code: 33,
    exclusive: false,
    caseSensitiveLayout: 0,
    caseSensitiveSpacing: 2
  },
  alternateKana: {
    code: 34,
    exclusive: false,
    alternateHorizKana: 0,
    alternateVertKana: 2
  },
  stylisticAlternatives: {
    code: 35,
    exclusive: false,
    noStylisticAlternates: 0,
    stylisticAltOne: 2,
    stylisticAltTwo: 4,
    stylisticAltThree: 6,
    stylisticAltFour: 8,
    stylisticAltFive: 10,
    stylisticAltSix: 12,
    stylisticAltSeven: 14,
    stylisticAltEight: 16,
    stylisticAltNine: 18,
    stylisticAltTen: 20,
    stylisticAltEleven: 22,
    stylisticAltTwelve: 24,
    stylisticAltThirteen: 26,
    stylisticAltFourteen: 28,
    stylisticAltFifteen: 30,
    stylisticAltSixteen: 32,
    stylisticAltSeventeen: 34,
    stylisticAltEighteen: 36,
    stylisticAltNineteen: 38,
    stylisticAltTwenty: 40
  },
  contextualAlternates: {
    code: 36,
    exclusive: false,
    contextualAlternates: 0,
    swashAlternates: 2,
    contextualSwashAlternates: 4
  },
  lowerCase: {
    code: 37,
    exclusive: true,
    defaultLowerCase: 0,
    lowerCaseSmallCaps: 1,
    lowerCasePetiteCaps: 2
  },
  upperCase: {
    code: 38,
    exclusive: true,
    defaultUpperCase: 0,
    upperCaseSmallCaps: 1,
    upperCasePetiteCaps: 2
  },
  languageTag: {
    code: 39,
    exclusive: true
  },
  CJKRomanSpacing: {
    code: 103,
    exclusive: true,
    halfWidthCJKRoman: 0,
    proportionalCJKRoman: 1,
    defaultCJKRoman: 2,
    fullWidthCJKRoman: 3
  }
};
const $3b6302b64eccc32c$var$feature = (name, selector) => [
  $3b6302b64eccc32c$var$features[name].code,
  $3b6302b64eccc32c$var$features[name][selector]
];
const $3b6302b64eccc32c$var$OTMapping = {
  rlig: $3b6302b64eccc32c$var$feature("ligatures", "requiredLigatures"),
  clig: $3b6302b64eccc32c$var$feature("ligatures", "contextualLigatures"),
  dlig: $3b6302b64eccc32c$var$feature("ligatures", "rareLigatures"),
  hlig: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
  liga: $3b6302b64eccc32c$var$feature("ligatures", "commonLigatures"),
  hist: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
  smcp: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCaseSmallCaps"),
  pcap: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCasePetiteCaps"),
  frac: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  dnom: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  numr: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  afrc: $3b6302b64eccc32c$var$feature("fractions", "verticalFractions"),
  // aalt
  // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?
  // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?
  // unic, vatu, vhal, vjmo, vpal, vrt2
  // dist -> trak table?
  // kern, vkrn -> kern table
  // lfbd + opbd + rtbd -> opbd table?
  // mark, mkmk -> acnt table?
  // locl -> languageTag + ltag table
  case: $3b6302b64eccc32c$var$feature("caseSensitiveLayout", "caseSensitiveLayout"),
  ccmp: $3b6302b64eccc32c$var$feature("unicodeDecomposition", "canonicalComposition"),
  cpct: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  valt: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  swsh: $3b6302b64eccc32c$var$feature("contextualAlternates", "swashAlternates"),
  cswh: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualSwashAlternates"),
  curs: $3b6302b64eccc32c$var$feature("cursiveConnection", "cursive"),
  c2pc: $3b6302b64eccc32c$var$feature("upperCase", "upperCasePetiteCaps"),
  c2sc: $3b6302b64eccc32c$var$feature("upperCase", "upperCaseSmallCaps"),
  init: $3b6302b64eccc32c$var$feature("smartSwash", "wordInitialSwashes"),
  fin2: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  medi: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
  med2: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
  fin3: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  fina: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  pkna: $3b6302b64eccc32c$var$feature("kanaSpacing", "proportionalKana"),
  half: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
  halt: $3b6302b64eccc32c$var$feature("textSpacing", "altHalfWidthText"),
  hkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateHorizKana"),
  vkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateVertKana"),
  // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated
  ital: $3b6302b64eccc32c$var$feature("italicCJKRoman", "CJKItalicRoman"),
  lnum: $3b6302b64eccc32c$var$feature("numberCase", "upperCaseNumbers"),
  onum: $3b6302b64eccc32c$var$feature("numberCase", "lowerCaseNumbers"),
  mgrk: $3b6302b64eccc32c$var$feature("mathematicalExtras", "mathematicalGreek"),
  // nalt: not enough info. what type of annotation?
  // ornm: ditto, which ornament style?
  calt: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualAlternates"),
  vrt2: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
  vert: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
  tnum: $3b6302b64eccc32c$var$feature("numberSpacing", "monospacedNumbers"),
  pnum: $3b6302b64eccc32c$var$feature("numberSpacing", "proportionalNumbers"),
  sups: $3b6302b64eccc32c$var$feature("verticalPosition", "superiors"),
  subs: $3b6302b64eccc32c$var$feature("verticalPosition", "inferiors"),
  ordn: $3b6302b64eccc32c$var$feature("verticalPosition", "ordinals"),
  pwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
  hwid: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
  qwid: $3b6302b64eccc32c$var$feature("textSpacing", "quarterWidthText"),
  twid: $3b6302b64eccc32c$var$feature("textSpacing", "thirdWidthText"),
  fwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
  palt: $3b6302b64eccc32c$var$feature("textSpacing", "altProportionalText"),
  trad: $3b6302b64eccc32c$var$feature("characterShape", "traditionalCharacters"),
  smpl: $3b6302b64eccc32c$var$feature("characterShape", "simplifiedCharacters"),
  jp78: $3b6302b64eccc32c$var$feature("characterShape", "JIS1978Characters"),
  jp83: $3b6302b64eccc32c$var$feature("characterShape", "JIS1983Characters"),
  jp90: $3b6302b64eccc32c$var$feature("characterShape", "JIS1990Characters"),
  jp04: $3b6302b64eccc32c$var$feature("characterShape", "JIS2004Characters"),
  expt: $3b6302b64eccc32c$var$feature("characterShape", "expertCharacters"),
  hojo: $3b6302b64eccc32c$var$feature("characterShape", "hojoCharacters"),
  nlck: $3b6302b64eccc32c$var$feature("characterShape", "NLCCharacters"),
  tnam: $3b6302b64eccc32c$var$feature("characterShape", "traditionalNamesCharacters"),
  ruby: $3b6302b64eccc32c$var$feature("rubyKana", "rubyKana"),
  titl: $3b6302b64eccc32c$var$feature("styleOptions", "titlingCaps"),
  zero: $3b6302b64eccc32c$var$feature("typographicExtras", "slashedZero"),
  ss01: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltOne"),
  ss02: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwo"),
  ss03: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThree"),
  ss04: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFour"),
  ss05: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFive"),
  ss06: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSix"),
  ss07: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeven"),
  ss08: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEight"),
  ss09: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNine"),
  ss10: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTen"),
  ss11: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEleven"),
  ss12: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwelve"),
  ss13: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThirteen"),
  ss14: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFourteen"),
  ss15: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFifteen"),
  ss16: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSixteen"),
  ss17: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeventeen"),
  ss18: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEighteen"),
  ss19: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNineteen"),
  ss20: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwenty")
};
for (let i2 = 1; i2 <= 99; i2++) $3b6302b64eccc32c$var$OTMapping[`cv${`00${i2}`.slice(-2)}`] = [
  $3b6302b64eccc32c$var$features.characterAlternatives.code,
  i2
];
let $3b6302b64eccc32c$var$AATMapping = {};
for (let ot in $3b6302b64eccc32c$var$OTMapping) {
  let aat = $3b6302b64eccc32c$var$OTMapping[ot];
  if ($3b6302b64eccc32c$var$AATMapping[aat[0]] == null) $3b6302b64eccc32c$var$AATMapping[aat[0]] = {};
  $3b6302b64eccc32c$var$AATMapping[aat[0]][aat[1]] = ot;
}
function $3b6302b64eccc32c$export$b813f7d2a1677c16(features) {
  let res = {};
  for (let k2 in features) {
    let r2;
    if (r2 = $3b6302b64eccc32c$var$OTMapping[k2]) {
      if (res[r2[0]] == null) res[r2[0]] = {};
      res[r2[0]][r2[1]] = features[k2];
    }
  }
  return res;
}
function $3b6302b64eccc32c$var$mapFeatureStrings(f2) {
  let [type, setting] = f2;
  if (isNaN(type)) var typeCode = $3b6302b64eccc32c$var$features[type] && $3b6302b64eccc32c$var$features[type].code;
  else var typeCode = type;
  if (isNaN(setting)) var settingCode = $3b6302b64eccc32c$var$features[type] && $3b6302b64eccc32c$var$features[type][setting];
  else var settingCode = setting;
  return [
    typeCode,
    settingCode
  ];
}
function $3b6302b64eccc32c$export$bd6df347a4f391c4(features) {
  let res = {};
  if (Array.isArray(features)) for (let k2 = 0; k2 < features.length; k2++) {
    let r2;
    let f2 = $3b6302b64eccc32c$var$mapFeatureStrings(features[k2]);
    if (r2 = $3b6302b64eccc32c$var$AATMapping[f2[0]] && $3b6302b64eccc32c$var$AATMapping[f2[0]][f2[1]]) res[r2] = true;
  }
  else if (typeof features === "object") for (let type in features) {
    let feature = features[type];
    for (let setting in feature) {
      let r2;
      let f2 = $3b6302b64eccc32c$var$mapFeatureStrings([
        type,
        setting
      ]);
      if (feature[setting] && (r2 = $3b6302b64eccc32c$var$AATMapping[f2[0]] && $3b6302b64eccc32c$var$AATMapping[f2[0]][f2[1]])) res[r2] = true;
    }
  }
  return Object.keys(res);
}
class $ff5ce077dae0f144$export$2e2bcd8739ae039 {
  lookup(glyph) {
    switch (this.table.version) {
      case 0:
        return this.table.values.getItem(glyph);
      case 2:
      case 4: {
        let min2 = 0;
        let max2 = this.table.binarySearchHeader.nUnits - 1;
        while (min2 <= max2) {
          var mid = min2 + max2 >> 1;
          var seg = this.table.segments[mid];
          if (seg.firstGlyph === 65535) return null;
          if (glyph < seg.firstGlyph) max2 = mid - 1;
          else if (glyph > seg.lastGlyph) min2 = mid + 1;
          else {
            if (this.table.version === 2) return seg.value;
            else return seg.values[glyph - seg.firstGlyph];
          }
        }
        return null;
      }
      case 6: {
        let min2 = 0;
        let max2 = this.table.binarySearchHeader.nUnits - 1;
        while (min2 <= max2) {
          var mid = min2 + max2 >> 1;
          var seg = this.table.segments[mid];
          if (seg.glyph === 65535) return null;
          if (glyph < seg.glyph) max2 = mid - 1;
          else if (glyph > seg.glyph) min2 = mid + 1;
          else return seg.value;
        }
        return null;
      }
      case 8:
        return this.table.values[glyph - this.table.firstGlyph];
      default:
        throw new Error(`Unknown lookup table format: ${this.table.version}`);
    }
  }
  glyphsForValue(classValue) {
    let res = [];
    switch (this.table.version) {
      case 2:
      case 4:
        for (let segment of this.table.segments) if (this.table.version === 2 && segment.value === classValue) res.push(...$12727730ddfc8bfe$export$d02631cccf789723(segment.firstGlyph, segment.lastGlyph + 1));
        else {
          for (let index2 = 0; index2 < segment.values.length; index2++) if (segment.values[index2] === classValue) res.push(segment.firstGlyph + index2);
        }
        break;
      case 6:
        for (let segment of this.table.segments) if (segment.value === classValue) res.push(segment.glyph);
        break;
      case 8:
        for (let i2 = 0; i2 < this.table.values.length; i2++) if (this.table.values[i2] === classValue) res.push(this.table.firstGlyph + i2);
        break;
      default:
        throw new Error(`Unknown lookup table format: ${this.table.version}`);
    }
    return res;
  }
  constructor(table) {
    this.table = table;
  }
}
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $ff5ce077dae0f144$export$2e2bcd8739ae039.prototype, "glyphsForValue", null);
const $50c7aac9316f2948$var$START_OF_TEXT_STATE = 0;
const $50c7aac9316f2948$var$END_OF_TEXT_CLASS = 0;
const $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS = 1;
const $50c7aac9316f2948$var$DELETED_GLYPH_CLASS = 2;
const $50c7aac9316f2948$var$DONT_ADVANCE = 16384;
class $50c7aac9316f2948$export$2e2bcd8739ae039 {
  process(glyphs, reverse2, processEntry) {
    let currentState = $50c7aac9316f2948$var$START_OF_TEXT_STATE;
    let index2 = reverse2 ? glyphs.length - 1 : 0;
    let dir = reverse2 ? -1 : 1;
    while (dir === 1 && index2 <= glyphs.length || dir === -1 && index2 >= -1) {
      let glyph = null;
      let classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
      let shouldAdvance = true;
      if (index2 === glyphs.length || index2 === -1) classCode = $50c7aac9316f2948$var$END_OF_TEXT_CLASS;
      else {
        glyph = glyphs[index2];
        if (glyph.id === 65535) classCode = $50c7aac9316f2948$var$DELETED_GLYPH_CLASS;
        else {
          classCode = this.lookupTable.lookup(glyph.id);
          if (classCode == null) classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
        }
      }
      let row = this.stateTable.stateArray.getItem(currentState);
      let entryIndex = row[classCode];
      let entry = this.stateTable.entryTable.getItem(entryIndex);
      if (classCode !== $50c7aac9316f2948$var$END_OF_TEXT_CLASS && classCode !== $50c7aac9316f2948$var$DELETED_GLYPH_CLASS) {
        processEntry(glyph, entry, index2);
        shouldAdvance = !(entry.flags & $50c7aac9316f2948$var$DONT_ADVANCE);
      }
      currentState = entry.newState;
      if (shouldAdvance) index2 += dir;
    }
    return glyphs;
  }
  /**
  * Performs a depth-first traversal of the glyph strings
  * represented by the state machine.
  */
  traverse(opts2, state2 = 0, visited = /* @__PURE__ */ new Set()) {
    if (visited.has(state2)) return;
    visited.add(state2);
    let { nClasses, stateArray, entryTable } = this.stateTable;
    let row = stateArray.getItem(state2);
    for (let classCode = 4; classCode < nClasses; classCode++) {
      let entryIndex = row[classCode];
      let entry = entryTable.getItem(entryIndex);
      for (let glyph of this.lookupTable.glyphsForValue(classCode)) {
        if (opts2.enter) opts2.enter(glyph, entry);
        if (entry.newState !== 0) this.traverse(opts2, entry.newState, visited);
        if (opts2.exit) opts2.exit(glyph, entry);
      }
    }
  }
  constructor(stateTable) {
    this.stateTable = stateTable;
    this.lookupTable = new $ff5ce077dae0f144$export$2e2bcd8739ae039(stateTable.classTable);
  }
}
const $55f71433a605c87d$var$MARK_FIRST = 32768;
const $55f71433a605c87d$var$MARK_LAST = 8192;
const $55f71433a605c87d$var$VERB = 15;
const $55f71433a605c87d$var$SET_MARK = 32768;
const $55f71433a605c87d$var$SET_COMPONENT = 32768;
const $55f71433a605c87d$var$PERFORM_ACTION = 8192;
const $55f71433a605c87d$var$LAST_MASK = 2147483648;
const $55f71433a605c87d$var$STORE_MASK = 1073741824;
const $55f71433a605c87d$var$OFFSET_MASK = 1073741823;
const $55f71433a605c87d$var$REVERSE_DIRECTION = 4194304;
const $55f71433a605c87d$var$CURRENT_INSERT_BEFORE = 2048;
const $55f71433a605c87d$var$MARKED_INSERT_BEFORE = 1024;
const $55f71433a605c87d$var$CURRENT_INSERT_COUNT = 992;
const $55f71433a605c87d$var$MARKED_INSERT_COUNT = 31;
class $55f71433a605c87d$export$2e2bcd8739ae039 {
  // Processes an array of glyphs and applies the specified features
  // Features should be in the form of {featureType:{featureSetting:boolean}}
  process(glyphs, features = {}) {
    for (let chain of this.morx.chains) {
      let flags = chain.defaultFlags;
      for (let feature of chain.features) {
        let f2;
        if (f2 = features[feature.featureType]) {
          if (f2[feature.featureSetting]) {
            flags &= feature.disableFlags;
            flags |= feature.enableFlags;
          } else if (f2[feature.featureSetting] === false) {
            flags |= ~feature.disableFlags;
            flags &= ~feature.enableFlags;
          }
        }
      }
      for (let subtable of chain.subtables) if (subtable.subFeatureFlags & flags) this.processSubtable(subtable, glyphs);
    }
    let index2 = glyphs.length - 1;
    while (index2 >= 0) {
      if (glyphs[index2].id === 65535) glyphs.splice(index2, 1);
      index2--;
    }
    return glyphs;
  }
  processSubtable(subtable, glyphs) {
    this.subtable = subtable;
    this.glyphs = glyphs;
    if (this.subtable.type === 4) {
      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
      return;
    }
    this.ligatureStack = [];
    this.markedGlyph = null;
    this.firstGlyph = null;
    this.lastGlyph = null;
    this.markedIndex = null;
    let stateMachine = this.getStateMachine(subtable);
    let process = this.getProcessor();
    let reverse2 = !!(this.subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
    return stateMachine.process(this.glyphs, reverse2, process);
  }
  getStateMachine(subtable) {
    return new $50c7aac9316f2948$export$2e2bcd8739ae039(subtable.table.stateTable);
  }
  getProcessor() {
    switch (this.subtable.type) {
      case 0:
        return this.processIndicRearragement;
      case 1:
        return this.processContextualSubstitution;
      case 2:
        return this.processLigature;
      case 4:
        return this.processNoncontextualSubstitutions;
      case 5:
        return this.processGlyphInsertion;
      default:
        throw new Error(`Invalid morx subtable type: ${this.subtable.type}`);
    }
  }
  processIndicRearragement(glyph, entry, index2) {
    if (entry.flags & $55f71433a605c87d$var$MARK_FIRST) this.firstGlyph = index2;
    if (entry.flags & $55f71433a605c87d$var$MARK_LAST) this.lastGlyph = index2;
    $55f71433a605c87d$var$reorderGlyphs(this.glyphs, entry.flags & $55f71433a605c87d$var$VERB, this.firstGlyph, this.lastGlyph);
  }
  processContextualSubstitution(glyph, entry, index2) {
    let subsitutions = this.subtable.table.substitutionTable.items;
    if (entry.markIndex !== 65535) {
      let lookup2 = subsitutions.getItem(entry.markIndex);
      let lookupTable = new $ff5ce077dae0f144$export$2e2bcd8739ae039(lookup2);
      glyph = this.glyphs[this.markedGlyph];
      var gid = lookupTable.lookup(glyph.id);
      if (gid) this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);
    }
    if (entry.currentIndex !== 65535) {
      let lookup2 = subsitutions.getItem(entry.currentIndex);
      let lookupTable = new $ff5ce077dae0f144$export$2e2bcd8739ae039(lookup2);
      glyph = this.glyphs[index2];
      var gid = lookupTable.lookup(glyph.id);
      if (gid) this.glyphs[index2] = this.font.getGlyph(gid, glyph.codePoints);
    }
    if (entry.flags & $55f71433a605c87d$var$SET_MARK) this.markedGlyph = index2;
  }
  processLigature(glyph, entry, index2) {
    if (entry.flags & $55f71433a605c87d$var$SET_COMPONENT) this.ligatureStack.push(index2);
    if (entry.flags & $55f71433a605c87d$var$PERFORM_ACTION) {
      let actions = this.subtable.table.ligatureActions;
      let components = this.subtable.table.components;
      let ligatureList = this.subtable.table.ligatureList;
      let actionIndex = entry.action;
      let last2 = false;
      let ligatureIndex = 0;
      let codePoints = [];
      let ligatureGlyphs = [];
      while (!last2) {
        let componentGlyph = this.ligatureStack.pop();
        codePoints.unshift(...this.glyphs[componentGlyph].codePoints);
        let action = actions.getItem(actionIndex++);
        last2 = !!(action & $55f71433a605c87d$var$LAST_MASK);
        let store = !!(action & $55f71433a605c87d$var$STORE_MASK);
        let offset2 = (action & $55f71433a605c87d$var$OFFSET_MASK) << 2 >> 2;
        offset2 += this.glyphs[componentGlyph].id;
        let component = components.getItem(offset2);
        ligatureIndex += component;
        if (last2 || store) {
          let ligatureEntry = ligatureList.getItem(ligatureIndex);
          this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);
          ligatureGlyphs.push(componentGlyph);
          ligatureIndex = 0;
          codePoints = [];
        } else this.glyphs[componentGlyph] = this.font.getGlyph(65535);
      }
      this.ligatureStack.push(...ligatureGlyphs);
    }
  }
  processNoncontextualSubstitutions(subtable, glyphs, index2) {
    let lookupTable = new $ff5ce077dae0f144$export$2e2bcd8739ae039(subtable.table.lookupTable);
    for (index2 = 0; index2 < glyphs.length; index2++) {
      let glyph = glyphs[index2];
      if (glyph.id !== 65535) {
        let gid = lookupTable.lookup(glyph.id);
        if (gid) glyphs[index2] = this.font.getGlyph(gid, glyph.codePoints);
      }
    }
  }
  _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {
    let insertions = [];
    while (count--) {
      let gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);
      insertions.push(this.font.getGlyph(gid));
    }
    if (!isBefore) glyphIndex++;
    this.glyphs.splice(glyphIndex, 0, ...insertions);
  }
  processGlyphInsertion(glyph, entry, index2) {
    if (entry.flags & $55f71433a605c87d$var$SET_MARK) this.markedIndex = index2;
    if (entry.markedInsertIndex !== 65535) {
      let count = (entry.flags & $55f71433a605c87d$var$MARKED_INSERT_COUNT) >>> 5;
      let isBefore = !!(entry.flags & $55f71433a605c87d$var$MARKED_INSERT_BEFORE);
      this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);
    }
    if (entry.currentInsertIndex !== 65535) {
      let count = (entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_COUNT) >>> 5;
      let isBefore = !!(entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_BEFORE);
      this._insertGlyphs(index2, entry.currentInsertIndex, count, isBefore);
    }
  }
  getSupportedFeatures() {
    let features = [];
    for (let chain of this.morx.chains) for (let feature of chain.features) features.push([
      feature.featureType,
      feature.featureSetting
    ]);
    return features;
  }
  generateInputs(gid) {
    if (!this.inputCache) this.generateInputCache();
    return this.inputCache[gid] || [];
  }
  generateInputCache() {
    this.inputCache = {};
    for (let chain of this.morx.chains) {
      let flags = chain.defaultFlags;
      for (let subtable of chain.subtables) if (subtable.subFeatureFlags & flags) this.generateInputsForSubtable(subtable);
    }
  }
  generateInputsForSubtable(subtable) {
    if (subtable.type !== 2) return;
    let reverse2 = !!(subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
    if (reverse2) throw new Error("Reverse subtable, not supported.");
    this.subtable = subtable;
    this.ligatureStack = [];
    let stateMachine = this.getStateMachine(subtable);
    let process = this.getProcessor();
    let input = [];
    let stack = [];
    this.glyphs = [];
    stateMachine.traverse({
      enter: (glyph, entry) => {
        let glyphs = this.glyphs;
        stack.push({
          glyphs: glyphs.slice(),
          ligatureStack: this.ligatureStack.slice()
        });
        let g = this.font.getGlyph(glyph);
        input.push(g);
        glyphs.push(input[input.length - 1]);
        process(glyphs[glyphs.length - 1], entry, glyphs.length - 1);
        let count = 0;
        let found = 0;
        for (let i2 = 0; i2 < glyphs.length && count <= 1; i2++) if (glyphs[i2].id !== 65535) {
          count++;
          found = glyphs[i2].id;
        }
        if (count === 1) {
          let result = input.map((g2) => g2.id);
          let cache2 = this.inputCache[found];
          if (cache2) cache2.push(result);
          else this.inputCache[found] = [
            result
          ];
        }
      },
      exit: () => {
        ({ glyphs: this.glyphs, ligatureStack: this.ligatureStack } = stack.pop());
        input.pop();
      }
    });
  }
  constructor(font) {
    this.processIndicRearragement = this.processIndicRearragement.bind(this);
    this.processContextualSubstitution = this.processContextualSubstitution.bind(this);
    this.processLigature = this.processLigature.bind(this);
    this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);
    this.processGlyphInsertion = this.processGlyphInsertion.bind(this);
    this.font = font;
    this.morx = font.morx;
    this.inputCache = null;
  }
}
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $55f71433a605c87d$export$2e2bcd8739ae039.prototype, "getStateMachine", null);
function $55f71433a605c87d$var$swap(glyphs, rangeA, rangeB, reverseA = false, reverseB = false) {
  let end2 = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);
  if (reverseB) end2.reverse();
  let start2 = glyphs.splice(rangeA[0], rangeA[1], ...end2);
  if (reverseA) start2.reverse();
  glyphs.splice(rangeB[0] - (rangeA[1] - 1), 0, ...start2);
  return glyphs;
}
function $55f71433a605c87d$var$reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {
  switch (verb) {
    case 0:
      return glyphs;
    case 1:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        0
      ]);
    case 2:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        1
      ]);
    case 3:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        1
      ]);
    case 4:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        0
      ]);
    case 5:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        0
      ], true, false);
    case 6:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        2
      ]);
    case 7:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        2
      ], false, true);
    case 8:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        2
      ]);
    case 9:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        2
      ], false, true);
    case 10:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        1
      ]);
    case 11:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        1
      ], true, false);
    case 12:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ]);
    case 13:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], true, false);
    case 14:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], false, true);
    case 15:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], true, true);
    default:
      throw new Error(`Unknown verb: ${verb}`);
  }
}
class $ba6dd74203be8728$export$2e2bcd8739ae039 {
  substitute(glyphRun) {
    if (glyphRun.direction === "rtl") glyphRun.glyphs.reverse();
    this.morxProcessor.process(glyphRun.glyphs, $3b6302b64eccc32c$export$b813f7d2a1677c16(glyphRun.features));
  }
  getAvailableFeatures(script, language) {
    return $3b6302b64eccc32c$export$bd6df347a4f391c4(this.morxProcessor.getSupportedFeatures());
  }
  stringsForGlyph(gid) {
    let glyphStrings = this.morxProcessor.generateInputs(gid);
    let result = /* @__PURE__ */ new Set();
    for (let glyphs of glyphStrings) this._addStrings(glyphs, 0, result, "");
    return result;
  }
  _addStrings(glyphs, index2, strings, string) {
    let codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index2]);
    for (let codePoint of codePoints) {
      let s2 = string + String.fromCodePoint(codePoint);
      if (index2 < glyphs.length - 1) this._addStrings(glyphs, index2 + 1, strings, s2);
      else strings.add(s2);
    }
  }
  constructor(font) {
    this.font = font;
    this.morxProcessor = new $55f71433a605c87d$export$2e2bcd8739ae039(font);
    this.fallbackPosition = false;
  }
}
class $94d7a73bd2edfc9a$export$2e2bcd8739ae039 {
  /**
  * Adds the given features to the last stage.
  * Ignores features that have already been applied.
  */
  _addFeatures(features, global2) {
    let stageIndex = this.stages.length - 1;
    let stage = this.stages[stageIndex];
    for (let feature of features) if (this.allFeatures[feature] == null) {
      stage.push(feature);
      this.allFeatures[feature] = stageIndex;
      if (global2) this.globalFeatures[feature] = true;
    }
  }
  /**
  * Add features to the last stage
  */
  add(arg, global2 = true) {
    if (this.stages.length === 0) this.stages.push([]);
    if (typeof arg === "string") arg = [
      arg
    ];
    if (Array.isArray(arg)) this._addFeatures(arg, global2);
    else if (typeof arg === "object") {
      this._addFeatures(arg.global || [], true);
      this._addFeatures(arg.local || [], false);
    } else throw new Error("Unsupported argument to ShapingPlan#add");
  }
  /**
  * Add a new stage
  */
  addStage(arg, global2) {
    if (typeof arg === "function") this.stages.push(arg, []);
    else {
      this.stages.push([]);
      this.add(arg, global2);
    }
  }
  setFeatureOverrides(features) {
    if (Array.isArray(features)) this.add(features);
    else if (typeof features === "object") for (let tag in features) {
      if (features[tag]) this.add(tag);
      else if (this.allFeatures[tag] != null) {
        let stage = this.stages[this.allFeatures[tag]];
        stage.splice(stage.indexOf(tag), 1);
        delete this.allFeatures[tag];
        delete this.globalFeatures[tag];
      }
    }
  }
  /**
  * Assigns the global features to the given glyphs
  */
  assignGlobalFeatures(glyphs) {
    for (let glyph of glyphs) for (let feature in this.globalFeatures) glyph.features[feature] = true;
  }
  /**
  * Executes the planned stages using the given OTProcessor
  */
  process(processor, glyphs, positions) {
    for (let stage of this.stages) {
      if (typeof stage === "function") {
        if (!positions) stage(this.font, glyphs, this);
      } else if (stage.length > 0) processor.applyFeatures(stage, glyphs, positions);
    }
  }
  constructor(font, script, direction) {
    this.font = font;
    this.script = script;
    this.direction = direction;
    this.stages = [];
    this.globalFeatures = {};
    this.allFeatures = {};
  }
}
const $649970d87335b30f$var$VARIATION_FEATURES = [
  "rvrn"
];
const $649970d87335b30f$var$COMMON_FEATURES = [
  "ccmp",
  "locl",
  "rlig",
  "mark",
  "mkmk"
];
const $649970d87335b30f$var$FRACTIONAL_FEATURES = [
  "frac",
  "numr",
  "dnom"
];
const $649970d87335b30f$var$HORIZONTAL_FEATURES = [
  "calt",
  "clig",
  "liga",
  "rclt",
  "curs",
  "kern"
];
const $649970d87335b30f$var$DIRECTIONAL_FEATURES = {
  ltr: [
    "ltra",
    "ltrm"
  ],
  rtl: [
    "rtla",
    "rtlm"
  ]
};
class $649970d87335b30f$export$2e2bcd8739ae039 {
  static plan(plan, glyphs, features) {
    this.planPreprocessing(plan);
    this.planFeatures(plan);
    this.planPostprocessing(plan, features);
    plan.assignGlobalFeatures(glyphs);
    this.assignFeatures(plan, glyphs);
  }
  static planPreprocessing(plan) {
    plan.add({
      global: [
        ...$649970d87335b30f$var$VARIATION_FEATURES,
        ...$649970d87335b30f$var$DIRECTIONAL_FEATURES[plan.direction]
      ],
      local: $649970d87335b30f$var$FRACTIONAL_FEATURES
    });
  }
  static planFeatures(plan) {
  }
  static planPostprocessing(plan, userFeatures) {
    plan.add([
      ...$649970d87335b30f$var$COMMON_FEATURES,
      ...$649970d87335b30f$var$HORIZONTAL_FEATURES
    ]);
    plan.setFeatureOverrides(userFeatures);
  }
  static assignFeatures(plan, glyphs) {
    for (let i2 = 0; i2 < glyphs.length; i2++) {
      let glyph = glyphs[i2];
      if (glyph.codePoints[0] === 8260) {
        let start2 = i2;
        let end2 = i2 + 1;
        while (start2 > 0 && $747425b437e121da$export$727d9dbc4fbb948f(glyphs[start2 - 1].codePoints[0])) {
          glyphs[start2 - 1].features.numr = true;
          glyphs[start2 - 1].features.frac = true;
          start2--;
        }
        while (end2 < glyphs.length && $747425b437e121da$export$727d9dbc4fbb948f(glyphs[end2].codePoints[0])) {
          glyphs[end2].features.dnom = true;
          glyphs[end2].features.frac = true;
          end2++;
        }
        glyph.features.frac = true;
        i2 = end2 - 1;
      }
    }
  }
}
_define_property($649970d87335b30f$export$2e2bcd8739ae039, "zeroMarkWidths", "AFTER_GPOS");
const $764eb544bbe1ccf0$var$trie = new $hJqJp$unicodetrie($12727730ddfc8bfe$export$94fdf11bafc8de6b("APABAAAAAAAAOAAAAf0BAv7tmi1MxDAUx7vtvjhAgcDgkEgEAnmXEBIMCYaEcygEiqBQ4FAkCE4ikUgMiiBJSAgSiUQSDMn9L9eSl6bddddug9t7yS/trevre+3r27pcNxZiG+yCfdCVv/9LeQxOwRm4AJegD27ALbgD9+ABPJF+z+BN/h7yDj5k/VOWX6SdmU5+wLWknggxDxaS8u0qiiX4uiz9XamQ3wzDMAzDMAzDMAzDVI/h959V/v7BMAzDMAzDMLlyNTNiMSdewVxbiA44B4/guz1qW58VYlMI0WsJ0W+N6kXw0spvPtdwhtkwnGM6uLaV4Xyzg3v3PM9DPfQ/sOg4xPWjipy31P8LTqbU304c/cLCUmWJLNB2Uz2U1KTeRKNmKHVMfbJC+/0loTZRH/W5cvEvBJPMbREkWt3FD1NcqXZBSpuE2Ad0PBehPtNrPtIEdYP+hiRt/V1jIiE69X4NT/uVZI3PUHE9bm5M7ePGdZWy951v7Nn6j8v1WWKP3mt6ttnsigx6VN7Vc0VomSSGqW2mGNP1muZPl7LfjNUaKNFtDGVf2fvE9O7VlBS5j333c5p/eeoOqcs1R/hIqDWLJ7TTlksirVT1SI7l8k4Yp+g3jafGcrU1RM6l9th80XOpnlN97bDNY4i4s61B0Si/ipa0uHMl6zqEjlFfCZm/TM8KmzQDjmuTAQ=="));
const $764eb544bbe1ccf0$var$FEATURES = [
  "isol",
  "fina",
  "fin2",
  "fin3",
  "medi",
  "med2",
  "init"
];
const $764eb544bbe1ccf0$var$ShapingClasses = {
  Non_Joining: 0,
  Transparent: 6
};
const $764eb544bbe1ccf0$var$ISOL = "isol";
const $764eb544bbe1ccf0$var$FINA = "fina";
const $764eb544bbe1ccf0$var$FIN2 = "fin2";
const $764eb544bbe1ccf0$var$FIN3 = "fin3";
const $764eb544bbe1ccf0$var$MEDI = "medi";
const $764eb544bbe1ccf0$var$MED2 = "med2";
const $764eb544bbe1ccf0$var$INIT = "init";
const $764eb544bbe1ccf0$var$NONE = null;
const $764eb544bbe1ccf0$var$STATE_TABLE = [
  //   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH
  // State 0: prev was U,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 1: prev was R or ISOL/ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 2: prev was D/L in ISOL form,  willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      1
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      3
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      4
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      6
    ]
  ],
  // State 3: prev was D in FINA form,  willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      1
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      3
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      4
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      6
    ]
  ],
  // State 4: prev was FINA ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 6: prev was DALATH/RISH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$FIN3,
      5
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ]
];
class $764eb544bbe1ccf0$export$2e2bcd8739ae039 extends $649970d87335b30f$export$2e2bcd8739ae039 {
  static planFeatures(plan) {
    plan.add([
      "ccmp",
      "locl"
    ]);
    for (let i2 = 0; i2 < $764eb544bbe1ccf0$var$FEATURES.length; i2++) {
      let feature = $764eb544bbe1ccf0$var$FEATURES[i2];
      plan.addStage(feature, false);
    }
    plan.addStage("mset");
  }
  static assignFeatures(plan, glyphs) {
    super.assignFeatures(plan, glyphs);
    let prev = -1;
    let state2 = 0;
    let actions = [];
    for (let i2 = 0; i2 < glyphs.length; i2++) {
      let curAction, prevAction;
      var glyph = glyphs[i2];
      let type = $764eb544bbe1ccf0$var$getShapingClass(glyph.codePoints[0]);
      if (type === $764eb544bbe1ccf0$var$ShapingClasses.Transparent) {
        actions[i2] = $764eb544bbe1ccf0$var$NONE;
        continue;
      }
      [prevAction, curAction, state2] = $764eb544bbe1ccf0$var$STATE_TABLE[state2][type];
      if (prevAction !== $764eb544bbe1ccf0$var$NONE && prev !== -1) actions[prev] = prevAction;
      actions[i2] = curAction;
      prev = i2;
    }
    for (let index2 = 0; index2 < glyphs.length; index2++) {
      let feature;
      var glyph = glyphs[index2];
      if (feature = actions[index2]) glyph.features[feature] = true;
    }
  }
}
function $764eb544bbe1ccf0$var$getShapingClass(codePoint) {
  let res = $764eb544bbe1ccf0$var$trie.get(codePoint);
  if (res) return res - 1;
  let category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  if (category === "Mn" || category === "Me" || category === "Cf") return $764eb544bbe1ccf0$var$ShapingClasses.Transparent;
  return $764eb544bbe1ccf0$var$ShapingClasses.Non_Joining;
}
class $85d408632270248b$export$2e2bcd8739ae039 {
  reset(options = {}, index2 = 0) {
    this.options = options;
    this.flags = options.flags || {};
    this.markAttachmentType = options.markAttachmentType || 0;
    this.index = index2;
  }
  get cur() {
    return this.glyphs[this.index] || null;
  }
  shouldIgnore(glyph) {
    return this.flags.ignoreMarks && glyph.isMark || this.flags.ignoreBaseGlyphs && glyph.isBase || this.flags.ignoreLigatures && glyph.isLigature || this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType;
  }
  move(dir) {
    this.index += dir;
    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) this.index += dir;
    if (0 > this.index || this.index >= this.glyphs.length) return null;
    return this.glyphs[this.index];
  }
  next() {
    return this.move(1);
  }
  prev() {
    return this.move(-1);
  }
  peek(count = 1) {
    let idx = this.index;
    let res = this.increment(count);
    this.index = idx;
    return res;
  }
  peekIndex(count = 1) {
    let idx = this.index;
    this.increment(count);
    let res = this.index;
    this.index = idx;
    return res;
  }
  increment(count = 1) {
    let dir = count < 0 ? -1 : 1;
    count = Math.abs(count);
    while (count--) this.move(dir);
    return this.glyphs[this.index];
  }
  constructor(glyphs, options) {
    this.glyphs = glyphs;
    this.reset(options);
  }
}
const $a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS = [
  "DFLT",
  "dflt",
  "latn"
];
class $a83b9c36aaa94fd3$export$2e2bcd8739ae039 {
  findScript(script) {
    if (this.table.scriptList == null) return null;
    if (!Array.isArray(script)) script = [
      script
    ];
    for (let s2 of script) for (let entry of this.table.scriptList) {
      if (entry.tag === s2) return entry;
    }
    return null;
  }
  selectScript(script, language, direction) {
    let changed = false;
    let entry;
    if (!this.script || script !== this.scriptTag) {
      entry = this.findScript(script);
      if (!entry) entry = this.findScript($a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS);
      if (!entry) return this.scriptTag;
      this.scriptTag = entry.tag;
      this.script = entry.script;
      this.language = null;
      this.languageTag = null;
      changed = true;
    }
    if (!direction || direction !== this.direction) this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
    if (language && language.length < 4) language += " ".repeat(4 - language.length);
    if (!language || language !== this.languageTag) {
      this.language = null;
      for (let lang of this.script.langSysRecords) if (lang.tag === language) {
        this.language = lang.langSys;
        this.languageTag = lang.tag;
        break;
      }
      if (!this.language) {
        this.language = this.script.defaultLangSys;
        this.languageTag = null;
      }
      changed = true;
    }
    if (changed) {
      this.features = {};
      if (this.language) for (let featureIndex of this.language.featureIndexes) {
        let record = this.table.featureList[featureIndex];
        let substituteFeature = this.substituteFeatureForVariations(featureIndex);
        this.features[record.tag] = substituteFeature || record.feature;
      }
    }
    return this.scriptTag;
  }
  lookupsForFeatures(userFeatures = [], exclude) {
    let lookups = [];
    for (let tag of userFeatures) {
      let feature = this.features[tag];
      if (!feature) continue;
      for (let lookupIndex of feature.lookupListIndexes) {
        if (exclude && exclude.indexOf(lookupIndex) !== -1) continue;
        lookups.push({
          feature: tag,
          index: lookupIndex,
          lookup: this.table.lookupList.get(lookupIndex)
        });
      }
    }
    lookups.sort((a2, b2) => a2.index - b2.index);
    return lookups;
  }
  substituteFeatureForVariations(featureIndex) {
    if (this.variationsIndex === -1) return null;
    let record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];
    let substitutions = record.featureTableSubstitution.substitutions;
    for (let substitution of substitutions) {
      if (substitution.featureIndex === featureIndex) return substitution.alternateFeatureTable;
    }
    return null;
  }
  findVariationsIndex(coords) {
    let variations = this.table.featureVariations;
    if (!variations) return -1;
    let records = variations.featureVariationRecords;
    for (let i2 = 0; i2 < records.length; i2++) {
      let conditions = records[i2].conditionSet.conditionTable;
      if (this.variationConditionsMatch(conditions, coords)) return i2;
    }
    return -1;
  }
  variationConditionsMatch(conditions, coords) {
    return conditions.every((condition) => {
      let coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;
      return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;
    });
  }
  applyFeatures(userFeatures, glyphs, advances) {
    let lookups = this.lookupsForFeatures(userFeatures);
    this.applyLookups(lookups, glyphs, advances);
  }
  applyLookups(lookups, glyphs, positions) {
    this.glyphs = glyphs;
    this.positions = positions;
    this.glyphIterator = new $85d408632270248b$export$2e2bcd8739ae039(glyphs);
    for (let { feature, lookup: lookup2 } of lookups) {
      this.currentFeature = feature;
      this.glyphIterator.reset(lookup2.flags);
      while (this.glyphIterator.index < glyphs.length) {
        if (!(feature in this.glyphIterator.cur.features)) {
          this.glyphIterator.next();
          continue;
        }
        for (let table of lookup2.subTables) {
          let res = this.applyLookup(lookup2.lookupType, table);
          if (res) break;
        }
        this.glyphIterator.next();
      }
    }
  }
  applyLookup(lookup2, table) {
    throw new Error("applyLookup must be implemented by subclasses");
  }
  applyLookupList(lookupRecords) {
    let options = this.glyphIterator.options;
    let glyphIndex = this.glyphIterator.index;
    for (let lookupRecord of lookupRecords) {
      this.glyphIterator.reset(options, glyphIndex);
      this.glyphIterator.increment(lookupRecord.sequenceIndex);
      let lookup2 = this.table.lookupList.get(lookupRecord.lookupListIndex);
      this.glyphIterator.reset(lookup2.flags, this.glyphIterator.index);
      for (let table of lookup2.subTables) {
        if (this.applyLookup(lookup2.lookupType, table)) break;
      }
    }
    this.glyphIterator.reset(options, glyphIndex);
    return true;
  }
  coverageIndex(coverage, glyph) {
    if (glyph == null) glyph = this.glyphIterator.cur.id;
    switch (coverage.version) {
      case 1:
        return coverage.glyphs.indexOf(glyph);
      case 2:
        for (let range2 of coverage.rangeRecords) {
          if (range2.start <= glyph && glyph <= range2.end) return range2.startCoverageIndex + glyph - range2.start;
        }
        break;
    }
    return -1;
  }
  match(sequenceIndex, sequence, fn, matched) {
    let pos = this.glyphIterator.index;
    let glyph = this.glyphIterator.increment(sequenceIndex);
    let idx = 0;
    while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {
      if (matched) matched.push(this.glyphIterator.index);
      idx++;
      glyph = this.glyphIterator.next();
    }
    this.glyphIterator.index = pos;
    if (idx < sequence.length) return false;
    return matched || true;
  }
  sequenceMatches(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (component, glyph) => component === glyph.id);
  }
  sequenceMatchIndices(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (component, glyph) => {
      if (!(this.currentFeature in glyph.features)) return false;
      return component === glyph.id;
    }, []);
  }
  coverageSequenceMatches(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (coverage, glyph) => this.coverageIndex(coverage, glyph.id) >= 0);
  }
  getClassID(glyph, classDef) {
    switch (classDef.version) {
      case 1:
        let i2 = glyph - classDef.startGlyph;
        if (i2 >= 0 && i2 < classDef.classValueArray.length) return classDef.classValueArray[i2];
        break;
      case 2:
        for (let range2 of classDef.classRangeRecord) {
          if (range2.start <= glyph && glyph <= range2.end) return range2.class;
        }
        break;
    }
    return 0;
  }
  classSequenceMatches(sequenceIndex, sequence, classDef) {
    return this.match(sequenceIndex, sequence, (classID, glyph) => classID === this.getClassID(glyph.id, classDef));
  }
  applyContext(table) {
    let index2, set5;
    switch (table.version) {
      case 1:
        index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        set5 = table.ruleSets[index2];
        for (let rule of set5) {
          if (this.sequenceMatches(1, rule.input)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 2:
        if (this.coverageIndex(table.coverage) === -1) return false;
        index2 = this.getClassID(this.glyphIterator.cur.id, table.classDef);
        if (index2 === -1) return false;
        set5 = table.classSet[index2];
        for (let rule of set5) {
          if (this.classSequenceMatches(1, rule.classes, table.classDef)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(0, table.coverages)) return this.applyLookupList(table.lookupRecords);
        break;
    }
    return false;
  }
  applyChainingContext(table) {
    let index2;
    switch (table.version) {
      case 1:
        index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        let set5 = table.chainRuleSets[index2];
        for (let rule of set5) {
          if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 2:
        if (this.coverageIndex(table.coverage) === -1) return false;
        index2 = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);
        let rules = table.chainClassSet[index2];
        if (!rules) return false;
        for (let rule of rules) {
          if (this.classSequenceMatches(-rule.backtrack.length, rule.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, rule.input, table.inputClassDef) && this.classSequenceMatches(1 + rule.input.length, rule.lookahead, table.lookaheadClassDef)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) return this.applyLookupList(table.lookupRecords);
        break;
    }
    return false;
  }
  constructor(font, table) {
    this.font = font;
    this.table = table;
    this.script = null;
    this.scriptTag = null;
    this.language = null;
    this.languageTag = null;
    this.features = {};
    this.lookups = {};
    this.variationsIndex = font._variationProcessor ? this.findVariationsIndex(font._variationProcessor.normalizedCoords) : -1;
    this.selectScript();
    this.glyphs = [];
    this.positions = [];
    this.ligatureID = 1;
    this.currentFeature = null;
  }
}
class $10e7b257e1a9a756$export$2e2bcd8739ae039 {
  get id() {
    return this._id;
  }
  set id(id) {
    this._id = id;
    this.substituted = true;
    let GDEF = this._font.GDEF;
    if (GDEF && GDEF.glyphClassDef) {
      let classID = $a83b9c36aaa94fd3$export$2e2bcd8739ae039.prototype.getClassID(id, GDEF.glyphClassDef);
      this.isBase = classID === 1;
      this.isLigature = classID === 2;
      this.isMark = classID === 3;
      this.markAttachmentType = GDEF.markAttachClassDef ? $a83b9c36aaa94fd3$export$2e2bcd8739ae039.prototype.getClassID(id, GDEF.markAttachClassDef) : 0;
    } else {
      this.isMark = this.codePoints.length > 0 && this.codePoints.every($747425b437e121da$export$e33ad6871e762338);
      this.isBase = !this.isMark;
      this.isLigature = this.codePoints.length > 1;
      this.markAttachmentType = 0;
    }
  }
  copy() {
    return new $10e7b257e1a9a756$export$2e2bcd8739ae039(this._font, this.id, this.codePoints, this.features);
  }
  constructor(font, id, codePoints = [], features) {
    this._font = font;
    this.codePoints = codePoints;
    this.id = id;
    this.features = {};
    if (Array.isArray(features)) for (let i2 = 0; i2 < features.length; i2++) {
      let feature = features[i2];
      this.features[feature] = true;
    }
    else if (typeof features === "object") Object.assign(this.features, features);
    this.ligatureID = null;
    this.ligatureComponent = null;
    this.isLigated = false;
    this.cursiveAttachment = null;
    this.markAttachment = null;
    this.shaperInfo = null;
    this.substituted = false;
    this.isMultiplied = false;
  }
}
class $e1c6bbc8cb416f8c$export$2e2bcd8739ae039 extends $649970d87335b30f$export$2e2bcd8739ae039 {
  static planFeatures(plan) {
    plan.add([
      "ljmo",
      "vjmo",
      "tjmo"
    ], false);
  }
  static assignFeatures(plan, glyphs) {
    let state2 = 0;
    let i2 = 0;
    while (i2 < glyphs.length) {
      let action;
      let glyph = glyphs[i2];
      let code = glyph.codePoints[0];
      let type = $e1c6bbc8cb416f8c$var$getType(code);
      [action, state2] = $e1c6bbc8cb416f8c$var$STATE_TABLE[state2][type];
      switch (action) {
        case $e1c6bbc8cb416f8c$var$DECOMPOSE:
          if (!plan.font.hasGlyphForCodePoint(code)) i2 = $e1c6bbc8cb416f8c$var$decompose(glyphs, i2, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$COMPOSE:
          i2 = $e1c6bbc8cb416f8c$var$compose(glyphs, i2, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$TONE_MARK:
          $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i2, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$INVALID:
          i2 = $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i2, plan.font);
          break;
      }
      i2++;
    }
  }
}
_define_property($e1c6bbc8cb416f8c$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
const $e1c6bbc8cb416f8c$var$HANGUL_BASE = 44032;
const $e1c6bbc8cb416f8c$var$HANGUL_END = 55204;
const $e1c6bbc8cb416f8c$var$HANGUL_COUNT = $e1c6bbc8cb416f8c$var$HANGUL_END - $e1c6bbc8cb416f8c$var$HANGUL_BASE + 1;
const $e1c6bbc8cb416f8c$var$L_BASE = 4352;
const $e1c6bbc8cb416f8c$var$V_BASE = 4449;
const $e1c6bbc8cb416f8c$var$T_BASE = 4519;
const $e1c6bbc8cb416f8c$var$L_COUNT = 19;
const $e1c6bbc8cb416f8c$var$V_COUNT = 21;
const $e1c6bbc8cb416f8c$var$T_COUNT = 28;
const $e1c6bbc8cb416f8c$var$L_END = $e1c6bbc8cb416f8c$var$L_BASE + $e1c6bbc8cb416f8c$var$L_COUNT - 1;
const $e1c6bbc8cb416f8c$var$V_END = $e1c6bbc8cb416f8c$var$V_BASE + $e1c6bbc8cb416f8c$var$V_COUNT - 1;
const $e1c6bbc8cb416f8c$var$T_END = $e1c6bbc8cb416f8c$var$T_BASE + $e1c6bbc8cb416f8c$var$T_COUNT - 1;
const $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE = 9676;
const $e1c6bbc8cb416f8c$var$isL = (code) => 4352 <= code && code <= 4447 || 43360 <= code && code <= 43388;
const $e1c6bbc8cb416f8c$var$isV = (code) => 4448 <= code && code <= 4519 || 55216 <= code && code <= 55238;
const $e1c6bbc8cb416f8c$var$isT = (code) => 4520 <= code && code <= 4607 || 55243 <= code && code <= 55291;
const $e1c6bbc8cb416f8c$var$isTone = (code) => 12334 <= code && code <= 12335;
const $e1c6bbc8cb416f8c$var$isLVT = (code) => $e1c6bbc8cb416f8c$var$HANGUL_BASE <= code && code <= $e1c6bbc8cb416f8c$var$HANGUL_END;
const $e1c6bbc8cb416f8c$var$isLV = (code) => code - $e1c6bbc8cb416f8c$var$HANGUL_BASE < $e1c6bbc8cb416f8c$var$HANGUL_COUNT && (code - $e1c6bbc8cb416f8c$var$HANGUL_BASE) % $e1c6bbc8cb416f8c$var$T_COUNT === 0;
const $e1c6bbc8cb416f8c$var$isCombiningL = (code) => $e1c6bbc8cb416f8c$var$L_BASE <= code && code <= $e1c6bbc8cb416f8c$var$L_END;
const $e1c6bbc8cb416f8c$var$isCombiningV = (code) => $e1c6bbc8cb416f8c$var$V_BASE <= code && code <= $e1c6bbc8cb416f8c$var$V_END;
const $e1c6bbc8cb416f8c$var$isCombiningT = (code) => 1 <= code && code <= $e1c6bbc8cb416f8c$var$T_END;
const $e1c6bbc8cb416f8c$var$X = 0;
const $e1c6bbc8cb416f8c$var$L = 1;
const $e1c6bbc8cb416f8c$var$V = 2;
const $e1c6bbc8cb416f8c$var$T = 3;
const $e1c6bbc8cb416f8c$var$LV = 4;
const $e1c6bbc8cb416f8c$var$LVT = 5;
const $e1c6bbc8cb416f8c$var$M = 6;
function $e1c6bbc8cb416f8c$var$getType(code) {
  if ($e1c6bbc8cb416f8c$var$isL(code)) return $e1c6bbc8cb416f8c$var$L;
  if ($e1c6bbc8cb416f8c$var$isV(code)) return $e1c6bbc8cb416f8c$var$V;
  if ($e1c6bbc8cb416f8c$var$isT(code)) return $e1c6bbc8cb416f8c$var$T;
  if ($e1c6bbc8cb416f8c$var$isLV(code)) return $e1c6bbc8cb416f8c$var$LV;
  if ($e1c6bbc8cb416f8c$var$isLVT(code)) return $e1c6bbc8cb416f8c$var$LVT;
  if ($e1c6bbc8cb416f8c$var$isTone(code)) return $e1c6bbc8cb416f8c$var$M;
  return $e1c6bbc8cb416f8c$var$X;
}
const $e1c6bbc8cb416f8c$var$NO_ACTION = 0;
const $e1c6bbc8cb416f8c$var$DECOMPOSE = 1;
const $e1c6bbc8cb416f8c$var$COMPOSE = 2;
const $e1c6bbc8cb416f8c$var$TONE_MARK = 4;
const $e1c6bbc8cb416f8c$var$INVALID = 5;
const $e1c6bbc8cb416f8c$var$STATE_TABLE = [
  //       X                 L                 V                T                  LV                LVT               M
  // State 0: start state
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$INVALID,
      0
    ]
  ],
  // State 1: <L>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$COMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$INVALID,
      0
    ]
  ],
  // State 2: <L,V> or <LV>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$COMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$TONE_MARK,
      0
    ]
  ],
  // State 3: <L,V,T> or <LVT>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$TONE_MARK,
      0
    ]
  ]
];
function $e1c6bbc8cb416f8c$var$getGlyph(font, code, features) {
  return new $10e7b257e1a9a756$export$2e2bcd8739ae039(font, font.glyphForCodePoint(code).id, [
    code
  ], features);
}
function $e1c6bbc8cb416f8c$var$decompose(glyphs, i2, font) {
  let glyph = glyphs[i2];
  let code = glyph.codePoints[0];
  let s2 = code - $e1c6bbc8cb416f8c$var$HANGUL_BASE;
  let t2 = $e1c6bbc8cb416f8c$var$T_BASE + s2 % $e1c6bbc8cb416f8c$var$T_COUNT;
  s2 = s2 / $e1c6bbc8cb416f8c$var$T_COUNT | 0;
  let l2 = $e1c6bbc8cb416f8c$var$L_BASE + s2 / $e1c6bbc8cb416f8c$var$V_COUNT | 0;
  let v2 = $e1c6bbc8cb416f8c$var$V_BASE + s2 % $e1c6bbc8cb416f8c$var$V_COUNT;
  if (!font.hasGlyphForCodePoint(l2) || !font.hasGlyphForCodePoint(v2) || t2 !== $e1c6bbc8cb416f8c$var$T_BASE && !font.hasGlyphForCodePoint(t2)) return i2;
  let ljmo = $e1c6bbc8cb416f8c$var$getGlyph(font, l2, glyph.features);
  ljmo.features.ljmo = true;
  let vjmo = $e1c6bbc8cb416f8c$var$getGlyph(font, v2, glyph.features);
  vjmo.features.vjmo = true;
  let insert2 = [
    ljmo,
    vjmo
  ];
  if (t2 > $e1c6bbc8cb416f8c$var$T_BASE) {
    let tjmo = $e1c6bbc8cb416f8c$var$getGlyph(font, t2, glyph.features);
    tjmo.features.tjmo = true;
    insert2.push(tjmo);
  }
  glyphs.splice(i2, 1, ...insert2);
  return i2 + insert2.length - 1;
}
function $e1c6bbc8cb416f8c$var$compose(glyphs, i2, font) {
  let glyph = glyphs[i2];
  let code = glyphs[i2].codePoints[0];
  let type = $e1c6bbc8cb416f8c$var$getType(code);
  let prev = glyphs[i2 - 1].codePoints[0];
  let prevType = $e1c6bbc8cb416f8c$var$getType(prev);
  let lv, ljmo, vjmo, tjmo;
  if (prevType === $e1c6bbc8cb416f8c$var$LV && type === $e1c6bbc8cb416f8c$var$T) {
    lv = prev;
    tjmo = glyph;
  } else {
    if (type === $e1c6bbc8cb416f8c$var$V) {
      ljmo = glyphs[i2 - 1];
      vjmo = glyph;
    } else {
      ljmo = glyphs[i2 - 2];
      vjmo = glyphs[i2 - 1];
      tjmo = glyph;
    }
    let l2 = ljmo.codePoints[0];
    let v2 = vjmo.codePoints[0];
    if ($e1c6bbc8cb416f8c$var$isCombiningL(l2) && $e1c6bbc8cb416f8c$var$isCombiningV(v2)) lv = $e1c6bbc8cb416f8c$var$HANGUL_BASE + ((l2 - $e1c6bbc8cb416f8c$var$L_BASE) * $e1c6bbc8cb416f8c$var$V_COUNT + (v2 - $e1c6bbc8cb416f8c$var$V_BASE)) * $e1c6bbc8cb416f8c$var$T_COUNT;
  }
  let t2 = tjmo && tjmo.codePoints[0] || $e1c6bbc8cb416f8c$var$T_BASE;
  if (lv != null && (t2 === $e1c6bbc8cb416f8c$var$T_BASE || $e1c6bbc8cb416f8c$var$isCombiningT(t2))) {
    let s2 = lv + (t2 - $e1c6bbc8cb416f8c$var$T_BASE);
    if (font.hasGlyphForCodePoint(s2)) {
      let del = prevType === $e1c6bbc8cb416f8c$var$V ? 3 : 2;
      glyphs.splice(i2 - del + 1, del, $e1c6bbc8cb416f8c$var$getGlyph(font, s2, glyph.features));
      return i2 - del + 1;
    }
  }
  if (ljmo) ljmo.features.ljmo = true;
  if (vjmo) vjmo.features.vjmo = true;
  if (tjmo) tjmo.features.tjmo = true;
  if (prevType === $e1c6bbc8cb416f8c$var$LV) {
    $e1c6bbc8cb416f8c$var$decompose(glyphs, i2 - 1, font);
    return i2 + 1;
  }
  return i2;
}
function $e1c6bbc8cb416f8c$var$getLength(code) {
  switch ($e1c6bbc8cb416f8c$var$getType(code)) {
    case $e1c6bbc8cb416f8c$var$LV:
    case $e1c6bbc8cb416f8c$var$LVT:
      return 1;
    case $e1c6bbc8cb416f8c$var$V:
      return 2;
    case $e1c6bbc8cb416f8c$var$T:
      return 3;
  }
}
function $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i2, font) {
  let glyph = glyphs[i2];
  let code = glyphs[i2].codePoints[0];
  if (font.glyphForCodePoint(code).advanceWidth === 0) return;
  let prev = glyphs[i2 - 1].codePoints[0];
  let len = $e1c6bbc8cb416f8c$var$getLength(prev);
  glyphs.splice(i2, 1);
  return glyphs.splice(i2 - len, 0, glyph);
}
function $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i2, font) {
  let glyph = glyphs[i2];
  let code = glyphs[i2].codePoints[0];
  if (font.hasGlyphForCodePoint($e1c6bbc8cb416f8c$var$DOTTED_CIRCLE)) {
    let dottedCircle = $e1c6bbc8cb416f8c$var$getGlyph(font, $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE, glyph.features);
    let idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i2 : i2 + 1;
    glyphs.splice(idx, 0, dottedCircle);
    i2++;
  }
  return i2;
}
var $4b0735ca6c692ea5$exports = {};
$4b0735ca6c692ea5$exports = JSON.parse('{"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,14,15,16,17],[0,0,0,18,19,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,28,29,30,31,32,33,0,34,0,0,35,36,0,0,37,0],[0,0,0,38,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,39,0,0,0,40,41,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,12,43,0,0,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,0,43,0,0,0,0],[0,0,0,45,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,50,0,0,51,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,0],[0,0,0,53,54,55,56,57,58,0,59,0,0,60,61,0,0,62,0],[0,0,0,4,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,63,64,0,0,40,41,0,9,0,10,0,0,0,42,0,63,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,0,2,16,0],[0,0,0,18,65,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,0,0],[0,0,0,69,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,73,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,75,0,0,0,76,77,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,25,79,0,0,0,0],[0,0,0,18,19,20,74,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,81,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,86,0,0,87,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,0],[0,0,0,18,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,89,90,0,0,76,77,0,23,0,24,0,0,0,78,0,89,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,0,0],[0,0,0,94,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,96,0,0,0,97,98,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,35,100,0,0,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,102,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,107,0,0,108,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,109,0,0,0,0,0,0,0,0],[0,0,0,28,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,110,111,0,0,97,98,0,33,0,34,0,0,0,99,0,110,0,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,0,0],[0,0,0,0,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,0,0,115,116,117,118,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,39,0,122,0,123,123,8,9,0,10,0,0,0,42,0,39,0,0],[0,124,64,0,0,0,0,0,0,0,0,0,0,0,0,0,124,0,0],[0,39,0,0,0,121,125,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,126,126,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,47,47,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,128,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,129,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,50,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,134,0,0,0,0,0,0,0,0],[0,0,0,135,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,136,0,0,0,137,138,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,60,140,0,0,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,0,140,0,0,0,0],[0,0,0,142,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,147,0,0,148,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,149,0,0,0,0,0,0,0,0],[0,0,0,53,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,150,151,0,0,137,138,0,58,0,59,0,0,0,139,0,150,0,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,0,0],[0,0,0,155,116,156,157,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,75,3,4,5,159,160,8,161,0,162,0,11,12,163,0,75,16,0],[0,0,0,0,0,40,164,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,0,165,0,0,0,0],[0,124,64,0,0,40,164,0,9,0,10,0,0,0,42,0,124,0,0],[0,0,0,0,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,167,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,168,0,0,0,0,0,0,0,0],[0,0,0,0,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,0,79,0,0,0,0],[0,0,0,169,170,171,172,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,75,0,176,0,177,177,22,23,0,24,0,0,0,78,0,75,0,0],[0,178,90,0,0,0,0,0,0,0,0,0,0,0,0,0,178,0,0],[0,75,0,0,0,175,179,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,180,180,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,83,83,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,182,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,183,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,86,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,188,0,0,0,0,0,0,0,0],[0,0,0,189,170,190,191,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,76,193,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,0,194,0,0,0,0],[0,178,90,0,0,76,193,0,23,0,24,0,0,0,78,0,178,0,0],[0,0,0,0,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,195,196,197,198,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,96,0,202,0,203,203,32,33,0,34,0,0,0,99,0,96,0,0],[0,204,111,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0],[0,96,0,0,0,201,205,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,206,206,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,104,104,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,208,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,209,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,107,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,214,0,0,0,0,0,0,0,0],[0,0,0,215,196,216,217,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,97,219,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,0,220,0,0,0,0],[0,204,111,0,0,97,219,0,33,0,34,0,0,0,99,0,204,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,223,0,0,0,40,224,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,119,225,0,0,0,0],[0,0,0,115,116,117,222,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,115,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,226,64,0,0,40,224,0,9,0,10,0,0,0,42,0,226,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,39,0,0,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,44,44,8,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,227,0,228,229,0,9,0,10,0,0,230,0,0,0,0,0],[0,39,0,122,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,231,231,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,131,131,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,234,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,235,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,0,0,240,241,242,243,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,136,0,247,0,248,248,57,58,0,59,0,0,0,139,0,136,0,0],[0,249,151,0,0,0,0,0,0,0,0,0,0,0,0,0,249,0,0],[0,136,0,0,0,246,250,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,251,251,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,144,144,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,253,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,254,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,147,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,259,0,0,0,0,0,0,0,0],[0,0,0,260,241,261,262,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,137,264,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,0,265,0,0,0,0],[0,249,151,0,0,137,264,0,58,0,59,0,0,0,139,0,249,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,158,225,0,0,0,0],[0,0,0,155,116,156,222,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,155,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,43,266,266,8,161,0,24,0,0,12,267,0,0,0,0],[0,75,0,176,43,268,268,269,161,0,24,0,0,0,267,0,75,0,0],[0,0,0,0,0,270,0,0,271,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,272,0,0,0,0,0,0,0,0],[0,273,274,0,0,40,41,0,9,0,10,0,0,0,42,0,273,0,0],[0,0,0,40,0,123,123,8,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,121,275,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,276,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,279,0,0,0,76,280,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,173,281,0,0,0,0],[0,0,0,169,170,171,278,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,169,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,282,90,0,0,76,280,0,23,0,24,0,0,0,78,0,282,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,75,0,0,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,80,80,22,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,283,0,284,285,0,23,0,24,0,0,286,0,0,0,0,0],[0,75,0,176,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,287,287,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,288,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,185,185,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,290,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,291,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,192,281,0,0,0,0],[0,0,0,189,170,190,278,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,189,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,76,0,177,177,22,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,175,296,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,299,0,0,0,97,300,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,199,301,0,0,0,0],[0,0,0,195,196,197,298,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,195,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,302,111,0,0,97,300,0,33,0,34,0,0,0,99,0,302,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,96,0,0,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,101,101,32,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,303,0,304,305,0,33,0,34,0,0,306,0,0,0,0,0],[0,96,0,202,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,307,307,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,308,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,211,211,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,310,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,311,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,218,301,0,0,0,0],[0,0,0,215,196,216,298,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,215,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,97,0,203,203,32,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,201,316,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,0,225,0,0,0,0],[0,0,0,317,318,319,320,8,9,0,10,0,0,321,322,0,0,16,0],[0,223,0,323,0,123,123,8,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,0,0,121,324,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,325,318,326,327,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,64,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,230,0,0,0,0,0],[0,0,0,227,0,228,121,0,9,0,10,0,0,230,0,0,0,0,0],[0,0,0,227,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,0,0],[0,0,0,0,0,329,329,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,330,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,237,237,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,332,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,333,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,337,0,0,0,137,338,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,244,339,0,0,0,0],[0,0,0,240,241,242,336,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,240,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,340,151,0,0,137,338,0,58,0,59,0,0,0,139,0,340,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,136,0,0,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,141,141,57,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,341,0,342,343,0,58,0,59,0,0,344,0,0,0,0,0],[0,136,0,247,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,345,345,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,346,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,256,256,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,348,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,349,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,263,339,0,0,0,0],[0,0,0,260,241,261,336,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,260,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,137,0,248,248,57,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,246,354,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,126,126,8,23,0,0,0,0,0,0,0,0,0,0],[0,355,90,0,0,121,125,0,9,0,10,0,0,0,42,0,355,0,0],[0,0,0,0,0,356,356,269,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,357,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,270,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,363,0,0,0,0,0,0,0,0],[0,0,0,364,116,365,366,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,40,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,0,281,0,0,0,0],[0,0,0,369,370,371,372,22,23,0,24,0,0,373,374,0,0,27,0],[0,279,0,375,0,177,177,22,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,0,0,175,376,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,377,370,378,379,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,90,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,286,0,0,0,0,0],[0,0,0,283,0,284,175,0,23,0,24,0,0,286,0,0,0,0,0],[0,0,0,283,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,82,0,0],[0,0,0,0,0,381,381,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,382,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,293,293,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,384,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,385,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,76,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,0,301,0,0,0,0],[0,0,0,387,388,389,390,32,33,0,34,0,0,391,392,0,0,37,0],[0,299,0,393,0,203,203,32,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,0,0,201,394,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,395,388,396,397,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,111,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,306,0,0,0,0,0],[0,0,0,303,0,304,201,0,33,0,34,0,0,306,0,0,0,0,0],[0,0,0,303,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,0,0],[0,0,0,0,0,399,399,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,400,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,313,313,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,402,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,403,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,97,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,407,0,0,0,40,408,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,321,409,0,0,0,0],[0,0,0,317,318,319,406,8,9,0,10,0,0,321,322,0,0,16,0],[0,0,0,317,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,410,64,0,0,40,408,0,9,0,10,0,0,0,42,0,410,0,0],[0,223,0,0,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,323,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,328,409,0,0,0,0],[0,0,0,325,318,326,406,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,325,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,0,0,0,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0],[0,0,0,0,0,411,411,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,412,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,413,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,0,339,0,0,0,0],[0,0,0,414,415,416,417,57,58,0,59,0,0,418,419,0,0,62,0],[0,337,0,420,0,248,248,57,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,0,0,246,421,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,422,415,423,424,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,151,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,344,0,0,0,0,0],[0,0,0,341,0,342,246,0,58,0,59,0,0,344,0,0,0,0,0],[0,0,0,341,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,143,0,0],[0,0,0,0,0,426,426,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,427,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,351,351,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,429,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,430,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,137,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,432,116,433,434,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,0,0,180,180,269,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,359,359,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,437,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,438,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,443,274,0,0,0,0,0,0,0,0,0,0,0,0,0,443,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,367,225,0,0,0,0],[0,0,0,364,116,365,445,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,364,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,448,0,0,0,76,449,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,373,450,0,0,0,0],[0,0,0,369,370,371,447,22,23,0,24,0,0,373,374,0,0,27,0],[0,0,0,369,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,451,90,0,0,76,449,0,23,0,24,0,0,0,78,0,451,0,0],[0,279,0,0,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,375,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,380,450,0,0,0,0],[0,0,0,377,370,378,447,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,377,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,0,0,0,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,184,0,0],[0,0,0,0,0,452,452,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,453,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,454,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,457,0,0,0,97,458,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,391,459,0,0,0,0],[0,0,0,387,388,389,456,32,33,0,34,0,0,391,392,0,0,37,0],[0,0,0,387,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,460,111,0,0,97,458,0,33,0,34,0,0,0,99,0,460,0,0],[0,299,0,0,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,393,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,398,459,0,0,0,0],[0,0,0,395,388,396,456,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,395,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,0,0,0,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,210,0,0],[0,0,0,0,0,461,461,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,462,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,463,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,0,409,0,0,0,0],[0,0,0,464,465,466,467,8,9,0,10,0,0,468,469,0,0,16,0],[0,407,0,470,0,123,123,8,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,0,0,121,471,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,472,465,473,474,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,0,0,0,0,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,236,0,0],[0,0,0,0,0,0,476,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,479,0,0,0,137,480,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,418,481,0,0,0,0],[0,0,0,414,415,416,478,57,58,0,59,0,0,418,419,0,0,62,0],[0,0,0,414,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,482,151,0,0,137,480,0,58,0,59,0,0,0,139,0,482,0,0],[0,337,0,0,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,420,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,425,481,0,0,0,0],[0,0,0,422,415,423,478,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,422,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,0,0,0,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0],[0,0,0,0,0,483,483,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,484,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,485,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,435,225,0,0,0,0],[0,0,0,432,116,433,445,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,432,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,486,486,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,487,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,440,440,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,489,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,490,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,495,0,496,497,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,0,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,0,225,0,0,0,0],[0,0,0,0,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,0,450,0,0,0,0],[0,0,0,499,500,501,502,22,23,0,24,0,0,503,504,0,0,27,0],[0,448,0,505,0,177,177,22,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,0,0,175,506,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,507,500,508,509,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,0,0,0,0,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,292,0,0],[0,0,0,0,0,0,511,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,0,459,0,0,0,0],[0,0,0,512,513,514,515,32,33,0,34,0,0,516,517,0,0,37,0],[0,457,0,518,0,203,203,32,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,0,0,201,519,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,520,513,521,522,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,0,0,0,0,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,312,0,0],[0,0,0,0,0,0,524,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,527,0,0,0,40,528,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,468,529,0,0,0,0],[0,0,0,464,465,466,526,8,9,0,10,0,0,468,469,0,0,16,0],[0,0,0,464,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,530,64,0,0,40,528,0,9,0,10,0,0,0,42,0,530,0,0],[0,407,0,0,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,470,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,475,529,0,0,0,0],[0,0,0,472,465,473,526,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,472,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,0,0],[0,0,0,0,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,0,481,0,0,0,0],[0,0,0,531,532,533,534,57,58,0,59,0,0,535,536,0,0,62,0],[0,479,0,537,0,248,248,57,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,0,0,246,538,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,539,532,540,541,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,0,0,0,0,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,350,0,0],[0,0,0,0,0,0,543,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,358,0,0],[0,0,0,0,0,544,544,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,545,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,492,492,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,547,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,548,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,274,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,498,0,0,0,0,0],[0,0,0,495,0,496,368,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,495,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,553,0,0,0,76,554,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,503,555,0,0,0,0],[0,0,0,499,500,501,552,22,23,0,24,0,0,503,504,0,0,27,0],[0,0,0,499,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,556,90,0,0,76,554,0,23,0,24,0,0,0,78,0,556,0,0],[0,448,0,0,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,505,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,510,555,0,0,0,0],[0,0,0,507,500,508,552,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,507,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,76,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,559,0,0,0,97,560,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,516,561,0,0,0,0],[0,0,0,512,513,514,558,32,33,0,34,0,0,516,517,0,0,37,0],[0,0,0,512,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,562,111,0,0,97,560,0,33,0,34,0,0,0,99,0,562,0,0],[0,457,0,0,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,518,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,523,561,0,0,0,0],[0,0,0,520,513,521,558,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,520,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,0,0],[0,0,0,0,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,0,529,0,0,0,0],[0,0,0,563,66,564,565,8,9,0,10,0,0,566,68,0,0,16,0],[0,527,0,567,0,123,123,8,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,0,0,121,568,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,569,66,570,571,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,575,0,0,0,137,576,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,535,577,0,0,0,0],[0,0,0,531,532,533,574,57,58,0,59,0,0,535,536,0,0,62,0],[0,0,0,531,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,578,151,0,0,137,576,0,58,0,59,0,0,0,139,0,578,0,0],[0,479,0,0,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,537,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,542,577,0,0,0,0],[0,0,0,539,532,540,574,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,539,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,137,0,0],[0,0,0,0,0,0,0,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,439,0,0],[0,0,0,0,0,579,579,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,580,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,581,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,0,555,0,0,0,0],[0,0,0,582,91,583,584,22,23,0,24,0,0,585,93,0,0,27,0],[0,553,0,586,0,177,177,22,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,0,0,175,587,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,588,91,589,590,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,0,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,0,561,0,0,0,0],[0,0,0,592,112,593,594,32,33,0,34,0,0,595,114,0,0,37,0],[0,559,0,596,0,203,203,32,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,0,0,201,597,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,598,112,599,600,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,566,165,0,0,0,0],[0,0,0,563,66,564,67,8,9,0,10,0,0,566,68,0,0,16,0],[0,0,0,563,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,527,0,0,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,567,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,572,165,0,0,0,0],[0,0,0,569,66,570,67,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,569,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,0,577,0,0,0,0],[0,0,0,603,152,604,605,57,58,0,59,0,0,606,154,0,0,62,0],[0,575,0,607,0,248,248,57,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,0,0,246,608,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,609,152,610,611,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,0,0,0,0,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,491,0,0],[0,0,0,0,0,0,613,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,585,194,0,0,0,0],[0,0,0,582,91,583,92,22,23,0,24,0,0,585,93,0,0,27,0],[0,0,0,582,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,553,0,0,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,586,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,591,194,0,0,0,0],[0,0,0,588,91,589,92,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,588,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,595,220,0,0,0,0],[0,0,0,592,112,593,113,32,33,0,34,0,0,595,114,0,0,37,0],[0,0,0,592,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,559,0,0,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,596,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,601,220,0,0,0,0],[0,0,0,598,112,599,113,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,598,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,606,265,0,0,0,0],[0,0,0,603,152,604,153,57,58,0,59,0,0,606,154,0,0,62,0],[0,0,0,603,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,575,0,0,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,607,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,612,265,0,0,0,0],[0,0,0,609,152,610,153,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,609,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,549,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0]],"accepting":[false,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,false,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,false,false,true,false,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,false,false,true,true,false,false,true,true,true,false,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,false,false,false,false,false,false,false,true,true,false,false,true,true,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,false,true,true,false,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,false,true,true,true,true,true,false,true,true,false,true,true,true],"tags":[[],["broken_cluster"],["consonant_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],[],["broken_cluster"],["symbol_cluster"],[],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["symbol_cluster"],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],[],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],[],[],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],["consonant_syllable"],["vowel_syllable"],["standalone_cluster"]]}');
var $aa333a9607471296$exports = {};
$aa333a9607471296$exports = JSON.parse('{"categories":["O","IND","S","GB","B","FM","CGJ","VMAbv","VMPst","VAbv","VPst","CMBlw","VPre","VBlw","H","VMBlw","CMAbv","MBlw","CS","R","SUB","MPst","MPre","FAbv","FPst","FBlw","null","SMAbv","SMBlw","VMPre","ZWNJ","ZWJ","WJ","M","VS","N","HN","MAbv"],"decompositions":{"2507":[2503,2494],"2508":[2503,2519],"2888":[2887,2902],"2891":[2887,2878],"2892":[2887,2903],"3018":[3014,3006],"3019":[3015,3006],"3020":[3014,3031],"3144":[3142,3158],"3264":[3263,3285],"3271":[3270,3285],"3272":[3270,3286],"3274":[3270,3266],"3275":[3270,3266,3285],"3402":[3398,3390],"3403":[3399,3390],"3404":[3398,3415],"3546":[3545,3530],"3548":[3545,3535],"3549":[3545,3535,3530],"3550":[3545,3551],"3635":[3661,3634],"3763":[3789,3762],"3955":[3953,3954],"3957":[3953,3956],"3958":[4018,3968],"3959":[4018,3953,3968],"3960":[4019,3968],"3961":[4019,3953,3968],"3969":[3953,3968],"6971":[6970,6965],"6973":[6972,6965],"6976":[6974,6965],"6977":[6975,6965],"6979":[6978,6965],"69934":[69937,69927],"69935":[69938,69927],"70475":[70471,70462],"70476":[70471,70487],"70843":[70841,70842],"70844":[70841,70832],"70846":[70841,70845],"71098":[71096,71087],"71099":[71097,71087]},"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,2,3,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,17,18,11,19,20,21,22,0,0,0,23,0,0,2,0,0,24,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,27,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,39,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,49,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,22,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,0,23,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,53,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,45,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,0,46,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,0,23,0,0,0,0,0,0,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,54,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,0,46,0,0,0,0,0,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0]],"accepting":[false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true],"tags":[[],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["symbol_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["virama_terminated_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["number_joiner_terminated_cluster"],["standard_cluster"],["standard_cluster"],["numeral_cluster"]]}');
const $90a9d3398ee54fe5$export$a513ea61a7bee91c = {
  X: 1,
  C: 2,
  V: 4,
  N: 8,
  H: 16,
  ZWNJ: 32,
  ZWJ: 64,
  M: 128,
  Placeholder: 2048,
  Dotted_Circle: 4096,
  RS: 8192,
  Coeng: 16384,
  Repha: 32768,
  Ra: 65536,
  CM: 131072
};
const $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0 = {
  Start: 1,
  Ra_To_Become_Reph: 2,
  Pre_M: 4,
  Pre_C: 8,
  Base_C: 16,
  After_Main: 32,
  Before_Sub: 128,
  Below_C: 256,
  After_Sub: 512,
  Before_Post: 1024,
  Post_C: 2048,
  After_Post: 4096,
  Final_C: 8192,
  SMVD: 16384,
  End: 32768
};
const $90a9d3398ee54fe5$export$8519deaa7de2b07 = $90a9d3398ee54fe5$export$a513ea61a7bee91c.C | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Ra | $90a9d3398ee54fe5$export$a513ea61a7bee91c.CM | $90a9d3398ee54fe5$export$a513ea61a7bee91c.V | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Placeholder | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Dotted_Circle;
const $90a9d3398ee54fe5$export$bbcd928767338e0d = $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWJ | $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWNJ;
const $90a9d3398ee54fe5$export$ca9599b2a300afc = $90a9d3398ee54fe5$export$a513ea61a7bee91c.H | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Coeng;
const $90a9d3398ee54fe5$export$e99d119da76a0fc5 = {
  Default: {
    hasOldSpec: false,
    virama: 0,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Devanagari: {
    hasOldSpec: true,
    virama: 2381,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Bengali: {
    hasOldSpec: true,
    virama: 2509,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gurmukhi: {
    hasOldSpec: true,
    virama: 2637,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gujarati: {
    hasOldSpec: true,
    virama: 2765,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Oriya: {
    hasOldSpec: true,
    virama: 2893,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Tamil: {
    hasOldSpec: true,
    virama: 3021,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Telugu: {
    hasOldSpec: true,
    virama: 3149,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Explicit",
    blwfMode: "Post_Only"
  },
  Kannada: {
    hasOldSpec: true,
    virama: 3277,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Implicit",
    blwfMode: "Post_Only"
  },
  Malayalam: {
    hasOldSpec: true,
    virama: 3405,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
    rephMode: "Log_Repha",
    blwfMode: "Pre_And_Post"
  },
  // Handled by UniversalShaper
  // Sinhala: {
  //   hasOldSpec: false,
  //   virama: 0x0DCA,
  //   basePos: 'Last_Sinhala',
  //   rephPos: POSITIONS.After_Main,
  //   rephMode: 'Explicit',
  //   blwfMode: 'Pre_And_Post'
  // },
  Khmer: {
    hasOldSpec: false,
    virama: 6098,
    basePos: "First",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Ra_To_Become_Reph,
    rephMode: "Vis_Repha",
    blwfMode: "Pre_And_Post"
  }
};
const $90a9d3398ee54fe5$export$f647c9cfdd77d95a = {
  // Khmer
  6078: [
    6081,
    6078
  ],
  6079: [
    6081,
    6079
  ],
  6080: [
    6081,
    6080
  ],
  6084: [
    6081,
    6084
  ],
  6085: [
    6081,
    6085
  ]
};
const { decompositions: $7826f90f6f0cecc9$var$decompositions } = /* @__PURE__ */ $parcel$interopDefault($aa333a9607471296$exports);
const $7826f90f6f0cecc9$var$trie = new $hJqJp$unicodetrie($12727730ddfc8bfe$export$94fdf11bafc8de6b("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"));
const $7826f90f6f0cecc9$var$stateMachine = new $6uUbQ$dfa(/* @__PURE__ */ $parcel$interopDefault($4b0735ca6c692ea5$exports));
class $7826f90f6f0cecc9$export$2e2bcd8739ae039 extends $649970d87335b30f$export$2e2bcd8739ae039 {
  static planFeatures(plan) {
    plan.addStage($7826f90f6f0cecc9$var$setupSyllables);
    plan.addStage([
      "locl",
      "ccmp"
    ]);
    plan.addStage($7826f90f6f0cecc9$var$initialReordering);
    plan.addStage("nukt");
    plan.addStage("akhn");
    plan.addStage("rphf", false);
    plan.addStage("rkrf");
    plan.addStage("pref", false);
    plan.addStage("blwf", false);
    plan.addStage("abvf", false);
    plan.addStage("half", false);
    plan.addStage("pstf", false);
    plan.addStage("vatu");
    plan.addStage("cjct");
    plan.addStage("cfar", false);
    plan.addStage($7826f90f6f0cecc9$var$finalReordering);
    plan.addStage({
      local: [
        "init"
      ],
      global: [
        "pres",
        "abvs",
        "blws",
        "psts",
        "haln",
        "dist",
        "abvm",
        "blwm",
        "calt",
        "clig"
      ]
    });
    plan.unicodeScript = $130d1a642ebcd2b7$export$ce50e82f12a827a4(plan.script);
    plan.indicConfig = $90a9d3398ee54fe5$export$e99d119da76a0fc5[plan.unicodeScript] || $90a9d3398ee54fe5$export$e99d119da76a0fc5.Default;
    plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== "2";
  }
  static assignFeatures(plan, glyphs) {
    for (let i2 = glyphs.length - 1; i2 >= 0; i2--) {
      let codepoint = glyphs[i2].codePoints[0];
      let d2 = $90a9d3398ee54fe5$export$f647c9cfdd77d95a[codepoint] || $7826f90f6f0cecc9$var$decompositions[codepoint];
      if (d2) {
        let decomposed = d2.map((c2) => {
          let g = plan.font.glyphForCodePoint(c2);
          return new $10e7b257e1a9a756$export$2e2bcd8739ae039(plan.font, g.id, [
            c2
          ], glyphs[i2].features);
        });
        glyphs.splice(i2, 1, ...decomposed);
      }
    }
  }
}
_define_property($7826f90f6f0cecc9$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
function $7826f90f6f0cecc9$var$indicCategory(glyph) {
  return $7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) >> 8;
}
function $7826f90f6f0cecc9$var$indicPosition(glyph) {
  return 1 << ($7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) & 255);
}
class $7826f90f6f0cecc9$var$IndicInfo {
  constructor(category, position, syllableType, syllable) {
    this.category = category;
    this.position = position;
    this.syllableType = syllableType;
    this.syllable = syllable;
  }
}
function $7826f90f6f0cecc9$var$setupSyllables(font, glyphs) {
  let syllable = 0;
  let last2 = 0;
  for (let [start2, end2, tags2] of $7826f90f6f0cecc9$var$stateMachine.match(glyphs.map($7826f90f6f0cecc9$var$indicCategory))) {
    if (start2 > last2) {
      ++syllable;
      for (let i2 = last2; i2 < start2; i2++) glyphs[i2].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo($90a9d3398ee54fe5$export$a513ea61a7bee91c.X, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.End, "non_indic_cluster", syllable);
    }
    ++syllable;
    for (let i2 = start2; i2 <= end2; i2++) glyphs[i2].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(glyphs[i2]), $7826f90f6f0cecc9$var$indicPosition(glyphs[i2]), tags2[0], syllable);
    last2 = end2 + 1;
  }
  if (last2 < glyphs.length) {
    ++syllable;
    for (let i2 = last2; i2 < glyphs.length; i2++) glyphs[i2].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo($90a9d3398ee54fe5$export$a513ea61a7bee91c.X, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.End, "non_indic_cluster", syllable);
  }
}
function $7826f90f6f0cecc9$var$isConsonant(glyph) {
  return glyph.shaperInfo.category & $90a9d3398ee54fe5$export$8519deaa7de2b07;
}
function $7826f90f6f0cecc9$var$isJoiner(glyph) {
  return glyph.shaperInfo.category & $90a9d3398ee54fe5$export$bbcd928767338e0d;
}
function $7826f90f6f0cecc9$var$isHalantOrCoeng(glyph) {
  return glyph.shaperInfo.category & $90a9d3398ee54fe5$export$ca9599b2a300afc;
}
function $7826f90f6f0cecc9$var$wouldSubstitute(glyphs, feature) {
  for (let glyph of glyphs) glyph.features = {
    [feature]: true
  };
  let GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;
  GSUB.applyFeatures([
    feature
  ], glyphs);
  return glyphs.length === 1;
}
function $7826f90f6f0cecc9$var$consonantPosition(font, consonant, virama) {
  let glyphs = [
    virama,
    consonant,
    virama
  ];
  if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "blwf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "blwf")) return $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Below_C;
  else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pstf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pstf")) return $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Post_C;
  else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pref") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pref")) return $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Post_C;
  return $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Base_C;
}
function $7826f90f6f0cecc9$var$initialReordering(font, glyphs, plan) {
  let indicConfig = plan.indicConfig;
  let features = font._layoutEngine.engine.GSUBProcessor.features;
  let dottedCircle = font.glyphForCodePoint(9676).id;
  let virama = font.glyphForCodePoint(indicConfig.virama).id;
  if (virama) {
    let info = new $10e7b257e1a9a756$export$2e2bcd8739ae039(font, virama, [
      indicConfig.virama
    ]);
    for (let i2 = 0; i2 < glyphs.length; i2++) if (glyphs[i2].shaperInfo.position === $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Base_C) glyphs[i2].shaperInfo.position = $7826f90f6f0cecc9$var$consonantPosition(font, glyphs[i2].copy(), info);
  }
  for (let start2 = 0, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start2 < glyphs.length; start2 = end2, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start2)) {
    let { category, syllableType } = glyphs[start2].shaperInfo;
    if (syllableType === "symbol_cluster" || syllableType === "non_indic_cluster") continue;
    if (syllableType === "broken_cluster" && dottedCircle) {
      let g = new $10e7b257e1a9a756$export$2e2bcd8739ae039(font, dottedCircle, [
        9676
      ]);
      g.shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(g), $7826f90f6f0cecc9$var$indicPosition(g), glyphs[start2].shaperInfo.syllableType, glyphs[start2].shaperInfo.syllable);
      let i2 = start2;
      while (i2 < end2 && glyphs[i2].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.Repha) i2++;
      glyphs.splice(i2++, 0, g);
      end2++;
    }
    let base = end2;
    let limit = start2;
    let hasReph = false;
    if (indicConfig.rephPos !== $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Ra_To_Become_Reph && features.rphf && start2 + 3 <= end2 && (indicConfig.rephMode === "Implicit" && !$7826f90f6f0cecc9$var$isJoiner(glyphs[start2 + 2]) || indicConfig.rephMode === "Explicit" && glyphs[start2 + 2].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWJ)) {
      let g = [
        glyphs[start2].copy(),
        glyphs[start2 + 1].copy(),
        glyphs[start2 + 2].copy()
      ];
      if ($7826f90f6f0cecc9$var$wouldSubstitute(g.slice(0, 2), "rphf") || indicConfig.rephMode === "Explicit" && $7826f90f6f0cecc9$var$wouldSubstitute(g, "rphf")) {
        limit += 2;
        while (limit < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit])) limit++;
        base = start2;
        hasReph = true;
      }
    } else if (indicConfig.rephMode === "Log_Repha" && glyphs[start2].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.Repha) {
      limit++;
      while (limit < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit])) limit++;
      base = start2;
      hasReph = true;
    }
    switch (indicConfig.basePos) {
      case "Last": {
        let i2 = end2;
        let seenBelow = false;
        do {
          let info = glyphs[--i2].shaperInfo;
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i2])) {
            if (info.position !== $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Below_C && (info.position !== $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Post_C || seenBelow)) {
              base = i2;
              break;
            }
            if (info.position === $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Below_C) seenBelow = true;
            base = i2;
          } else if (start2 < i2 && info.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWJ && glyphs[i2 - 1].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.H) break;
        } while (i2 > limit);
        break;
      }
      case "First":
        base = start2;
        for (let i2 = base + 1; i2 < end2; i2++) if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i2])) glyphs[i2].shaperInfo.position = $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Below_C;
    }
    if (hasReph && base === start2 && limit - base <= 2) hasReph = false;
    for (let i2 = start2; i2 < base; i2++) {
      let info = glyphs[i2].shaperInfo;
      info.position = Math.min($90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Pre_C, info.position);
    }
    if (base < end2) glyphs[base].shaperInfo.position = $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Base_C;
    for (let i2 = base + 1; i2 < end2; i2++) if (glyphs[i2].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.M) {
      for (let j = i2 + 1; j < end2; j++) if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j])) {
        glyphs[j].shaperInfo.position = $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Final_C;
        break;
      }
      break;
    }
    if (hasReph) glyphs[start2].shaperInfo.position = $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Ra_To_Become_Reph;
    if (plan.isOldSpec) {
      let disallowDoubleHalants = plan.unicodeScript !== "Malayalam";
      for (let i2 = base + 1; i2 < end2; i2++) if (glyphs[i2].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.H) {
        let j;
        for (j = end2 - 1; j > i2; j--) {
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j]) || disallowDoubleHalants && glyphs[j].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.H) break;
        }
        if (glyphs[j].shaperInfo.category !== $90a9d3398ee54fe5$export$a513ea61a7bee91c.H && j > i2) {
          let t2 = glyphs[i2];
          glyphs.splice(i2, 0, ...glyphs.splice(i2 + 1, j - i2));
          glyphs[j] = t2;
        }
        break;
      }
    }
    let lastPos = $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Start;
    for (let i2 = start2; i2 < end2; i2++) {
      let info = glyphs[i2].shaperInfo;
      if (info.category & ($90a9d3398ee54fe5$export$bbcd928767338e0d | $90a9d3398ee54fe5$export$a513ea61a7bee91c.N | $90a9d3398ee54fe5$export$a513ea61a7bee91c.RS | $90a9d3398ee54fe5$export$a513ea61a7bee91c.CM | $90a9d3398ee54fe5$export$ca9599b2a300afc & info.category)) {
        info.position = lastPos;
        if (info.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.H && info.position === $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Pre_M) {
          for (let j = i2; j > start2; j--) if (glyphs[j - 1].shaperInfo.position !== $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Pre_M) {
            info.position = glyphs[j - 1].shaperInfo.position;
            break;
          }
        }
      } else if (info.position !== $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.SMVD) lastPos = info.position;
    }
    let last2 = base;
    for (let i2 = base + 1; i2 < end2; i2++) {
      if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i2])) {
        for (let j = last2 + 1; j < i2; j++) if (glyphs[j].shaperInfo.position < $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.SMVD) glyphs[j].shaperInfo.position = glyphs[i2].shaperInfo.position;
        last2 = i2;
      } else if (glyphs[i2].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.M) last2 = i2;
    }
    let arr = glyphs.slice(start2, end2);
    arr.sort((a2, b2) => a2.shaperInfo.position - b2.shaperInfo.position);
    glyphs.splice(start2, arr.length, ...arr);
    for (let i2 = start2; i2 < end2; i2++) if (glyphs[i2].shaperInfo.position === $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Base_C) {
      base = i2;
      break;
    }
    for (let i2 = start2; i2 < end2 && glyphs[i2].shaperInfo.position === $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Ra_To_Become_Reph; i2++) glyphs[i2].features.rphf = true;
    let blwf = !plan.isOldSpec && indicConfig.blwfMode === "Pre_And_Post";
    for (let i2 = start2; i2 < base; i2++) {
      glyphs[i2].features.half = true;
      if (blwf) glyphs[i2].features.blwf = true;
    }
    for (let i2 = base + 1; i2 < end2; i2++) {
      glyphs[i2].features.abvf = true;
      glyphs[i2].features.pstf = true;
      glyphs[i2].features.blwf = true;
    }
    if (plan.isOldSpec && plan.unicodeScript === "Devanagari") {
      for (let i2 = start2; i2 + 1 < base; i2++) if (glyphs[i2].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.Ra && glyphs[i2 + 1].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.H && (i2 + 1 === base || glyphs[i2 + 2].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWJ)) {
        glyphs[i2].features.blwf = true;
        glyphs[i2 + 1].features.blwf = true;
      }
    }
    let prefLen = 2;
    if (features.pref && base + prefLen < end2)
      for (let i2 = base + 1; i2 + prefLen - 1 < end2; i2++) {
        let g = [
          glyphs[i2].copy(),
          glyphs[i2 + 1].copy()
        ];
        if ($7826f90f6f0cecc9$var$wouldSubstitute(g, "pref")) {
          for (let j = 0; j < prefLen; j++) glyphs[i2++].features.pref = true;
          if (features.cfar) for (; i2 < end2; i2++) glyphs[i2].features.cfar = true;
          break;
        }
      }
    for (let i2 = start2 + 1; i2 < end2; i2++) if ($7826f90f6f0cecc9$var$isJoiner(glyphs[i2])) {
      let nonJoiner = glyphs[i2].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWNJ;
      let j = i2;
      do {
        j--;
        if (nonJoiner) delete glyphs[j].features.half;
      } while (j > start2 && !$7826f90f6f0cecc9$var$isConsonant(glyphs[j]));
    }
  }
}
function $7826f90f6f0cecc9$var$finalReordering(font, glyphs, plan) {
  let indicConfig = plan.indicConfig;
  let features = font._layoutEngine.engine.GSUBProcessor.features;
  for (let start2 = 0, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start2 < glyphs.length; start2 = end2, end2 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start2)) {
    let tryPref = !!features.pref;
    let base = start2;
    for (; base < end2; base++) if (glyphs[base].shaperInfo.position >= $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Base_C) {
      if (tryPref && base + 1 < end2) {
        for (let i2 = base + 1; i2 < end2; i2++) if (glyphs[i2].features.pref) {
          if (!(glyphs[i2].substituted && glyphs[i2].isLigated && !glyphs[i2].isMultiplied)) {
            base = i2;
            while (base < end2 && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[base])) base++;
            glyphs[base].shaperInfo.position = $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.BASE_C;
            tryPref = false;
          }
          break;
        }
      }
      if (plan.unicodeScript === "Malayalam") for (let i2 = base + 1; i2 < end2; i2++) {
        while (i2 < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[i2])) i2++;
        if (i2 === end2 || !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[i2])) break;
        i2++;
        while (i2 < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[i2])) i2++;
        if (i2 < end2 && $7826f90f6f0cecc9$var$isConsonant(glyphs[i2]) && glyphs[i2].shaperInfo.position === $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Below_C) {
          base = i2;
          glyphs[base].shaperInfo.position = $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Base_C;
        }
      }
      if (start2 < base && glyphs[base].shaperInfo.position > $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Base_C) base--;
      break;
    }
    if (base === end2 && start2 < base && glyphs[base - 1].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWJ) base--;
    if (base < end2) while (start2 < base && glyphs[base].shaperInfo.category & ($90a9d3398ee54fe5$export$a513ea61a7bee91c.N | $90a9d3398ee54fe5$export$ca9599b2a300afc)) base--;
    if (start2 + 1 < end2 && start2 < base) {
      let newPos = base === end2 ? base - 2 : base - 1;
      if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
        while (newPos > start2 && !(glyphs[newPos].shaperInfo.category & ($90a9d3398ee54fe5$export$a513ea61a7bee91c.M | $90a9d3398ee54fe5$export$ca9599b2a300afc))) newPos--;
        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Pre_M) {
          if (newPos + 1 < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos + 1])) newPos++;
        } else newPos = start2;
      }
      if (start2 < newPos && glyphs[newPos].shaperInfo.position !== $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Pre_M) {
        for (let i2 = newPos; i2 > start2; i2--) if (glyphs[i2 - 1].shaperInfo.position === $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Pre_M) {
          let oldPos = i2 - 1;
          if (oldPos < base && base <= newPos) base--;
          let tmp = glyphs[oldPos];
          glyphs.splice(oldPos, 0, ...glyphs.splice(oldPos + 1, newPos - oldPos));
          glyphs[newPos] = tmp;
          newPos--;
        }
      }
    }
    if (start2 + 1 < end2 && glyphs[start2].shaperInfo.position === $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Ra_To_Become_Reph && glyphs[start2].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.Repha !== (glyphs[start2].isLigated && !glyphs[start2].isMultiplied)) {
      let newRephPos;
      let rephPos = indicConfig.rephPos;
      let found = false;
      if (rephPos !== $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post) {
        newRephPos = start2 + 1;
        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) newRephPos++;
        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1])) newRephPos++;
          found = true;
        }
        if (!found && rephPos === $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main) {
          newRephPos = base;
          while (newRephPos + 1 < end2 && glyphs[newRephPos + 1].shaperInfo.position <= $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main) newRephPos++;
          found = newRephPos < end2;
        }
        if (!found && rephPos === $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Sub) {
          newRephPos = base;
          while (newRephPos + 1 < end2 && !(glyphs[newRephPos + 1].shaperInfo.position & ($90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Post_C | $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post | $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.SMVD))) newRephPos++;
          found = newRephPos < end2;
        }
      }
      if (!found) {
        newRephPos = start2 + 1;
        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) newRephPos++;
        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1])) newRephPos++;
          found = true;
        }
      }
      if (!found) {
        newRephPos = end2 - 1;
        while (newRephPos > start2 && glyphs[newRephPos].shaperInfo.position === $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.SMVD) newRephPos--;
        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          for (let i2 = base + 1; i2 < newRephPos; i2++) if (glyphs[i2].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.M) newRephPos--;
        }
      }
      let reph = glyphs[start2];
      glyphs.splice(start2, 0, ...glyphs.splice(start2 + 1, newRephPos - start2));
      glyphs[newRephPos] = reph;
      if (start2 < base && base <= newRephPos) base--;
    }
    if (tryPref && base + 1 < end2) {
      for (let i2 = base + 1; i2 < end2; i2++) if (glyphs[i2].features.pref) {
        if (glyphs[i2].isLigated && !glyphs[i2].isMultiplied) {
          let newPos = base;
          if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
            while (newPos > start2 && !(glyphs[newPos - 1].shaperInfo.category & ($90a9d3398ee54fe5$export$a513ea61a7bee91c.M | $90a9d3398ee54fe5$export$ca9599b2a300afc))) newPos--;
            if (newPos > start2 && glyphs[newPos - 1].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.M) {
              let oldPos2 = i2;
              for (let j = base + 1; j < oldPos2; j++) if (glyphs[j].shaperInfo.category === $90a9d3398ee54fe5$export$a513ea61a7bee91c.M) {
                newPos--;
                break;
              }
            }
          }
          if (newPos > start2 && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos - 1])) {
            if (newPos < end2 && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos])) newPos++;
          }
          let oldPos = i2;
          let tmp = glyphs[oldPos];
          glyphs.splice(newPos + 1, 0, ...glyphs.splice(newPos, oldPos - newPos));
          glyphs[newPos] = tmp;
          if (newPos <= base && base < oldPos) base++;
        }
        break;
      }
    }
    if (glyphs[start2].shaperInfo.position === $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Pre_M && (!start2 || !/Cf|Mn/.test($747425b437e121da$export$410364bbb673ddbc(glyphs[start2 - 1].codePoints[0])))) glyphs[start2].features.init = true;
  }
}
function $7826f90f6f0cecc9$var$nextSyllable(glyphs, start2) {
  if (start2 >= glyphs.length) return start2;
  let syllable = glyphs[start2].shaperInfo.syllable;
  while (++start2 < glyphs.length && glyphs[start2].shaperInfo.syllable === syllable) ;
  return start2;
}
const { categories: $7ab494fe977143c6$var$categories, decompositions: $7ab494fe977143c6$var$decompositions } = /* @__PURE__ */ $parcel$interopDefault($aa333a9607471296$exports);
const $7ab494fe977143c6$var$trie = new $hJqJp$unicodetrie($12727730ddfc8bfe$export$94fdf11bafc8de6b("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"));
const $7ab494fe977143c6$var$stateMachine = new $6uUbQ$dfa(/* @__PURE__ */ $parcel$interopDefault($aa333a9607471296$exports));
class $7ab494fe977143c6$export$2e2bcd8739ae039 extends $649970d87335b30f$export$2e2bcd8739ae039 {
  static planFeatures(plan) {
    plan.addStage($7ab494fe977143c6$var$setupSyllables);
    plan.addStage([
      "locl",
      "ccmp",
      "nukt",
      "akhn"
    ]);
    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
    plan.addStage([
      "rphf"
    ], false);
    plan.addStage($7ab494fe977143c6$var$recordRphf);
    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
    plan.addStage([
      "pref"
    ]);
    plan.addStage($7ab494fe977143c6$var$recordPref);
    plan.addStage([
      "rkrf",
      "abvf",
      "blwf",
      "half",
      "pstf",
      "vatu",
      "cjct"
    ]);
    plan.addStage($7ab494fe977143c6$var$reorder);
    plan.addStage([
      "abvs",
      "blws",
      "pres",
      "psts",
      "dist",
      "abvm",
      "blwm"
    ]);
  }
  static assignFeatures(plan, glyphs) {
    for (let i2 = glyphs.length - 1; i2 >= 0; i2--) {
      let codepoint = glyphs[i2].codePoints[0];
      if ($7ab494fe977143c6$var$decompositions[codepoint]) {
        let decomposed = $7ab494fe977143c6$var$decompositions[codepoint].map((c2) => {
          let g = plan.font.glyphForCodePoint(c2);
          return new $10e7b257e1a9a756$export$2e2bcd8739ae039(plan.font, g.id, [
            c2
          ], glyphs[i2].features);
        });
        glyphs.splice(i2, 1, ...decomposed);
      }
    }
  }
}
_define_property($7ab494fe977143c6$export$2e2bcd8739ae039, "zeroMarkWidths", "BEFORE_GPOS");
function $7ab494fe977143c6$var$useCategory(glyph) {
  return $7ab494fe977143c6$var$trie.get(glyph.codePoints[0]);
}
class $7ab494fe977143c6$var$USEInfo {
  constructor(category, syllableType, syllable) {
    this.category = category;
    this.syllableType = syllableType;
    this.syllable = syllable;
  }
}
function $7ab494fe977143c6$var$setupSyllables(font, glyphs) {
  let syllable = 0;
  for (let [start2, end2, tags2] of $7ab494fe977143c6$var$stateMachine.match(glyphs.map($7ab494fe977143c6$var$useCategory))) {
    ++syllable;
    for (let i2 = start2; i2 <= end2; i2++) glyphs[i2].shaperInfo = new $7ab494fe977143c6$var$USEInfo($7ab494fe977143c6$var$categories[$7ab494fe977143c6$var$useCategory(glyphs[i2])], tags2[0], syllable);
    let limit = glyphs[start2].shaperInfo.category === "R" ? 1 : Math.min(3, end2 - start2);
    for (let i2 = start2; i2 < start2 + limit; i2++) glyphs[i2].features.rphf = true;
  }
}
function $7ab494fe977143c6$var$clearSubstitutionFlags(font, glyphs) {
  for (let glyph of glyphs) glyph.substituted = false;
}
function $7ab494fe977143c6$var$recordRphf(font, glyphs) {
  for (let glyph of glyphs) if (glyph.substituted && glyph.features.rphf)
    glyph.shaperInfo.category = "R";
}
function $7ab494fe977143c6$var$recordPref(font, glyphs) {
  for (let glyph of glyphs) if (glyph.substituted)
    glyph.shaperInfo.category = "VPre";
}
function $7ab494fe977143c6$var$reorder(font, glyphs) {
  let dottedCircle = font.glyphForCodePoint(9676).id;
  for (let start2 = 0, end2 = $7ab494fe977143c6$var$nextSyllable(glyphs, 0); start2 < glyphs.length; start2 = end2, end2 = $7ab494fe977143c6$var$nextSyllable(glyphs, start2)) {
    let i2, j;
    let info = glyphs[start2].shaperInfo;
    let type = info.syllableType;
    if (type !== "virama_terminated_cluster" && type !== "standard_cluster" && type !== "broken_cluster") continue;
    if (type === "broken_cluster" && dottedCircle) {
      let g = new $10e7b257e1a9a756$export$2e2bcd8739ae039(font, dottedCircle, [
        9676
      ]);
      g.shaperInfo = info;
      for (i2 = start2; i2 < end2 && glyphs[i2].shaperInfo.category === "R"; i2++) ;
      glyphs.splice(++i2, 0, g);
      end2++;
    }
    if (info.category === "R" && end2 - start2 > 1)
      for (i2 = start2 + 1; i2 < end2; i2++) {
        info = glyphs[i2].shaperInfo;
        if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i2])) {
          if ($7ab494fe977143c6$var$isHalant(glyphs[i2])) i2--;
          glyphs.splice(start2, 0, ...glyphs.splice(start2 + 1, i2 - start2), glyphs[i2]);
          break;
        }
      }
    for (i2 = start2, j = end2; i2 < end2; i2++) {
      info = glyphs[i2].shaperInfo;
      if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i2]))
        j = $7ab494fe977143c6$var$isHalant(glyphs[i2]) ? i2 + 1 : i2;
      else if ((info.category === "VPre" || info.category === "VMPre") && j < i2) glyphs.splice(j, 1, glyphs[i2], ...glyphs.splice(j, i2 - j));
    }
  }
}
function $7ab494fe977143c6$var$nextSyllable(glyphs, start2) {
  if (start2 >= glyphs.length) return start2;
  let syllable = glyphs[start2].shaperInfo.syllable;
  while (++start2 < glyphs.length && glyphs[start2].shaperInfo.syllable === syllable) ;
  return start2;
}
function $7ab494fe977143c6$var$isHalant(glyph) {
  return glyph.shaperInfo.category === "H" && !glyph.isLigated;
}
function $7ab494fe977143c6$var$isBase(info) {
  return info.category === "B" || info.category === "GB";
}
const $102b6fe50f1d50b4$var$SHAPERS = {
  arab: $764eb544bbe1ccf0$export$2e2bcd8739ae039,
  mong: $764eb544bbe1ccf0$export$2e2bcd8739ae039,
  syrc: $764eb544bbe1ccf0$export$2e2bcd8739ae039,
  "nko ": $764eb544bbe1ccf0$export$2e2bcd8739ae039,
  phag: $764eb544bbe1ccf0$export$2e2bcd8739ae039,
  mand: $764eb544bbe1ccf0$export$2e2bcd8739ae039,
  mani: $764eb544bbe1ccf0$export$2e2bcd8739ae039,
  phlp: $764eb544bbe1ccf0$export$2e2bcd8739ae039,
  hang: $e1c6bbc8cb416f8c$export$2e2bcd8739ae039,
  bng2: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  beng: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  dev2: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  deva: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  gjr2: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  gujr: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  guru: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  gur2: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  knda: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  knd2: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  mlm2: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  mlym: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  ory2: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  orya: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  taml: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  tml2: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  telu: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  tel2: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  khmr: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  bali: $7ab494fe977143c6$export$2e2bcd8739ae039,
  batk: $7ab494fe977143c6$export$2e2bcd8739ae039,
  brah: $7ab494fe977143c6$export$2e2bcd8739ae039,
  bugi: $7ab494fe977143c6$export$2e2bcd8739ae039,
  buhd: $7ab494fe977143c6$export$2e2bcd8739ae039,
  cakm: $7ab494fe977143c6$export$2e2bcd8739ae039,
  cham: $7ab494fe977143c6$export$2e2bcd8739ae039,
  dupl: $7ab494fe977143c6$export$2e2bcd8739ae039,
  egyp: $7ab494fe977143c6$export$2e2bcd8739ae039,
  gran: $7ab494fe977143c6$export$2e2bcd8739ae039,
  hano: $7ab494fe977143c6$export$2e2bcd8739ae039,
  java: $7ab494fe977143c6$export$2e2bcd8739ae039,
  kthi: $7ab494fe977143c6$export$2e2bcd8739ae039,
  kali: $7ab494fe977143c6$export$2e2bcd8739ae039,
  khar: $7ab494fe977143c6$export$2e2bcd8739ae039,
  khoj: $7ab494fe977143c6$export$2e2bcd8739ae039,
  sind: $7ab494fe977143c6$export$2e2bcd8739ae039,
  lepc: $7ab494fe977143c6$export$2e2bcd8739ae039,
  limb: $7ab494fe977143c6$export$2e2bcd8739ae039,
  mahj: $7ab494fe977143c6$export$2e2bcd8739ae039,
  // mand: UniversalShaper, // Mandaic
  // mani: UniversalShaper, // Manichaean
  mtei: $7ab494fe977143c6$export$2e2bcd8739ae039,
  modi: $7ab494fe977143c6$export$2e2bcd8739ae039,
  // mong: UniversalShaper, // Mongolian
  // 'nko ': UniversalShaper, // NKo
  hmng: $7ab494fe977143c6$export$2e2bcd8739ae039,
  // phag: UniversalShaper, // Phags-pa
  // phlp: UniversalShaper, // Psalter Pahlavi
  rjng: $7ab494fe977143c6$export$2e2bcd8739ae039,
  saur: $7ab494fe977143c6$export$2e2bcd8739ae039,
  shrd: $7ab494fe977143c6$export$2e2bcd8739ae039,
  sidd: $7ab494fe977143c6$export$2e2bcd8739ae039,
  sinh: $7826f90f6f0cecc9$export$2e2bcd8739ae039,
  sund: $7ab494fe977143c6$export$2e2bcd8739ae039,
  sylo: $7ab494fe977143c6$export$2e2bcd8739ae039,
  tglg: $7ab494fe977143c6$export$2e2bcd8739ae039,
  tagb: $7ab494fe977143c6$export$2e2bcd8739ae039,
  tale: $7ab494fe977143c6$export$2e2bcd8739ae039,
  lana: $7ab494fe977143c6$export$2e2bcd8739ae039,
  tavt: $7ab494fe977143c6$export$2e2bcd8739ae039,
  takr: $7ab494fe977143c6$export$2e2bcd8739ae039,
  tibt: $7ab494fe977143c6$export$2e2bcd8739ae039,
  tfng: $7ab494fe977143c6$export$2e2bcd8739ae039,
  tirh: $7ab494fe977143c6$export$2e2bcd8739ae039,
  latn: $649970d87335b30f$export$2e2bcd8739ae039,
  DFLT: $649970d87335b30f$export$2e2bcd8739ae039
};
function $102b6fe50f1d50b4$export$7877a478dd30fd3d(script) {
  if (!Array.isArray(script)) script = [
    script
  ];
  for (let s2 of script) {
    let shaper = $102b6fe50f1d50b4$var$SHAPERS[s2];
    if (shaper) return shaper;
  }
  return $649970d87335b30f$export$2e2bcd8739ae039;
}
class $0a876c45f1f7c41c$export$2e2bcd8739ae039 extends $a83b9c36aaa94fd3$export$2e2bcd8739ae039 {
  applyLookup(lookupType, table) {
    switch (lookupType) {
      case 1: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        let glyph = this.glyphIterator.cur;
        switch (table.version) {
          case 1:
            glyph.id = glyph.id + table.deltaGlyphID & 65535;
            break;
          case 2:
            glyph.id = table.substitute.get(index2);
            break;
        }
        return true;
      }
      case 2: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 !== -1) {
          let sequence = table.sequences.get(index2);
          if (sequence.length === 0) {
            this.glyphs.splice(this.glyphIterator.index, 1);
            return true;
          }
          this.glyphIterator.cur.id = sequence[0];
          this.glyphIterator.cur.ligatureComponent = 0;
          let features = this.glyphIterator.cur.features;
          let curGlyph = this.glyphIterator.cur;
          let replacement = sequence.slice(1).map((gid, i2) => {
            let glyph = new $10e7b257e1a9a756$export$2e2bcd8739ae039(this.font, gid, void 0, features);
            glyph.shaperInfo = curGlyph.shaperInfo;
            glyph.isLigated = curGlyph.isLigated;
            glyph.ligatureComponent = i2 + 1;
            glyph.substituted = true;
            glyph.isMultiplied = true;
            return glyph;
          });
          this.glyphs.splice(this.glyphIterator.index + 1, 0, ...replacement);
          return true;
        }
        return false;
      }
      case 3: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 !== -1) {
          let USER_INDEX = 0;
          this.glyphIterator.cur.id = table.alternateSet.get(index2)[USER_INDEX];
          return true;
        }
        return false;
      }
      case 4: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        for (let ligature of table.ligatureSets.get(index2)) {
          let matched = this.sequenceMatchIndices(1, ligature.components);
          if (!matched) continue;
          let curGlyph = this.glyphIterator.cur;
          let characters2 = curGlyph.codePoints.slice();
          for (let index3 of matched) characters2.push(...this.glyphs[index3].codePoints);
          let ligatureGlyph = new $10e7b257e1a9a756$export$2e2bcd8739ae039(this.font, ligature.glyph, characters2, curGlyph.features);
          ligatureGlyph.shaperInfo = curGlyph.shaperInfo;
          ligatureGlyph.isLigated = true;
          ligatureGlyph.substituted = true;
          let isMarkLigature = curGlyph.isMark;
          for (let i2 = 0; i2 < matched.length && isMarkLigature; i2++) isMarkLigature = this.glyphs[matched[i2]].isMark;
          ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;
          let lastLigID = curGlyph.ligatureID;
          let lastNumComps = curGlyph.codePoints.length;
          let curComps = lastNumComps;
          let idx = this.glyphIterator.index + 1;
          for (let matchIndex of matched) {
            if (isMarkLigature) idx = matchIndex;
            else while (idx < matchIndex) {
              var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);
              this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;
              this.glyphs[idx].ligatureComponent = ligatureComponent;
              idx++;
            }
            lastLigID = this.glyphs[idx].ligatureID;
            lastNumComps = this.glyphs[idx].codePoints.length;
            curComps += lastNumComps;
            idx++;
          }
          if (lastLigID && !isMarkLigature) for (let i2 = idx; i2 < this.glyphs.length; i2++) {
            if (this.glyphs[i2].ligatureID === lastLigID) {
              var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[i2].ligatureComponent || 1, lastNumComps);
              this.glyphs[i2].ligatureComponent = ligatureComponent;
            } else break;
          }
          for (let i2 = matched.length - 1; i2 >= 0; i2--) this.glyphs.splice(matched[i2], 1);
          this.glyphs[this.glyphIterator.index] = ligatureGlyph;
          return true;
        }
        return false;
      }
      case 5:
        return this.applyContext(table);
      case 6:
        return this.applyChainingContext(table);
      case 7:
        return this.applyLookup(table.lookupType, table.extension);
      default:
        throw new Error(`GSUB lookupType ${lookupType} is not supported`);
    }
  }
}
class $c96c93587d49c14d$export$2e2bcd8739ae039 extends $a83b9c36aaa94fd3$export$2e2bcd8739ae039 {
  applyPositionValue(sequenceIndex, value2) {
    let position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];
    if (value2.xAdvance != null) position.xAdvance += value2.xAdvance;
    if (value2.yAdvance != null) position.yAdvance += value2.yAdvance;
    if (value2.xPlacement != null) position.xOffset += value2.xPlacement;
    if (value2.yPlacement != null) position.yOffset += value2.yPlacement;
    let variationProcessor = this.font._variationProcessor;
    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (value2.xPlaDevice) position.xOffset += variationProcessor.getDelta(variationStore, value2.xPlaDevice.a, value2.xPlaDevice.b);
      if (value2.yPlaDevice) position.yOffset += variationProcessor.getDelta(variationStore, value2.yPlaDevice.a, value2.yPlaDevice.b);
      if (value2.xAdvDevice) position.xAdvance += variationProcessor.getDelta(variationStore, value2.xAdvDevice.a, value2.xAdvDevice.b);
      if (value2.yAdvDevice) position.yAdvance += variationProcessor.getDelta(variationStore, value2.yAdvDevice.a, value2.yAdvDevice.b);
    }
  }
  applyLookup(lookupType, table) {
    switch (lookupType) {
      case 1: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        switch (table.version) {
          case 1:
            this.applyPositionValue(0, table.value);
            break;
          case 2:
            this.applyPositionValue(0, table.values.get(index2));
            break;
        }
        return true;
      }
      case 2: {
        let nextGlyph = this.glyphIterator.peek();
        if (!nextGlyph) return false;
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        switch (table.version) {
          case 1:
            let set5 = table.pairSets.get(index2);
            for (let pair2 of set5) if (pair2.secondGlyph === nextGlyph.id) {
              this.applyPositionValue(0, pair2.value1);
              this.applyPositionValue(1, pair2.value2);
              return true;
            }
            return false;
          case 2:
            let class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);
            let class2 = this.getClassID(nextGlyph.id, table.classDef2);
            if (class1 === -1 || class2 === -1) return false;
            var pair = table.classRecords.get(class1).get(class2);
            this.applyPositionValue(0, pair.value1);
            this.applyPositionValue(1, pair.value2);
            return true;
        }
      }
      case 3: {
        let nextIndex = this.glyphIterator.peekIndex();
        let nextGlyph = this.glyphs[nextIndex];
        if (!nextGlyph) return false;
        let curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];
        if (!curRecord || !curRecord.exitAnchor) return false;
        let nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, nextGlyph.id)];
        if (!nextRecord || !nextRecord.entryAnchor) return false;
        let entry = this.getAnchor(nextRecord.entryAnchor);
        let exit = this.getAnchor(curRecord.exitAnchor);
        let cur = this.positions[this.glyphIterator.index];
        let next = this.positions[nextIndex];
        let d2;
        switch (this.direction) {
          case "ltr":
            cur.xAdvance = exit.x + cur.xOffset;
            d2 = entry.x + next.xOffset;
            next.xAdvance -= d2;
            next.xOffset -= d2;
            break;
          case "rtl":
            d2 = exit.x + cur.xOffset;
            cur.xAdvance -= d2;
            cur.xOffset -= d2;
            next.xAdvance = entry.x + next.xOffset;
            break;
        }
        if (this.glyphIterator.flags.rightToLeft) {
          this.glyphIterator.cur.cursiveAttachment = nextIndex;
          cur.yOffset = entry.y - exit.y;
        } else {
          nextGlyph.cursiveAttachment = this.glyphIterator.index;
          cur.yOffset = exit.y - entry.y;
        }
        return true;
      }
      case 4: {
        let markIndex = this.coverageIndex(table.markCoverage);
        if (markIndex === -1) return false;
        let baseGlyphIndex = this.glyphIterator.index;
        while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0)) ;
        if (baseGlyphIndex < 0) return false;
        let baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);
        if (baseIndex === -1) return false;
        let markRecord = table.markArray[markIndex];
        let baseAnchor = table.baseArray[baseIndex][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
        return true;
      }
      case 5: {
        let markIndex = this.coverageIndex(table.markCoverage);
        if (markIndex === -1) return false;
        let baseGlyphIndex = this.glyphIterator.index;
        while (--baseGlyphIndex >= 0 && this.glyphs[baseGlyphIndex].isMark) ;
        if (baseGlyphIndex < 0) return false;
        let ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[baseGlyphIndex].id);
        if (ligIndex === -1) return false;
        let ligAttach = table.ligatureArray[ligIndex];
        let markGlyph = this.glyphIterator.cur;
        let ligGlyph = this.glyphs[baseGlyphIndex];
        let compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent > 0 ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;
        let markRecord = table.markArray[markIndex];
        let baseAnchor = ligAttach[compIndex][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
        return true;
      }
      case 6: {
        let mark1Index = this.coverageIndex(table.mark1Coverage);
        if (mark1Index === -1) return false;
        let prevIndex = this.glyphIterator.peekIndex(-1);
        let prev = this.glyphs[prevIndex];
        if (!prev || !prev.isMark) return false;
        let cur = this.glyphIterator.cur;
        let good = false;
        if (cur.ligatureID === prev.ligatureID) {
          if (!cur.ligatureID) good = true;
          else if (cur.ligatureComponent === prev.ligatureComponent) good = true;
        } else if (cur.ligatureID && !cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent) good = true;
        if (!good) return false;
        let mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);
        if (mark2Index === -1) return false;
        let markRecord = table.mark1Array[mark1Index];
        let baseAnchor = table.mark2Array[mark2Index][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, prevIndex);
        return true;
      }
      case 7:
        return this.applyContext(table);
      case 8:
        return this.applyChainingContext(table);
      case 9:
        return this.applyLookup(table.lookupType, table.extension);
      default:
        throw new Error(`Unsupported GPOS table: ${lookupType}`);
    }
  }
  applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {
    let baseCoords = this.getAnchor(baseAnchor);
    let markCoords = this.getAnchor(markRecord.markAnchor);
    this.positions[baseGlyphIndex];
    let markPos = this.positions[this.glyphIterator.index];
    markPos.xOffset = baseCoords.x - markCoords.x;
    markPos.yOffset = baseCoords.y - markCoords.y;
    this.glyphIterator.cur.markAttachment = baseGlyphIndex;
  }
  getAnchor(anchor) {
    let x = anchor.xCoordinate;
    let y2 = anchor.yCoordinate;
    let variationProcessor = this.font._variationProcessor;
    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (anchor.xDeviceTable) x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);
      if (anchor.yDeviceTable) y2 += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);
    }
    return {
      x,
      y: y2
    };
  }
  applyFeatures(userFeatures, glyphs, advances) {
    super.applyFeatures(userFeatures, glyphs, advances);
    for (var i2 = 0; i2 < this.glyphs.length; i2++) this.fixCursiveAttachment(i2);
    this.fixMarkAttachment();
  }
  fixCursiveAttachment(i2) {
    let glyph = this.glyphs[i2];
    if (glyph.cursiveAttachment != null) {
      let j = glyph.cursiveAttachment;
      glyph.cursiveAttachment = null;
      this.fixCursiveAttachment(j);
      this.positions[i2].yOffset += this.positions[j].yOffset;
    }
  }
  fixMarkAttachment() {
    for (let i2 = 0; i2 < this.glyphs.length; i2++) {
      let glyph = this.glyphs[i2];
      if (glyph.markAttachment != null) {
        let j = glyph.markAttachment;
        this.positions[i2].xOffset += this.positions[j].xOffset;
        this.positions[i2].yOffset += this.positions[j].yOffset;
        if (this.direction === "ltr") for (let k2 = j; k2 < i2; k2++) {
          this.positions[i2].xOffset -= this.positions[k2].xAdvance;
          this.positions[i2].yOffset -= this.positions[k2].yAdvance;
        }
        else for (let k2 = j + 1; k2 < i2 + 1; k2++) {
          this.positions[i2].xOffset += this.positions[k2].xAdvance;
          this.positions[i2].yOffset += this.positions[k2].yAdvance;
        }
      }
    }
  }
}
class $a62492810de27e3d$export$2e2bcd8739ae039 {
  setup(glyphRun) {
    this.glyphInfos = glyphRun.glyphs.map((glyph) => new $10e7b257e1a9a756$export$2e2bcd8739ae039(this.font, glyph.id, [
      ...glyph.codePoints
    ]));
    let script = null;
    if (this.GPOSProcessor) script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    if (this.GSUBProcessor) script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    this.shaper = $102b6fe50f1d50b4$export$7877a478dd30fd3d(script);
    this.plan = new $94d7a73bd2edfc9a$export$2e2bcd8739ae039(this.font, script, glyphRun.direction);
    this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);
    for (let key in this.plan.allFeatures) glyphRun.features[key] = true;
  }
  substitute(glyphRun) {
    if (this.GSUBProcessor) {
      this.plan.process(this.GSUBProcessor, this.glyphInfos);
      glyphRun.glyphs = this.glyphInfos.map((glyphInfo) => this.font.getGlyph(glyphInfo.id, glyphInfo.codePoints));
    }
  }
  position(glyphRun) {
    if (this.shaper.zeroMarkWidths === "BEFORE_GPOS") this.zeroMarkAdvances(glyphRun.positions);
    if (this.GPOSProcessor) this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);
    if (this.shaper.zeroMarkWidths === "AFTER_GPOS") this.zeroMarkAdvances(glyphRun.positions);
    if (glyphRun.direction === "rtl") {
      glyphRun.glyphs.reverse();
      glyphRun.positions.reverse();
    }
    return this.GPOSProcessor && this.GPOSProcessor.features;
  }
  zeroMarkAdvances(positions) {
    for (let i2 = 0; i2 < this.glyphInfos.length; i2++) if (this.glyphInfos[i2].isMark) {
      positions[i2].xAdvance = 0;
      positions[i2].yAdvance = 0;
    }
  }
  cleanup() {
    this.glyphInfos = null;
    this.plan = null;
    this.shaper = null;
  }
  getAvailableFeatures(script, language) {
    let features = [];
    if (this.GSUBProcessor) {
      this.GSUBProcessor.selectScript(script, language);
      features.push(...Object.keys(this.GSUBProcessor.features));
    }
    if (this.GPOSProcessor) {
      this.GPOSProcessor.selectScript(script, language);
      features.push(...Object.keys(this.GPOSProcessor.features));
    }
    return features;
  }
  constructor(font) {
    this.font = font;
    this.glyphInfos = null;
    this.plan = null;
    this.GSUBProcessor = null;
    this.GPOSProcessor = null;
    this.fallbackPosition = true;
    if (font.GSUB) this.GSUBProcessor = new $0a876c45f1f7c41c$export$2e2bcd8739ae039(font, font.GSUB);
    if (font.GPOS) this.GPOSProcessor = new $c96c93587d49c14d$export$2e2bcd8739ae039(font, font.GPOS);
  }
}
class $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039 {
  layout(string, features, script, language, direction) {
    if (typeof features === "string") {
      direction = language;
      language = script;
      script = features;
      features = [];
    }
    if (typeof string === "string") {
      if (script == null) script = $130d1a642ebcd2b7$export$e5cb25e204fb8450(string);
      var glyphs = this.font.glyphsForString(string);
    } else {
      if (script == null) {
        let codePoints = [];
        for (let glyph of string) codePoints.push(...glyph.codePoints);
        script = $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints);
      }
      var glyphs = string;
    }
    let glyphRun = new $be07b3e97a42687a$export$2e2bcd8739ae039(glyphs, features, script, language, direction);
    if (glyphs.length === 0) {
      glyphRun.positions = [];
      return glyphRun;
    }
    if (this.engine && this.engine.setup) this.engine.setup(glyphRun);
    this.substitute(glyphRun);
    this.position(glyphRun);
    this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);
    if (this.engine && this.engine.cleanup) this.engine.cleanup();
    return glyphRun;
  }
  substitute(glyphRun) {
    if (this.engine && this.engine.substitute) this.engine.substitute(glyphRun);
  }
  position(glyphRun) {
    glyphRun.positions = glyphRun.glyphs.map((glyph) => new $1ac75d9a55b67f01$export$2e2bcd8739ae039(glyph.advanceWidth));
    let positioned = null;
    if (this.engine && this.engine.position) positioned = this.engine.position(glyphRun);
    if (!positioned && (!this.engine || this.engine.fallbackPosition)) {
      if (!this.unicodeLayoutEngine) this.unicodeLayoutEngine = new $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039(this.font);
      this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);
    }
    if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {
      if (!this.kernProcessor) this.kernProcessor = new $0bba3a9db57637f3$export$2e2bcd8739ae039(this.font);
      this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);
      glyphRun.features.kern = true;
    }
  }
  hideDefaultIgnorables(glyphs, positions) {
    let space = this.font.glyphForCodePoint(32);
    for (let i2 = 0; i2 < glyphs.length; i2++) if (this.isDefaultIgnorable(glyphs[i2].codePoints[0])) {
      glyphs[i2] = space;
      positions[i2].xAdvance = 0;
      positions[i2].yAdvance = 0;
    }
  }
  isDefaultIgnorable(ch) {
    let plane = ch >> 16;
    if (plane === 0)
      switch (ch >> 8) {
        case 0:
          return ch === 173;
        case 3:
          return ch === 847;
        case 6:
          return ch === 1564;
        case 23:
          return 6068 <= ch && ch <= 6069;
        case 24:
          return 6155 <= ch && ch <= 6158;
        case 32:
          return 8203 <= ch && ch <= 8207 || 8234 <= ch && ch <= 8238 || 8288 <= ch && ch <= 8303;
        case 254:
          return 65024 <= ch && ch <= 65039 || ch === 65279;
        case 255:
          return 65520 <= ch && ch <= 65528;
        default:
          return false;
      }
    else
      switch (plane) {
        case 1:
          return 113824 <= ch && ch <= 113827 || 119155 <= ch && ch <= 119162;
        case 14:
          return 917504 <= ch && ch <= 921599;
        default:
          return false;
      }
  }
  getAvailableFeatures(script, language) {
    let features = [];
    if (this.engine) features.push(...this.engine.getAvailableFeatures(script, language));
    if (this.font.kern && features.indexOf("kern") === -1) features.push("kern");
    return features;
  }
  stringsForGlyph(gid) {
    let result = /* @__PURE__ */ new Set();
    let codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);
    for (let codePoint of codePoints) result.add(String.fromCodePoint(codePoint));
    if (this.engine && this.engine.stringsForGlyph) for (let string of this.engine.stringsForGlyph(gid)) result.add(string);
    return Array.from(result);
  }
  constructor(font) {
    this.font = font;
    this.unicodeLayoutEngine = null;
    this.kernProcessor = null;
    if (this.font.morx) this.engine = new $ba6dd74203be8728$export$2e2bcd8739ae039(this.font);
    else if (this.font.GSUB || this.font.GPOS) this.engine = new $a62492810de27e3d$export$2e2bcd8739ae039(this.font);
  }
}
const $f43aec954cdfdf21$var$SVG_COMMANDS = {
  moveTo: "M",
  lineTo: "L",
  quadraticCurveTo: "Q",
  bezierCurveTo: "C",
  closePath: "Z"
};
class $f43aec954cdfdf21$export$2e2bcd8739ae039 {
  /**
  * Compiles the path to a JavaScript function that can be applied with
  * a graphics context in order to render the path.
  * @return {string}
  */
  toFunction() {
    return (ctx) => {
      this.commands.forEach((c2) => {
        return ctx[c2.command].apply(ctx, c2.args);
      });
    };
  }
  /**
  * Converts the path to an SVG path data string
  * @return {string}
  */
  toSVG() {
    let cmds = this.commands.map((c2) => {
      let args = c2.args.map((arg) => Math.round(arg * 100) / 100);
      return `${$f43aec954cdfdf21$var$SVG_COMMANDS[c2.command]}${args.join(" ")}`;
    });
    return cmds.join("");
  }
  /**
  * Gets the "control box" of a path.
  * This is like the bounding box, but it includes all points including
  * control points of bezier segments and is much faster to compute than
  * the real bounding box.
  * @type {BBox}
  */
  get cbox() {
    if (!this._cbox) {
      let cbox = new $f34600ab9d7f70d8$export$2e2bcd8739ae039();
      for (let command of this.commands) for (let i2 = 0; i2 < command.args.length; i2 += 2) cbox.addPoint(command.args[i2], command.args[i2 + 1]);
      this._cbox = Object.freeze(cbox);
    }
    return this._cbox;
  }
  /**
  * Gets the exact bounding box of the path by evaluating curve segments.
  * Slower to compute than the control box, but more accurate.
  * @type {BBox}
  */
  get bbox() {
    if (this._bbox) return this._bbox;
    let bbox = new $f34600ab9d7f70d8$export$2e2bcd8739ae039();
    let cx2 = 0, cy2 = 0;
    let f2 = (t2) => Math.pow(1 - t2, 3) * p0[i2] + 3 * Math.pow(1 - t2, 2) * t2 * p1[i2] + 3 * (1 - t2) * Math.pow(t2, 2) * p2[i2] + Math.pow(t2, 3) * p3[i2];
    for (let c2 of this.commands) switch (c2.command) {
      case "moveTo":
      case "lineTo":
        let [x, y2] = c2.args;
        bbox.addPoint(x, y2);
        cx2 = x;
        cy2 = y2;
        break;
      case "quadraticCurveTo":
      case "bezierCurveTo":
        if (c2.command === "quadraticCurveTo") {
          var [qp1x, qp1y, p3x, p3y] = c2.args;
          var cp1x = cx2 + 2 / 3 * (qp1x - cx2);
          var cp1y = cy2 + 2 / 3 * (qp1y - cy2);
          var cp2x = p3x + 2 / 3 * (qp1x - p3x);
          var cp2y = p3y + 2 / 3 * (qp1y - p3y);
        } else var [cp1x, cp1y, cp2x, cp2y, p3x, p3y] = c2.args;
        bbox.addPoint(p3x, p3y);
        var p0 = [
          cx2,
          cy2
        ];
        var p1 = [
          cp1x,
          cp1y
        ];
        var p2 = [
          cp2x,
          cp2y
        ];
        var p3 = [
          p3x,
          p3y
        ];
        for (var i2 = 0; i2 <= 1; i2++) {
          let b2 = 6 * p0[i2] - 12 * p1[i2] + 6 * p2[i2];
          let a2 = -3 * p0[i2] + 9 * p1[i2] - 9 * p2[i2] + 3 * p3[i2];
          c2 = 3 * p1[i2] - 3 * p0[i2];
          if (a2 === 0) {
            if (b2 === 0) continue;
            let t3 = -c2 / b2;
            if (0 < t3 && t3 < 1) {
              if (i2 === 0) bbox.addPoint(f2(t3), bbox.maxY);
              else if (i2 === 1) bbox.addPoint(bbox.maxX, f2(t3));
            }
            continue;
          }
          let b2ac = Math.pow(b2, 2) - 4 * c2 * a2;
          if (b2ac < 0) continue;
          let t1 = (-b2 + Math.sqrt(b2ac)) / (2 * a2);
          if (0 < t1 && t1 < 1) {
            if (i2 === 0) bbox.addPoint(f2(t1), bbox.maxY);
            else if (i2 === 1) bbox.addPoint(bbox.maxX, f2(t1));
          }
          let t2 = (-b2 - Math.sqrt(b2ac)) / (2 * a2);
          if (0 < t2 && t2 < 1) {
            if (i2 === 0) bbox.addPoint(f2(t2), bbox.maxY);
            else if (i2 === 1) bbox.addPoint(bbox.maxX, f2(t2));
          }
        }
        cx2 = p3x;
        cy2 = p3y;
        break;
    }
    return this._bbox = Object.freeze(bbox);
  }
  /**
  * Applies a mapping function to each point in the path.
  * @param {function} fn
  * @return {Path}
  */
  mapPoints(fn) {
    let path = new $f43aec954cdfdf21$export$2e2bcd8739ae039();
    for (let c2 of this.commands) {
      let args = [];
      for (let i2 = 0; i2 < c2.args.length; i2 += 2) {
        let [x, y2] = fn(c2.args[i2], c2.args[i2 + 1]);
        args.push(x, y2);
      }
      path[c2.command](...args);
    }
    return path;
  }
  /**
  * Transforms the path by the given matrix.
  */
  transform(m0, m1, m2, m3, m4, m5) {
    return this.mapPoints((x, y2) => {
      const tx = m0 * x + m2 * y2 + m4;
      const ty = m1 * x + m3 * y2 + m5;
      return [
        tx,
        ty
      ];
    });
  }
  /**
  * Translates the path by the given offset.
  */
  translate(x, y2) {
    return this.transform(1, 0, 0, 1, x, y2);
  }
  /**
  * Rotates the path by the given angle (in radians).
  */
  rotate(angle) {
    let cos = Math.cos(angle);
    let sin = Math.sin(angle);
    return this.transform(cos, sin, -sin, cos, 0, 0);
  }
  /**
  * Scales the path.
  */
  scale(scaleX, scaleY = scaleX) {
    return this.transform(scaleX, 0, 0, scaleY, 0, 0);
  }
  constructor() {
    this.commands = [];
    this._bbox = null;
    this._cbox = null;
  }
}
for (let command of [
  "moveTo",
  "lineTo",
  "quadraticCurveTo",
  "bezierCurveTo",
  "closePath"
]) $f43aec954cdfdf21$export$2e2bcd8739ae039.prototype[command] = function(...args) {
  this._bbox = this._cbox = null;
  this.commands.push({
    command,
    args
  });
  return this;
};
var $7713b9b7b438dff8$export$2e2bcd8739ae039 = [
  ".notdef",
  ".null",
  "nonmarkingreturn",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quotesingle",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "grave",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "Adieresis",
  "Aring",
  "Ccedilla",
  "Eacute",
  "Ntilde",
  "Odieresis",
  "Udieresis",
  "aacute",
  "agrave",
  "acircumflex",
  "adieresis",
  "atilde",
  "aring",
  "ccedilla",
  "eacute",
  "egrave",
  "ecircumflex",
  "edieresis",
  "iacute",
  "igrave",
  "icircumflex",
  "idieresis",
  "ntilde",
  "oacute",
  "ograve",
  "ocircumflex",
  "odieresis",
  "otilde",
  "uacute",
  "ugrave",
  "ucircumflex",
  "udieresis",
  "dagger",
  "degree",
  "cent",
  "sterling",
  "section",
  "bullet",
  "paragraph",
  "germandbls",
  "registered",
  "copyright",
  "trademark",
  "acute",
  "dieresis",
  "notequal",
  "AE",
  "Oslash",
  "infinity",
  "plusminus",
  "lessequal",
  "greaterequal",
  "yen",
  "mu",
  "partialdiff",
  "summation",
  "product",
  "pi",
  "integral",
  "ordfeminine",
  "ordmasculine",
  "Omega",
  "ae",
  "oslash",
  "questiondown",
  "exclamdown",
  "logicalnot",
  "radical",
  "florin",
  "approxequal",
  "Delta",
  "guillemotleft",
  "guillemotright",
  "ellipsis",
  "nonbreakingspace",
  "Agrave",
  "Atilde",
  "Otilde",
  "OE",
  "oe",
  "endash",
  "emdash",
  "quotedblleft",
  "quotedblright",
  "quoteleft",
  "quoteright",
  "divide",
  "lozenge",
  "ydieresis",
  "Ydieresis",
  "fraction",
  "currency",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "daggerdbl",
  "periodcentered",
  "quotesinglbase",
  "quotedblbase",
  "perthousand",
  "Acircumflex",
  "Ecircumflex",
  "Aacute",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Oacute",
  "Ocircumflex",
  "apple",
  "Ograve",
  "Uacute",
  "Ucircumflex",
  "Ugrave",
  "dotlessi",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "Lslash",
  "lslash",
  "Scaron",
  "scaron",
  "Zcaron",
  "zcaron",
  "brokenbar",
  "Eth",
  "eth",
  "Yacute",
  "yacute",
  "Thorn",
  "thorn",
  "minus",
  "multiply",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "onehalf",
  "onequarter",
  "threequarters",
  "franc",
  "Gbreve",
  "gbreve",
  "Idotaccent",
  "Scedilla",
  "scedilla",
  "Cacute",
  "cacute",
  "Ccaron",
  "ccaron",
  "dcroat"
];
class $f92906be28e61769$export$2e2bcd8739ae039 {
  _getPath() {
    return new $f43aec954cdfdf21$export$2e2bcd8739ae039();
  }
  _getCBox() {
    return this.path.cbox;
  }
  _getBBox() {
    return this.path.bbox;
  }
  _getTableMetrics(table) {
    if (this.id < table.metrics.length) return table.metrics.get(this.id);
    let metric = table.metrics.get(table.metrics.length - 1);
    let res = {
      advance: metric ? metric.advance : 0,
      bearing: table.bearings.get(this.id - table.metrics.length) || 0
    };
    return res;
  }
  _getMetrics(cbox) {
    if (this._metrics) return this._metrics;
    let { advance: advanceWidth2, bearing: leftBearing } = this._getTableMetrics(this._font.hmtx);
    if (this._font.vmtx) var { advance: advanceHeight, bearing: topBearing } = this._getTableMetrics(this._font.vmtx);
    else {
      let os2;
      if (typeof cbox === "undefined" || cbox === null) ({ cbox } = this);
      if ((os2 = this._font["OS/2"]) && os2.version > 0) {
        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);
        var topBearing = os2.typoAscender - cbox.maxY;
      } else {
        let { hhea } = this._font;
        var advanceHeight = Math.abs(hhea.ascent - hhea.descent);
        var topBearing = hhea.ascent - cbox.maxY;
      }
    }
    if (this._font._variationProcessor && this._font.HVAR) advanceWidth2 += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);
    return this._metrics = {
      advanceWidth: advanceWidth2,
      advanceHeight,
      leftBearing,
      topBearing
    };
  }
  /**
  * The glyphs control box.
  * This is often the same as the bounding box, but is faster to compute.
  * Because of the way bezier curves are defined, some of the control points
  * can be outside of the bounding box. Where `bbox` takes this into account,
  * `cbox` does not. Thus, cbox is less accurate, but faster to compute.
  * See [here](http://www.freetype.org/freetype2/docs/glyphs/glyphs-6.html#section-2)
  * for a more detailed description.
  *
  * @type {BBox}
  */
  get cbox() {
    return this._getCBox();
  }
  /**
  * The glyphs bounding box, i.e. the rectangle that encloses the
  * glyph outline as tightly as possible.
  * @type {BBox}
  */
  get bbox() {
    return this._getBBox();
  }
  /**
  * A vector Path object representing the glyph outline.
  * @type {Path}
  */
  get path() {
    return this._getPath();
  }
  /**
  * Returns a path scaled to the given font size.
  * @param {number} size
  * @return {Path}
  */
  getScaledPath(size) {
    let scale2 = 1 / this._font.unitsPerEm * size;
    return this.path.scale(scale2);
  }
  /**
  * The glyph's advance width.
  * @type {number}
  */
  get advanceWidth() {
    return this._getMetrics().advanceWidth;
  }
  /**
  * The glyph's advance height.
  * @type {number}
  */
  get advanceHeight() {
    return this._getMetrics().advanceHeight;
  }
  get ligatureCaretPositions() {
  }
  _getName() {
    let { post } = this._font;
    if (!post) return null;
    switch (post.version) {
      case 1:
        return $7713b9b7b438dff8$export$2e2bcd8739ae039[this.id];
      case 2:
        let id = post.glyphNameIndex[this.id];
        if (id < $7713b9b7b438dff8$export$2e2bcd8739ae039.length) return $7713b9b7b438dff8$export$2e2bcd8739ae039[id];
        return post.names[id - $7713b9b7b438dff8$export$2e2bcd8739ae039.length];
      case 2.5:
        return $7713b9b7b438dff8$export$2e2bcd8739ae039[this.id + post.offsets[this.id]];
      case 4:
        return String.fromCharCode(post.map[this.id]);
    }
  }
  /**
  * The glyph's name
  * @type {string}
  */
  get name() {
    return this._getName();
  }
  /**
  * Renders the glyph to the given graphics context, at the specified font size.
  * @param {CanvasRenderingContext2d} ctx
  * @param {number} size
  */
  render(ctx, size) {
    ctx.save();
    let scale2 = 1 / this._font.head.unitsPerEm * size;
    ctx.scale(scale2, scale2);
    let fn = this.path.toFunction();
    fn(ctx);
    ctx.fill();
    ctx.restore();
  }
  constructor(id, codePoints, font) {
    this.id = id;
    this.codePoints = codePoints;
    this._font = font;
    this.isMark = this.codePoints.length > 0 && this.codePoints.every($747425b437e121da$export$e33ad6871e762338);
    this.isLigature = this.codePoints.length > 1;
  }
}
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "cbox", null);
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "bbox", null);
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "path", null);
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceWidth", null);
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceHeight", null);
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "name", null);
let $69aac16029968692$var$GlyfHeader = new Struct({
  numberOfContours: int16,
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16
});
const $69aac16029968692$var$ON_CURVE = 1;
const $69aac16029968692$var$X_SHORT_VECTOR = 2;
const $69aac16029968692$var$Y_SHORT_VECTOR = 4;
const $69aac16029968692$var$REPEAT = 8;
const $69aac16029968692$var$SAME_X = 16;
const $69aac16029968692$var$SAME_Y = 32;
const $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS = 1;
const $69aac16029968692$var$WE_HAVE_A_SCALE = 8;
const $69aac16029968692$var$MORE_COMPONENTS = 32;
const $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE = 64;
const $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO = 128;
const $69aac16029968692$var$WE_HAVE_INSTRUCTIONS = 256;
class $69aac16029968692$export$baf26146a414f24a {
  copy() {
    return new $69aac16029968692$export$baf26146a414f24a(this.onCurve, this.endContour, this.x, this.y);
  }
  constructor(onCurve, endContour, x = 0, y2 = 0) {
    this.onCurve = onCurve;
    this.endContour = endContour;
    this.x = x;
    this.y = y2;
  }
}
class $69aac16029968692$var$Component {
  constructor(glyphID, dx, dy) {
    this.glyphID = glyphID;
    this.dx = dx;
    this.dy = dy;
    this.pos = 0;
    this.scaleX = this.scaleY = 1;
    this.scale01 = this.scale10 = 0;
  }
}
class $69aac16029968692$export$2e2bcd8739ae039 extends $f92906be28e61769$export$2e2bcd8739ae039 {
  // Parses just the glyph header and returns the bounding box
  _getCBox(internal) {
    if (this._font._variationProcessor && !internal) return this.path.cbox;
    let stream2 = this._font._getTableStream("glyf");
    stream2.pos += this._font.loca.offsets[this.id];
    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream2);
    let cbox = new $f34600ab9d7f70d8$export$2e2bcd8739ae039(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);
    return Object.freeze(cbox);
  }
  // Parses a single glyph coordinate
  _parseGlyphCoord(stream2, prev, short, same) {
    if (short) {
      var val = stream2.readUInt8();
      if (!same) val = -val;
      val += prev;
    } else if (same) var val = prev;
    else var val = prev + stream2.readInt16BE();
    return val;
  }
  // Decodes the glyph data into points for simple glyphs,
  // or components for composite glyphs
  _decode() {
    let glyfPos = this._font.loca.offsets[this.id];
    let nextPos = this._font.loca.offsets[this.id + 1];
    if (glyfPos === nextPos) return null;
    let stream2 = this._font._getTableStream("glyf");
    stream2.pos += glyfPos;
    let startPos = stream2.pos;
    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream2);
    if (glyph.numberOfContours > 0) this._decodeSimple(glyph, stream2);
    else if (glyph.numberOfContours < 0) this._decodeComposite(glyph, stream2, startPos);
    return glyph;
  }
  _decodeSimple(glyph, stream2) {
    glyph.points = [];
    let endPtsOfContours = new ArrayT(uint16, glyph.numberOfContours).decode(stream2);
    glyph.instructions = new ArrayT(uint8, uint16).decode(stream2);
    let flags = [];
    let numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
    while (flags.length < numCoords) {
      var flag = stream2.readUInt8();
      flags.push(flag);
      if (flag & $69aac16029968692$var$REPEAT) {
        let count = stream2.readUInt8();
        for (let j = 0; j < count; j++) flags.push(flag);
      }
    }
    for (var i2 = 0; i2 < flags.length; i2++) {
      var flag = flags[i2];
      let point = new $69aac16029968692$export$baf26146a414f24a(!!(flag & $69aac16029968692$var$ON_CURVE), endPtsOfContours.indexOf(i2) >= 0, 0, 0);
      glyph.points.push(point);
    }
    let px2 = 0;
    for (var i2 = 0; i2 < flags.length; i2++) {
      var flag = flags[i2];
      glyph.points[i2].x = px2 = this._parseGlyphCoord(stream2, px2, flag & $69aac16029968692$var$X_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_X);
    }
    let py2 = 0;
    for (var i2 = 0; i2 < flags.length; i2++) {
      var flag = flags[i2];
      glyph.points[i2].y = py2 = this._parseGlyphCoord(stream2, py2, flag & $69aac16029968692$var$Y_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_Y);
    }
    if (this._font._variationProcessor) {
      let points = glyph.points.slice();
      points.push(...this._getPhantomPoints(glyph));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph.phantomPoints = points.slice(-4);
    }
    return;
  }
  _decodeComposite(glyph, stream2, offset2 = 0) {
    glyph.components = [];
    let haveInstructions = false;
    let flags = $69aac16029968692$var$MORE_COMPONENTS;
    while (flags & $69aac16029968692$var$MORE_COMPONENTS) {
      flags = stream2.readUInt16BE();
      let gPos = stream2.pos - offset2;
      let glyphID = stream2.readUInt16BE();
      if (!haveInstructions) haveInstructions = (flags & $69aac16029968692$var$WE_HAVE_INSTRUCTIONS) !== 0;
      if (flags & $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS) {
        var dx = stream2.readInt16BE();
        var dy = stream2.readInt16BE();
      } else {
        var dx = stream2.readInt8();
        var dy = stream2.readInt8();
      }
      var component = new $69aac16029968692$var$Component(glyphID, dx, dy);
      component.pos = gPos;
      if (flags & $69aac16029968692$var$WE_HAVE_A_SCALE)
        component.scaleX = component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      else if (flags & $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE) {
        component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      } else if (flags & $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO) {
        component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scale01 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scale10 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      }
      glyph.components.push(component);
    }
    if (this._font._variationProcessor) {
      let points = [];
      for (let j = 0; j < glyph.components.length; j++) {
        var component = glyph.components[j];
        points.push(new $69aac16029968692$export$baf26146a414f24a(true, true, component.dx, component.dy));
      }
      points.push(...this._getPhantomPoints(glyph));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph.phantomPoints = points.splice(-4, 4);
      for (let i2 = 0; i2 < points.length; i2++) {
        let point = points[i2];
        glyph.components[i2].dx = point.x;
        glyph.components[i2].dy = point.y;
      }
    }
    return haveInstructions;
  }
  _getPhantomPoints(glyph) {
    let cbox = this._getCBox(true);
    if (this._metrics == null) this._metrics = $f92906be28e61769$export$2e2bcd8739ae039.prototype._getMetrics.call(this, cbox);
    let { advanceWidth: advanceWidth2, advanceHeight, leftBearing, topBearing } = this._metrics;
    return [
      new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing, 0),
      new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing + advanceWidth2, 0),
      new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing),
      new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing + advanceHeight)
    ];
  }
  // Decodes font data, resolves composite glyphs, and returns an array of contours
  _getContours() {
    let glyph = this._decode();
    if (!glyph) return [];
    let points = [];
    if (glyph.numberOfContours < 0)
      for (let component of glyph.components) {
        let contours2 = this._font.getGlyph(component.glyphID)._getContours();
        for (let i2 = 0; i2 < contours2.length; i2++) {
          let contour = contours2[i2];
          for (let j = 0; j < contour.length; j++) {
            let point2 = contour[j];
            let x = point2.x * component.scaleX + point2.y * component.scale01 + component.dx;
            let y2 = point2.y * component.scaleY + point2.x * component.scale10 + component.dy;
            points.push(new $69aac16029968692$export$baf26146a414f24a(point2.onCurve, point2.endContour, x, y2));
          }
        }
      }
    else points = glyph.points || [];
    if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {
      this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;
      this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;
      this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;
      this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax;
    }
    let contours = [];
    let cur = [];
    for (let k2 = 0; k2 < points.length; k2++) {
      var point = points[k2];
      cur.push(point);
      if (point.endContour) {
        contours.push(cur);
        cur = [];
      }
    }
    return contours;
  }
  _getMetrics() {
    if (this._metrics) return this._metrics;
    let cbox = this._getCBox(true);
    super._getMetrics(cbox);
    if (this._font._variationProcessor && !this._font.HVAR)
      this.path;
    return this._metrics;
  }
  // Converts contours to a Path object that can be rendered
  _getPath() {
    let contours = this._getContours();
    let path = new $f43aec954cdfdf21$export$2e2bcd8739ae039();
    for (let i2 = 0; i2 < contours.length; i2++) {
      let contour = contours[i2];
      let firstPt = contour[0];
      let lastPt = contour[contour.length - 1];
      let start2 = 0;
      if (firstPt.onCurve) {
        var curvePt = null;
        start2 = 1;
      } else {
        if (lastPt.onCurve)
          firstPt = lastPt;
        else
          firstPt = new $69aac16029968692$export$baf26146a414f24a(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
        var curvePt = firstPt;
      }
      path.moveTo(firstPt.x, firstPt.y);
      for (let j = start2; j < contour.length; j++) {
        let pt = contour[j];
        let prevPt = j === 0 ? firstPt : contour[j - 1];
        if (prevPt.onCurve && pt.onCurve) path.lineTo(pt.x, pt.y);
        else if (prevPt.onCurve && !pt.onCurve) var curvePt = pt;
        else if (!prevPt.onCurve && !pt.onCurve) {
          let midX = (prevPt.x + pt.x) / 2;
          let midY = (prevPt.y + pt.y) / 2;
          path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
          var curvePt = pt;
        } else if (!prevPt.onCurve && pt.onCurve) {
          path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
          var curvePt = null;
        } else throw new Error("Unknown TTF path state");
      }
      if (curvePt) path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
      path.closePath();
    }
    return path;
  }
  constructor(...args) {
    super(...args);
    _define_property(this, "type", "TTF");
  }
}
class $62cc5109c6101893$export$2e2bcd8739ae039 extends $f92906be28e61769$export$2e2bcd8739ae039 {
  _getName() {
    if (this._font.CFF2) return super._getName();
    return this._font["CFF "].getGlyphName(this.id);
  }
  bias(s2) {
    if (s2.length < 1240) return 107;
    else if (s2.length < 33900) return 1131;
    else return 32768;
  }
  _getPath() {
    let cff = this._font.CFF2 || this._font["CFF "];
    let { stream: stream2 } = cff;
    let str = cff.topDict.CharStrings[this.id];
    let end2 = str.offset + str.length;
    stream2.pos = str.offset;
    let path = new $f43aec954cdfdf21$export$2e2bcd8739ae039();
    let stack = [];
    let trans = [];
    let width = null;
    let nStems = 0;
    let x = 0, y2 = 0;
    let usedGsubrs;
    let usedSubrs;
    let open = false;
    this._usedGsubrs = usedGsubrs = {};
    this._usedSubrs = usedSubrs = {};
    let gsubrs = cff.globalSubrIndex || [];
    let gsubrsBias = this.bias(gsubrs);
    let privateDict = cff.privateDictForGlyph(this.id) || {};
    let subrs = privateDict.Subrs || [];
    let subrsBias = this.bias(subrs);
    let vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;
    let vsindex = privateDict.vsindex;
    let variationProcessor = this._font._variationProcessor;
    function checkWidth() {
      if (width == null) width = stack.shift() + privateDict.nominalWidthX;
    }
    function parseStems() {
      if (stack.length % 2 !== 0) checkWidth();
      nStems += stack.length >> 1;
      return stack.length = 0;
    }
    function moveTo(x2, y3) {
      if (open) path.closePath();
      path.moveTo(x2, y3);
      open = true;
    }
    let parse2 = function() {
      while (stream2.pos < end2) {
        let op = stream2.readUInt8();
        if (op < 32) {
          let index2, subr, phase;
          let c1x, c1y, c2x, c2y, c3x, c3y;
          let c4x, c4y, c5x, c5y, c6x, c6y;
          let pts;
          switch (op) {
            case 1:
            case 3:
            case 18:
            case 23:
              parseStems();
              break;
            case 4:
              if (stack.length > 1) checkWidth();
              y2 += stack.shift();
              moveTo(x, y2);
              break;
            case 5:
              while (stack.length >= 2) {
                x += stack.shift();
                y2 += stack.shift();
                path.lineTo(x, y2);
              }
              break;
            case 6:
            case 7:
              phase = op === 6;
              while (stack.length >= 1) {
                if (phase) x += stack.shift();
                else y2 += stack.shift();
                path.lineTo(x, y2);
                phase = !phase;
              }
              break;
            case 8:
              while (stack.length > 0) {
                c1x = x + stack.shift();
                c1y = y2 + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y2 = c2y + stack.shift();
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y2);
              }
              break;
            case 10:
              index2 = stack.pop() + subrsBias;
              subr = subrs[index2];
              if (subr) {
                usedSubrs[index2] = true;
                let p2 = stream2.pos;
                let e2 = end2;
                stream2.pos = subr.offset;
                end2 = subr.offset + subr.length;
                parse2();
                stream2.pos = p2;
                end2 = e2;
              }
              break;
            case 11:
              if (cff.version >= 2) break;
              return;
            case 14:
              if (cff.version >= 2) break;
              if (stack.length > 0) checkWidth();
              if (open) {
                path.closePath();
                open = false;
              }
              break;
            case 15:
              if (cff.version < 2) throw new Error("vsindex operator not supported in CFF v1");
              vsindex = stack.pop();
              break;
            case 16: {
              if (cff.version < 2) throw new Error("blend operator not supported in CFF v1");
              if (!variationProcessor) throw new Error("blend operator in non-variation font");
              let blendVector = variationProcessor.getBlendVector(vstore, vsindex);
              let numBlends = stack.pop();
              let numOperands = numBlends * blendVector.length;
              let delta = stack.length - numOperands;
              let base = delta - numBlends;
              for (let i2 = 0; i2 < numBlends; i2++) {
                let sum = stack[base + i2];
                for (let j = 0; j < blendVector.length; j++) sum += blendVector[j] * stack[delta++];
                stack[base + i2] = sum;
              }
              while (numOperands--) stack.pop();
              break;
            }
            case 19:
            case 20:
              parseStems();
              stream2.pos += nStems + 7 >> 3;
              break;
            case 21:
              if (stack.length > 2) checkWidth();
              x += stack.shift();
              y2 += stack.shift();
              moveTo(x, y2);
              break;
            case 22:
              if (stack.length > 1) checkWidth();
              x += stack.shift();
              moveTo(x, y2);
              break;
            case 24:
              while (stack.length >= 8) {
                c1x = x + stack.shift();
                c1y = y2 + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y2 = c2y + stack.shift();
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y2);
              }
              x += stack.shift();
              y2 += stack.shift();
              path.lineTo(x, y2);
              break;
            case 25:
              while (stack.length >= 8) {
                x += stack.shift();
                y2 += stack.shift();
                path.lineTo(x, y2);
              }
              c1x = x + stack.shift();
              c1y = y2 + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              x = c2x + stack.shift();
              y2 = c2y + stack.shift();
              path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y2);
              break;
            case 26:
              if (stack.length % 2) x += stack.shift();
              while (stack.length >= 4) {
                c1x = x;
                c1y = y2 + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x;
                y2 = c2y + stack.shift();
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y2);
              }
              break;
            case 27:
              if (stack.length % 2) y2 += stack.shift();
              while (stack.length >= 4) {
                c1x = x + stack.shift();
                c1y = y2;
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y2 = c2y;
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y2);
              }
              break;
            case 28:
              stack.push(stream2.readInt16BE());
              break;
            case 29:
              index2 = stack.pop() + gsubrsBias;
              subr = gsubrs[index2];
              if (subr) {
                usedGsubrs[index2] = true;
                let p2 = stream2.pos;
                let e2 = end2;
                stream2.pos = subr.offset;
                end2 = subr.offset + subr.length;
                parse2();
                stream2.pos = p2;
                end2 = e2;
              }
              break;
            case 30:
            case 31:
              phase = op === 31;
              while (stack.length >= 4) {
                if (phase) {
                  c1x = x + stack.shift();
                  c1y = y2;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  y2 = c2y + stack.shift();
                  x = c2x + (stack.length === 1 ? stack.shift() : 0);
                } else {
                  c1x = x;
                  c1y = y2 + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x = c2x + stack.shift();
                  y2 = c2y + (stack.length === 1 ? stack.shift() : 0);
                }
                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y2);
                phase = !phase;
              }
              break;
            case 12:
              op = stream2.readUInt8();
              switch (op) {
                case 3:
                  let a2 = stack.pop();
                  let b2 = stack.pop();
                  stack.push(a2 && b2 ? 1 : 0);
                  break;
                case 4:
                  a2 = stack.pop();
                  b2 = stack.pop();
                  stack.push(a2 || b2 ? 1 : 0);
                  break;
                case 5:
                  a2 = stack.pop();
                  stack.push(a2 ? 0 : 1);
                  break;
                case 9:
                  a2 = stack.pop();
                  stack.push(Math.abs(a2));
                  break;
                case 10:
                  a2 = stack.pop();
                  b2 = stack.pop();
                  stack.push(a2 + b2);
                  break;
                case 11:
                  a2 = stack.pop();
                  b2 = stack.pop();
                  stack.push(a2 - b2);
                  break;
                case 12:
                  a2 = stack.pop();
                  b2 = stack.pop();
                  stack.push(a2 / b2);
                  break;
                case 14:
                  a2 = stack.pop();
                  stack.push(-a2);
                  break;
                case 15:
                  a2 = stack.pop();
                  b2 = stack.pop();
                  stack.push(a2 === b2 ? 1 : 0);
                  break;
                case 18:
                  stack.pop();
                  break;
                case 20:
                  let val = stack.pop();
                  let idx = stack.pop();
                  trans[idx] = val;
                  break;
                case 21:
                  idx = stack.pop();
                  stack.push(trans[idx] || 0);
                  break;
                case 22:
                  let s1 = stack.pop();
                  let s2 = stack.pop();
                  let v1 = stack.pop();
                  let v2 = stack.pop();
                  stack.push(v1 <= v2 ? s1 : s2);
                  break;
                case 23:
                  stack.push(Math.random());
                  break;
                case 24:
                  a2 = stack.pop();
                  b2 = stack.pop();
                  stack.push(a2 * b2);
                  break;
                case 26:
                  a2 = stack.pop();
                  stack.push(Math.sqrt(a2));
                  break;
                case 27:
                  a2 = stack.pop();
                  stack.push(a2, a2);
                  break;
                case 28:
                  a2 = stack.pop();
                  b2 = stack.pop();
                  stack.push(b2, a2);
                  break;
                case 29:
                  idx = stack.pop();
                  if (idx < 0) idx = 0;
                  else if (idx > stack.length - 1) idx = stack.length - 1;
                  stack.push(stack[idx]);
                  break;
                case 30:
                  let n3 = stack.pop();
                  let j = stack.pop();
                  if (j >= 0) while (j > 0) {
                    var t2 = stack[n3 - 1];
                    for (let i2 = n3 - 2; i2 >= 0; i2--) stack[i2 + 1] = stack[i2];
                    stack[0] = t2;
                    j--;
                  }
                  else while (j < 0) {
                    var t2 = stack[0];
                    for (let i2 = 0; i2 <= n3; i2++) stack[i2] = stack[i2 + 1];
                    stack[n3 - 1] = t2;
                    j++;
                  }
                  break;
                case 34:
                  c1x = x + stack.shift();
                  c1y = y2;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  c3x = c2x + stack.shift();
                  c3y = c2y;
                  c4x = c3x + stack.shift();
                  c4y = c3y;
                  c5x = c4x + stack.shift();
                  c5y = c4y;
                  c6x = c5x + stack.shift();
                  c6y = c5y;
                  x = c6x;
                  y2 = c6y;
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 35:
                  pts = [];
                  for (let i2 = 0; i2 <= 5; i2++) {
                    x += stack.shift();
                    y2 += stack.shift();
                    pts.push(x, y2);
                  }
                  path.bezierCurveTo(...pts.slice(0, 6));
                  path.bezierCurveTo(...pts.slice(6));
                  stack.shift();
                  break;
                case 36:
                  c1x = x + stack.shift();
                  c1y = y2 + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  c3x = c2x + stack.shift();
                  c3y = c2y;
                  c4x = c3x + stack.shift();
                  c4y = c3y;
                  c5x = c4x + stack.shift();
                  c5y = c4y + stack.shift();
                  c6x = c5x + stack.shift();
                  c6y = c5y;
                  x = c6x;
                  y2 = c6y;
                  path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 37:
                  let startx = x;
                  let starty = y2;
                  pts = [];
                  for (let i2 = 0; i2 <= 4; i2++) {
                    x += stack.shift();
                    y2 += stack.shift();
                    pts.push(x, y2);
                  }
                  if (Math.abs(x - startx) > Math.abs(y2 - starty)) {
                    x += stack.shift();
                    y2 = starty;
                  } else {
                    x = startx;
                    y2 += stack.shift();
                  }
                  pts.push(x, y2);
                  path.bezierCurveTo(...pts.slice(0, 6));
                  path.bezierCurveTo(...pts.slice(6));
                  break;
                default:
                  throw new Error(`Unknown op: 12 ${op}`);
              }
              break;
            default:
              throw new Error(`Unknown op: ${op}`);
          }
        } else if (op < 247) stack.push(op - 139);
        else if (op < 251) {
          var b1 = stream2.readUInt8();
          stack.push((op - 247) * 256 + b1 + 108);
        } else if (op < 255) {
          var b1 = stream2.readUInt8();
          stack.push(-(op - 251) * 256 - b1 - 108);
        } else stack.push(stream2.readInt32BE() / 65536);
      }
    };
    parse2();
    if (open) path.closePath();
    return path;
  }
  constructor(...args) {
    super(...args);
    _define_property(this, "type", "CFF");
  }
}
let $25d8f049c222084c$var$SBIXImage = new Struct({
  originX: uint16,
  originY: uint16,
  type: new StringT(4),
  data: new BufferT((t2) => t2.parent.buflen - t2._currentOffset)
});
class $25d8f049c222084c$export$2e2bcd8739ae039 extends $69aac16029968692$export$2e2bcd8739ae039 {
  /**
  * Returns an object representing a glyph image at the given point size.
  * The object has a data property with a Buffer containing the actual image data,
  * along with the image type, and origin.
  *
  * @param {number} size
  * @return {object}
  */
  getImageForSize(size) {
    for (let i2 = 0; i2 < this._font.sbix.imageTables.length; i2++) {
      var table = this._font.sbix.imageTables[i2];
      if (table.ppem >= size) break;
    }
    let offsets = table.imageOffsets;
    let start2 = offsets[this.id];
    let end2 = offsets[this.id + 1];
    if (start2 === end2) return null;
    this._font.stream.pos = start2;
    return $25d8f049c222084c$var$SBIXImage.decode(this._font.stream, {
      buflen: end2 - start2
    });
  }
  render(ctx, size) {
    let img = this.getImageForSize(size);
    if (img != null) {
      let scale2 = size / this._font.unitsPerEm;
      ctx.image(img.data, {
        height: size,
        x: img.originX,
        y: (this.bbox.minY - img.originY) * scale2
      });
    }
    if (this._font.sbix.flags.renderOutlines) super.render(ctx, size);
  }
  constructor(...args) {
    super(...args);
    _define_property(this, "type", "SBIX");
  }
}
class $0d411f0165859681$var$COLRLayer {
  constructor(glyph, color) {
    this.glyph = glyph;
    this.color = color;
  }
}
class $0d411f0165859681$export$2e2bcd8739ae039 extends $f92906be28e61769$export$2e2bcd8739ae039 {
  _getBBox() {
    let bbox = new $f34600ab9d7f70d8$export$2e2bcd8739ae039();
    for (let i2 = 0; i2 < this.layers.length; i2++) {
      let layer = this.layers[i2];
      let b2 = layer.glyph.bbox;
      bbox.addPoint(b2.minX, b2.minY);
      bbox.addPoint(b2.maxX, b2.maxY);
    }
    return bbox;
  }
  /**
  * Returns an array of objects containing the glyph and color for
  * each layer in the composite color glyph.
  * @type {object[]}
  */
  get layers() {
    let cpal = this._font.CPAL;
    let colr = this._font.COLR;
    let low = 0;
    let high = colr.baseGlyphRecord.length - 1;
    while (low <= high) {
      let mid = low + high >> 1;
      var rec = colr.baseGlyphRecord[mid];
      if (this.id < rec.gid) high = mid - 1;
      else if (this.id > rec.gid) low = mid + 1;
      else {
        var baseLayer = rec;
        break;
      }
    }
    if (baseLayer == null) {
      var g = this._font._getBaseGlyph(this.id);
      var color = {
        red: 0,
        green: 0,
        blue: 0,
        alpha: 255
      };
      return [
        new $0d411f0165859681$var$COLRLayer(g, color)
      ];
    }
    let layers = [];
    for (let i2 = baseLayer.firstLayerIndex; i2 < baseLayer.firstLayerIndex + baseLayer.numLayers; i2++) {
      var rec = colr.layerRecords[i2];
      var color = cpal.colorRecords[rec.paletteIndex];
      var g = this._font._getBaseGlyph(rec.gid);
      layers.push(new $0d411f0165859681$var$COLRLayer(g, color));
    }
    return layers;
  }
  render(ctx, size) {
    for (let { glyph, color } of this.layers) {
      ctx.fillColor([
        color.red,
        color.green,
        color.blue
      ], color.alpha / 255 * 100);
      glyph.render(ctx, size);
    }
    return;
  }
  constructor(...args) {
    super(...args);
    _define_property(this, "type", "COLR");
  }
}
const $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS = 32768;
const $0bb840cac04e911b$var$TUPLE_COUNT_MASK = 4095;
const $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD = 32768;
const $0bb840cac04e911b$var$INTERMEDIATE_TUPLE = 16384;
const $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS = 8192;
const $0bb840cac04e911b$var$TUPLE_INDEX_MASK = 4095;
const $0bb840cac04e911b$var$POINTS_ARE_WORDS = 128;
const $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK = 127;
const $0bb840cac04e911b$var$DELTAS_ARE_ZERO = 128;
const $0bb840cac04e911b$var$DELTAS_ARE_WORDS = 64;
const $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK = 63;
class $0bb840cac04e911b$export$2e2bcd8739ae039 {
  normalizeCoords(coords) {
    let normalized = [];
    for (var i2 = 0; i2 < this.font.fvar.axis.length; i2++) {
      let axis = this.font.fvar.axis[i2];
      if (coords[i2] < axis.defaultValue) normalized.push((coords[i2] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));
      else normalized.push((coords[i2] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));
    }
    if (this.font.avar) for (var i2 = 0; i2 < this.font.avar.segment.length; i2++) {
      let segment = this.font.avar.segment[i2];
      for (let j = 0; j < segment.correspondence.length; j++) {
        let pair = segment.correspondence[j];
        if (j >= 1 && normalized[i2] < pair.fromCoord) {
          let prev = segment.correspondence[j - 1];
          normalized[i2] = ((normalized[i2] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) / (pair.fromCoord - prev.fromCoord + Number.EPSILON) + prev.toCoord;
          break;
        }
      }
    }
    return normalized;
  }
  transformPoints(gid, glyphPoints) {
    if (!this.font.fvar || !this.font.gvar) return;
    let { gvar } = this.font;
    if (gid >= gvar.glyphCount) return;
    let offset2 = gvar.offsets[gid];
    if (offset2 === gvar.offsets[gid + 1]) return;
    let { stream: stream2 } = this.font;
    stream2.pos = offset2;
    if (stream2.pos >= stream2.length) return;
    let tupleCount = stream2.readUInt16BE();
    let offsetToData = offset2 + stream2.readUInt16BE();
    if (tupleCount & $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS) {
      var here = stream2.pos;
      stream2.pos = offsetToData;
      var sharedPoints = this.decodePoints();
      offsetToData = stream2.pos;
      stream2.pos = here;
    }
    let origPoints = glyphPoints.map((pt) => pt.copy());
    tupleCount &= $0bb840cac04e911b$var$TUPLE_COUNT_MASK;
    for (let i2 = 0; i2 < tupleCount; i2++) {
      let tupleDataSize = stream2.readUInt16BE();
      let tupleIndex = stream2.readUInt16BE();
      if (tupleIndex & $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD) {
        var tupleCoords = [];
        for (let a2 = 0; a2 < gvar.axisCount; a2++) tupleCoords.push(stream2.readInt16BE() / 16384);
      } else {
        if ((tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK) >= gvar.globalCoordCount) throw new Error("Invalid gvar table");
        var tupleCoords = gvar.globalCoords[tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK];
      }
      if (tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) {
        var startCoords = [];
        for (let a2 = 0; a2 < gvar.axisCount; a2++) startCoords.push(stream2.readInt16BE() / 16384);
        var endCoords = [];
        for (let a2 = 0; a2 < gvar.axisCount; a2++) endCoords.push(stream2.readInt16BE() / 16384);
      }
      let factor2 = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);
      if (factor2 === 0) {
        offsetToData += tupleDataSize;
        continue;
      }
      var here = stream2.pos;
      stream2.pos = offsetToData;
      if (tupleIndex & $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS) var points = this.decodePoints();
      else var points = sharedPoints;
      let nPoints = points.length === 0 ? glyphPoints.length : points.length;
      let xDeltas = this.decodeDeltas(nPoints);
      let yDeltas = this.decodeDeltas(nPoints);
      if (points.length === 0) for (let i3 = 0; i3 < glyphPoints.length; i3++) {
        var point = glyphPoints[i3];
        point.x += Math.round(xDeltas[i3] * factor2);
        point.y += Math.round(yDeltas[i3] * factor2);
      }
      else {
        let outPoints = origPoints.map((pt) => pt.copy());
        let hasDelta = glyphPoints.map(() => false);
        for (let i3 = 0; i3 < points.length; i3++) {
          let idx = points[i3];
          if (idx < glyphPoints.length) {
            let point2 = outPoints[idx];
            hasDelta[idx] = true;
            point2.x += xDeltas[i3] * factor2;
            point2.y += yDeltas[i3] * factor2;
          }
        }
        this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);
        for (let i3 = 0; i3 < glyphPoints.length; i3++) {
          let deltaX = outPoints[i3].x - origPoints[i3].x;
          let deltaY = outPoints[i3].y - origPoints[i3].y;
          glyphPoints[i3].x = Math.round(glyphPoints[i3].x + deltaX);
          glyphPoints[i3].y = Math.round(glyphPoints[i3].y + deltaY);
        }
      }
      offsetToData += tupleDataSize;
      stream2.pos = here;
    }
  }
  decodePoints() {
    let stream2 = this.font.stream;
    let count = stream2.readUInt8();
    if (count & $0bb840cac04e911b$var$POINTS_ARE_WORDS) count = (count & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) << 8 | stream2.readUInt8();
    let points = new Uint16Array(count);
    let i2 = 0;
    let point = 0;
    while (i2 < count) {
      let run = stream2.readUInt8();
      let runCount = (run & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) + 1;
      let fn = run & $0bb840cac04e911b$var$POINTS_ARE_WORDS ? stream2.readUInt16 : stream2.readUInt8;
      for (let j = 0; j < runCount && i2 < count; j++) {
        point += fn.call(stream2);
        points[i2++] = point;
      }
    }
    return points;
  }
  decodeDeltas(count) {
    let stream2 = this.font.stream;
    let i2 = 0;
    let deltas = new Int16Array(count);
    while (i2 < count) {
      let run = stream2.readUInt8();
      let runCount = (run & $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK) + 1;
      if (run & $0bb840cac04e911b$var$DELTAS_ARE_ZERO) i2 += runCount;
      else {
        let fn = run & $0bb840cac04e911b$var$DELTAS_ARE_WORDS ? stream2.readInt16BE : stream2.readInt8;
        for (let j = 0; j < runCount && i2 < count; j++) deltas[i2++] = fn.call(stream2);
      }
    }
    return deltas;
  }
  tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {
    let normalized = this.normalizedCoords;
    let { gvar } = this.font;
    let factor2 = 1;
    for (let i2 = 0; i2 < gvar.axisCount; i2++) {
      if (tupleCoords[i2] === 0) continue;
      if (normalized[i2] === 0) return 0;
      if ((tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) === 0) {
        if (normalized[i2] < Math.min(0, tupleCoords[i2]) || normalized[i2] > Math.max(0, tupleCoords[i2])) return 0;
        factor2 = (factor2 * normalized[i2] + Number.EPSILON) / (tupleCoords[i2] + Number.EPSILON);
      } else {
        if (normalized[i2] < startCoords[i2] || normalized[i2] > endCoords[i2]) return 0;
        else if (normalized[i2] < tupleCoords[i2]) factor2 = factor2 * (normalized[i2] - startCoords[i2] + Number.EPSILON) / (tupleCoords[i2] - startCoords[i2] + Number.EPSILON);
        else factor2 = factor2 * (endCoords[i2] - normalized[i2] + Number.EPSILON) / (endCoords[i2] - tupleCoords[i2] + Number.EPSILON);
      }
    }
    return factor2;
  }
  // Interpolates points without delta values.
  // Needed for the  and Q glyphs in Skia.
  // Algorithm from Freetype.
  interpolateMissingDeltas(points, inPoints, hasDelta) {
    if (points.length === 0) return;
    let point = 0;
    while (point < points.length) {
      let firstPoint = point;
      let endPoint = point;
      let pt = points[endPoint];
      while (!pt.endContour) pt = points[++endPoint];
      while (point <= endPoint && !hasDelta[point]) point++;
      if (point > endPoint) continue;
      let firstDelta = point;
      let curDelta = point;
      point++;
      while (point <= endPoint) {
        if (hasDelta[point]) {
          this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);
          curDelta = point;
        }
        point++;
      }
      if (curDelta === firstDelta) this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);
      else {
        this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);
        if (firstDelta > 0) this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);
      }
      point = endPoint + 1;
    }
  }
  deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {
    if (p1 > p2) return;
    let iterable = [
      "x",
      "y"
    ];
    for (let i2 = 0; i2 < iterable.length; i2++) {
      let k2 = iterable[i2];
      if (inPoints[ref1][k2] > inPoints[ref2][k2]) {
        var p3 = ref1;
        ref1 = ref2;
        ref2 = p3;
      }
      let in1 = inPoints[ref1][k2];
      let in2 = inPoints[ref2][k2];
      let out1 = outPoints[ref1][k2];
      let out2 = outPoints[ref2][k2];
      if (in1 !== in2 || out1 === out2) {
        let scale2 = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);
        for (let p4 = p1; p4 <= p2; p4++) {
          let out = inPoints[p4][k2];
          if (out <= in1) out += out1 - in1;
          else if (out >= in2) out += out2 - in2;
          else out = out1 + (out - in1) * scale2;
          outPoints[p4][k2] = out;
        }
      }
    }
  }
  deltaShift(p1, p2, ref, inPoints, outPoints) {
    let deltaX = outPoints[ref].x - inPoints[ref].x;
    let deltaY = outPoints[ref].y - inPoints[ref].y;
    if (deltaX === 0 && deltaY === 0) return;
    for (let p3 = p1; p3 <= p2; p3++) if (p3 !== ref) {
      outPoints[p3].x += deltaX;
      outPoints[p3].y += deltaY;
    }
  }
  getAdvanceAdjustment(gid, table) {
    let outerIndex, innerIndex;
    if (table.advanceWidthMapping) {
      let idx = gid;
      if (idx >= table.advanceWidthMapping.mapCount) idx = table.advanceWidthMapping.mapCount - 1;
      table.advanceWidthMapping.entryFormat;
      ({ outerIndex, innerIndex } = table.advanceWidthMapping.mapData[idx]);
    } else {
      outerIndex = 0;
      innerIndex = gid;
    }
    return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);
  }
  // See pseudo code from `Font Variations Overview'
  // in the OpenType specification.
  getDelta(itemStore, outerIndex, innerIndex) {
    if (outerIndex >= itemStore.itemVariationData.length) return 0;
    let varData = itemStore.itemVariationData[outerIndex];
    if (innerIndex >= varData.deltaSets.length) return 0;
    let deltaSet = varData.deltaSets[innerIndex];
    let blendVector = this.getBlendVector(itemStore, outerIndex);
    let netAdjustment = 0;
    for (let master = 0; master < varData.regionIndexCount; master++) netAdjustment += deltaSet.deltas[master] * blendVector[master];
    return netAdjustment;
  }
  getBlendVector(itemStore, outerIndex) {
    let varData = itemStore.itemVariationData[outerIndex];
    if (this.blendVectors.has(varData)) return this.blendVectors.get(varData);
    let normalizedCoords = this.normalizedCoords;
    let blendVector = [];
    for (let master = 0; master < varData.regionIndexCount; master++) {
      let scalar = 1;
      let regionIndex = varData.regionIndexes[master];
      let axes = itemStore.variationRegionList.variationRegions[regionIndex];
      for (let j = 0; j < axes.length; j++) {
        let axis = axes[j];
        let axisScalar;
        if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) axisScalar = 1;
        else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) axisScalar = 1;
        else if (axis.peakCoord === 0) axisScalar = 1;
        else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) axisScalar = 0;
        else {
          if (normalizedCoords[j] === axis.peakCoord) axisScalar = 1;
          else if (normalizedCoords[j] < axis.peakCoord) axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) / (axis.peakCoord - axis.startCoord + Number.EPSILON);
          else axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) / (axis.endCoord - axis.peakCoord + Number.EPSILON);
        }
        scalar *= axisScalar;
      }
      blendVector[master] = scalar;
    }
    this.blendVectors.set(varData, blendVector);
    return blendVector;
  }
  constructor(font, coords) {
    this.font = font;
    this.normalizedCoords = this.normalizeCoords(coords);
    this.blendVectors = /* @__PURE__ */ new Map();
  }
}
Promise.resolve();
class $5cc7476da92df375$export$2e2bcd8739ae039 {
  includeGlyph(glyph) {
    if (typeof glyph === "object") glyph = glyph.id;
    if (this.mapping[glyph] == null) {
      this.glyphs.push(glyph);
      this.mapping[glyph] = this.glyphs.length - 1;
    }
    return this.mapping[glyph];
  }
  constructor(font) {
    this.font = font;
    this.glyphs = [];
    this.mapping = {};
    this.includeGlyph(0);
  }
}
const $807e58506be70005$var$ON_CURVE = 1;
const $807e58506be70005$var$X_SHORT_VECTOR = 2;
const $807e58506be70005$var$Y_SHORT_VECTOR = 4;
const $807e58506be70005$var$REPEAT = 8;
const $807e58506be70005$var$SAME_X = 16;
const $807e58506be70005$var$SAME_Y = 32;
class $807e58506be70005$var$Point {
  static size(val) {
    return val >= 0 && val <= 255 ? 1 : 2;
  }
  static encode(stream2, value2) {
    if (value2 >= 0 && value2 <= 255) stream2.writeUInt8(value2);
    else stream2.writeInt16BE(value2);
  }
}
let $807e58506be70005$var$Glyf = new Struct({
  numberOfContours: int16,
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16,
  endPtsOfContours: new ArrayT(uint16, "numberOfContours"),
  instructions: new ArrayT(uint8, uint16),
  flags: new ArrayT(uint8, 0),
  xPoints: new ArrayT($807e58506be70005$var$Point, 0),
  yPoints: new ArrayT($807e58506be70005$var$Point, 0)
});
class $807e58506be70005$export$2e2bcd8739ae039 {
  encodeSimple(path, instructions = []) {
    let endPtsOfContours = [];
    let xPoints = [];
    let yPoints = [];
    let flags = [];
    let same = 0;
    let lastX = 0, lastY = 0, lastFlag = 0;
    let pointCount = 0;
    for (let i2 = 0; i2 < path.commands.length; i2++) {
      let c2 = path.commands[i2];
      for (let j = 0; j < c2.args.length; j += 2) {
        let x = c2.args[j];
        let y2 = c2.args[j + 1];
        let flag = 0;
        if (c2.command === "quadraticCurveTo" && j === 2) {
          let next = path.commands[i2 + 1];
          if (next && next.command === "quadraticCurveTo") {
            let midX = (lastX + next.args[0]) / 2;
            let midY = (lastY + next.args[1]) / 2;
            if (x === midX && y2 === midY) continue;
          }
        }
        if (!(c2.command === "quadraticCurveTo" && j === 0)) flag |= $807e58506be70005$var$ON_CURVE;
        flag = this._encodePoint(x, lastX, xPoints, flag, $807e58506be70005$var$X_SHORT_VECTOR, $807e58506be70005$var$SAME_X);
        flag = this._encodePoint(y2, lastY, yPoints, flag, $807e58506be70005$var$Y_SHORT_VECTOR, $807e58506be70005$var$SAME_Y);
        if (flag === lastFlag && same < 255) {
          flags[flags.length - 1] |= $807e58506be70005$var$REPEAT;
          same++;
        } else {
          if (same > 0) {
            flags.push(same);
            same = 0;
          }
          flags.push(flag);
          lastFlag = flag;
        }
        lastX = x;
        lastY = y2;
        pointCount++;
      }
      if (c2.command === "closePath") endPtsOfContours.push(pointCount - 1);
    }
    if (path.commands.length > 1 && path.commands[path.commands.length - 1].command !== "closePath") endPtsOfContours.push(pointCount - 1);
    let bbox = path.bbox;
    let glyf = {
      numberOfContours: endPtsOfContours.length,
      xMin: bbox.minX,
      yMin: bbox.minY,
      xMax: bbox.maxX,
      yMax: bbox.maxY,
      endPtsOfContours,
      instructions,
      flags,
      xPoints,
      yPoints
    };
    let size = $807e58506be70005$var$Glyf.size(glyf);
    let tail = 4 - size % 4;
    let stream2 = new EncodeStream(size + tail);
    $807e58506be70005$var$Glyf.encode(stream2, glyf);
    if (tail !== 0) stream2.fill(0, tail);
    return stream2.buffer;
  }
  _encodePoint(value2, last2, points, flag, shortFlag, sameFlag) {
    let diff = value2 - last2;
    if (value2 === last2) flag |= sameFlag;
    else {
      if (-255 <= diff && diff <= 255) {
        flag |= shortFlag;
        if (diff < 0) diff = -diff;
        else flag |= sameFlag;
      }
      points.push(diff);
    }
    return flag;
  }
}
class $4abbb6a5dbdc441a$export$2e2bcd8739ae039 extends $5cc7476da92df375$export$2e2bcd8739ae039 {
  _addGlyph(gid) {
    let glyph = this.font.getGlyph(gid);
    let glyf = glyph._decode();
    let curOffset = this.font.loca.offsets[gid];
    let nextOffset = this.font.loca.offsets[gid + 1];
    let stream2 = this.font._getTableStream("glyf");
    stream2.pos += curOffset;
    let buffer = stream2.readBuffer(nextOffset - curOffset);
    if (glyf && glyf.numberOfContours < 0) {
      buffer = new Uint8Array(buffer);
      let view = new DataView(buffer.buffer);
      for (let component of glyf.components) {
        gid = this.includeGlyph(component.glyphID);
        view.setUint16(component.pos, gid);
      }
    } else if (glyf && this.font._variationProcessor)
      buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);
    this.glyf.push(buffer);
    this.loca.offsets.push(this.offset);
    this.hmtx.metrics.push({
      advance: glyph.advanceWidth,
      bearing: glyph._getMetrics().leftBearing
    });
    this.offset += buffer.length;
    return this.glyf.length - 1;
  }
  encode() {
    this.glyf = [];
    this.offset = 0;
    this.loca = {
      offsets: [],
      version: this.font.loca.version
    };
    this.hmtx = {
      metrics: [],
      bearings: []
    };
    let i2 = 0;
    while (i2 < this.glyphs.length) this._addGlyph(this.glyphs[i2++]);
    let maxp = $6uUbQ$clone(this.font.maxp);
    maxp.numGlyphs = this.glyf.length;
    this.loca.offsets.push(this.offset);
    let head = $6uUbQ$clone(this.font.head);
    head.indexToLocFormat = this.loca.version;
    let hhea = $6uUbQ$clone(this.font.hhea);
    hhea.numberOfMetrics = this.hmtx.metrics.length;
    return $816c07a04b6dba87$export$2e2bcd8739ae039.toBuffer({
      tables: {
        head,
        hhea,
        loca: this.loca,
        maxp,
        "cvt ": this.font["cvt "],
        prep: this.font.prep,
        glyf: this.glyf,
        hmtx: this.hmtx,
        fpgm: this.font.fpgm
      }
    });
  }
  constructor(font) {
    super(font);
    this.glyphEncoder = new $807e58506be70005$export$2e2bcd8739ae039();
  }
}
class $001d739428a71d5a$export$2e2bcd8739ae039 extends $5cc7476da92df375$export$2e2bcd8739ae039 {
  subsetCharstrings() {
    this.charstrings = [];
    let gsubrs = {};
    for (let gid of this.glyphs) {
      this.charstrings.push(this.cff.getCharString(gid));
      let glyph = this.font.getGlyph(gid);
      glyph.path;
      for (let subr in glyph._usedGsubrs) gsubrs[subr] = true;
    }
    this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);
  }
  subsetSubrs(subrs, used) {
    let res = [];
    for (let i2 = 0; i2 < subrs.length; i2++) {
      let subr = subrs[i2];
      if (used[i2]) {
        this.cff.stream.pos = subr.offset;
        res.push(this.cff.stream.readBuffer(subr.length));
      } else res.push(new Uint8Array([
        11
      ]));
    }
    return res;
  }
  subsetFontdict(topDict) {
    topDict.FDArray = [];
    topDict.FDSelect = {
      version: 0,
      fds: []
    };
    let used_fds = {};
    let used_subrs = [];
    let fd_select = {};
    for (let gid of this.glyphs) {
      let fd = this.cff.fdForGlyph(gid);
      if (fd == null) continue;
      if (!used_fds[fd]) {
        topDict.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[fd]));
        used_subrs.push({});
        fd_select[fd] = topDict.FDArray.length - 1;
      }
      used_fds[fd] = true;
      topDict.FDSelect.fds.push(fd_select[fd]);
      let glyph = this.font.getGlyph(gid);
      glyph.path;
      for (let subr in glyph._usedSubrs) used_subrs[fd_select[fd]][subr] = true;
    }
    for (let i2 = 0; i2 < topDict.FDArray.length; i2++) {
      let dict = topDict.FDArray[i2];
      delete dict.FontName;
      if (dict.Private && dict.Private.Subrs) {
        dict.Private = Object.assign({}, dict.Private);
        dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i2]);
      }
    }
    return;
  }
  createCIDFontdict(topDict) {
    let used_subrs = {};
    for (let gid of this.glyphs) {
      let glyph = this.font.getGlyph(gid);
      glyph.path;
      for (let subr in glyph._usedSubrs) used_subrs[subr] = true;
    }
    let privateDict = Object.assign({}, this.cff.topDict.Private);
    if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs) privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
    topDict.FDArray = [
      {
        Private: privateDict
      }
    ];
    return topDict.FDSelect = {
      version: 3,
      nRanges: 1,
      ranges: [
        {
          first: 0,
          fd: 0
        }
      ],
      sentinel: this.charstrings.length
    };
  }
  addString(string) {
    if (!string) return null;
    if (!this.strings) this.strings = [];
    this.strings.push(string);
    return $229224aec43783c5$export$2e2bcd8739ae039.length + this.strings.length - 1;
  }
  encode() {
    this.subsetCharstrings();
    let charset = {
      version: this.charstrings.length > 255 ? 2 : 1,
      ranges: [
        {
          first: 1,
          nLeft: this.charstrings.length - 2
        }
      ]
    };
    let topDict = Object.assign({}, this.cff.topDict);
    topDict.Private = null;
    topDict.charset = charset;
    topDict.Encoding = null;
    topDict.CharStrings = this.charstrings;
    for (let key of [
      "version",
      "Notice",
      "Copyright",
      "FullName",
      "FamilyName",
      "Weight",
      "PostScript",
      "BaseFontName",
      "FontName"
    ]) topDict[key] = this.addString(this.cff.string(topDict[key]));
    topDict.ROS = [
      this.addString("Adobe"),
      this.addString("Identity"),
      0
    ];
    topDict.CIDCount = this.charstrings.length;
    if (this.cff.isCIDFont) this.subsetFontdict(topDict);
    else this.createCIDFontdict(topDict);
    let top = {
      version: 1,
      hdrSize: this.cff.hdrSize,
      offSize: 4,
      header: this.cff.header,
      nameIndex: [
        this.cff.postscriptName
      ],
      topDictIndex: [
        topDict
      ],
      stringIndex: this.strings,
      globalSubrIndex: this.gsubrs
    };
    return $b84fd3dd9d8eddb2$export$2e2bcd8739ae039.toBuffer(top);
  }
  constructor(font) {
    super(font);
    this.cff = this.font["CFF "];
    if (!this.cff) throw new Error("Not a CFF Font");
  }
}
class $4c1709dee528ea76$export$2e2bcd8739ae039 {
  static probe(buffer) {
    let format2 = $12727730ddfc8bfe$export$3d28c1996ced1f14.decode(buffer.slice(0, 4));
    return format2 === "true" || format2 === "OTTO" || format2 === String.fromCharCode(0, 1, 0, 0);
  }
  setDefaultLanguage(lang = null) {
    this.defaultLanguage = lang;
  }
  _getTable(table) {
    if (!(table.tag in this._tables)) try {
      this._tables[table.tag] = this._decodeTable(table);
    } catch (e2) {
    }
    return this._tables[table.tag];
  }
  _getTableStream(tag) {
    let table = this.directory.tables[tag];
    if (table) {
      this.stream.pos = table.offset;
      return this.stream;
    }
    return null;
  }
  _decodeDirectory() {
    return this.directory = $816c07a04b6dba87$export$2e2bcd8739ae039.decode(this.stream, {
      _startOffset: 0
    });
  }
  _decodeTable(table) {
    let pos = this.stream.pos;
    let stream2 = this._getTableStream(table.tag);
    let result = $c3395722bea751e2$export$2e2bcd8739ae039[table.tag].decode(stream2, this, table.length);
    this.stream.pos = pos;
    return result;
  }
  /**
  * Gets a string from the font's `name` table
  * `lang` is a BCP-47 language code.
  * @return {string}
  */
  getName(key, lang = this.defaultLanguage || $d636bc798e7178db$export$42940898df819940) {
    let record = this.name && this.name.records[key];
    if (record)
      return record[lang] || record[this.defaultLanguage] || record[$d636bc798e7178db$export$42940898df819940] || record["en"] || record[Object.keys(record)[0]] || null;
    return null;
  }
  /**
  * The unique PostScript name for this font, e.g. "Helvetica-Bold"
  * @type {string}
  */
  get postscriptName() {
    return this.getName("postscriptName");
  }
  /**
  * The font's full name, e.g. "Helvetica Bold"
  * @type {string}
  */
  get fullName() {
    return this.getName("fullName");
  }
  /**
  * The font's family name, e.g. "Helvetica"
  * @type {string}
  */
  get familyName() {
    return this.getName("fontFamily");
  }
  /**
  * The font's sub-family, e.g. "Bold".
  * @type {string}
  */
  get subfamilyName() {
    return this.getName("fontSubfamily");
  }
  /**
  * The font's copyright information
  * @type {string}
  */
  get copyright() {
    return this.getName("copyright");
  }
  /**
  * The font's version number
  * @type {string}
  */
  get version() {
    return this.getName("version");
  }
  /**
  * The fonts [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))
  * @type {number}
  */
  get ascent() {
    return this.hhea.ascent;
  }
  /**
  * The fonts [descender](https://en.wikipedia.org/wiki/Descender)
  * @type {number}
  */
  get descent() {
    return this.hhea.descent;
  }
  /**
  * The amount of space that should be included between lines
  * @type {number}
  */
  get lineGap() {
    return this.hhea.lineGap;
  }
  /**
  * The offset from the normal underline position that should be used
  * @type {number}
  */
  get underlinePosition() {
    return this.post.underlinePosition;
  }
  /**
  * The weight of the underline that should be used
  * @type {number}
  */
  get underlineThickness() {
    return this.post.underlineThickness;
  }
  /**
  * If this is an italic font, the angle the cursor should be drawn at to match the font design
  * @type {number}
  */
  get italicAngle() {
    return this.post.italicAngle;
  }
  /**
  * The height of capital letters above the baseline.
  * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.
  * @type {number}
  */
  get capHeight() {
    let os2 = this["OS/2"];
    return os2 ? os2.capHeight : this.ascent;
  }
  /**
  * The height of lower case letters in the font.
  * See [here](https://en.wikipedia.org/wiki/X-height) for more details.
  * @type {number}
  */
  get xHeight() {
    let os2 = this["OS/2"];
    return os2 ? os2.xHeight : 0;
  }
  /**
  * The number of glyphs in the font.
  * @type {number}
  */
  get numGlyphs() {
    return this.maxp.numGlyphs;
  }
  /**
  * The size of the fonts internal coordinate grid
  * @type {number}
  */
  get unitsPerEm() {
    return this.head.unitsPerEm;
  }
  /**
  * The fonts bounding box, i.e. the box that encloses all glyphs in the font.
  * @type {BBox}
  */
  get bbox() {
    return Object.freeze(new $f34600ab9d7f70d8$export$2e2bcd8739ae039(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
  }
  get _cmapProcessor() {
    return new $f08dd41ef10b694c$export$2e2bcd8739ae039(this.cmap);
  }
  /**
  * An array of all of the unicode code points supported by the font.
  * @type {number[]}
  */
  get characterSet() {
    return this._cmapProcessor.getCharacterSet();
  }
  /**
  * Returns whether there is glyph in the font for the given unicode code point.
  *
  * @param {number} codePoint
  * @return {boolean}
  */
  hasGlyphForCodePoint(codePoint) {
    return !!this._cmapProcessor.lookup(codePoint);
  }
  /**
  * Maps a single unicode code point to a Glyph object.
  * Does not perform any advanced substitutions (there is no context to do so).
  *
  * @param {number} codePoint
  * @return {Glyph}
  */
  glyphForCodePoint(codePoint) {
    return this.getGlyph(this._cmapProcessor.lookup(codePoint), [
      codePoint
    ]);
  }
  /**
  * Returns an array of Glyph objects for the given string.
  * This is only a one-to-one mapping from characters to glyphs.
  * For most uses, you should use font.layout (described below), which
  * provides a much more advanced mapping supporting AAT and OpenType shaping.
  *
  * @param {string} string
  * @return {Glyph[]}
  */
  glyphsForString(string) {
    let glyphs = [];
    let len = string.length;
    let idx = 0;
    let last2 = -1;
    let state2 = -1;
    while (idx <= len) {
      let code = 0;
      let nextState = 0;
      if (idx < len) {
        code = string.charCodeAt(idx++);
        if (55296 <= code && code <= 56319 && idx < len) {
          let next = string.charCodeAt(idx);
          if (56320 <= next && next <= 57343) {
            idx++;
            code = ((code & 1023) << 10) + (next & 1023) + 65536;
          }
        }
        nextState = 65024 <= code && code <= 65039 || 917760 <= code && code <= 917999 ? 1 : 0;
      } else idx++;
      if (state2 === 0 && nextState === 1)
        glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last2, code), [
          last2,
          code
        ]));
      else if (state2 === 0 && nextState === 0)
        glyphs.push(this.glyphForCodePoint(last2));
      last2 = code;
      state2 = nextState;
    }
    return glyphs;
  }
  get _layoutEngine() {
    return new $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039(this);
  }
  /**
  * Returns a GlyphRun object, which includes an array of Glyphs and GlyphPositions for the given string.
  *
  * @param {string} string
  * @param {string[]} [userFeatures]
  * @param {string} [script]
  * @param {string} [language]
  * @param {string} [direction]
  * @return {GlyphRun}
  */
  layout(string, userFeatures, script, language, direction) {
    return this._layoutEngine.layout(string, userFeatures, script, language, direction);
  }
  /**
  * Returns an array of strings that map to the given glyph id.
  * @param {number} gid - glyph id
  */
  stringsForGlyph(gid) {
    return this._layoutEngine.stringsForGlyph(gid);
  }
  /**
  * An array of all [OpenType feature tags](https://www.microsoft.com/typography/otspec/featuretags.htm)
  * (or mapped AAT tags) supported by the font.
  * The features parameter is an array of OpenType feature tags to be applied in addition to the default set.
  * If this is an AAT font, the OpenType feature tags are mapped to AAT features.
  *
  * @type {string[]}
  */
  get availableFeatures() {
    return this._layoutEngine.getAvailableFeatures();
  }
  getAvailableFeatures(script, language) {
    return this._layoutEngine.getAvailableFeatures(script, language);
  }
  _getBaseGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.glyf) this._glyphs[glyph] = new $69aac16029968692$export$2e2bcd8739ae039(glyph, characters2, this);
      else if (this.directory.tables["CFF "] || this.directory.tables.CFF2) this._glyphs[glyph] = new $62cc5109c6101893$export$2e2bcd8739ae039(glyph, characters2, this);
    }
    return this._glyphs[glyph] || null;
  }
  /**
  * Returns a glyph object for the given glyph id.
  * You can pass the array of code points this glyph represents for
  * your use later, and it will be stored in the glyph object.
  *
  * @param {number} glyph
  * @param {number[]} characters
  * @return {Glyph}
  */
  getGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.sbix) this._glyphs[glyph] = new $25d8f049c222084c$export$2e2bcd8739ae039(glyph, characters2, this);
      else if (this.directory.tables.COLR && this.directory.tables.CPAL) this._glyphs[glyph] = new $0d411f0165859681$export$2e2bcd8739ae039(glyph, characters2, this);
      else this._getBaseGlyph(glyph, characters2);
    }
    return this._glyphs[glyph] || null;
  }
  /**
  * Returns a Subset for this font.
  * @return {Subset}
  */
  createSubset() {
    if (this.directory.tables["CFF "]) return new $001d739428a71d5a$export$2e2bcd8739ae039(this);
    return new $4abbb6a5dbdc441a$export$2e2bcd8739ae039(this);
  }
  /**
  * Returns an object describing the available variation axes
  * that this font supports. Keys are setting tags, and values
  * contain the axis name, range, and default value.
  *
  * @type {object}
  */
  get variationAxes() {
    let res = {};
    if (!this.fvar) return res;
    for (let axis of this.fvar.axis) res[axis.axisTag.trim()] = {
      name: axis.name.en,
      min: axis.minValue,
      default: axis.defaultValue,
      max: axis.maxValue
    };
    return res;
  }
  /**
  * Returns an object describing the named variation instances
  * that the font designer has specified. Keys are variation names
  * and values are the variation settings for this instance.
  *
  * @type {object}
  */
  get namedVariations() {
    let res = {};
    if (!this.fvar) return res;
    for (let instance of this.fvar.instance) {
      let settings = {};
      for (let i2 = 0; i2 < this.fvar.axis.length; i2++) {
        let axis = this.fvar.axis[i2];
        settings[axis.axisTag.trim()] = instance.coord[i2];
      }
      res[instance.name.en] = settings;
    }
    return res;
  }
  /**
  * Returns a new font with the given variation settings applied.
  * Settings can either be an instance name, or an object containing
  * variation tags as specified by the `variationAxes` property.
  *
  * @param {object} settings
  * @return {TTFFont}
  */
  getVariation(settings) {
    if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2))) throw new Error("Variations require a font with the fvar, gvar and glyf, or CFF2 tables.");
    if (typeof settings === "string") settings = this.namedVariations[settings];
    if (typeof settings !== "object") throw new Error("Variation settings must be either a variation name or settings object.");
    let coords = this.fvar.axis.map((axis, i2) => {
      let axisTag = axis.axisTag.trim();
      if (axisTag in settings) return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));
      else return axis.defaultValue;
    });
    let stream2 = new DecodeStream(this.stream.buffer);
    stream2.pos = this._directoryPos;
    let font = new $4c1709dee528ea76$export$2e2bcd8739ae039(stream2, coords);
    font._tables = this._tables;
    return font;
  }
  get _variationProcessor() {
    if (!this.fvar) return null;
    let variationCoords = this.variationCoords;
    if (!variationCoords && !this.CFF2) return null;
    if (!variationCoords) variationCoords = this.fvar.axis.map((axis) => axis.defaultValue);
    return new $0bb840cac04e911b$export$2e2bcd8739ae039(this, variationCoords);
  }
  // Standardized format plugin API
  getFont(name) {
    return this.getVariation(name);
  }
  constructor(stream2, variationCoords = null) {
    _define_property(this, "type", "TTF");
    this.defaultLanguage = null;
    this.stream = stream2;
    this.variationCoords = variationCoords;
    this._directoryPos = this.stream.pos;
    this._tables = {};
    this._glyphs = {};
    this._decodeDirectory();
    for (let tag in this.directory.tables) {
      let table = this.directory.tables[tag];
      if ($c3395722bea751e2$export$2e2bcd8739ae039[tag] && table.length > 0) Object.defineProperty(this, tag, {
        get: this._getTable.bind(this, table)
      });
    }
  }
}
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "bbox", null);
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_cmapProcessor", null);
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "characterSet", null);
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_layoutEngine", null);
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "variationAxes", null);
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "namedVariations", null);
__decorate([
  $e71565f2ce09cb6b$export$69a3209f1a06c04d
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_variationProcessor", null);
let $c1726355ecc5b889$var$WOFFDirectoryEntry = new Struct({
  tag: new StringT(4),
  offset: new Pointer(uint32, "void", {
    type: "global"
  }),
  compLength: uint32,
  length: uint32,
  origChecksum: uint32
});
let $c1726355ecc5b889$var$WOFFDirectory = new Struct({
  tag: new StringT(4),
  flavor: uint32,
  length: uint32,
  numTables: uint16,
  reserved: new Reserved(uint16),
  totalSfntSize: uint32,
  majorVersion: uint16,
  minorVersion: uint16,
  metaOffset: uint32,
  metaLength: uint32,
  metaOrigLength: uint32,
  privOffset: uint32,
  privLength: uint32,
  tables: new ArrayT($c1726355ecc5b889$var$WOFFDirectoryEntry, "numTables")
});
$c1726355ecc5b889$var$WOFFDirectory.process = function() {
  let tables = {};
  for (let table of this.tables) tables[table.tag] = table;
  this.tables = tables;
};
var $c1726355ecc5b889$export$2e2bcd8739ae039 = $c1726355ecc5b889$var$WOFFDirectory;
class $760785214b9fc52c$export$2e2bcd8739ae039 extends $4c1709dee528ea76$export$2e2bcd8739ae039 {
  static probe(buffer) {
    return $12727730ddfc8bfe$export$3d28c1996ced1f14.decode(buffer.slice(0, 4)) === "wOFF";
  }
  _decodeDirectory() {
    this.directory = $c1726355ecc5b889$export$2e2bcd8739ae039.decode(this.stream, {
      _startOffset: 0
    });
  }
  _getTableStream(tag) {
    let table = this.directory.tables[tag];
    if (table) {
      this.stream.pos = table.offset;
      if (table.compLength < table.length) {
        this.stream.pos += 2;
        let outBuffer = new Uint8Array(table.length);
        let buf = $6uUbQ$tinyinflate(this.stream.readBuffer(table.compLength - 2), outBuffer);
        return new DecodeStream(buf);
      } else return this.stream;
    }
    return null;
  }
  constructor(...args) {
    super(...args);
    _define_property(this, "type", "WOFF");
  }
}
class $8046190c9f1ad19e$export$2e2bcd8739ae039 extends $69aac16029968692$export$2e2bcd8739ae039 {
  _decode() {
    return this._font._transformedGlyphs[this.id];
  }
  _getCBox() {
    return this.path.bbox;
  }
  constructor(...args) {
    super(...args);
    _define_property(this, "type", "WOFF2");
  }
}
const $c28ec7bbb3b8de3a$var$Base128 = {
  decode(stream2) {
    let result = 0;
    let iterable = [
      0,
      1,
      2,
      3,
      4
    ];
    for (let j = 0; j < iterable.length; j++) {
      let code = stream2.readUInt8();
      if (result & 3758096384) throw new Error("Overflow");
      result = result << 7 | code & 127;
      if ((code & 128) === 0) return result;
    }
    throw new Error("Bad base 128 number");
  }
};
let $c28ec7bbb3b8de3a$var$knownTags = [
  "cmap",
  "head",
  "hhea",
  "hmtx",
  "maxp",
  "name",
  "OS/2",
  "post",
  "cvt ",
  "fpgm",
  "glyf",
  "loca",
  "prep",
  "CFF ",
  "VORG",
  "EBDT",
  "EBLC",
  "gasp",
  "hdmx",
  "kern",
  "LTSH",
  "PCLT",
  "VDMX",
  "vhea",
  "vmtx",
  "BASE",
  "GDEF",
  "GPOS",
  "GSUB",
  "EBSC",
  "JSTF",
  "MATH",
  "CBDT",
  "CBLC",
  "COLR",
  "CPAL",
  "SVG ",
  "sbix",
  "acnt",
  "avar",
  "bdat",
  "bloc",
  "bsln",
  "cvar",
  "fdsc",
  "feat",
  "fmtx",
  "fvar",
  "gvar",
  "hsty",
  "just",
  "lcar",
  "mort",
  "morx",
  "opbd",
  "prop",
  "trak",
  "Zapf",
  "Silf",
  "Glat",
  "Gloc",
  "Feat",
  "Sill"
];
let $c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry = new Struct({
  flags: uint8,
  customTag: new Optional(new StringT(4), (t2) => (t2.flags & 63) === 63),
  tag: (t2) => t2.customTag || $c28ec7bbb3b8de3a$var$knownTags[t2.flags & 63],
  length: $c28ec7bbb3b8de3a$var$Base128,
  transformVersion: (t2) => t2.flags >>> 6 & 3,
  transformed: (t2) => t2.tag === "glyf" || t2.tag === "loca" ? t2.transformVersion === 0 : t2.transformVersion !== 0,
  transformLength: new Optional($c28ec7bbb3b8de3a$var$Base128, (t2) => t2.transformed)
});
let $c28ec7bbb3b8de3a$var$WOFF2Directory = new Struct({
  tag: new StringT(4),
  flavor: uint32,
  length: uint32,
  numTables: uint16,
  reserved: new Reserved(uint16),
  totalSfntSize: uint32,
  totalCompressedSize: uint32,
  majorVersion: uint16,
  minorVersion: uint16,
  metaOffset: uint32,
  metaLength: uint32,
  metaOrigLength: uint32,
  privOffset: uint32,
  privLength: uint32,
  tables: new ArrayT($c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry, "numTables")
});
$c28ec7bbb3b8de3a$var$WOFF2Directory.process = function() {
  let tables = {};
  for (let i2 = 0; i2 < this.tables.length; i2++) {
    let table = this.tables[i2];
    tables[table.tag] = table;
  }
  return this.tables = tables;
};
var $c28ec7bbb3b8de3a$export$2e2bcd8739ae039 = $c28ec7bbb3b8de3a$var$WOFF2Directory;
class $21ee218f84ac7f32$export$2e2bcd8739ae039 extends $4c1709dee528ea76$export$2e2bcd8739ae039 {
  static probe(buffer) {
    return $12727730ddfc8bfe$export$3d28c1996ced1f14.decode(buffer.slice(0, 4)) === "wOF2";
  }
  _decodeDirectory() {
    this.directory = $c28ec7bbb3b8de3a$export$2e2bcd8739ae039.decode(this.stream);
    this._dataPos = this.stream.pos;
  }
  _decompress() {
    if (!this._decompressed) {
      this.stream.pos = this._dataPos;
      let buffer = this.stream.readBuffer(this.directory.totalCompressedSize);
      let decompressedSize = 0;
      for (let tag in this.directory.tables) {
        let entry = this.directory.tables[tag];
        entry.offset = decompressedSize;
        decompressedSize += entry.transformLength != null ? entry.transformLength : entry.length;
      }
      let decompressed = $6uUbQ$brotlidecompressjs(buffer, decompressedSize);
      if (!decompressed) throw new Error("Error decoding compressed data in WOFF2");
      this.stream = new DecodeStream(decompressed);
      this._decompressed = true;
    }
  }
  _decodeTable(table) {
    this._decompress();
    return super._decodeTable(table);
  }
  // Override this method to get a glyph and return our
  // custom subclass if there is a glyf table.
  _getBaseGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {
        if (!this._transformedGlyphs) this._transformGlyfTable();
        return this._glyphs[glyph] = new $8046190c9f1ad19e$export$2e2bcd8739ae039(glyph, characters2, this);
      } else return super._getBaseGlyph(glyph, characters2);
    }
  }
  _transformGlyfTable() {
    this._decompress();
    this.stream.pos = this.directory.tables.glyf.offset;
    let table = $21ee218f84ac7f32$var$GlyfTable.decode(this.stream);
    let glyphs = [];
    for (let index2 = 0; index2 < table.numGlyphs; index2++) {
      let glyph = {};
      let nContours = table.nContours.readInt16BE();
      glyph.numberOfContours = nContours;
      if (nContours > 0) {
        let nPoints = [];
        let totalPoints = 0;
        for (let i2 = 0; i2 < nContours; i2++) {
          let r2 = $21ee218f84ac7f32$var$read255UInt16(table.nPoints);
          totalPoints += r2;
          nPoints.push(totalPoints);
        }
        glyph.points = $21ee218f84ac7f32$var$decodeTriplet(table.flags, table.glyphs, totalPoints);
        for (let i2 = 0; i2 < nContours; i2++) glyph.points[nPoints[i2] - 1].endContour = true;
        var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);
      } else if (nContours < 0) {
        let haveInstructions = $69aac16029968692$export$2e2bcd8739ae039.prototype._decodeComposite.call({
          _font: this
        }, glyph, table.composites);
        if (haveInstructions) var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);
      }
      glyphs.push(glyph);
    }
    this._transformedGlyphs = glyphs;
  }
  constructor(...args) {
    super(...args);
    _define_property(this, "type", "WOFF2");
  }
}
class $21ee218f84ac7f32$var$Substream {
  decode(stream2, parent) {
    return new DecodeStream(this._buf.decode(stream2, parent));
  }
  constructor(length2) {
    this.length = length2;
    this._buf = new BufferT(length2);
  }
}
let $21ee218f84ac7f32$var$GlyfTable = new Struct({
  version: uint32,
  numGlyphs: uint16,
  indexFormat: uint16,
  nContourStreamSize: uint32,
  nPointsStreamSize: uint32,
  flagStreamSize: uint32,
  glyphStreamSize: uint32,
  compositeStreamSize: uint32,
  bboxStreamSize: uint32,
  instructionStreamSize: uint32,
  nContours: new $21ee218f84ac7f32$var$Substream("nContourStreamSize"),
  nPoints: new $21ee218f84ac7f32$var$Substream("nPointsStreamSize"),
  flags: new $21ee218f84ac7f32$var$Substream("flagStreamSize"),
  glyphs: new $21ee218f84ac7f32$var$Substream("glyphStreamSize"),
  composites: new $21ee218f84ac7f32$var$Substream("compositeStreamSize"),
  bboxes: new $21ee218f84ac7f32$var$Substream("bboxStreamSize"),
  instructions: new $21ee218f84ac7f32$var$Substream("instructionStreamSize")
});
const $21ee218f84ac7f32$var$WORD_CODE = 253;
const $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2 = 254;
const $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1 = 255;
const $21ee218f84ac7f32$var$LOWEST_U_CODE = 253;
function $21ee218f84ac7f32$var$read255UInt16(stream2) {
  let code = stream2.readUInt8();
  if (code === $21ee218f84ac7f32$var$WORD_CODE) return stream2.readUInt16BE();
  if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1) return stream2.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE;
  if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2) return stream2.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE * 2;
  return code;
}
function $21ee218f84ac7f32$var$withSign(flag, baseval) {
  return flag & 1 ? baseval : -baseval;
}
function $21ee218f84ac7f32$var$decodeTriplet(flags, glyphs, nPoints) {
  let y2;
  let x = y2 = 0;
  let res = [];
  for (let i2 = 0; i2 < nPoints; i2++) {
    let dx = 0, dy = 0;
    let flag = flags.readUInt8();
    let onCurve = !(flag >> 7);
    flag &= 127;
    if (flag < 10) {
      dx = 0;
      dy = $21ee218f84ac7f32$var$withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());
    } else if (flag < 20) {
      dx = $21ee218f84ac7f32$var$withSign(flag, ((flag - 10 & 14) << 7) + glyphs.readUInt8());
      dy = 0;
    } else if (flag < 84) {
      var b0 = flag - 20;
      var b1 = glyphs.readUInt8();
      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b0 & 48) + (b1 >> 4));
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + ((b0 & 12) << 2) + (b1 & 15));
    } else if (flag < 120) {
      var b0 = flag - 84;
      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b0 / 12 << 8) + glyphs.readUInt8());
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + (b0 % 12 >> 2 << 8) + glyphs.readUInt8());
    } else if (flag < 124) {
      var b1 = glyphs.readUInt8();
      let b2 = glyphs.readUInt8();
      dx = $21ee218f84ac7f32$var$withSign(flag, (b1 << 4) + (b2 >> 4));
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, ((b2 & 15) << 8) + glyphs.readUInt8());
    } else {
      dx = $21ee218f84ac7f32$var$withSign(flag, glyphs.readUInt16BE());
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, glyphs.readUInt16BE());
    }
    x += dx;
    y2 += dy;
    res.push(new $69aac16029968692$export$baf26146a414f24a(onCurve, false, x, y2));
  }
  return res;
}
let $cd5853a56c68fec7$var$TTCHeader = new VersionedStruct(uint32, {
  65536: {
    numFonts: uint32,
    offsets: new ArrayT(uint32, "numFonts")
  },
  131072: {
    numFonts: uint32,
    offsets: new ArrayT(uint32, "numFonts"),
    dsigTag: uint32,
    dsigLength: uint32,
    dsigOffset: uint32
  }
});
class $cd5853a56c68fec7$export$2e2bcd8739ae039 {
  static probe(buffer) {
    return $12727730ddfc8bfe$export$3d28c1996ced1f14.decode(buffer.slice(0, 4)) === "ttcf";
  }
  getFont(name) {
    for (let offset2 of this.header.offsets) {
      let stream2 = new DecodeStream(this.stream.buffer);
      stream2.pos = offset2;
      let font = new $4c1709dee528ea76$export$2e2bcd8739ae039(stream2);
      if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v2, i2) => name[i2] === v2)) return font;
    }
    return null;
  }
  get fonts() {
    let fonts = [];
    for (let offset2 of this.header.offsets) {
      let stream2 = new DecodeStream(this.stream.buffer);
      stream2.pos = offset2;
      fonts.push(new $4c1709dee528ea76$export$2e2bcd8739ae039(stream2));
    }
    return fonts;
  }
  constructor(stream2) {
    _define_property(this, "type", "TTC");
    this.stream = stream2;
    if (stream2.readString(4) !== "ttcf") throw new Error("Not a TrueType collection");
    this.header = $cd5853a56c68fec7$var$TTCHeader.decode(stream2);
  }
}
let $05f49f930186144e$var$DFontName = new StringT(uint8);
new Struct({
  len: uint32,
  buf: new BufferT("len")
});
let $05f49f930186144e$var$Ref = new Struct({
  id: uint16,
  nameOffset: int16,
  attr: uint8,
  dataOffset: uint24,
  handle: uint32
});
let $05f49f930186144e$var$Type = new Struct({
  name: new StringT(4),
  maxTypeIndex: uint16,
  refList: new Pointer(uint16, new ArrayT($05f49f930186144e$var$Ref, (t2) => t2.maxTypeIndex + 1), {
    type: "parent"
  })
});
let $05f49f930186144e$var$TypeList = new Struct({
  length: uint16,
  types: new ArrayT($05f49f930186144e$var$Type, (t2) => t2.length + 1)
});
let $05f49f930186144e$var$DFontMap = new Struct({
  reserved: new Reserved(uint8, 24),
  typeList: new Pointer(uint16, $05f49f930186144e$var$TypeList),
  nameListOffset: new Pointer(uint16, "void")
});
let $05f49f930186144e$var$DFontHeader = new Struct({
  dataOffset: uint32,
  map: new Pointer(uint32, $05f49f930186144e$var$DFontMap),
  dataLength: uint32,
  mapLength: uint32
});
class $05f49f930186144e$export$2e2bcd8739ae039 {
  static probe(buffer) {
    let stream2 = new DecodeStream(buffer);
    try {
      var header = $05f49f930186144e$var$DFontHeader.decode(stream2);
    } catch (e2) {
      return false;
    }
    for (let type of header.map.typeList.types) {
      if (type.name === "sfnt") return true;
    }
    return false;
  }
  getFont(name) {
    if (!this.sfnt) return null;
    for (let ref of this.sfnt.refList) {
      let pos = this.header.dataOffset + ref.dataOffset + 4;
      let stream2 = new DecodeStream(this.stream.buffer.slice(pos));
      let font = new $4c1709dee528ea76$export$2e2bcd8739ae039(stream2);
      if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v2, i2) => name[i2] === v2)) return font;
    }
    return null;
  }
  get fonts() {
    let fonts = [];
    for (let ref of this.sfnt.refList) {
      let pos = this.header.dataOffset + ref.dataOffset + 4;
      let stream2 = new DecodeStream(this.stream.buffer.slice(pos));
      fonts.push(new $4c1709dee528ea76$export$2e2bcd8739ae039(stream2));
    }
    return fonts;
  }
  constructor(stream2) {
    _define_property(this, "type", "DFont");
    this.stream = stream2;
    this.header = $05f49f930186144e$var$DFontHeader.decode(this.stream);
    for (let type of this.header.map.typeList.types) {
      for (let ref of type.refList) if (ref.nameOffset >= 0) {
        this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;
        ref.name = $05f49f930186144e$var$DFontName.decode(this.stream);
      } else ref.name = null;
      if (type.name === "sfnt") this.sfnt = type;
    }
  }
}
$d636bc798e7178db$export$36b2f24e97d43be($4c1709dee528ea76$export$2e2bcd8739ae039);
$d636bc798e7178db$export$36b2f24e97d43be($760785214b9fc52c$export$2e2bcd8739ae039);
$d636bc798e7178db$export$36b2f24e97d43be($21ee218f84ac7f32$export$2e2bcd8739ae039);
$d636bc798e7178db$export$36b2f24e97d43be($cd5853a56c68fec7$export$2e2bcd8739ae039);
$d636bc798e7178db$export$36b2f24e97d43be($05f49f930186144e$export$2e2bcd8739ae039);
var zstream$1;
var hasRequiredZstream;
function requireZstream() {
  if (hasRequiredZstream) return zstream$1;
  hasRequiredZstream = 1;
  function ZStream2() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  zstream$1 = ZStream2;
  return zstream$1;
}
var zstreamExports = requireZstream();
const require$$1$2$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(zstreamExports);
var deflate$2 = {};
var common$1 = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common$1;
  hasRequiredCommon = 1;
  (function(exports) {
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p2 in source) {
          if (_has(source, p2)) {
            obj[p2] = source[p2];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src2, src_offs, len, dest_offs) {
        if (src2.subarray && dest.subarray) {
          dest.set(src2.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i2 = 0; i2 < len; i2++) {
          dest[dest_offs + i2] = src2[src_offs + i2];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i2, l2, len, pos, chunk, result;
        len = 0;
        for (i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
          len += chunks[i2].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
          chunk = chunks[i2];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src2, src_offs, len, dest_offs) {
        for (var i2 = 0; i2 < len; i2++) {
          dest[dest_offs + i2] = src2[src_offs + i2];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on2) {
      if (on2) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  })(common$1);
  return common$1;
}
var trees$2 = {};
var hasRequiredTrees;
function requireTrees() {
  if (hasRequiredTrees) return trees$2;
  hasRequiredTrees = 1;
  var utils2 = requireCommon();
  var Z_FIXED2 = 4;
  var Z_BINARY2 = 0;
  var Z_TEXT2 = 1;
  var Z_UNKNOWN2 = 2;
  function zero2(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK2 = 0;
  var STATIC_TREES2 = 1;
  var DYN_TREES2 = 2;
  var MIN_MATCH2 = 3;
  var MAX_MATCH2 = 258;
  var LENGTH_CODES2 = 29;
  var LITERALS2 = 256;
  var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
  var D_CODES2 = 30;
  var BL_CODES2 = 19;
  var HEAP_SIZE2 = 2 * L_CODES2 + 1;
  var MAX_BITS2 = 15;
  var Buf_size2 = 16;
  var MAX_BL_BITS2 = 7;
  var END_BLOCK2 = 256;
  var REP_3_62 = 16;
  var REPZ_3_102 = 17;
  var REPZ_11_1382 = 18;
  var extra_lbits2 = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  );
  var extra_dbits2 = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  );
  var extra_blbits2 = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  );
  var bl_order2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN2 = 512;
  var static_ltree2 = new Array((L_CODES2 + 2) * 2);
  zero2(static_ltree2);
  var static_dtree2 = new Array(D_CODES2 * 2);
  zero2(static_dtree2);
  var _dist_code2 = new Array(DIST_CODE_LEN2);
  zero2(_dist_code2);
  var _length_code2 = new Array(MAX_MATCH2 - MIN_MATCH2 + 1);
  zero2(_length_code2);
  var base_length2 = new Array(LENGTH_CODES2);
  zero2(base_length2);
  var base_dist2 = new Array(D_CODES2);
  zero2(base_dist2);
  function StaticTreeDesc2(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc2;
  var static_d_desc2;
  var static_bl_desc2;
  function TreeDesc2(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function d_code2(dist) {
    return dist < 256 ? _dist_code2[dist] : _dist_code2[256 + (dist >>> 7)];
  }
  function put_short2(s2, w) {
    s2.pending_buf[s2.pending++] = w & 255;
    s2.pending_buf[s2.pending++] = w >>> 8 & 255;
  }
  function send_bits2(s2, value2, length2) {
    if (s2.bi_valid > Buf_size2 - length2) {
      s2.bi_buf |= value2 << s2.bi_valid & 65535;
      put_short2(s2, s2.bi_buf);
      s2.bi_buf = value2 >> Buf_size2 - s2.bi_valid;
      s2.bi_valid += length2 - Buf_size2;
    } else {
      s2.bi_buf |= value2 << s2.bi_valid & 65535;
      s2.bi_valid += length2;
    }
  }
  function send_code2(s2, c2, tree) {
    send_bits2(
      s2,
      tree[c2 * 2],
      tree[c2 * 2 + 1]
      /*.Len*/
    );
  }
  function bi_reverse2(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function bi_flush2(s2) {
    if (s2.bi_valid === 16) {
      put_short2(s2, s2.bi_buf);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    } else if (s2.bi_valid >= 8) {
      s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
      s2.bi_buf >>= 8;
      s2.bi_valid -= 8;
    }
  }
  function gen_bitlen2(s2, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h;
    var n3, m2;
    var bits;
    var xbits;
    var f2;
    var overflow = 0;
    for (bits = 0; bits <= MAX_BITS2; bits++) {
      s2.bl_count[bits] = 0;
    }
    tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
    for (h = s2.heap_max + 1; h < HEAP_SIZE2; h++) {
      n3 = s2.heap[h];
      bits = tree[tree[n3 * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n3 * 2 + 1] = bits;
      if (n3 > max_code) {
        continue;
      }
      s2.bl_count[bits]++;
      xbits = 0;
      if (n3 >= base) {
        xbits = extra[n3 - base];
      }
      f2 = tree[n3 * 2];
      s2.opt_len += f2 * (bits + xbits);
      if (has_stree) {
        s2.static_len += f2 * (stree[n3 * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s2.bl_count[bits] === 0) {
        bits--;
      }
      s2.bl_count[bits]--;
      s2.bl_count[bits + 1] += 2;
      s2.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n3 = s2.bl_count[bits];
      while (n3 !== 0) {
        m2 = s2.heap[--h];
        if (m2 > max_code) {
          continue;
        }
        if (tree[m2 * 2 + 1] !== bits) {
          s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
          tree[m2 * 2 + 1] = bits;
        }
        n3--;
      }
    }
  }
  function gen_codes2(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS2 + 1);
    var code = 0;
    var bits;
    var n3;
    for (bits = 1; bits <= MAX_BITS2; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n3 = 0; n3 <= max_code; n3++) {
      var len = tree[n3 * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n3 * 2] = bi_reverse2(next_code[len]++, len);
    }
  }
  function tr_static_init2() {
    var n3;
    var bits;
    var length2;
    var code;
    var dist;
    var bl_count = new Array(MAX_BITS2 + 1);
    length2 = 0;
    for (code = 0; code < LENGTH_CODES2 - 1; code++) {
      base_length2[code] = length2;
      for (n3 = 0; n3 < 1 << extra_lbits2[code]; n3++) {
        _length_code2[length2++] = code;
      }
    }
    _length_code2[length2 - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      base_dist2[code] = dist;
      for (n3 = 0; n3 < 1 << extra_dbits2[code]; n3++) {
        _dist_code2[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < D_CODES2; code++) {
      base_dist2[code] = dist << 7;
      for (n3 = 0; n3 < 1 << extra_dbits2[code] - 7; n3++) {
        _dist_code2[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS2; bits++) {
      bl_count[bits] = 0;
    }
    n3 = 0;
    while (n3 <= 143) {
      static_ltree2[n3 * 2 + 1] = 8;
      n3++;
      bl_count[8]++;
    }
    while (n3 <= 255) {
      static_ltree2[n3 * 2 + 1] = 9;
      n3++;
      bl_count[9]++;
    }
    while (n3 <= 279) {
      static_ltree2[n3 * 2 + 1] = 7;
      n3++;
      bl_count[7]++;
    }
    while (n3 <= 287) {
      static_ltree2[n3 * 2 + 1] = 8;
      n3++;
      bl_count[8]++;
    }
    gen_codes2(static_ltree2, L_CODES2 + 1, bl_count);
    for (n3 = 0; n3 < D_CODES2; n3++) {
      static_dtree2[n3 * 2 + 1] = 5;
      static_dtree2[n3 * 2] = bi_reverse2(n3, 5);
    }
    static_l_desc2 = new StaticTreeDesc2(static_ltree2, extra_lbits2, LITERALS2 + 1, L_CODES2, MAX_BITS2);
    static_d_desc2 = new StaticTreeDesc2(static_dtree2, extra_dbits2, 0, D_CODES2, MAX_BITS2);
    static_bl_desc2 = new StaticTreeDesc2(new Array(0), extra_blbits2, 0, BL_CODES2, MAX_BL_BITS2);
  }
  function init_block2(s2) {
    var n3;
    for (n3 = 0; n3 < L_CODES2; n3++) {
      s2.dyn_ltree[n3 * 2] = 0;
    }
    for (n3 = 0; n3 < D_CODES2; n3++) {
      s2.dyn_dtree[n3 * 2] = 0;
    }
    for (n3 = 0; n3 < BL_CODES2; n3++) {
      s2.bl_tree[n3 * 2] = 0;
    }
    s2.dyn_ltree[END_BLOCK2 * 2] = 1;
    s2.opt_len = s2.static_len = 0;
    s2.last_lit = s2.matches = 0;
  }
  function bi_windup2(s2) {
    if (s2.bi_valid > 8) {
      put_short2(s2, s2.bi_buf);
    } else if (s2.bi_valid > 0) {
      s2.pending_buf[s2.pending++] = s2.bi_buf;
    }
    s2.bi_buf = 0;
    s2.bi_valid = 0;
  }
  function copy_block2(s2, buf, len, header) {
    bi_windup2(s2);
    {
      put_short2(s2, len);
      put_short2(s2, ~len);
    }
    utils2.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
    s2.pending += len;
  }
  function smaller2(tree, n3, m2, depth) {
    var _n2 = n3 * 2;
    var _m2 = m2 * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n3] <= depth[m2];
  }
  function pqdownheap2(s2, tree, k2) {
    var v2 = s2.heap[k2];
    var j = k2 << 1;
    while (j <= s2.heap_len) {
      if (j < s2.heap_len && smaller2(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
        j++;
      }
      if (smaller2(tree, v2, s2.heap[j], s2.depth)) {
        break;
      }
      s2.heap[k2] = s2.heap[j];
      k2 = j;
      j <<= 1;
    }
    s2.heap[k2] = v2;
  }
  function compress_block2(s2, ltree, dtree) {
    var dist;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s2.last_lit !== 0) {
      do {
        dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
        lc = s2.pending_buf[s2.l_buf + lx];
        lx++;
        if (dist === 0) {
          send_code2(s2, lc, ltree);
        } else {
          code = _length_code2[lc];
          send_code2(s2, code + LITERALS2 + 1, ltree);
          extra = extra_lbits2[code];
          if (extra !== 0) {
            lc -= base_length2[code];
            send_bits2(s2, lc, extra);
          }
          dist--;
          code = d_code2(dist);
          send_code2(s2, code, dtree);
          extra = extra_dbits2[code];
          if (extra !== 0) {
            dist -= base_dist2[code];
            send_bits2(s2, dist, extra);
          }
        }
      } while (lx < s2.last_lit);
    }
    send_code2(s2, END_BLOCK2, ltree);
  }
  function build_tree2(s2, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n3, m2;
    var max_code = -1;
    var node;
    s2.heap_len = 0;
    s2.heap_max = HEAP_SIZE2;
    for (n3 = 0; n3 < elems; n3++) {
      if (tree[n3 * 2] !== 0) {
        s2.heap[++s2.heap_len] = max_code = n3;
        s2.depth[n3] = 0;
      } else {
        tree[n3 * 2 + 1] = 0;
      }
    }
    while (s2.heap_len < 2) {
      node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s2.depth[node] = 0;
      s2.opt_len--;
      if (has_stree) {
        s2.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n3 = s2.heap_len >> 1; n3 >= 1; n3--) {
      pqdownheap2(s2, tree, n3);
    }
    node = elems;
    do {
      n3 = s2.heap[
        1
        /*SMALLEST*/
      ];
      s2.heap[
        1
        /*SMALLEST*/
      ] = s2.heap[s2.heap_len--];
      pqdownheap2(
        s2,
        tree,
        1
        /*SMALLEST*/
      );
      m2 = s2.heap[
        1
        /*SMALLEST*/
      ];
      s2.heap[--s2.heap_max] = n3;
      s2.heap[--s2.heap_max] = m2;
      tree[node * 2] = tree[n3 * 2] + tree[m2 * 2];
      s2.depth[node] = (s2.depth[n3] >= s2.depth[m2] ? s2.depth[n3] : s2.depth[m2]) + 1;
      tree[n3 * 2 + 1] = tree[m2 * 2 + 1] = node;
      s2.heap[
        1
        /*SMALLEST*/
      ] = node++;
      pqdownheap2(
        s2,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s2.heap_len >= 2);
    s2.heap[--s2.heap_max] = s2.heap[
      1
      /*SMALLEST*/
    ];
    gen_bitlen2(s2, desc);
    gen_codes2(tree, max_code, s2.bl_count);
  }
  function scan_tree2(s2, tree, max_code) {
    var n3;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n3 = 0; n3 <= max_code; n3++) {
      curlen = nextlen;
      nextlen = tree[(n3 + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s2.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s2.bl_tree[curlen * 2]++;
        }
        s2.bl_tree[REP_3_62 * 2]++;
      } else if (count <= 10) {
        s2.bl_tree[REPZ_3_102 * 2]++;
      } else {
        s2.bl_tree[REPZ_11_1382 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_tree2(s2, tree, max_code) {
    var n3;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n3 = 0; n3 <= max_code; n3++) {
      curlen = nextlen;
      nextlen = tree[(n3 + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code2(s2, curlen, s2.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code2(s2, curlen, s2.bl_tree);
          count--;
        }
        send_code2(s2, REP_3_62, s2.bl_tree);
        send_bits2(s2, count - 3, 2);
      } else if (count <= 10) {
        send_code2(s2, REPZ_3_102, s2.bl_tree);
        send_bits2(s2, count - 3, 3);
      } else {
        send_code2(s2, REPZ_11_1382, s2.bl_tree);
        send_bits2(s2, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree2(s2) {
    var max_blindex;
    scan_tree2(s2, s2.dyn_ltree, s2.l_desc.max_code);
    scan_tree2(s2, s2.dyn_dtree, s2.d_desc.max_code);
    build_tree2(s2, s2.bl_desc);
    for (max_blindex = BL_CODES2 - 1; max_blindex >= 3; max_blindex--) {
      if (s2.bl_tree[bl_order2[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function send_all_trees2(s2, lcodes, dcodes, blcodes) {
    var rank2;
    send_bits2(s2, lcodes - 257, 5);
    send_bits2(s2, dcodes - 1, 5);
    send_bits2(s2, blcodes - 4, 4);
    for (rank2 = 0; rank2 < blcodes; rank2++) {
      send_bits2(s2, s2.bl_tree[bl_order2[rank2] * 2 + 1], 3);
    }
    send_tree2(s2, s2.dyn_ltree, lcodes - 1);
    send_tree2(s2, s2.dyn_dtree, dcodes - 1);
  }
  function detect_data_type2(s2) {
    var black_mask = 4093624447;
    var n3;
    for (n3 = 0; n3 <= 31; n3++, black_mask >>>= 1) {
      if (black_mask & 1 && s2.dyn_ltree[n3 * 2] !== 0) {
        return Z_BINARY2;
      }
    }
    if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT2;
    }
    for (n3 = 32; n3 < LITERALS2; n3++) {
      if (s2.dyn_ltree[n3 * 2] !== 0) {
        return Z_TEXT2;
      }
    }
    return Z_BINARY2;
  }
  var static_init_done2 = false;
  function _tr_init2(s2) {
    if (!static_init_done2) {
      tr_static_init2();
      static_init_done2 = true;
    }
    s2.l_desc = new TreeDesc2(s2.dyn_ltree, static_l_desc2);
    s2.d_desc = new TreeDesc2(s2.dyn_dtree, static_d_desc2);
    s2.bl_desc = new TreeDesc2(s2.bl_tree, static_bl_desc2);
    s2.bi_buf = 0;
    s2.bi_valid = 0;
    init_block2(s2);
  }
  function _tr_stored_block2(s2, buf, stored_len, last2) {
    send_bits2(s2, (STORED_BLOCK2 << 1) + (last2 ? 1 : 0), 3);
    copy_block2(s2, buf, stored_len);
  }
  function _tr_align2(s2) {
    send_bits2(s2, STATIC_TREES2 << 1, 3);
    send_code2(s2, END_BLOCK2, static_ltree2);
    bi_flush2(s2);
  }
  function _tr_flush_block2(s2, buf, stored_len, last2) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s2.level > 0) {
      if (s2.strm.data_type === Z_UNKNOWN2) {
        s2.strm.data_type = detect_data_type2(s2);
      }
      build_tree2(s2, s2.l_desc);
      build_tree2(s2, s2.d_desc);
      max_blindex = build_bl_tree2(s2);
      opt_lenb = s2.opt_len + 3 + 7 >>> 3;
      static_lenb = s2.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block2(s2, buf, stored_len, last2);
    } else if (s2.strategy === Z_FIXED2 || static_lenb === opt_lenb) {
      send_bits2(s2, (STATIC_TREES2 << 1) + (last2 ? 1 : 0), 3);
      compress_block2(s2, static_ltree2, static_dtree2);
    } else {
      send_bits2(s2, (DYN_TREES2 << 1) + (last2 ? 1 : 0), 3);
      send_all_trees2(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
      compress_block2(s2, s2.dyn_ltree, s2.dyn_dtree);
    }
    init_block2(s2);
    if (last2) {
      bi_windup2(s2);
    }
  }
  function _tr_tally2(s2, dist, lc) {
    s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
    s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
    s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
    s2.last_lit++;
    if (dist === 0) {
      s2.dyn_ltree[lc * 2]++;
    } else {
      s2.matches++;
      dist--;
      s2.dyn_ltree[(_length_code2[lc] + LITERALS2 + 1) * 2]++;
      s2.dyn_dtree[d_code2(dist) * 2]++;
    }
    return s2.last_lit === s2.lit_bufsize - 1;
  }
  trees$2._tr_init = _tr_init2;
  trees$2._tr_stored_block = _tr_stored_block2;
  trees$2._tr_flush_block = _tr_flush_block2;
  trees$2._tr_tally = _tr_tally2;
  trees$2._tr_align = _tr_align2;
  return trees$2;
}
var adler32_1$1;
var hasRequiredAdler32;
function requireAdler32() {
  if (hasRequiredAdler32) return adler32_1$1;
  hasRequiredAdler32 = 1;
  function adler322(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n3 = 0;
    while (len !== 0) {
      n3 = len > 2e3 ? 2e3 : len;
      len -= n3;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n3);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
  adler32_1$1 = adler322;
  return adler32_1$1;
}
var crc32_1$1;
var hasRequiredCrc32;
function requireCrc32() {
  if (hasRequiredCrc32) return crc32_1$1;
  hasRequiredCrc32 = 1;
  function makeTable2() {
    var c2, table = [];
    for (var n3 = 0; n3 < 256; n3++) {
      c2 = n3;
      for (var k2 = 0; k2 < 8; k2++) {
        c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
      }
      table[n3] = c2;
    }
    return table;
  }
  var crcTable2 = makeTable2();
  function crc322(crc, buf, len, pos) {
    var t2 = crcTable2, end2 = pos + len;
    crc ^= -1;
    for (var i2 = pos; i2 < end2; i2++) {
      crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
    }
    return crc ^ -1;
  }
  crc32_1$1 = crc322;
  return crc32_1$1;
}
var messages$1;
var hasRequiredMessages;
function requireMessages() {
  if (hasRequiredMessages) return messages$1;
  hasRequiredMessages = 1;
  messages$1 = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  return messages$1;
}
var hasRequiredDeflate;
function requireDeflate() {
  if (hasRequiredDeflate) return deflate$2;
  hasRequiredDeflate = 1;
  var utils2 = requireCommon();
  var trees2 = requireTrees();
  var adler322 = requireAdler32();
  var crc322 = requireCrc32();
  var msg2 = requireMessages();
  var Z_NO_FLUSH2 = 0;
  var Z_PARTIAL_FLUSH2 = 1;
  var Z_FULL_FLUSH2 = 3;
  var Z_FINISH2 = 4;
  var Z_BLOCK2 = 5;
  var Z_OK2 = 0;
  var Z_STREAM_END2 = 1;
  var Z_STREAM_ERROR2 = -2;
  var Z_DATA_ERROR2 = -3;
  var Z_BUF_ERROR2 = -5;
  var Z_DEFAULT_COMPRESSION2 = -1;
  var Z_FILTERED2 = 1;
  var Z_HUFFMAN_ONLY2 = 2;
  var Z_RLE2 = 3;
  var Z_FIXED2 = 4;
  var Z_DEFAULT_STRATEGY2 = 0;
  var Z_UNKNOWN2 = 2;
  var Z_DEFLATED2 = 8;
  var MAX_MEM_LEVEL2 = 9;
  var MAX_WBITS2 = 15;
  var DEF_MEM_LEVEL2 = 8;
  var LENGTH_CODES2 = 29;
  var LITERALS2 = 256;
  var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
  var D_CODES2 = 30;
  var BL_CODES2 = 19;
  var HEAP_SIZE2 = 2 * L_CODES2 + 1;
  var MAX_BITS2 = 15;
  var MIN_MATCH2 = 3;
  var MAX_MATCH2 = 258;
  var MIN_LOOKAHEAD2 = MAX_MATCH2 + MIN_MATCH2 + 1;
  var PRESET_DICT2 = 32;
  var INIT_STATE2 = 42;
  var EXTRA_STATE2 = 69;
  var NAME_STATE2 = 73;
  var COMMENT_STATE2 = 91;
  var HCRC_STATE2 = 103;
  var BUSY_STATE2 = 113;
  var FINISH_STATE2 = 666;
  var BS_NEED_MORE2 = 1;
  var BS_BLOCK_DONE2 = 2;
  var BS_FINISH_STARTED2 = 3;
  var BS_FINISH_DONE2 = 4;
  var OS_CODE2 = 3;
  function err2(strm, errorCode) {
    strm.msg = msg2[errorCode];
    return errorCode;
  }
  function rank2(f2) {
    return (f2 << 1) - (f2 > 4 ? 9 : 0);
  }
  function zero2(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  function flush_pending2(strm) {
    var s2 = strm.state;
    var len = s2.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils2.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
    strm.next_out += len;
    s2.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s2.pending -= len;
    if (s2.pending === 0) {
      s2.pending_out = 0;
    }
  }
  function flush_block_only2(s2, last2) {
    trees2._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last2);
    s2.block_start = s2.strstart;
    flush_pending2(s2.strm);
  }
  function put_byte2(s2, b2) {
    s2.pending_buf[s2.pending++] = b2;
  }
  function putShortMSB2(s2, b2) {
    s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
    s2.pending_buf[s2.pending++] = b2 & 255;
  }
  function read_buf2(strm, buf, start2, size) {
    var len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils2.arraySet(buf, strm.input, strm.next_in, len, start2);
    if (strm.state.wrap === 1) {
      strm.adler = adler322(strm.adler, buf, len, start2);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc322(strm.adler, buf, len, start2);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  function longest_match2(s2, cur_match) {
    var chain_length = s2.max_chain_length;
    var scan = s2.strstart;
    var match;
    var len;
    var best_len = s2.prev_length;
    var nice_match = s2.nice_match;
    var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD2 ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD2) : 0;
    var _win = s2.window;
    var wmask = s2.w_mask;
    var prev = s2.prev;
    var strend = s2.strstart + MAX_MATCH2;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s2.prev_length >= s2.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s2.lookahead) {
      nice_match = s2.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = MAX_MATCH2 - (strend - scan);
      scan = strend - MAX_MATCH2;
      if (len > best_len) {
        s2.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s2.lookahead) {
      return best_len;
    }
    return s2.lookahead;
  }
  function fill_window2(s2) {
    var _w_size = s2.w_size;
    var p2, n3, m2, more, str;
    do {
      more = s2.window_size - s2.lookahead - s2.strstart;
      if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD2)) {
        utils2.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
        s2.match_start -= _w_size;
        s2.strstart -= _w_size;
        s2.block_start -= _w_size;
        n3 = s2.hash_size;
        p2 = n3;
        do {
          m2 = s2.head[--p2];
          s2.head[p2] = m2 >= _w_size ? m2 - _w_size : 0;
        } while (--n3);
        n3 = _w_size;
        p2 = n3;
        do {
          m2 = s2.prev[--p2];
          s2.prev[p2] = m2 >= _w_size ? m2 - _w_size : 0;
        } while (--n3);
        more += _w_size;
      }
      if (s2.strm.avail_in === 0) {
        break;
      }
      n3 = read_buf2(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
      s2.lookahead += n3;
      if (s2.lookahead + s2.insert >= MIN_MATCH2) {
        str = s2.strstart - s2.insert;
        s2.ins_h = s2.window[str];
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
        while (s2.insert) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH2 - 1]) & s2.hash_mask;
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
          s2.insert--;
          if (s2.lookahead + s2.insert < MIN_MATCH2) {
            break;
          }
        }
      }
    } while (s2.lookahead < MIN_LOOKAHEAD2 && s2.strm.avail_in !== 0);
  }
  function deflate_stored2(s2, flush) {
    var max_block_size = 65535;
    if (max_block_size > s2.pending_buf_size - 5) {
      max_block_size = s2.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s2.lookahead <= 1) {
        fill_window2(s2);
        if (s2.lookahead === 0 && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE2;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      s2.strstart += s2.lookahead;
      s2.lookahead = 0;
      var max_start = s2.block_start + max_block_size;
      if (s2.strstart === 0 || s2.strstart >= max_start) {
        s2.lookahead = s2.strstart - max_start;
        s2.strstart = max_start;
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD2) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH2) {
      flush_block_only2(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED2;
      }
      return BS_FINISH_DONE2;
    }
    if (s2.strstart > s2.block_start) {
      flush_block_only2(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE2;
      }
    }
    return BS_NEED_MORE2;
  }
  function deflate_fast2(s2, flush) {
    var hash_head;
    var bflush;
    for (; ; ) {
      if (s2.lookahead < MIN_LOOKAHEAD2) {
        fill_window2(s2);
        if (s2.lookahead < MIN_LOOKAHEAD2 && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE2;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s2.lookahead >= MIN_MATCH2) {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
        hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = s2.strstart;
      }
      if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD2) {
        s2.match_length = longest_match2(s2, hash_head);
      }
      if (s2.match_length >= MIN_MATCH2) {
        bflush = trees2._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH2);
        s2.lookahead -= s2.match_length;
        if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH2) {
          s2.match_length--;
          do {
            s2.strstart++;
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          } while (--s2.match_length !== 0);
          s2.strstart++;
        } else {
          s2.strstart += s2.match_length;
          s2.match_length = 0;
          s2.ins_h = s2.window[s2.strstart];
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
        }
      } else {
        bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
      }
      if (bflush) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
    }
    s2.insert = s2.strstart < MIN_MATCH2 - 1 ? s2.strstart : MIN_MATCH2 - 1;
    if (flush === Z_FINISH2) {
      flush_block_only2(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED2;
      }
      return BS_FINISH_DONE2;
    }
    if (s2.last_lit) {
      flush_block_only2(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE2;
      }
    }
    return BS_BLOCK_DONE2;
  }
  function deflate_slow2(s2, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (; ; ) {
      if (s2.lookahead < MIN_LOOKAHEAD2) {
        fill_window2(s2);
        if (s2.lookahead < MIN_LOOKAHEAD2 && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE2;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s2.lookahead >= MIN_MATCH2) {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
        hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = s2.strstart;
      }
      s2.prev_length = s2.match_length;
      s2.prev_match = s2.match_start;
      s2.match_length = MIN_MATCH2 - 1;
      if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD2) {
        s2.match_length = longest_match2(s2, hash_head);
        if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED2 || s2.match_length === MIN_MATCH2 && s2.strstart - s2.match_start > 4096)) {
          s2.match_length = MIN_MATCH2 - 1;
        }
      }
      if (s2.prev_length >= MIN_MATCH2 && s2.match_length <= s2.prev_length) {
        max_insert = s2.strstart + s2.lookahead - MIN_MATCH2;
        bflush = trees2._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH2);
        s2.lookahead -= s2.prev_length - 1;
        s2.prev_length -= 2;
        do {
          if (++s2.strstart <= max_insert) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          }
        } while (--s2.prev_length !== 0);
        s2.match_available = 0;
        s2.match_length = MIN_MATCH2 - 1;
        s2.strstart++;
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      } else if (s2.match_available) {
        bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        if (bflush) {
          flush_block_only2(s2, false);
        }
        s2.strstart++;
        s2.lookahead--;
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      } else {
        s2.match_available = 1;
        s2.strstart++;
        s2.lookahead--;
      }
    }
    if (s2.match_available) {
      bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
      s2.match_available = 0;
    }
    s2.insert = s2.strstart < MIN_MATCH2 - 1 ? s2.strstart : MIN_MATCH2 - 1;
    if (flush === Z_FINISH2) {
      flush_block_only2(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED2;
      }
      return BS_FINISH_DONE2;
    }
    if (s2.last_lit) {
      flush_block_only2(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE2;
      }
    }
    return BS_BLOCK_DONE2;
  }
  function deflate_rle2(s2, flush) {
    var bflush;
    var prev;
    var scan, strend;
    var _win = s2.window;
    for (; ; ) {
      if (s2.lookahead <= MAX_MATCH2) {
        fill_window2(s2);
        if (s2.lookahead <= MAX_MATCH2 && flush === Z_NO_FLUSH2) {
          return BS_NEED_MORE2;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      s2.match_length = 0;
      if (s2.lookahead >= MIN_MATCH2 && s2.strstart > 0) {
        scan = s2.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s2.strstart + MAX_MATCH2;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s2.match_length = MAX_MATCH2 - (strend - scan);
          if (s2.match_length > s2.lookahead) {
            s2.match_length = s2.lookahead;
          }
        }
      }
      if (s2.match_length >= MIN_MATCH2) {
        bflush = trees2._tr_tally(s2, 1, s2.match_length - MIN_MATCH2);
        s2.lookahead -= s2.match_length;
        s2.strstart += s2.match_length;
        s2.match_length = 0;
      } else {
        bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
      }
      if (bflush) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH2) {
      flush_block_only2(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED2;
      }
      return BS_FINISH_DONE2;
    }
    if (s2.last_lit) {
      flush_block_only2(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE2;
      }
    }
    return BS_BLOCK_DONE2;
  }
  function deflate_huff2(s2, flush) {
    var bflush;
    for (; ; ) {
      if (s2.lookahead === 0) {
        fill_window2(s2);
        if (s2.lookahead === 0) {
          if (flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          break;
        }
      }
      s2.match_length = 0;
      bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
      if (bflush) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH2) {
      flush_block_only2(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED2;
      }
      return BS_FINISH_DONE2;
    }
    if (s2.last_lit) {
      flush_block_only2(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE2;
      }
    }
    return BS_BLOCK_DONE2;
  }
  function Config2(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table2;
  configuration_table2 = [
    /*      good lazy nice chain */
    new Config2(0, 0, 0, 0, deflate_stored2),
    /* 0 store only */
    new Config2(4, 4, 8, 4, deflate_fast2),
    /* 1 max speed, no lazy matches */
    new Config2(4, 5, 16, 8, deflate_fast2),
    /* 2 */
    new Config2(4, 6, 32, 32, deflate_fast2),
    /* 3 */
    new Config2(4, 4, 16, 16, deflate_slow2),
    /* 4 lazy matches */
    new Config2(8, 16, 32, 32, deflate_slow2),
    /* 5 */
    new Config2(8, 16, 128, 128, deflate_slow2),
    /* 6 */
    new Config2(8, 32, 128, 256, deflate_slow2),
    /* 7 */
    new Config2(32, 128, 258, 1024, deflate_slow2),
    /* 8 */
    new Config2(32, 258, 258, 4096, deflate_slow2)
    /* 9 max compression */
  ];
  function lm_init2(s2) {
    s2.window_size = 2 * s2.w_size;
    zero2(s2.head);
    s2.max_lazy_match = configuration_table2[s2.level].max_lazy;
    s2.good_match = configuration_table2[s2.level].good_length;
    s2.nice_match = configuration_table2[s2.level].nice_length;
    s2.max_chain_length = configuration_table2[s2.level].max_chain;
    s2.strstart = 0;
    s2.block_start = 0;
    s2.lookahead = 0;
    s2.insert = 0;
    s2.match_length = s2.prev_length = MIN_MATCH2 - 1;
    s2.match_available = 0;
    s2.ins_h = 0;
  }
  function DeflateState2() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED2;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils2.Buf16(HEAP_SIZE2 * 2);
    this.dyn_dtree = new utils2.Buf16((2 * D_CODES2 + 1) * 2);
    this.bl_tree = new utils2.Buf16((2 * BL_CODES2 + 1) * 2);
    zero2(this.dyn_ltree);
    zero2(this.dyn_dtree);
    zero2(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils2.Buf16(MAX_BITS2 + 1);
    this.heap = new utils2.Buf16(2 * L_CODES2 + 1);
    zero2(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils2.Buf16(2 * L_CODES2 + 1);
    zero2(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function deflateResetKeep2(strm) {
    var s2;
    if (!strm || !strm.state) {
      return err2(strm, Z_STREAM_ERROR2);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN2;
    s2 = strm.state;
    s2.pending = 0;
    s2.pending_out = 0;
    if (s2.wrap < 0) {
      s2.wrap = -s2.wrap;
    }
    s2.status = s2.wrap ? INIT_STATE2 : BUSY_STATE2;
    strm.adler = s2.wrap === 2 ? 0 : 1;
    s2.last_flush = Z_NO_FLUSH2;
    trees2._tr_init(s2);
    return Z_OK2;
  }
  function deflateReset2(strm) {
    var ret = deflateResetKeep2(strm);
    if (ret === Z_OK2) {
      lm_init2(strm.state);
    }
    return ret;
  }
  function deflateSetHeader2(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR2;
    }
    strm.state.gzhead = head;
    return Z_OK2;
  }
  function deflateInit22(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR2;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION2) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL2 || method !== Z_DEFLATED2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED2) {
      return err2(strm, Z_STREAM_ERROR2);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s2 = new DeflateState2();
    strm.state = s2;
    s2.strm = strm;
    s2.wrap = wrap;
    s2.gzhead = null;
    s2.w_bits = windowBits;
    s2.w_size = 1 << s2.w_bits;
    s2.w_mask = s2.w_size - 1;
    s2.hash_bits = memLevel + 7;
    s2.hash_size = 1 << s2.hash_bits;
    s2.hash_mask = s2.hash_size - 1;
    s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH2 - 1) / MIN_MATCH2);
    s2.window = new utils2.Buf8(s2.w_size * 2);
    s2.head = new utils2.Buf16(s2.hash_size);
    s2.prev = new utils2.Buf16(s2.w_size);
    s2.lit_bufsize = 1 << memLevel + 6;
    s2.pending_buf_size = s2.lit_bufsize * 4;
    s2.pending_buf = new utils2.Buf8(s2.pending_buf_size);
    s2.d_buf = 1 * s2.lit_bufsize;
    s2.l_buf = (1 + 2) * s2.lit_bufsize;
    s2.level = level;
    s2.strategy = strategy;
    s2.method = method;
    return deflateReset2(strm);
  }
  function deflateInit3(strm, level) {
    return deflateInit22(strm, level, Z_DEFLATED2, MAX_WBITS2, DEF_MEM_LEVEL2, Z_DEFAULT_STRATEGY2);
  }
  function deflate2(strm, flush) {
    var old_flush, s2;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK2 || flush < 0) {
      return strm ? err2(strm, Z_STREAM_ERROR2) : Z_STREAM_ERROR2;
    }
    s2 = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE2 && flush !== Z_FINISH2) {
      return err2(strm, strm.avail_out === 0 ? Z_BUF_ERROR2 : Z_STREAM_ERROR2);
    }
    s2.strm = strm;
    old_flush = s2.last_flush;
    s2.last_flush = flush;
    if (s2.status === INIT_STATE2) {
      if (s2.wrap === 2) {
        strm.adler = 0;
        put_byte2(s2, 31);
        put_byte2(s2, 139);
        put_byte2(s2, 8);
        if (!s2.gzhead) {
          put_byte2(s2, 0);
          put_byte2(s2, 0);
          put_byte2(s2, 0);
          put_byte2(s2, 0);
          put_byte2(s2, 0);
          put_byte2(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2 ? 4 : 0);
          put_byte2(s2, OS_CODE2);
          s2.status = BUSY_STATE2;
        } else {
          put_byte2(
            s2,
            (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
          );
          put_byte2(s2, s2.gzhead.time & 255);
          put_byte2(s2, s2.gzhead.time >> 8 & 255);
          put_byte2(s2, s2.gzhead.time >> 16 & 255);
          put_byte2(s2, s2.gzhead.time >> 24 & 255);
          put_byte2(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2 ? 4 : 0);
          put_byte2(s2, s2.gzhead.os & 255);
          if (s2.gzhead.extra && s2.gzhead.extra.length) {
            put_byte2(s2, s2.gzhead.extra.length & 255);
            put_byte2(s2, s2.gzhead.extra.length >> 8 & 255);
          }
          if (s2.gzhead.hcrc) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending, 0);
          }
          s2.gzindex = 0;
          s2.status = EXTRA_STATE2;
        }
      } else {
        var header = Z_DEFLATED2 + (s2.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2) {
          level_flags = 0;
        } else if (s2.level < 6) {
          level_flags = 1;
        } else if (s2.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s2.strstart !== 0) {
          header |= PRESET_DICT2;
        }
        header += 31 - header % 31;
        s2.status = BUSY_STATE2;
        putShortMSB2(s2, header);
        if (s2.strstart !== 0) {
          putShortMSB2(s2, strm.adler >>> 16);
          putShortMSB2(s2, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s2.status === EXTRA_STATE2) {
      if (s2.gzhead.extra) {
        beg = s2.pending;
        while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending2(strm);
            beg = s2.pending;
            if (s2.pending === s2.pending_buf_size) {
              break;
            }
          }
          put_byte2(s2, s2.gzhead.extra[s2.gzindex] & 255);
          s2.gzindex++;
        }
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        if (s2.gzindex === s2.gzhead.extra.length) {
          s2.gzindex = 0;
          s2.status = NAME_STATE2;
        }
      } else {
        s2.status = NAME_STATE2;
      }
    }
    if (s2.status === NAME_STATE2) {
      if (s2.gzhead.name) {
        beg = s2.pending;
        do {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending2(strm);
            beg = s2.pending;
            if (s2.pending === s2.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s2.gzindex < s2.gzhead.name.length) {
            val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte2(s2, val);
        } while (val !== 0);
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        if (val === 0) {
          s2.gzindex = 0;
          s2.status = COMMENT_STATE2;
        }
      } else {
        s2.status = COMMENT_STATE2;
      }
    }
    if (s2.status === COMMENT_STATE2) {
      if (s2.gzhead.comment) {
        beg = s2.pending;
        do {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending2(strm);
            beg = s2.pending;
            if (s2.pending === s2.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s2.gzindex < s2.gzhead.comment.length) {
            val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte2(s2, val);
        } while (val !== 0);
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        if (val === 0) {
          s2.status = HCRC_STATE2;
        }
      } else {
        s2.status = HCRC_STATE2;
      }
    }
    if (s2.status === HCRC_STATE2) {
      if (s2.gzhead.hcrc) {
        if (s2.pending + 2 > s2.pending_buf_size) {
          flush_pending2(strm);
        }
        if (s2.pending + 2 <= s2.pending_buf_size) {
          put_byte2(s2, strm.adler & 255);
          put_byte2(s2, strm.adler >> 8 & 255);
          strm.adler = 0;
          s2.status = BUSY_STATE2;
        }
      } else {
        s2.status = BUSY_STATE2;
      }
    }
    if (s2.pending !== 0) {
      flush_pending2(strm);
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
        return Z_OK2;
      }
    } else if (strm.avail_in === 0 && rank2(flush) <= rank2(old_flush) && flush !== Z_FINISH2) {
      return err2(strm, Z_BUF_ERROR2);
    }
    if (s2.status === FINISH_STATE2 && strm.avail_in !== 0) {
      return err2(strm, Z_BUF_ERROR2);
    }
    if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH2 && s2.status !== FINISH_STATE2) {
      var bstate = s2.strategy === Z_HUFFMAN_ONLY2 ? deflate_huff2(s2, flush) : s2.strategy === Z_RLE2 ? deflate_rle2(s2, flush) : configuration_table2[s2.level].func(s2, flush);
      if (bstate === BS_FINISH_STARTED2 || bstate === BS_FINISH_DONE2) {
        s2.status = FINISH_STATE2;
      }
      if (bstate === BS_NEED_MORE2 || bstate === BS_FINISH_STARTED2) {
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
        }
        return Z_OK2;
      }
      if (bstate === BS_BLOCK_DONE2) {
        if (flush === Z_PARTIAL_FLUSH2) {
          trees2._tr_align(s2);
        } else if (flush !== Z_BLOCK2) {
          trees2._tr_stored_block(s2, 0, 0, false);
          if (flush === Z_FULL_FLUSH2) {
            zero2(s2.head);
            if (s2.lookahead === 0) {
              s2.strstart = 0;
              s2.block_start = 0;
              s2.insert = 0;
            }
          }
        }
        flush_pending2(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK2;
        }
      }
    }
    if (flush !== Z_FINISH2) {
      return Z_OK2;
    }
    if (s2.wrap <= 0) {
      return Z_STREAM_END2;
    }
    if (s2.wrap === 2) {
      put_byte2(s2, strm.adler & 255);
      put_byte2(s2, strm.adler >> 8 & 255);
      put_byte2(s2, strm.adler >> 16 & 255);
      put_byte2(s2, strm.adler >> 24 & 255);
      put_byte2(s2, strm.total_in & 255);
      put_byte2(s2, strm.total_in >> 8 & 255);
      put_byte2(s2, strm.total_in >> 16 & 255);
      put_byte2(s2, strm.total_in >> 24 & 255);
    } else {
      putShortMSB2(s2, strm.adler >>> 16);
      putShortMSB2(s2, strm.adler & 65535);
    }
    flush_pending2(strm);
    if (s2.wrap > 0) {
      s2.wrap = -s2.wrap;
    }
    return s2.pending !== 0 ? Z_OK2 : Z_STREAM_END2;
  }
  function deflateEnd2(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    status = strm.state.status;
    if (status !== INIT_STATE2 && status !== EXTRA_STATE2 && status !== NAME_STATE2 && status !== COMMENT_STATE2 && status !== HCRC_STATE2 && status !== BUSY_STATE2 && status !== FINISH_STATE2) {
      return err2(strm, Z_STREAM_ERROR2);
    }
    strm.state = null;
    return status === BUSY_STATE2 ? err2(strm, Z_DATA_ERROR2) : Z_OK2;
  }
  function deflateSetDictionary2(strm, dictionary2) {
    var dictLength = dictionary2.length;
    var s2;
    var str, n3;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    s2 = strm.state;
    wrap = s2.wrap;
    if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE2 || s2.lookahead) {
      return Z_STREAM_ERROR2;
    }
    if (wrap === 1) {
      strm.adler = adler322(strm.adler, dictionary2, dictLength, 0);
    }
    s2.wrap = 0;
    if (dictLength >= s2.w_size) {
      if (wrap === 0) {
        zero2(s2.head);
        s2.strstart = 0;
        s2.block_start = 0;
        s2.insert = 0;
      }
      tmpDict = new utils2.Buf8(s2.w_size);
      utils2.arraySet(tmpDict, dictionary2, dictLength - s2.w_size, s2.w_size, 0);
      dictionary2 = tmpDict;
      dictLength = s2.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary2;
    fill_window2(s2);
    while (s2.lookahead >= MIN_MATCH2) {
      str = s2.strstart;
      n3 = s2.lookahead - (MIN_MATCH2 - 1);
      do {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH2 - 1]) & s2.hash_mask;
        s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = str;
        str++;
      } while (--n3);
      s2.strstart = str;
      s2.lookahead = MIN_MATCH2 - 1;
      fill_window2(s2);
    }
    s2.strstart += s2.lookahead;
    s2.block_start = s2.strstart;
    s2.insert = s2.lookahead;
    s2.lookahead = 0;
    s2.match_length = s2.prev_length = MIN_MATCH2 - 1;
    s2.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s2.wrap = wrap;
    return Z_OK2;
  }
  deflate$2.deflateInit = deflateInit3;
  deflate$2.deflateInit2 = deflateInit22;
  deflate$2.deflateReset = deflateReset2;
  deflate$2.deflateResetKeep = deflateResetKeep2;
  deflate$2.deflateSetHeader = deflateSetHeader2;
  deflate$2.deflate = deflate2;
  deflate$2.deflateEnd = deflateEnd2;
  deflate$2.deflateSetDictionary = deflateSetDictionary2;
  deflate$2.deflateInfo = "pako deflate (from Nodeca project)";
  return deflate$2;
}
var deflateExports = requireDeflate();
const require$$2 = /* @__PURE__ */ getDefaultExportFromCjs$2(deflateExports);
var inflate$2 = {};
var inffast$1;
var hasRequiredInffast;
function requireInffast() {
  if (hasRequiredInffast) return inffast$1;
  hasRequiredInffast = 1;
  var BAD2 = 30;
  var TYPE2 = 12;
  inffast$1 = function inflate_fast3(strm, start2) {
    var state2;
    var _in;
    var last2;
    var _out;
    var beg;
    var end2;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from2;
    var from_source;
    var input, output;
    state2 = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last2 = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start2 - strm.avail_out);
    end2 = _out + (strm.avail_out - 257);
    dmax = state2.dmax;
    wsize = state2.wsize;
    whave = state2.whave;
    wnext = state2.wnext;
    s_window = state2.window;
    hold = state2.hold;
    bits = state2.bits;
    lcode = state2.lencode;
    dcode = state2.distcode;
    lmask = (1 << state2.lenbits) - 1;
    dmask = (1 << state2.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state2.mode = BAD2;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state2.sane) {
                          strm.msg = "invalid distance too far back";
                          state2.mode = BAD2;
                          break top;
                        }
                      }
                      from2 = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from2 += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from2 += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from2++];
                            } while (--op);
                            from2 = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from2 += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from2++];
                        output[_out++] = from_source[from2++];
                        output[_out++] = from_source[from2++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from2++];
                        if (len > 1) {
                          output[_out++] = from_source[from2++];
                        }
                      }
                    } else {
                      from2 = _out - dist;
                      do {
                        output[_out++] = output[from2++];
                        output[_out++] = output[from2++];
                        output[_out++] = output[from2++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from2++];
                        if (len > 1) {
                          output[_out++] = output[from2++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state2.mode = BAD2;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state2.mode = TYPE2;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state2.mode = BAD2;
              break top;
            }
            break;
          }
      } while (_in < last2 && _out < end2);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
    strm.avail_out = _out < end2 ? 257 + (end2 - _out) : 257 - (_out - end2);
    state2.hold = hold;
    state2.bits = bits;
    return;
  };
  return inffast$1;
}
var inftrees$1;
var hasRequiredInftrees;
function requireInftrees() {
  if (hasRequiredInftrees) return inftrees$1;
  hasRequiredInftrees = 1;
  var utils2 = requireCommon();
  var MAXBITS2 = 15;
  var ENOUGH_LENS2 = 852;
  var ENOUGH_DISTS2 = 592;
  var CODES2 = 0;
  var LENS2 = 1;
  var DISTS2 = 2;
  var lbase2 = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext2 = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase2 = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext2 = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  inftrees$1 = function inflate_table3(type, lens, lens_index, codes2, table, table_index, work, opts2) {
    var bits = opts2.bits;
    var len = 0;
    var sym = 0;
    var min2 = 0, max2 = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill4;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end2;
    var count = new utils2.Buf16(MAXBITS2 + 1);
    var offs = new utils2.Buf16(MAXBITS2 + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS2; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes2; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max2 = MAXBITS2; max2 >= 1; max2--) {
      if (count[max2] !== 0) {
        break;
      }
    }
    if (root > max2) {
      root = max2;
    }
    if (max2 === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts2.bits = 1;
      return 0;
    }
    for (min2 = 1; min2 < max2; min2++) {
      if (count[min2] !== 0) {
        break;
      }
    }
    if (root < min2) {
      root = min2;
    }
    left = 1;
    for (len = 1; len <= MAXBITS2; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === CODES2 || max2 !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS2; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes2; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === CODES2) {
      base = extra = work;
      end2 = 19;
    } else if (type === LENS2) {
      base = lbase2;
      base_index -= 257;
      extra = lext2;
      extra_index -= 257;
      end2 = 256;
    } else {
      base = dbase2;
      extra = dext2;
      end2 = -1;
    }
    huff = 0;
    sym = 0;
    len = min2;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === LENS2 && used > ENOUGH_LENS2 || type === DISTS2 && used > ENOUGH_DISTS2) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end2) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end2) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill4 = 1 << curr;
      min2 = fill4;
      do {
        fill4 -= incr;
        table[next + (huff >> drop) + fill4] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill4 !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max2) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min2;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max2) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === LENS2 && used > ENOUGH_LENS2 || type === DISTS2 && used > ENOUGH_DISTS2) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts2.bits = root;
    return 0;
  };
  return inftrees$1;
}
var hasRequiredInflate;
function requireInflate() {
  if (hasRequiredInflate) return inflate$2;
  hasRequiredInflate = 1;
  var utils2 = requireCommon();
  var adler322 = requireAdler32();
  var crc322 = requireCrc32();
  var inflate_fast3 = requireInffast();
  var inflate_table3 = requireInftrees();
  var CODES2 = 0;
  var LENS2 = 1;
  var DISTS2 = 2;
  var Z_FINISH2 = 4;
  var Z_BLOCK2 = 5;
  var Z_TREES2 = 6;
  var Z_OK2 = 0;
  var Z_STREAM_END2 = 1;
  var Z_NEED_DICT2 = 2;
  var Z_STREAM_ERROR2 = -2;
  var Z_DATA_ERROR2 = -3;
  var Z_MEM_ERROR2 = -4;
  var Z_BUF_ERROR2 = -5;
  var Z_DEFLATED2 = 8;
  var HEAD2 = 1;
  var FLAGS2 = 2;
  var TIME2 = 3;
  var OS2 = 4;
  var EXLEN2 = 5;
  var EXTRA2 = 6;
  var NAME2 = 7;
  var COMMENT2 = 8;
  var HCRC2 = 9;
  var DICTID2 = 10;
  var DICT2 = 11;
  var TYPE2 = 12;
  var TYPEDO2 = 13;
  var STORED2 = 14;
  var COPY_2 = 15;
  var COPY2 = 16;
  var TABLE2 = 17;
  var LENLENS2 = 18;
  var CODELENS2 = 19;
  var LEN_2 = 20;
  var LEN2 = 21;
  var LENEXT2 = 22;
  var DIST2 = 23;
  var DISTEXT2 = 24;
  var MATCH2 = 25;
  var LIT2 = 26;
  var CHECK2 = 27;
  var LENGTH2 = 28;
  var DONE2 = 29;
  var BAD2 = 30;
  var MEM2 = 31;
  var SYNC2 = 32;
  var ENOUGH_LENS2 = 852;
  var ENOUGH_DISTS2 = 592;
  var MAX_WBITS2 = 15;
  var DEF_WBITS2 = MAX_WBITS2;
  function zswap322(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  function InflateState2() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils2.Buf16(320);
    this.work = new utils2.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function inflateResetKeep2(strm) {
    var state2;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state2 = strm.state;
    strm.total_in = strm.total_out = state2.total = 0;
    strm.msg = "";
    if (state2.wrap) {
      strm.adler = state2.wrap & 1;
    }
    state2.mode = HEAD2;
    state2.last = 0;
    state2.havedict = 0;
    state2.dmax = 32768;
    state2.head = null;
    state2.hold = 0;
    state2.bits = 0;
    state2.lencode = state2.lendyn = new utils2.Buf32(ENOUGH_LENS2);
    state2.distcode = state2.distdyn = new utils2.Buf32(ENOUGH_DISTS2);
    state2.sane = 1;
    state2.back = -1;
    return Z_OK2;
  }
  function inflateReset3(strm) {
    var state2;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state2 = strm.state;
    state2.wsize = 0;
    state2.whave = 0;
    state2.wnext = 0;
    return inflateResetKeep2(strm);
  }
  function inflateReset22(strm, windowBits) {
    var wrap;
    var state2;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state2 = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR2;
    }
    if (state2.window !== null && state2.wbits !== windowBits) {
      state2.window = null;
    }
    state2.wrap = wrap;
    state2.wbits = windowBits;
    return inflateReset3(strm);
  }
  function inflateInit22(strm, windowBits) {
    var ret;
    var state2;
    if (!strm) {
      return Z_STREAM_ERROR2;
    }
    state2 = new InflateState2();
    strm.state = state2;
    state2.window = null;
    ret = inflateReset22(strm, windowBits);
    if (ret !== Z_OK2) {
      strm.state = null;
    }
    return ret;
  }
  function inflateInit3(strm) {
    return inflateInit22(strm, DEF_WBITS2);
  }
  var virgin2 = true;
  var lenfix2, distfix2;
  function fixedtables2(state2) {
    if (virgin2) {
      var sym;
      lenfix2 = new utils2.Buf32(512);
      distfix2 = new utils2.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state2.lens[sym++] = 8;
      }
      while (sym < 256) {
        state2.lens[sym++] = 9;
      }
      while (sym < 280) {
        state2.lens[sym++] = 7;
      }
      while (sym < 288) {
        state2.lens[sym++] = 8;
      }
      inflate_table3(LENS2, state2.lens, 0, 288, lenfix2, 0, state2.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state2.lens[sym++] = 5;
      }
      inflate_table3(DISTS2, state2.lens, 0, 32, distfix2, 0, state2.work, { bits: 5 });
      virgin2 = false;
    }
    state2.lencode = lenfix2;
    state2.lenbits = 9;
    state2.distcode = distfix2;
    state2.distbits = 5;
  }
  function updatewindow2(strm, src2, end2, copy5) {
    var dist;
    var state2 = strm.state;
    if (state2.window === null) {
      state2.wsize = 1 << state2.wbits;
      state2.wnext = 0;
      state2.whave = 0;
      state2.window = new utils2.Buf8(state2.wsize);
    }
    if (copy5 >= state2.wsize) {
      utils2.arraySet(state2.window, src2, end2 - state2.wsize, state2.wsize, 0);
      state2.wnext = 0;
      state2.whave = state2.wsize;
    } else {
      dist = state2.wsize - state2.wnext;
      if (dist > copy5) {
        dist = copy5;
      }
      utils2.arraySet(state2.window, src2, end2 - copy5, dist, state2.wnext);
      copy5 -= dist;
      if (copy5) {
        utils2.arraySet(state2.window, src2, end2 - copy5, copy5, 0);
        state2.wnext = copy5;
        state2.whave = state2.wsize;
      } else {
        state2.wnext += dist;
        if (state2.wnext === state2.wsize) {
          state2.wnext = 0;
        }
        if (state2.whave < state2.wsize) {
          state2.whave += dist;
        }
      }
    }
    return 0;
  }
  function inflate2(strm, flush) {
    var state2;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy5;
    var from2;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils2.Buf8(4);
    var opts2;
    var n3;
    var order = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR2;
    }
    state2 = strm.state;
    if (state2.mode === TYPE2) {
      state2.mode = TYPEDO2;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state2.hold;
    bits = state2.bits;
    _in = have;
    _out = left;
    ret = Z_OK2;
    inf_leave:
      for (; ; ) {
        switch (state2.mode) {
          case HEAD2:
            if (state2.wrap === 0) {
              state2.mode = TYPEDO2;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.wrap & 2 && hold === 35615) {
              state2.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc322(state2.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state2.mode = FLAGS2;
              break;
            }
            state2.flags = 0;
            if (state2.head) {
              state2.head.done = false;
            }
            if (!(state2.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state2.mode = BAD2;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED2) {
              strm.msg = "unknown compression method";
              state2.mode = BAD2;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state2.wbits === 0) {
              state2.wbits = len;
            } else if (len > state2.wbits) {
              strm.msg = "invalid window size";
              state2.mode = BAD2;
              break;
            }
            state2.dmax = 1 << len;
            strm.adler = state2.check = 1;
            state2.mode = hold & 512 ? DICTID2 : TYPE2;
            hold = 0;
            bits = 0;
            break;
          case FLAGS2:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.flags = hold;
            if ((state2.flags & 255) !== Z_DEFLATED2) {
              strm.msg = "unknown compression method";
              state2.mode = BAD2;
              break;
            }
            if (state2.flags & 57344) {
              strm.msg = "unknown header flags set";
              state2.mode = BAD2;
              break;
            }
            if (state2.head) {
              state2.head.text = hold >> 8 & 1;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc322(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state2.mode = TIME2;
          /* falls through */
          case TIME2:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.head) {
              state2.head.time = hold;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state2.check = crc322(state2.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state2.mode = OS2;
          /* falls through */
          case OS2:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.head) {
              state2.head.xflags = hold & 255;
              state2.head.os = hold >> 8;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc322(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state2.mode = EXLEN2;
          /* falls through */
          case EXLEN2:
            if (state2.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.length = hold;
              if (state2.head) {
                state2.head.extra_len = hold;
              }
              if (state2.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state2.head) {
              state2.head.extra = null;
            }
            state2.mode = EXTRA2;
          /* falls through */
          case EXTRA2:
            if (state2.flags & 1024) {
              copy5 = state2.length;
              if (copy5 > have) {
                copy5 = have;
              }
              if (copy5) {
                if (state2.head) {
                  len = state2.head.extra_len - state2.length;
                  if (!state2.head.extra) {
                    state2.head.extra = new Array(state2.head.extra_len);
                  }
                  utils2.arraySet(
                    state2.head.extra,
                    input,
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    copy5,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state2.flags & 512) {
                  state2.check = crc322(state2.check, input, copy5, next);
                }
                have -= copy5;
                next += copy5;
                state2.length -= copy5;
              }
              if (state2.length) {
                break inf_leave;
              }
            }
            state2.length = 0;
            state2.mode = NAME2;
          /* falls through */
          case NAME2:
            if (state2.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy5 = 0;
              do {
                len = input[next + copy5++];
                if (state2.head && len && state2.length < 65536) {
                  state2.head.name += String.fromCharCode(len);
                }
              } while (len && copy5 < have);
              if (state2.flags & 512) {
                state2.check = crc322(state2.check, input, copy5, next);
              }
              have -= copy5;
              next += copy5;
              if (len) {
                break inf_leave;
              }
            } else if (state2.head) {
              state2.head.name = null;
            }
            state2.length = 0;
            state2.mode = COMMENT2;
          /* falls through */
          case COMMENT2:
            if (state2.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy5 = 0;
              do {
                len = input[next + copy5++];
                if (state2.head && len && state2.length < 65536) {
                  state2.head.comment += String.fromCharCode(len);
                }
              } while (len && copy5 < have);
              if (state2.flags & 512) {
                state2.check = crc322(state2.check, input, copy5, next);
              }
              have -= copy5;
              next += copy5;
              if (len) {
                break inf_leave;
              }
            } else if (state2.head) {
              state2.head.comment = null;
            }
            state2.mode = HCRC2;
          /* falls through */
          case HCRC2:
            if (state2.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state2.check & 65535)) {
                strm.msg = "header crc mismatch";
                state2.mode = BAD2;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state2.head) {
              state2.head.hcrc = state2.flags >> 9 & 1;
              state2.head.done = true;
            }
            strm.adler = state2.check = 0;
            state2.mode = TYPE2;
            break;
          case DICTID2:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state2.check = zswap322(hold);
            hold = 0;
            bits = 0;
            state2.mode = DICT2;
          /* falls through */
          case DICT2:
            if (state2.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state2.hold = hold;
              state2.bits = bits;
              return Z_NEED_DICT2;
            }
            strm.adler = state2.check = 1;
            state2.mode = TYPE2;
          /* falls through */
          case TYPE2:
            if (flush === Z_BLOCK2 || flush === Z_TREES2) {
              break inf_leave;
            }
          /* falls through */
          case TYPEDO2:
            if (state2.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state2.mode = CHECK2;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state2.mode = STORED2;
                break;
              case 1:
                fixedtables2(state2);
                state2.mode = LEN_2;
                if (flush === Z_TREES2) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state2.mode = TABLE2;
                break;
              case 3:
                strm.msg = "invalid block type";
                state2.mode = BAD2;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED2:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state2.mode = BAD2;
              break;
            }
            state2.length = hold & 65535;
            hold = 0;
            bits = 0;
            state2.mode = COPY_2;
            if (flush === Z_TREES2) {
              break inf_leave;
            }
          /* falls through */
          case COPY_2:
            state2.mode = COPY2;
          /* falls through */
          case COPY2:
            copy5 = state2.length;
            if (copy5) {
              if (copy5 > have) {
                copy5 = have;
              }
              if (copy5 > left) {
                copy5 = left;
              }
              if (copy5 === 0) {
                break inf_leave;
              }
              utils2.arraySet(output, input, next, copy5, put);
              have -= copy5;
              next += copy5;
              left -= copy5;
              put += copy5;
              state2.length -= copy5;
              break;
            }
            state2.mode = TYPE2;
            break;
          case TABLE2:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state2.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state2.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state2.nlen > 286 || state2.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state2.mode = BAD2;
              break;
            }
            state2.have = 0;
            state2.mode = LENLENS2;
          /* falls through */
          case LENLENS2:
            while (state2.have < state2.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.lens[order[state2.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state2.have < 19) {
              state2.lens[order[state2.have++]] = 0;
            }
            state2.lencode = state2.lendyn;
            state2.lenbits = 7;
            opts2 = { bits: state2.lenbits };
            ret = inflate_table3(CODES2, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts2);
            state2.lenbits = opts2.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state2.mode = BAD2;
              break;
            }
            state2.have = 0;
            state2.mode = CODELENS2;
          /* falls through */
          case CODELENS2:
            while (state2.have < state2.nlen + state2.ndist) {
              for (; ; ) {
                here = state2.lencode[hold & (1 << state2.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state2.lens[state2.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n3 = here_bits + 2;
                  while (bits < n3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state2.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state2.mode = BAD2;
                    break;
                  }
                  len = state2.lens[state2.have - 1];
                  copy5 = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n3 = here_bits + 3;
                  while (bits < n3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy5 = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n3 = here_bits + 7;
                  while (bits < n3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy5 = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state2.have + copy5 > state2.nlen + state2.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state2.mode = BAD2;
                  break;
                }
                while (copy5--) {
                  state2.lens[state2.have++] = len;
                }
              }
            }
            if (state2.mode === BAD2) {
              break;
            }
            if (state2.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state2.mode = BAD2;
              break;
            }
            state2.lenbits = 9;
            opts2 = { bits: state2.lenbits };
            ret = inflate_table3(LENS2, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts2);
            state2.lenbits = opts2.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state2.mode = BAD2;
              break;
            }
            state2.distbits = 6;
            state2.distcode = state2.distdyn;
            opts2 = { bits: state2.distbits };
            ret = inflate_table3(DISTS2, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts2);
            state2.distbits = opts2.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state2.mode = BAD2;
              break;
            }
            state2.mode = LEN_2;
            if (flush === Z_TREES2) {
              break inf_leave;
            }
          /* falls through */
          case LEN_2:
            state2.mode = LEN2;
          /* falls through */
          case LEN2:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state2.hold = hold;
              state2.bits = bits;
              inflate_fast3(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state2.hold;
              bits = state2.bits;
              if (state2.mode === TYPE2) {
                state2.back = -1;
              }
              break;
            }
            state2.back = 0;
            for (; ; ) {
              here = state2.lencode[hold & (1 << state2.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state2.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state2.back += here_bits;
            state2.length = here_val;
            if (here_op === 0) {
              state2.mode = LIT2;
              break;
            }
            if (here_op & 32) {
              state2.back = -1;
              state2.mode = TYPE2;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state2.mode = BAD2;
              break;
            }
            state2.extra = here_op & 15;
            state2.mode = LENEXT2;
          /* falls through */
          case LENEXT2:
            if (state2.extra) {
              n3 = state2.extra;
              while (bits < n3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.length += hold & (1 << state2.extra) - 1;
              hold >>>= state2.extra;
              bits -= state2.extra;
              state2.back += state2.extra;
            }
            state2.was = state2.length;
            state2.mode = DIST2;
          /* falls through */
          case DIST2:
            for (; ; ) {
              here = state2.distcode[hold & (1 << state2.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state2.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state2.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state2.mode = BAD2;
              break;
            }
            state2.offset = here_val;
            state2.extra = here_op & 15;
            state2.mode = DISTEXT2;
          /* falls through */
          case DISTEXT2:
            if (state2.extra) {
              n3 = state2.extra;
              while (bits < n3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.offset += hold & (1 << state2.extra) - 1;
              hold >>>= state2.extra;
              bits -= state2.extra;
              state2.back += state2.extra;
            }
            if (state2.offset > state2.dmax) {
              strm.msg = "invalid distance too far back";
              state2.mode = BAD2;
              break;
            }
            state2.mode = MATCH2;
          /* falls through */
          case MATCH2:
            if (left === 0) {
              break inf_leave;
            }
            copy5 = _out - left;
            if (state2.offset > copy5) {
              copy5 = state2.offset - copy5;
              if (copy5 > state2.whave) {
                if (state2.sane) {
                  strm.msg = "invalid distance too far back";
                  state2.mode = BAD2;
                  break;
                }
              }
              if (copy5 > state2.wnext) {
                copy5 -= state2.wnext;
                from2 = state2.wsize - copy5;
              } else {
                from2 = state2.wnext - copy5;
              }
              if (copy5 > state2.length) {
                copy5 = state2.length;
              }
              from_source = state2.window;
            } else {
              from_source = output;
              from2 = put - state2.offset;
              copy5 = state2.length;
            }
            if (copy5 > left) {
              copy5 = left;
            }
            left -= copy5;
            state2.length -= copy5;
            do {
              output[put++] = from_source[from2++];
            } while (--copy5);
            if (state2.length === 0) {
              state2.mode = LEN2;
            }
            break;
          case LIT2:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state2.length;
            left--;
            state2.mode = LEN2;
            break;
          case CHECK2:
            if (state2.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state2.total += _out;
              if (_out) {
                strm.adler = state2.check = /*UPDATE(state.check, put - _out, _out);*/
                state2.flags ? crc322(state2.check, output, _out, put - _out) : adler322(state2.check, output, _out, put - _out);
              }
              _out = left;
              if ((state2.flags ? hold : zswap322(hold)) !== state2.check) {
                strm.msg = "incorrect data check";
                state2.mode = BAD2;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state2.mode = LENGTH2;
          /* falls through */
          case LENGTH2:
            if (state2.wrap && state2.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state2.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state2.mode = BAD2;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state2.mode = DONE2;
          /* falls through */
          case DONE2:
            ret = Z_STREAM_END2;
            break inf_leave;
          case BAD2:
            ret = Z_DATA_ERROR2;
            break inf_leave;
          case MEM2:
            return Z_MEM_ERROR2;
          case SYNC2:
          /* falls through */
          default:
            return Z_STREAM_ERROR2;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state2.hold = hold;
    state2.bits = bits;
    if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD2 && (state2.mode < CHECK2 || flush !== Z_FINISH2)) {
      if (updatewindow2(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state2.total += _out;
    if (state2.wrap && _out) {
      strm.adler = state2.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      state2.flags ? crc322(state2.check, output, _out, strm.next_out - _out) : adler322(state2.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE2 ? 128 : 0) + (state2.mode === LEN_2 || state2.mode === COPY_2 ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH2) && ret === Z_OK2) {
      ret = Z_BUF_ERROR2;
    }
    return ret;
  }
  function inflateEnd2(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    var state2 = strm.state;
    if (state2.window) {
      state2.window = null;
    }
    strm.state = null;
    return Z_OK2;
  }
  function inflateGetHeader2(strm, head) {
    var state2;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state2 = strm.state;
    if ((state2.wrap & 2) === 0) {
      return Z_STREAM_ERROR2;
    }
    state2.head = head;
    head.done = false;
    return Z_OK2;
  }
  function inflateSetDictionary2(strm, dictionary2) {
    var dictLength = dictionary2.length;
    var state2;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR2;
    }
    state2 = strm.state;
    if (state2.wrap !== 0 && state2.mode !== DICT2) {
      return Z_STREAM_ERROR2;
    }
    if (state2.mode === DICT2) {
      dictid = 1;
      dictid = adler322(dictid, dictionary2, dictLength, 0);
      if (dictid !== state2.check) {
        return Z_DATA_ERROR2;
      }
    }
    ret = updatewindow2(strm, dictionary2, dictLength, dictLength);
    if (ret) {
      state2.mode = MEM2;
      return Z_MEM_ERROR2;
    }
    state2.havedict = 1;
    return Z_OK2;
  }
  inflate$2.inflateReset = inflateReset3;
  inflate$2.inflateReset2 = inflateReset22;
  inflate$2.inflateResetKeep = inflateResetKeep2;
  inflate$2.inflateInit = inflateInit3;
  inflate$2.inflateInit2 = inflateInit22;
  inflate$2.inflate = inflate2;
  inflate$2.inflateEnd = inflateEnd2;
  inflate$2.inflateGetHeader = inflateGetHeader2;
  inflate$2.inflateSetDictionary = inflateSetDictionary2;
  inflate$2.inflateInfo = "pako inflate (from Nodeca project)";
  return inflate$2;
}
var inflateExports = requireInflate();
const require$$3$1$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(inflateExports);
var constants$2;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants$2;
  hasRequiredConstants = 1;
  constants$2 = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  return constants$2;
}
var constantsExports = requireConstants();
const require$$4$1$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(constantsExports);
var md5$1 = { exports: {} };
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var core$1 = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace$2(__viteBrowserExternal$1);
var core = core$1.exports;
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core$1.exports;
  hasRequiredCore = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory();
      }
    })(core, function() {
      var CryptoJS2 = CryptoJS2 || function(Math2, undefined$1) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof commonjsGlobal$1 !== "undefined" && commonjsGlobal$1.crypto) {
          crypto = commonjsGlobal$1.crypto;
        }
        if (!crypto && typeof commonjsRequire === "function") {
          try {
            crypto = require$$0$2;
          } catch (err2) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err2) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err2) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || /* @__PURE__ */ function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base2 = C_lib.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base2.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i2 = 0; i2 < thatSigBytes; i2++) {
                var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone2 = Base2.clone.call(this);
            clone2.words = this.words.slice(0);
            return clone2;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i2 = 0; i2 < nBytes; i2 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
              words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i2 = 0; i2 < latin1StrLength; i2++) {
              words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e2) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base2.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data2) {
            if (typeof data2 == "string") {
              data2 = Utf8.parse(data2);
            }
            this._data.concat(data2);
            this._nDataBytes += data2.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data2 = this._data;
            var dataWords = data2.words;
            var dataSigBytes = data2.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset2 = 0; offset2 < nWordsReady; offset2 += blockSize) {
                this._doProcessBlock(dataWords, offset2);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data2.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone2 = Base2.clone.call(this);
            clone2._data = this._data.clone();
            return clone2;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base2.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS2;
    });
  })(core$1);
  return core$1.exports;
}
var md5 = md5$1.exports;
var hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5$1.exports;
  hasRequiredMd5 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(md5, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i2 = 0; i2 < 64; i2++) {
            T[i2] = Math2.abs(Math2.sin(i2 + 1)) * 4294967296 | 0;
          }
        })();
        var MD52 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset2) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset2 + i2;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset2 + 0];
            var M_offset_1 = M[offset2 + 1];
            var M_offset_2 = M[offset2 + 2];
            var M_offset_3 = M[offset2 + 3];
            var M_offset_4 = M[offset2 + 4];
            var M_offset_5 = M[offset2 + 5];
            var M_offset_6 = M[offset2 + 6];
            var M_offset_7 = M[offset2 + 7];
            var M_offset_8 = M[offset2 + 8];
            var M_offset_9 = M[offset2 + 9];
            var M_offset_10 = M[offset2 + 10];
            var M_offset_11 = M[offset2 + 11];
            var M_offset_12 = M[offset2 + 12];
            var M_offset_13 = M[offset2 + 13];
            var M_offset_14 = M[offset2 + 14];
            var M_offset_15 = M[offset2 + 15];
            var a2 = H[0];
            var b2 = H[1];
            var c2 = H[2];
            var d2 = H[3];
            a2 = FF(a2, b2, c2, d2, M_offset_0, 7, T[0]);
            d2 = FF(d2, a2, b2, c2, M_offset_1, 12, T[1]);
            c2 = FF(c2, d2, a2, b2, M_offset_2, 17, T[2]);
            b2 = FF(b2, c2, d2, a2, M_offset_3, 22, T[3]);
            a2 = FF(a2, b2, c2, d2, M_offset_4, 7, T[4]);
            d2 = FF(d2, a2, b2, c2, M_offset_5, 12, T[5]);
            c2 = FF(c2, d2, a2, b2, M_offset_6, 17, T[6]);
            b2 = FF(b2, c2, d2, a2, M_offset_7, 22, T[7]);
            a2 = FF(a2, b2, c2, d2, M_offset_8, 7, T[8]);
            d2 = FF(d2, a2, b2, c2, M_offset_9, 12, T[9]);
            c2 = FF(c2, d2, a2, b2, M_offset_10, 17, T[10]);
            b2 = FF(b2, c2, d2, a2, M_offset_11, 22, T[11]);
            a2 = FF(a2, b2, c2, d2, M_offset_12, 7, T[12]);
            d2 = FF(d2, a2, b2, c2, M_offset_13, 12, T[13]);
            c2 = FF(c2, d2, a2, b2, M_offset_14, 17, T[14]);
            b2 = FF(b2, c2, d2, a2, M_offset_15, 22, T[15]);
            a2 = GG(a2, b2, c2, d2, M_offset_1, 5, T[16]);
            d2 = GG(d2, a2, b2, c2, M_offset_6, 9, T[17]);
            c2 = GG(c2, d2, a2, b2, M_offset_11, 14, T[18]);
            b2 = GG(b2, c2, d2, a2, M_offset_0, 20, T[19]);
            a2 = GG(a2, b2, c2, d2, M_offset_5, 5, T[20]);
            d2 = GG(d2, a2, b2, c2, M_offset_10, 9, T[21]);
            c2 = GG(c2, d2, a2, b2, M_offset_15, 14, T[22]);
            b2 = GG(b2, c2, d2, a2, M_offset_4, 20, T[23]);
            a2 = GG(a2, b2, c2, d2, M_offset_9, 5, T[24]);
            d2 = GG(d2, a2, b2, c2, M_offset_14, 9, T[25]);
            c2 = GG(c2, d2, a2, b2, M_offset_3, 14, T[26]);
            b2 = GG(b2, c2, d2, a2, M_offset_8, 20, T[27]);
            a2 = GG(a2, b2, c2, d2, M_offset_13, 5, T[28]);
            d2 = GG(d2, a2, b2, c2, M_offset_2, 9, T[29]);
            c2 = GG(c2, d2, a2, b2, M_offset_7, 14, T[30]);
            b2 = GG(b2, c2, d2, a2, M_offset_12, 20, T[31]);
            a2 = HH(a2, b2, c2, d2, M_offset_5, 4, T[32]);
            d2 = HH(d2, a2, b2, c2, M_offset_8, 11, T[33]);
            c2 = HH(c2, d2, a2, b2, M_offset_11, 16, T[34]);
            b2 = HH(b2, c2, d2, a2, M_offset_14, 23, T[35]);
            a2 = HH(a2, b2, c2, d2, M_offset_1, 4, T[36]);
            d2 = HH(d2, a2, b2, c2, M_offset_4, 11, T[37]);
            c2 = HH(c2, d2, a2, b2, M_offset_7, 16, T[38]);
            b2 = HH(b2, c2, d2, a2, M_offset_10, 23, T[39]);
            a2 = HH(a2, b2, c2, d2, M_offset_13, 4, T[40]);
            d2 = HH(d2, a2, b2, c2, M_offset_0, 11, T[41]);
            c2 = HH(c2, d2, a2, b2, M_offset_3, 16, T[42]);
            b2 = HH(b2, c2, d2, a2, M_offset_6, 23, T[43]);
            a2 = HH(a2, b2, c2, d2, M_offset_9, 4, T[44]);
            d2 = HH(d2, a2, b2, c2, M_offset_12, 11, T[45]);
            c2 = HH(c2, d2, a2, b2, M_offset_15, 16, T[46]);
            b2 = HH(b2, c2, d2, a2, M_offset_2, 23, T[47]);
            a2 = II(a2, b2, c2, d2, M_offset_0, 6, T[48]);
            d2 = II(d2, a2, b2, c2, M_offset_7, 10, T[49]);
            c2 = II(c2, d2, a2, b2, M_offset_14, 15, T[50]);
            b2 = II(b2, c2, d2, a2, M_offset_5, 21, T[51]);
            a2 = II(a2, b2, c2, d2, M_offset_12, 6, T[52]);
            d2 = II(d2, a2, b2, c2, M_offset_3, 10, T[53]);
            c2 = II(c2, d2, a2, b2, M_offset_10, 15, T[54]);
            b2 = II(b2, c2, d2, a2, M_offset_1, 21, T[55]);
            a2 = II(a2, b2, c2, d2, M_offset_8, 6, T[56]);
            d2 = II(d2, a2, b2, c2, M_offset_15, 10, T[57]);
            c2 = II(c2, d2, a2, b2, M_offset_6, 15, T[58]);
            b2 = II(b2, c2, d2, a2, M_offset_13, 21, T[59]);
            a2 = II(a2, b2, c2, d2, M_offset_4, 6, T[60]);
            d2 = II(d2, a2, b2, c2, M_offset_11, 10, T[61]);
            c2 = II(c2, d2, a2, b2, M_offset_2, 15, T[62]);
            b2 = II(b2, c2, d2, a2, M_offset_9, 21, T[63]);
            H[0] = H[0] + a2 | 0;
            H[1] = H[1] + b2 | 0;
            H[2] = H[2] + c2 | 0;
            H[3] = H[3] + d2 | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i2 = 0; i2 < 4; i2++) {
              var H_i = H[i2];
              H[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        function FF(a2, b2, c2, d2, x, s2, t2) {
          var n3 = a2 + (b2 & c2 | ~b2 & d2) + x + t2;
          return (n3 << s2 | n3 >>> 32 - s2) + b2;
        }
        function GG(a2, b2, c2, d2, x, s2, t2) {
          var n3 = a2 + (b2 & d2 | c2 & ~d2) + x + t2;
          return (n3 << s2 | n3 >>> 32 - s2) + b2;
        }
        function HH(a2, b2, c2, d2, x, s2, t2) {
          var n3 = a2 + (b2 ^ c2 ^ d2) + x + t2;
          return (n3 << s2 | n3 >>> 32 - s2) + b2;
        }
        function II(a2, b2, c2, d2, x, s2, t2) {
          var n3 = a2 + (c2 ^ (b2 | ~d2)) + x + t2;
          return (n3 << s2 | n3 >>> 32 - s2) + b2;
        }
        C.MD5 = Hasher._createHelper(MD52);
        C.HmacMD5 = Hasher._createHmacHelper(MD52);
      })(Math);
      return CryptoJS2.MD5;
    });
  })(md5$1);
  return md5$1.exports;
}
var md5Exports = requireMd5();
const MD5 = /* @__PURE__ */ getDefaultExportFromCjs$2(md5Exports);
var b64 = {};
var hasRequiredB64;
function requireB64() {
  if (hasRequiredB64) return b64;
  hasRequiredB64 = 1;
  (function(exports) {
    var lookup2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    (function(exports2) {
      var Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var PLUS = "+".charCodeAt(0);
      var SLASH = "/".charCodeAt(0);
      var NUMBER = "0".charCodeAt(0);
      var LOWER = "a".charCodeAt(0);
      var UPPER = "A".charCodeAt(0);
      var PLUS_URL_SAFE = "-".charCodeAt(0);
      var SLASH_URL_SAFE = "_".charCodeAt(0);
      function decode2(elt) {
        var code = elt.charCodeAt(0);
        if (code === PLUS || code === PLUS_URL_SAFE)
          return 62;
        if (code === SLASH || code === SLASH_URL_SAFE)
          return 63;
        if (code < NUMBER)
          return -1;
        if (code < NUMBER + 10)
          return code - NUMBER + 26 + 26;
        if (code < UPPER + 26)
          return code - UPPER;
        if (code < LOWER + 26)
          return code - LOWER + 26;
      }
      function b64ToByteArray(b642) {
        var i2, j, l2, tmp, placeHolders, arr;
        if (b642.length % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var len = b642.length;
        placeHolders = "=" === b642.charAt(len - 2) ? 2 : "=" === b642.charAt(len - 1) ? 1 : 0;
        arr = new Arr2(b642.length * 3 / 4 - placeHolders);
        l2 = placeHolders > 0 ? b642.length - 4 : b642.length;
        var L = 0;
        function push(v2) {
          arr[L++] = v2;
        }
        for (i2 = 0, j = 0; i2 < l2; i2 += 4, j += 3) {
          tmp = decode2(b642.charAt(i2)) << 18 | decode2(b642.charAt(i2 + 1)) << 12 | decode2(b642.charAt(i2 + 2)) << 6 | decode2(b642.charAt(i2 + 3));
          push((tmp & 16711680) >> 16);
          push((tmp & 65280) >> 8);
          push(tmp & 255);
        }
        if (placeHolders === 2) {
          tmp = decode2(b642.charAt(i2)) << 2 | decode2(b642.charAt(i2 + 1)) >> 4;
          push(tmp & 255);
        } else if (placeHolders === 1) {
          tmp = decode2(b642.charAt(i2)) << 10 | decode2(b642.charAt(i2 + 1)) << 4 | decode2(b642.charAt(i2 + 2)) >> 2;
          push(tmp >> 8 & 255);
          push(tmp & 255);
        }
        return arr;
      }
      function uint8ToBase64(uint82) {
        var i2, extraBytes = uint82.length % 3, output = "", temp, length2;
        function encode(num) {
          return lookup2.charAt(num);
        }
        function tripletToBase642(num) {
          return encode(num >> 18 & 63) + encode(num >> 12 & 63) + encode(num >> 6 & 63) + encode(num & 63);
        }
        for (i2 = 0, length2 = uint82.length - extraBytes; i2 < length2; i2 += 3) {
          temp = (uint82[i2] << 16) + (uint82[i2 + 1] << 8) + uint82[i2 + 2];
          output += tripletToBase642(temp);
        }
        switch (extraBytes) {
          case 1:
            temp = uint82[uint82.length - 1];
            output += encode(temp >> 2);
            output += encode(temp << 4 & 63);
            output += "==";
            break;
          case 2:
            temp = (uint82[uint82.length - 2] << 8) + uint82[uint82.length - 1];
            output += encode(temp >> 10);
            output += encode(temp >> 4 & 63);
            output += encode(temp << 2 & 63);
            output += "=";
            break;
        }
        return output;
      }
      exports2.toByteArray = b64ToByteArray;
      exports2.fromByteArray = uint8ToBase64;
    })(exports);
  })(b64);
  return b64;
}
var b64Exports = requireB64();
const $hJqJp$base64js = /* @__PURE__ */ getDefaultExportFromCjs$2(b64Exports);
var $557adaaeb0c7885f$exports = {};
const $1627905f8be2ef3f$export$fb4028874a74450 = 5;
const $1627905f8be2ef3f$export$1bb1140fe1358b00 = 12;
const $1627905f8be2ef3f$export$f3e416a182673355 = 13;
const $1627905f8be2ef3f$export$24aa617c849a894a = 16;
const $1627905f8be2ef3f$export$a73c4d14459b698d = 17;
const $1627905f8be2ef3f$export$9e5d732f3676a9ba = 22;
const $1627905f8be2ef3f$export$1dff41d5c0caca01 = 28;
const $1627905f8be2ef3f$export$30a74a373318dec6 = 31;
const $1627905f8be2ef3f$export$d710c5f50fc7496a = 33;
const $1627905f8be2ef3f$export$66498d28055820a9 = 34;
const $1627905f8be2ef3f$export$eb6c6d0b7c8826f2 = 35;
const $1627905f8be2ef3f$export$de92be486109a1df = 36;
const $1627905f8be2ef3f$export$606cfc2a8896c91f = 37;
const $1627905f8be2ef3f$export$e51d3c675bb0140d = 38;
const $1627905f8be2ef3f$export$da51c6332ad11d7b = 39;
const $1627905f8be2ef3f$export$bea437c40441867d = 40;
const $1627905f8be2ef3f$export$c4c7eecbfed13dc9 = 41;
const $1627905f8be2ef3f$export$98e1f8a379849661 = 42;
const $32627af916ac1b00$export$98f50d781a474745 = 0;
const $32627af916ac1b00$export$12ee1f8f5315ca7e = 1;
const $32627af916ac1b00$export$e4965ce242860454 = 2;
const $32627af916ac1b00$export$8f14048969dcd45e = 3;
const $32627af916ac1b00$export$133eb141bf58aff4 = 4;
const $32627af916ac1b00$export$5bdb8ccbf5c57afc = [
  //OP   , CL    , CP    , QU    , GL    , NS    , EX    , SY    , IS    , PR    , PO    , NU    , AL    , HL    , ID    , IN    , HY    , BA    , BB    , B2    , ZW    , CM    , WJ    , H2    , H3    , JL    , JV    , JT    , RI    , EB    , EM    , ZWJ   , CB
  [
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$8f14048969dcd45e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ],
  [
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$e4965ce242860454,
    $32627af916ac1b00$export$133eb141bf58aff4,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$98f50d781a474745,
    $32627af916ac1b00$export$12ee1f8f5315ca7e,
    $32627af916ac1b00$export$98f50d781a474745
  ]
  // CB
];
const $557adaaeb0c7885f$var$data = $hJqJp$base64js.toByteArray("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");
const $557adaaeb0c7885f$var$classTrie = new $hJqJp$unicodetrie($557adaaeb0c7885f$var$data);
const $557adaaeb0c7885f$var$mapClass = function(c2) {
  switch (c2) {
    case $1627905f8be2ef3f$export$d710c5f50fc7496a:
      return $1627905f8be2ef3f$export$1bb1140fe1358b00;
    case $1627905f8be2ef3f$export$da51c6332ad11d7b:
    case $1627905f8be2ef3f$export$bea437c40441867d:
    case $1627905f8be2ef3f$export$98e1f8a379849661:
      return $1627905f8be2ef3f$export$1bb1140fe1358b00;
    case $1627905f8be2ef3f$export$eb6c6d0b7c8826f2:
      return $1627905f8be2ef3f$export$fb4028874a74450;
    default:
      return c2;
  }
};
const $557adaaeb0c7885f$var$mapFirst = function(c2) {
  switch (c2) {
    case $1627905f8be2ef3f$export$606cfc2a8896c91f:
    case $1627905f8be2ef3f$export$e51d3c675bb0140d:
      return $1627905f8be2ef3f$export$66498d28055820a9;
    case $1627905f8be2ef3f$export$c4c7eecbfed13dc9:
      return $1627905f8be2ef3f$export$9e5d732f3676a9ba;
    default:
      return c2;
  }
};
class $557adaaeb0c7885f$var$Break {
  constructor(position, required = false) {
    this.position = position;
    this.required = required;
  }
}
class $557adaaeb0c7885f$var$LineBreaker {
  nextCodePoint() {
    const code = this.string.charCodeAt(this.pos++);
    const next = this.string.charCodeAt(this.pos);
    if (55296 <= code && code <= 56319 && 56320 <= next && next <= 57343) {
      this.pos++;
      return (code - 55296) * 1024 + (next - 56320) + 65536;
    }
    return code;
  }
  nextCharClass() {
    return $557adaaeb0c7885f$var$mapClass($557adaaeb0c7885f$var$classTrie.get(this.nextCodePoint()));
  }
  getSimpleBreak() {
    switch (this.nextClass) {
      case $1627905f8be2ef3f$export$c4c7eecbfed13dc9:
        return false;
      case $1627905f8be2ef3f$export$66498d28055820a9:
      case $1627905f8be2ef3f$export$606cfc2a8896c91f:
      case $1627905f8be2ef3f$export$e51d3c675bb0140d:
        this.curClass = $1627905f8be2ef3f$export$66498d28055820a9;
        return false;
      case $1627905f8be2ef3f$export$de92be486109a1df:
        this.curClass = $1627905f8be2ef3f$export$de92be486109a1df;
        return false;
    }
    return null;
  }
  getPairTableBreak(lastClass) {
    let shouldBreak2 = false;
    switch ($32627af916ac1b00$export$5bdb8ccbf5c57afc[this.curClass][this.nextClass]) {
      case $32627af916ac1b00$export$98f50d781a474745:
        shouldBreak2 = true;
        break;
      case $32627af916ac1b00$export$12ee1f8f5315ca7e:
        shouldBreak2 = lastClass === $1627905f8be2ef3f$export$c4c7eecbfed13dc9;
        break;
      case $32627af916ac1b00$export$e4965ce242860454:
        shouldBreak2 = lastClass === $1627905f8be2ef3f$export$c4c7eecbfed13dc9;
        if (!shouldBreak2) {
          shouldBreak2 = false;
          return shouldBreak2;
        }
        break;
      case $32627af916ac1b00$export$8f14048969dcd45e:
        if (lastClass !== $1627905f8be2ef3f$export$c4c7eecbfed13dc9) return shouldBreak2;
        break;
    }
    if (this.LB8a) shouldBreak2 = false;
    if (this.LB21a && (this.curClass === $1627905f8be2ef3f$export$24aa617c849a894a || this.curClass === $1627905f8be2ef3f$export$a73c4d14459b698d)) {
      shouldBreak2 = false;
      this.LB21a = false;
    } else this.LB21a = this.curClass === $1627905f8be2ef3f$export$f3e416a182673355;
    if (this.curClass === $1627905f8be2ef3f$export$1dff41d5c0caca01) {
      this.LB30a++;
      if (this.LB30a == 2 && this.nextClass === $1627905f8be2ef3f$export$1dff41d5c0caca01) {
        shouldBreak2 = true;
        this.LB30a = 0;
      }
    } else this.LB30a = 0;
    this.curClass = this.nextClass;
    return shouldBreak2;
  }
  nextBreak() {
    if (this.curClass == null) {
      let firstClass = this.nextCharClass();
      this.curClass = $557adaaeb0c7885f$var$mapFirst(firstClass);
      this.nextClass = firstClass;
      this.LB8a = firstClass === $1627905f8be2ef3f$export$30a74a373318dec6;
      this.LB30a = 0;
    }
    while (this.pos < this.string.length) {
      this.lastPos = this.pos;
      const lastClass = this.nextClass;
      this.nextClass = this.nextCharClass();
      if (this.curClass === $1627905f8be2ef3f$export$66498d28055820a9 || this.curClass === $1627905f8be2ef3f$export$de92be486109a1df && this.nextClass !== $1627905f8be2ef3f$export$606cfc2a8896c91f) {
        this.curClass = $557adaaeb0c7885f$var$mapFirst($557adaaeb0c7885f$var$mapClass(this.nextClass));
        return new $557adaaeb0c7885f$var$Break(this.lastPos, true);
      }
      let shouldBreak2 = this.getSimpleBreak();
      if (shouldBreak2 === null) shouldBreak2 = this.getPairTableBreak(lastClass);
      this.LB8a = this.nextClass === $1627905f8be2ef3f$export$30a74a373318dec6;
      if (shouldBreak2) return new $557adaaeb0c7885f$var$Break(this.lastPos);
    }
    if (this.lastPos < this.string.length) {
      this.lastPos = this.string.length;
      return new $557adaaeb0c7885f$var$Break(this.string.length);
    }
    return null;
  }
  constructor(string) {
    this.string = string;
    this.pos = 0;
    this.lastPos = 0;
    this.curClass = null;
    this.nextClass = null;
    this.LB8a = false;
    this.LB21a = false;
    this.LB30a = 0;
  }
}
$557adaaeb0c7885f$exports = $557adaaeb0c7885f$var$LineBreaker;
const DACTable = new Struct({
  identifier: new BufferT(1),
  value: new BufferT(1)
});
const DACMarker = {
  name: () => "DAC",
  length: uint16be,
  tables: new ArrayT(DACTable, (parent) => parent.length / 2)
};
const readUInt8 = (array, offset2) => {
  return array[offset2];
};
const readUInt16BE = (array, offset2) => {
  return array[offset2] << 8 | array[offset2 + 1];
};
const readUInt16LE = (array, offset2) => {
  return array[offset2] | array[offset2 + 1] << 8;
};
const readUInt32BE = (array, offset2) => {
  return readInt32BE(array, offset2) >>> 0;
};
const readUInt32LE = (array, offset2) => {
  return readInt32LE(array, offset2) >>> 0;
};
const uint8ArrayToHexString = (uint8Array) => {
  return Array.from(
    uint8Array,
    (byte) => byte.toString(16).padStart(2, "0")
  ).join("");
};
const decoder = new TextDecoder("utf-8");
const uint8ArrayToString = (uint8Array) => {
  return decoder.decode(uint8Array);
};
const concatenateUint8Arrays = (arrays) => {
  const totalLength = arrays.reduce((length2, arr) => length2 + arr.length, 0);
  const concatenatedArray = new Uint8Array(totalLength);
  let offset2 = 0;
  arrays.forEach((arr) => {
    concatenatedArray.set(arr, offset2);
    offset2 += arr.length;
  });
  return concatenatedArray;
};
const readInt32BE = (array, offset2) => {
  return array[offset2] << 24 | array[offset2 + 1] << 16 | array[offset2 + 2] << 8 | array[offset2 + 3];
};
const readInt32LE = (array, offset2) => {
  return array[offset2] | array[offset2 + 1] << 8 | array[offset2 + 2] << 16 | array[offset2 + 3] << 24;
};
class HuffmanTableElements {
  decode(stream2, parent) {
    const tables = {};
    let buffer = stream2.buffer.slice(
      stream2.pos,
      stream2.pos + parent.length - 2
    );
    while (buffer.length > 0) {
      let offset2 = 1;
      const elements = [];
      const identifier = readUInt8(buffer, 0);
      const lengths = buffer.slice(offset2, offset2 + 16);
      offset2 += 16;
      for (const length2 of lengths) {
        elements.push(buffer.slice(offset2, offset2 + length2));
        offset2 += length2;
      }
      buffer = buffer.slice(offset2);
      tables[identifier] = concatenateUint8Arrays(elements);
    }
    stream2.pos += parent.length - 2;
    return tables;
  }
}
const DefineHuffmanTableMarker = {
  name: () => "DHT",
  length: uint16be,
  tables: new HuffmanTableElements()
};
const DQTMarker = {
  name: () => "DQT",
  length: uint16be,
  tables: new ArrayT(
    new Struct({
      identifier: new BufferT(1),
      data: new BufferT(64)
    }),
    (parent) => (parent.length - 2) / 65
  )
};
const DRIMarker = {
  name: () => "DRI",
  length: uint16be,
  restartInterval: uint16be
};
const EndOfImageMarker = {
  name: () => "EOI",
  afterEOI: new Reserved(uint8, Infinity)
};
const tags = {
  ifd: {
    "010e": "imageDescription",
    "010f": "make",
    "011a": "xResolution",
    "011b": "yResolution",
    "011c": "planarConfiguration",
    "012d": "transferFunction",
    "013b": "artist",
    "013e": "whitePoint",
    "013f": "primaryChromaticities",
    "0100": "imageWidth",
    "0101": "imageHeight",
    "0102": "bitsPerSample",
    "0103": "compression",
    "0106": "photometricInterpretation",
    "0110": "model",
    "0111": "stripOffsets",
    "0112": "orientation",
    "0115": "samplesPerPixel",
    "0116": "rowsPerStrip",
    "0117": "stripByteCounts",
    "0128": "resolutionUnit",
    "0131": "software",
    "0132": "dateTime",
    "0201": "jpegInterchangeFormat",
    "0202": "jpegInterchangeFormatLength",
    "0211": "ycbCrCoefficients",
    "0212": "ycbCrSubSampling",
    "0213": "ycbCrPositioning",
    "0214": "referenceBlackWhite",
    "829a": "exposureTime",
    "829d": "fNumber",
    "920a": "focalLength",
    "927c": "makerNote",
    8298: "copyright",
    8769: "exifIFDPointer",
    8822: "exposureProgram",
    8824: "spectralSensitivity",
    8825: "gpsInfoIFDPointer",
    8827: "photographicSensitivity",
    8828: "oecf",
    8830: "sensitivityType",
    8831: "standardOutputSensitivity",
    8832: "recommendedExposureIndex",
    8833: "isoSpeed",
    8834: "isoSpeedLatitudeyyy",
    8835: "isoSpeedLatitudezzz",
    9e3: "exifVersion",
    9003: "dateTimeOriginal",
    9004: "dateTimeDigitized",
    9101: "componentsConfiguration",
    9102: "compressedBitsPerPixel",
    9201: "shutterSpeedValue",
    9202: "apertureValue",
    9203: "brightnessValue",
    9204: "exposureBiasValue",
    9205: "maxApertureValue",
    9206: "subjectDistance",
    9207: "meteringMode",
    9208: "lightSource",
    9209: "flash",
    9214: "subjectArea",
    9286: "userComment",
    9290: "subSecTime",
    9291: "subSecTimeOriginal",
    9292: "subSecTimeDigitized",
    a000: "flashpixVersion",
    a001: "colorSpace",
    a002: "pixelXDimension",
    a003: "pixelYDimension",
    a004: "relatedSoundFile",
    a005: "interoperabilityIFDPointer",
    a20b: "flashEnergy",
    a20c: "spatialFrequencyResponse",
    a20e: "focalPlaneXResolution",
    a20f: "focalPlaneYResolution",
    a40a: "sharpness",
    a40b: "deviceSettingDescription",
    a40c: "subjectDistanceRange",
    a210: "focalPlaneResolutionUnit",
    a214: "subjectLocation",
    a215: "exposureIndex",
    a217: "sensingMethod",
    a300: "fileSource",
    a301: "sceneType",
    a302: "cfaPattern",
    a401: "customRendered",
    a402: "exposureMode",
    a403: "whiteBalance",
    a404: "digitalZoomRatio",
    a405: "focalLengthIn35mmFilm",
    a406: "sceneCaptureType",
    a407: "gainControl",
    a408: "contrast",
    a409: "saturation",
    a420: "imageUniqueID",
    a430: "cameraOwnerName",
    a431: "bodySerialNumber",
    a432: "lensSpecification",
    a433: "lensMake",
    a434: "lensModel",
    a435: "lensSerialNumber",
    a500: "gamma"
  },
  gps: {
    "0000": "gpsVersionID",
    "0001": "gpsLatitudeRef",
    "0002": "gpsLatitude",
    "0003": "gpsLongitudeRef",
    "0004": "gpsLongitude",
    "0005": "gpsAltitudeRef",
    "0006": "gpsAltitude",
    "0007": "gpsTimeStamp",
    "0008": "gpsSatellites",
    "0009": "gpsStatus",
    "000a": "gpsMeasureMode",
    "000b": "gpsDOP",
    "000c": "gpsSpeedRef",
    "000d": "gpsSpeed",
    "000e": "gpsTrackRef",
    "000f": "gpsTrack",
    "0010": "gpsImgDirectionRef",
    "0011": "gpsImgDirection",
    "0012": "gpsMapDatum",
    "0013": "gpsDestLatitudeRef",
    "0014": "gpsDestLatitude",
    "0015": "gpsDestLongitudeRef",
    "0016": "gpsDestLongitude",
    "0017": "gpsDestBearingRef",
    "0018": "gpsDestBearing",
    "0019": "gpsDestDistanceRef",
    "001a": "gpsDestDistance",
    "001b": "gpsProcessingMethod",
    "001c": "gpsAreaInformation",
    "001d": "gpsDateStamp",
    "001e": "gpsDifferential",
    "001f": "gpsHPositioningError"
  }
};
class IDFEntries {
  constructor(bigEndian) {
    this.bigEndian = bigEndian;
    this.bytes = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8];
  }
  _getTagValue(dataValue, dataFormat, componentsNumber) {
    switch (dataFormat) {
      case 2:
        return dataValue.toString("ascii").replace(/\0+$/, "");
      case 129:
        return dataValue.toString("utf8").replace(/\0+$/, "");
      case 7:
        return "0x" + dataValue.toString("hex");
      default:
        return this._getTagValueForNumericalData(dataValue, dataFormat, componentsNumber);
    }
  }
  _getTagValueForNumericalData(dataValue, dataFormat, componentsNumber) {
    const tagValue = [];
    const componentsBytes = this.bytes[dataFormat];
    for (let i2 = 0; i2 < componentsNumber; i2 += 1) {
      tagValue.push(this._getSingleTagValueForNumericalData(dataValue, dataFormat, i2 * componentsBytes));
    }
    return tagValue.length === 1 ? tagValue[0] : tagValue;
  }
  _getSingleTagValueForNumericalData(dataValue, dataFormat, pos) {
    const uint162 = (pos2) => this.bigEndian ? readUInt16BE(dataValue, pos2) : readUInt16LE(dataValue, pos2);
    const uint322 = (pos2) => this.bigEndian ? readUInt32BE(dataValue, pos2) : readUInt32LE(dataValue, pos2);
    const int322 = (pos2) => this.bigEndian ? readInt32BE(dataValue, pos2) : readInt32LE(dataValue, pos2);
    switch (dataFormat) {
      case 1:
        return readUInt8(dataValue, pos);
      case 3:
        return uint162(pos);
      case 4:
        return uint322(pos);
      case 5:
        return uint322(pos) / uint322(pos + 4);
      case 9:
        return int322(pos);
      case 10: {
        return int322(pos) / int322(pos + 4);
      }
    }
  }
  _decodeIDFEntries(buffer, tags2, offset2, log2 = false) {
    let pos = 2 + offset2;
    const entries = {};
    const uint162 = (pos2) => this.bigEndian ? readUInt16BE(buffer, pos2) : readUInt16LE(buffer, pos2);
    const uint322 = (pos2) => this.bigEndian ? readUInt32BE(buffer, pos2) : readUInt32LE(buffer, pos2);
    const numberOfEntries = uint162(offset2);
    for (let i2 = 0; i2 < numberOfEntries; i2++) {
      const tagAddress = buffer.slice(pos, pos + 2);
      const dataFormat = uint162(pos + 2);
      const componentsNumber = uint322(pos + 4);
      const componentsBytes = this.bytes[dataFormat];
      const dataLength = componentsNumber * componentsBytes;
      let dataValue = buffer.slice(pos + 8, pos + 12);
      if (dataLength > 4) {
        const dataOffset = this.bigEndian ? readUInt32BE(dataValue, 0) : readUInt32LE(dataValue, 0);
        dataValue = buffer.slice(dataOffset, dataOffset + dataLength);
      }
      const tagValue = this._getTagValue(dataValue, dataFormat, componentsNumber);
      const tagNumber = this.bigEndian ? uint8ArrayToHexString(tagAddress) : uint8ArrayToHexString(tagAddress.reverse());
      const tagName = tags2[tagNumber];
      entries[tagName] = tagValue;
      pos += 12;
    }
    return entries;
  }
  decode(stream2, parent) {
    const buffer = stream2.buffer.slice(stream2.pos - 8);
    const offsetToFirstIFD = parent.offsetToFirstIFD;
    if (offsetToFirstIFD > buffer.length) {
      stream2.pos += parent.parent.length - 16;
      return {};
    }
    const entries = this._decodeIDFEntries(buffer, tags.ifd, offsetToFirstIFD);
    const { exifIFDPointer, gpsInfoIFDPointer } = entries;
    if (exifIFDPointer) {
      entries.subExif = this._decodeIDFEntries(
        buffer,
        tags.ifd,
        exifIFDPointer
      );
    }
    if (gpsInfoIFDPointer) {
      const gps = gpsInfoIFDPointer;
      entries.gpsInfo = this._decodeIDFEntries(buffer, tags.gps, gps, true);
    }
    stream2.pos += parent.parent.length - 16;
    return entries;
  }
}
const IFDData = (bigEndian) => {
  const uint162 = bigEndian ? uint16be : uint16le;
  const uint322 = bigEndian ? uint32be : uint32le;
  return new Struct({
    fortyTwo: uint162,
    offsetToFirstIFD: uint322,
    entries: new IDFEntries(bigEndian)
  });
};
class TIFFHeader {
  decode(stream2, parent) {
    const byteOrder = uint8ArrayToString(
      stream2.buffer.slice(stream2.pos, stream2.pos + 2)
    );
    const bigEndian = byteOrder === "MM";
    stream2.pos += 2;
    const data2 = IFDData(bigEndian).decode(stream2, parent);
    return data2.entries;
  }
}
const EXIFMarker = {
  name: () => "EXIF",
  length: uint16be,
  identifier: new StringT(6),
  entries: new TIFFHeader()
};
const JFIFMarker = {
  name: () => "JFIF",
  length: uint16be,
  identifier: new StringT(5),
  version: uint16be,
  units: uint8,
  xDensity: uint16be,
  yDensity: uint16be,
  thumbnailWidth: uint8,
  thumbnailHeight: uint8
};
class ImageData {
  decode(stream2) {
    const buffer = stream2.buffer.slice(stream2.pos);
    let length2 = 0;
    let i2 = buffer.indexOf(255);
    while (i2 !== -1) {
      length2 = i2;
      const nextByte = buffer[length2 + 1];
      const comesRestart = nextByte >= 208 && nextByte <= 215;
      if (nextByte !== 0 && !comesRestart) break;
      i2 = buffer.indexOf(255, i2 + 1);
    }
    stream2.pos += length2;
    return buffer.slice(0, length2);
  }
}
const SOSComponentSpecification = new Struct({
  scanComponentSelector: uint8,
  entropyCodingTable: new BufferT(1)
});
const SOSMarker = {
  name: () => "SOS",
  length: uint16be,
  numberOfImageComponents: uint8,
  componentSpecifications: new ArrayT(
    SOSComponentSpecification,
    (parent) => parent.numberOfImageComponents
  ),
  startOfSpectral: uint8,
  endOfSpectral: uint8,
  successiveApproximationBit: new BufferT(1),
  data: new ImageData()
};
const FrameColorComponent = new Struct({
  id: uint8,
  samplingFactors: uint8,
  quantizationTableId: uint8
});
const StartOfFrameMarker = {
  name: () => "SOF",
  length: uint16be,
  precision: uint8,
  height: uint16be,
  width: uint16be,
  numberOfComponents: uint8,
  components: new ArrayT(
    FrameColorComponent,
    (parent) => parent.numberOfComponents
  )
};
const StartOfImageMarker = {
  name: () => "SOI"
};
const UnknownMarker = {
  length: uint16be,
  buf: new BufferT((parent) => parent.length - 2)
};
const unknownMarkers = Array(63).fill(0).reduce((acc, v2, i2) => ({ ...acc, [i2 + 65472]: UnknownMarker }), {});
const Marker = new VersionedStruct(uint16be, {
  ...unknownMarkers,
  65472: StartOfFrameMarker,
  65473: StartOfFrameMarker,
  65474: StartOfFrameMarker,
  65475: StartOfFrameMarker,
  65476: DefineHuffmanTableMarker,
  65477: StartOfFrameMarker,
  65478: StartOfFrameMarker,
  65479: StartOfFrameMarker,
  65481: StartOfFrameMarker,
  65482: StartOfFrameMarker,
  65483: StartOfFrameMarker,
  65484: DACMarker,
  65485: StartOfFrameMarker,
  65486: StartOfFrameMarker,
  65487: StartOfFrameMarker,
  65496: StartOfImageMarker,
  65497: EndOfImageMarker,
  65498: SOSMarker,
  65499: DQTMarker,
  65501: DRIMarker,
  65504: JFIFMarker,
  65505: EXIFMarker
});
const JPEG$2 = new ArrayT(Marker);
const decode = (buffer) => {
  const markers = JPEG$2.fromBuffer(buffer);
  return markers.map(({ version: version2, ...rest }) => ({ type: version2, ...rest }));
};
const _JPEG = { decode };
var global$1$2 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup$2 = [];
var revLookup$2 = [];
var Arr$2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited$2 = false;
function init$2() {
  inited$2 = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code.length; i2 < len; ++i2) {
    lookup$2[i2] = code[i2];
    revLookup$2[code.charCodeAt(i2)] = i2;
  }
  revLookup$2["-".charCodeAt(0)] = 62;
  revLookup$2["_".charCodeAt(0)] = 63;
}
function toByteArray$2(b642) {
  if (!inited$2) {
    init$2();
  }
  var i2, j, l2, tmp, placeHolders, arr;
  var len = b642.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b642[len - 2] === "=" ? 2 : b642[len - 1] === "=" ? 1 : 0;
  arr = new Arr$2(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i2 = 0, j = 0; i2 < l2; i2 += 4, j += 3) {
    tmp = revLookup$2[b642.charCodeAt(i2)] << 18 | revLookup$2[b642.charCodeAt(i2 + 1)] << 12 | revLookup$2[b642.charCodeAt(i2 + 2)] << 6 | revLookup$2[b642.charCodeAt(i2 + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup$2[b642.charCodeAt(i2)] << 2 | revLookup$2[b642.charCodeAt(i2 + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup$2[b642.charCodeAt(i2)] << 10 | revLookup$2[b642.charCodeAt(i2 + 1)] << 4 | revLookup$2[b642.charCodeAt(i2 + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64$2(num) {
  return lookup$2[num >> 18 & 63] + lookup$2[num >> 12 & 63] + lookup$2[num >> 6 & 63] + lookup$2[num & 63];
}
function encodeChunk$2(uint82, start2, end2) {
  var tmp;
  var output = [];
  for (var i2 = start2; i2 < end2; i2 += 3) {
    tmp = (uint82[i2] << 16) + (uint82[i2 + 1] << 8) + uint82[i2 + 2];
    output.push(tripletToBase64$2(tmp));
  }
  return output.join("");
}
function fromByteArray$2(uint82) {
  if (!inited$2) {
    init$2();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(encodeChunk$2(uint82, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup$2[tmp >> 2];
    output += lookup$2[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup$2[tmp >> 10];
    output += lookup$2[tmp >> 4 & 63];
    output += lookup$2[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read$2(buffer, offset2, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer[offset2 + i2];
  i2 += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
}
function write$2(buffer, value2, offset2, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer[offset2 + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer[offset2 + i2 - d2] |= s2 * 128;
}
var toString$2 = {}.toString;
var isArray$1$1 = Array.isArray || function(arr) {
  return toString$2.call(arr) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var INSPECT_MAX_BYTES$2 = 50;
Buffer$4.TYPED_ARRAY_SUPPORT = global$1$2.TYPED_ARRAY_SUPPORT !== void 0 ? global$1$2.TYPED_ARRAY_SUPPORT : true;
var _kMaxLength$1 = kMaxLength$2();
function kMaxLength$2() {
  return Buffer$4.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer$2(that, length2) {
  if (kMaxLength$2() < length2) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length2);
    that.__proto__ = Buffer$4.prototype;
  } else {
    if (that === null) {
      that = new Buffer$4(length2);
    }
    that.length = length2;
  }
  return that;
}
function Buffer$4(arg, encodingOrOffset, length2) {
  if (!Buffer$4.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$4)) {
    return new Buffer$4(arg, encodingOrOffset, length2);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe$2(this, arg);
  }
  return from$3(this, arg, encodingOrOffset, length2);
}
Buffer$4.poolSize = 8192;
Buffer$4._augment = function(arr) {
  arr.__proto__ = Buffer$4.prototype;
  return arr;
};
function from$3(that, value2, encodingOrOffset, length2) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer$2(that, value2, encodingOrOffset, length2);
  }
  if (typeof value2 === "string") {
    return fromString$2(that, value2, encodingOrOffset);
  }
  return fromObject$2(that, value2);
}
Buffer$4.from = function(value2, encodingOrOffset, length2) {
  return from$3(null, value2, encodingOrOffset, length2);
};
if (Buffer$4.TYPED_ARRAY_SUPPORT) {
  Buffer$4.prototype.__proto__ = Uint8Array.prototype;
  Buffer$4.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer$4[Symbol.species] === Buffer$4) ;
}
function assertSize$2(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc$2(that, size, fill4, encoding) {
  assertSize$2(size);
  if (size <= 0) {
    return createBuffer$2(that, size);
  }
  if (fill4 !== void 0) {
    return typeof encoding === "string" ? createBuffer$2(that, size).fill(fill4, encoding) : createBuffer$2(that, size).fill(fill4);
  }
  return createBuffer$2(that, size);
}
Buffer$4.alloc = function(size, fill4, encoding) {
  return alloc$2(null, size, fill4, encoding);
};
function allocUnsafe$2(that, size) {
  assertSize$2(size);
  that = createBuffer$2(that, size < 0 ? 0 : checked$2(size) | 0);
  if (!Buffer$4.TYPED_ARRAY_SUPPORT) {
    for (var i2 = 0; i2 < size; ++i2) {
      that[i2] = 0;
    }
  }
  return that;
}
Buffer$4.allocUnsafe = function(size) {
  return allocUnsafe$2(null, size);
};
Buffer$4.allocUnsafeSlow = function(size) {
  return allocUnsafe$2(null, size);
};
function fromString$2(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer$4.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length2 = byteLength$2(string, encoding) | 0;
  that = createBuffer$2(that, length2);
  var actual = that.write(string, encoding);
  if (actual !== length2) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike$2(that, array) {
  var length2 = array.length < 0 ? 0 : checked$2(array.length) | 0;
  that = createBuffer$2(that, length2);
  for (var i2 = 0; i2 < length2; i2 += 1) {
    that[i2] = array[i2] & 255;
  }
  return that;
}
function fromArrayBuffer$2(that, array, byteOffset, length2) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length2 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length2 === void 0) {
    array = new Uint8Array(array);
  } else if (length2 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length2);
  }
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer$4.prototype;
  } else {
    that = fromArrayLike$2(that, array);
  }
  return that;
}
function fromObject$2(that, obj) {
  if (internalIsBuffer$2(obj)) {
    var len = checked$2(obj.length) | 0;
    that = createBuffer$2(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan$2(obj.length)) {
        return createBuffer$2(that, 0);
      }
      return fromArrayLike$2(that, obj);
    }
    if (obj.type === "Buffer" && isArray$1$1(obj.data)) {
      return fromArrayLike$2(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked$2(length2) {
  if (length2 >= kMaxLength$2()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength$2().toString(16) + " bytes");
  }
  return length2 | 0;
}
function SlowBuffer$1(length2) {
  if (+length2 != length2) {
    length2 = 0;
  }
  return Buffer$4.alloc(+length2);
}
Buffer$4.isBuffer = isBuffer$1$2;
function internalIsBuffer$2(b2) {
  return !!(b2 != null && b2._isBuffer);
}
Buffer$4.compare = function compare(a2, b2) {
  if (!internalIsBuffer$2(a2) || !internalIsBuffer$2(b2)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a2 === b2) return 0;
  var x = a2.length;
  var y2 = b2.length;
  for (var i2 = 0, len = Math.min(x, y2); i2 < len; ++i2) {
    if (a2[i2] !== b2[i2]) {
      x = a2[i2];
      y2 = b2[i2];
      break;
    }
  }
  if (x < y2) return -1;
  if (y2 < x) return 1;
  return 0;
};
Buffer$4.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer$4.concat = function concat(list, length2) {
  if (!isArray$1$1(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer$4.alloc(0);
  }
  var i2;
  if (length2 === void 0) {
    length2 = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      length2 += list[i2].length;
    }
  }
  var buffer = Buffer$4.allocUnsafe(length2);
  var pos = 0;
  for (i2 = 0; i2 < list.length; ++i2) {
    var buf = list[i2];
    if (!internalIsBuffer$2(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength$2(string, encoding) {
  if (internalIsBuffer$2(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0) return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes$2(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes$2(string).length;
      default:
        if (loweredCase) return utf8ToBytes$2(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$4.byteLength = byteLength$2;
function slowToString$2(encoding, start2, end2) {
  var loweredCase = false;
  if (start2 === void 0 || start2 < 0) {
    start2 = 0;
  }
  if (start2 > this.length) {
    return "";
  }
  if (end2 === void 0 || end2 > this.length) {
    end2 = this.length;
  }
  if (end2 <= 0) {
    return "";
  }
  end2 >>>= 0;
  start2 >>>= 0;
  if (end2 <= start2) {
    return "";
  }
  if (!encoding) encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice$2(this, start2, end2);
      case "utf8":
      case "utf-8":
        return utf8Slice$2(this, start2, end2);
      case "ascii":
        return asciiSlice$2(this, start2, end2);
      case "latin1":
      case "binary":
        return latin1Slice$2(this, start2, end2);
      case "base64":
        return base64Slice$2(this, start2, end2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice$2(this, start2, end2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$4.prototype._isBuffer = true;
function swap$2(b2, n3, m2) {
  var i2 = b2[n3];
  b2[n3] = b2[m2];
  b2[m2] = i2;
}
Buffer$4.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 2) {
    swap$2(this, i2, i2 + 1);
  }
  return this;
};
Buffer$4.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 4) {
    swap$2(this, i2, i2 + 3);
    swap$2(this, i2 + 1, i2 + 2);
  }
  return this;
};
Buffer$4.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 8) {
    swap$2(this, i2, i2 + 7);
    swap$2(this, i2 + 1, i2 + 6);
    swap$2(this, i2 + 2, i2 + 5);
    swap$2(this, i2 + 3, i2 + 4);
  }
  return this;
};
Buffer$4.prototype.toString = function toString() {
  var length2 = this.length | 0;
  if (length2 === 0) return "";
  if (arguments.length === 0) return utf8Slice$2(this, 0, length2);
  return slowToString$2.apply(this, arguments);
};
Buffer$4.prototype.equals = function equals(b2) {
  if (!internalIsBuffer$2(b2)) throw new TypeError("Argument must be a Buffer");
  if (this === b2) return true;
  return Buffer$4.compare(this, b2) === 0;
};
Buffer$4.prototype.inspect = function inspect() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES$2;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2) str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer$4.prototype.compare = function compare2(target, start2, end2, thisStart, thisEnd) {
  if (!internalIsBuffer$2(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start2 === void 0) {
    start2 = 0;
  }
  if (end2 === void 0) {
    end2 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start2 >= end2) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start2 >= end2) {
    return 1;
  }
  start2 >>>= 0;
  end2 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y2 = end2 - start2;
  var len = Math.min(x, y2);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start2, end2);
  for (var i2 = 0; i2 < len; ++i2) {
    if (thisCopy[i2] !== targetCopy[i2]) {
      x = thisCopy[i2];
      y2 = targetCopy[i2];
      break;
    }
  }
  if (x < y2) return -1;
  if (y2 < x) return 1;
  return 0;
};
function bidirectionalIndexOf$2(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1;
  }
  if (typeof val === "string") {
    val = Buffer$4.from(val, encoding);
  }
  if (internalIsBuffer$2(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf$2(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer$4.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf$2(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf$2(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i3) {
    if (indexSize === 1) {
      return buf[i3];
    } else {
      return buf.readUInt16BE(i3 * indexSize);
    }
  }
  var i2;
  if (dir) {
    var foundIndex = -1;
    for (i2 = byteOffset; i2 < arrLength; i2++) {
      if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1) foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i2 = byteOffset; i2 >= 0; i2--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i2 + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i2;
    }
  }
  return -1;
}
Buffer$4.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer$4.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf$2(this, val, byteOffset, encoding, true);
};
Buffer$4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf$2(this, val, byteOffset, encoding, false);
};
function hexWrite$2(buf, string, offset2, length2) {
  offset2 = Number(offset2) || 0;
  var remaining = buf.length - offset2;
  if (!length2) {
    length2 = remaining;
  } else {
    length2 = Number(length2);
    if (length2 > remaining) {
      length2 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
  if (length2 > strLen / 2) {
    length2 = strLen / 2;
  }
  for (var i2 = 0; i2 < length2; ++i2) {
    var parsed = parseInt(string.substr(i2 * 2, 2), 16);
    if (isNaN(parsed)) return i2;
    buf[offset2 + i2] = parsed;
  }
  return i2;
}
function utf8Write$2(buf, string, offset2, length2) {
  return blitBuffer$2(utf8ToBytes$2(string, buf.length - offset2), buf, offset2, length2);
}
function asciiWrite$2(buf, string, offset2, length2) {
  return blitBuffer$2(asciiToBytes$2(string), buf, offset2, length2);
}
function latin1Write$2(buf, string, offset2, length2) {
  return asciiWrite$2(buf, string, offset2, length2);
}
function base64Write$2(buf, string, offset2, length2) {
  return blitBuffer$2(base64ToBytes$2(string), buf, offset2, length2);
}
function ucs2Write$2(buf, string, offset2, length2) {
  return blitBuffer$2(utf16leToBytes$2(string, buf.length - offset2), buf, offset2, length2);
}
Buffer$4.prototype.write = function write(string, offset2, length2, encoding) {
  if (offset2 === void 0) {
    encoding = "utf8";
    length2 = this.length;
    offset2 = 0;
  } else if (length2 === void 0 && typeof offset2 === "string") {
    encoding = offset2;
    length2 = this.length;
    offset2 = 0;
  } else if (isFinite(offset2)) {
    offset2 = offset2 | 0;
    if (isFinite(length2)) {
      length2 = length2 | 0;
      if (encoding === void 0) encoding = "utf8";
    } else {
      encoding = length2;
      length2 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset2;
  if (length2 === void 0 || length2 > remaining) length2 = remaining;
  if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding) encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite$2(this, string, offset2, length2);
      case "utf8":
      case "utf-8":
        return utf8Write$2(this, string, offset2, length2);
      case "ascii":
        return asciiWrite$2(this, string, offset2, length2);
      case "latin1":
      case "binary":
        return latin1Write$2(this, string, offset2, length2);
      case "base64":
        return base64Write$2(this, string, offset2, length2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write$2(this, string, offset2, length2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer$4.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice$2(buf, start2, end2) {
  if (start2 === 0 && end2 === buf.length) {
    return fromByteArray$2(buf);
  } else {
    return fromByteArray$2(buf.slice(start2, end2));
  }
}
function utf8Slice$2(buf, start2, end2) {
  end2 = Math.min(buf.length, end2);
  var res = [];
  var i2 = start2;
  while (i2 < end2) {
    var firstByte = buf[i2];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i2 + bytesPerSequence <= end2) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i2 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          fourthByte = buf[i2 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i2 += bytesPerSequence;
  }
  return decodeCodePointsArray$2(res);
}
var MAX_ARGUMENTS_LENGTH$2 = 4096;
function decodeCodePointsArray$2(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH$2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH$2)
    );
  }
  return res;
}
function asciiSlice$2(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i2 = start2; i2 < end2; ++i2) {
    ret += String.fromCharCode(buf[i2] & 127);
  }
  return ret;
}
function latin1Slice$2(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i2 = start2; i2 < end2; ++i2) {
    ret += String.fromCharCode(buf[i2]);
  }
  return ret;
}
function hexSlice$2(buf, start2, end2) {
  var len = buf.length;
  if (!start2 || start2 < 0) start2 = 0;
  if (!end2 || end2 < 0 || end2 > len) end2 = len;
  var out = "";
  for (var i2 = start2; i2 < end2; ++i2) {
    out += toHex$3(buf[i2]);
  }
  return out;
}
function utf16leSlice$2(buf, start2, end2) {
  var bytes = buf.slice(start2, end2);
  var res = "";
  for (var i2 = 0; i2 < bytes.length; i2 += 2) {
    res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
  }
  return res;
}
Buffer$4.prototype.slice = function slice(start2, end2) {
  var len = this.length;
  start2 = ~~start2;
  end2 = end2 === void 0 ? len : ~~end2;
  if (start2 < 0) {
    start2 += len;
    if (start2 < 0) start2 = 0;
  } else if (start2 > len) {
    start2 = len;
  }
  if (end2 < 0) {
    end2 += len;
    if (end2 < 0) end2 = 0;
  } else if (end2 > len) {
    end2 = len;
  }
  if (end2 < start2) end2 = start2;
  var newBuf;
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start2, end2);
    newBuf.__proto__ = Buffer$4.prototype;
  } else {
    var sliceLen = end2 - start2;
    newBuf = new Buffer$4(sliceLen, void 0);
    for (var i2 = 0; i2 < sliceLen; ++i2) {
      newBuf[i2] = this[i2 + start2];
    }
  }
  return newBuf;
};
function checkOffset$2(offset2, ext, length2) {
  if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
  if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
}
Buffer$4.prototype.readUIntLE = function readUIntLE(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) checkOffset$2(offset2, byteLength2, this.length);
  var val = this[offset2];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength2 && (mul *= 256)) {
    val += this[offset2 + i2] * mul;
  }
  return val;
};
Buffer$4.prototype.readUIntBE = function readUIntBE(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    checkOffset$2(offset2, byteLength2, this.length);
  }
  var val = this[offset2 + --byteLength2];
  var mul = 1;
  while (byteLength2 > 0 && (mul *= 256)) {
    val += this[offset2 + --byteLength2] * mul;
  }
  return val;
};
Buffer$4.prototype.readUInt8 = function readUInt82(offset2, noAssert) {
  if (!noAssert) checkOffset$2(offset2, 1, this.length);
  return this[offset2];
};
Buffer$4.prototype.readUInt16LE = function readUInt16LE2(offset2, noAssert) {
  if (!noAssert) checkOffset$2(offset2, 2, this.length);
  return this[offset2] | this[offset2 + 1] << 8;
};
Buffer$4.prototype.readUInt16BE = function readUInt16BE2(offset2, noAssert) {
  if (!noAssert) checkOffset$2(offset2, 2, this.length);
  return this[offset2] << 8 | this[offset2 + 1];
};
Buffer$4.prototype.readUInt32LE = function readUInt32LE2(offset2, noAssert) {
  if (!noAssert) checkOffset$2(offset2, 4, this.length);
  return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
};
Buffer$4.prototype.readUInt32BE = function readUInt32BE2(offset2, noAssert) {
  if (!noAssert) checkOffset$2(offset2, 4, this.length);
  return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
};
Buffer$4.prototype.readIntLE = function readIntLE(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) checkOffset$2(offset2, byteLength2, this.length);
  var val = this[offset2];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength2 && (mul *= 256)) {
    val += this[offset2 + i2] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer$4.prototype.readIntBE = function readIntBE(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) checkOffset$2(offset2, byteLength2, this.length);
  var i2 = byteLength2;
  var mul = 1;
  var val = this[offset2 + --i2];
  while (i2 > 0 && (mul *= 256)) {
    val += this[offset2 + --i2] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer$4.prototype.readInt8 = function readInt8(offset2, noAssert) {
  if (!noAssert) checkOffset$2(offset2, 1, this.length);
  if (!(this[offset2] & 128)) return this[offset2];
  return (255 - this[offset2] + 1) * -1;
};
Buffer$4.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
  if (!noAssert) checkOffset$2(offset2, 2, this.length);
  var val = this[offset2] | this[offset2 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$4.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
  if (!noAssert) checkOffset$2(offset2, 2, this.length);
  var val = this[offset2 + 1] | this[offset2] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$4.prototype.readInt32LE = function readInt32LE2(offset2, noAssert) {
  if (!noAssert) checkOffset$2(offset2, 4, this.length);
  return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
};
Buffer$4.prototype.readInt32BE = function readInt32BE2(offset2, noAssert) {
  if (!noAssert) checkOffset$2(offset2, 4, this.length);
  return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
};
Buffer$4.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
  if (!noAssert) checkOffset$2(offset2, 4, this.length);
  return read$2(this, offset2, true, 23, 4);
};
Buffer$4.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
  if (!noAssert) checkOffset$2(offset2, 4, this.length);
  return read$2(this, offset2, false, 23, 4);
};
Buffer$4.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
  if (!noAssert) checkOffset$2(offset2, 8, this.length);
  return read$2(this, offset2, true, 52, 8);
};
Buffer$4.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
  if (!noAssert) checkOffset$2(offset2, 8, this.length);
  return read$2(this, offset2, false, 52, 8);
};
function checkInt$2(buf, value2, offset2, ext, max2, min2) {
  if (!internalIsBuffer$2(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max2 || value2 < min2) throw new RangeError('"value" argument is out of bounds');
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer$4.prototype.writeUIntLE = function writeUIntLE(value2, offset2, byteLength2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt$2(this, value2, offset2, byteLength2, maxBytes, 0);
  }
  var mul = 1;
  var i2 = 0;
  this[offset2] = value2 & 255;
  while (++i2 < byteLength2 && (mul *= 256)) {
    this[offset2 + i2] = value2 / mul & 255;
  }
  return offset2 + byteLength2;
};
Buffer$4.prototype.writeUIntBE = function writeUIntBE(value2, offset2, byteLength2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt$2(this, value2, offset2, byteLength2, maxBytes, 0);
  }
  var i2 = byteLength2 - 1;
  var mul = 1;
  this[offset2 + i2] = value2 & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    this[offset2 + i2] = value2 / mul & 255;
  }
  return offset2 + byteLength2;
};
Buffer$4.prototype.writeUInt8 = function writeUInt8(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$2(this, value2, offset2, 1, 255, 0);
  if (!Buffer$4.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
function objectWriteUInt16$2(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 65535 + value2 + 1;
  for (var i2 = 0, j = Math.min(buf.length - offset2, 2); i2 < j; ++i2) {
    buf[offset2 + i2] = (value2 & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
  }
}
Buffer$4.prototype.writeUInt16LE = function writeUInt16LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$2(this, value2, offset2, 2, 65535, 0);
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16$2(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer$4.prototype.writeUInt16BE = function writeUInt16BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$2(this, value2, offset2, 2, 65535, 0);
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt16$2(this, value2, offset2, false);
  }
  return offset2 + 2;
};
function objectWriteUInt32$2(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  for (var i2 = 0, j = Math.min(buf.length - offset2, 4); i2 < j; ++i2) {
    buf[offset2 + i2] = value2 >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
  }
}
Buffer$4.prototype.writeUInt32LE = function writeUInt32LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$2(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset2 + 3] = value2 >>> 24;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2] = value2 & 255;
  } else {
    objectWriteUInt32$2(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer$4.prototype.writeUInt32BE = function writeUInt32BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$2(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt32$2(this, value2, offset2, false);
  }
  return offset2 + 4;
};
Buffer$4.prototype.writeIntLE = function writeIntLE(value2, offset2, byteLength2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt$2(this, value2, offset2, byteLength2, limit - 1, -limit);
  }
  var i2 = 0;
  var mul = 1;
  var sub = 0;
  this[offset2] = value2 & 255;
  while (++i2 < byteLength2 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i2 - 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i2] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength2;
};
Buffer$4.prototype.writeIntBE = function writeIntBE(value2, offset2, byteLength2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt$2(this, value2, offset2, byteLength2, limit - 1, -limit);
  }
  var i2 = byteLength2 - 1;
  var mul = 1;
  var sub = 0;
  this[offset2 + i2] = value2 & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i2 + 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i2] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength2;
};
Buffer$4.prototype.writeInt8 = function writeInt8(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$2(this, value2, offset2, 1, 127, -128);
  if (!Buffer$4.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  if (value2 < 0) value2 = 255 + value2 + 1;
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
Buffer$4.prototype.writeInt16LE = function writeInt16LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$2(this, value2, offset2, 2, 32767, -32768);
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16$2(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer$4.prototype.writeInt16BE = function writeInt16BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$2(this, value2, offset2, 2, 32767, -32768);
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt16$2(this, value2, offset2, false);
  }
  return offset2 + 2;
};
Buffer$4.prototype.writeInt32LE = function writeInt32LE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$2(this, value2, offset2, 4, 2147483647, -2147483648);
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt32$2(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer$4.prototype.writeInt32BE = function writeInt32BE(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$2(this, value2, offset2, 4, 2147483647, -2147483648);
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt32$2(this, value2, offset2, false);
  }
  return offset2 + 4;
};
function checkIEEE754$2(buf, value2, offset2, ext, max2, min2) {
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  if (offset2 < 0) throw new RangeError("Index out of range");
}
function writeFloat$2(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754$2(buf, value2, offset2, 4);
  }
  write$2(buf, value2, offset2, littleEndian, 23, 4);
  return offset2 + 4;
}
Buffer$4.prototype.writeFloatLE = function writeFloatLE(value2, offset2, noAssert) {
  return writeFloat$2(this, value2, offset2, true, noAssert);
};
Buffer$4.prototype.writeFloatBE = function writeFloatBE(value2, offset2, noAssert) {
  return writeFloat$2(this, value2, offset2, false, noAssert);
};
function writeDouble$2(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754$2(buf, value2, offset2, 8);
  }
  write$2(buf, value2, offset2, littleEndian, 52, 8);
  return offset2 + 8;
}
Buffer$4.prototype.writeDoubleLE = function writeDoubleLE(value2, offset2, noAssert) {
  return writeDouble$2(this, value2, offset2, true, noAssert);
};
Buffer$4.prototype.writeDoubleBE = function writeDoubleBE(value2, offset2, noAssert) {
  return writeDouble$2(this, value2, offset2, false, noAssert);
};
Buffer$4.prototype.copy = function copy(target, targetStart, start2, end2) {
  if (!start2) start2 = 0;
  if (!end2 && end2 !== 0) end2 = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end2 > 0 && end2 < start2) end2 = start2;
  if (end2 === start2) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start2 < 0 || start2 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
  if (end2 > this.length) end2 = this.length;
  if (target.length - targetStart < end2 - start2) {
    end2 = target.length - targetStart + start2;
  }
  var len = end2 - start2;
  var i2;
  if (this === target && start2 < targetStart && targetStart < end2) {
    for (i2 = len - 1; i2 >= 0; --i2) {
      target[i2 + targetStart] = this[i2 + start2];
    }
  } else if (len < 1e3 || !Buffer$4.TYPED_ARRAY_SUPPORT) {
    for (i2 = 0; i2 < len; ++i2) {
      target[i2 + targetStart] = this[i2 + start2];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start2, start2 + len),
      targetStart
    );
  }
  return len;
};
Buffer$4.prototype.fill = function fill(val, start2, end2, encoding) {
  if (typeof val === "string") {
    if (typeof start2 === "string") {
      encoding = start2;
      start2 = 0;
      end2 = this.length;
    } else if (typeof end2 === "string") {
      encoding = end2;
      end2 = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer$4.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start2 < 0 || this.length < start2 || this.length < end2) {
    throw new RangeError("Out of range index");
  }
  if (end2 <= start2) {
    return this;
  }
  start2 = start2 >>> 0;
  end2 = end2 === void 0 ? this.length : end2 >>> 0;
  if (!val) val = 0;
  var i2;
  if (typeof val === "number") {
    for (i2 = start2; i2 < end2; ++i2) {
      this[i2] = val;
    }
  } else {
    var bytes = internalIsBuffer$2(val) ? val : utf8ToBytes$2(new Buffer$4(val, encoding).toString());
    var len = bytes.length;
    for (i2 = 0; i2 < end2 - start2; ++i2) {
      this[i2 + start2] = bytes[i2 % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE$2 = /[^+\/0-9A-Za-z-_]/g;
function base64clean$2(str) {
  str = stringtrim$2(str).replace(INVALID_BASE64_RE$2, "");
  if (str.length < 2) return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim$2(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex$3(n3) {
  if (n3 < 16) return "0" + n3.toString(16);
  return n3.toString(16);
}
function utf8ToBytes$2(string, units) {
  units = units || Infinity;
  var codePoint;
  var length2 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i2 = 0; i2 < length2; ++i2) {
    codePoint = string.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length2) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes$2(str) {
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    byteArray.push(str.charCodeAt(i2) & 255);
  }
  return byteArray;
}
function utf16leToBytes$2(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    if ((units -= 2) < 0) break;
    c2 = str.charCodeAt(i2);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes$2(str) {
  return toByteArray$2(base64clean$2(str));
}
function blitBuffer$2(src2, dst, offset2, length2) {
  for (var i2 = 0; i2 < length2; ++i2) {
    if (i2 + offset2 >= dst.length || i2 >= src2.length) break;
    dst[i2 + offset2] = src2[i2];
  }
  return i2;
}
function isnan$2(val) {
  return val !== val;
}
function isBuffer$1$2(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer$2(obj) || isSlowBuffer$2(obj));
}
function isFastBuffer$2(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer$2(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer$2(obj.slice(0, 0));
}
var _polyfillNode_buffer$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Buffer: Buffer$4,
  INSPECT_MAX_BYTES: INSPECT_MAX_BYTES$2,
  SlowBuffer: SlowBuffer$1,
  isBuffer: isBuffer$1$2,
  kMaxLength: _kMaxLength$1
});
function defaultSetTimout$1() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout$1() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout$1 = defaultSetTimout$1;
var cachedClearTimeout$1 = defaultClearTimeout$1;
if (typeof global$1$2.setTimeout === "function") {
  cachedSetTimeout$1 = setTimeout;
}
if (typeof global$1$2.clearTimeout === "function") {
  cachedClearTimeout$1 = clearTimeout;
}
function runTimeout$1(fun) {
  if (cachedSetTimeout$1 === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout$1 === defaultSetTimout$1 || !cachedSetTimeout$1) && setTimeout) {
    cachedSetTimeout$1 = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout$1(fun, 0);
  } catch (e2) {
    try {
      return cachedSetTimeout$1.call(null, fun, 0);
    } catch (e3) {
      return cachedSetTimeout$1.call(this, fun, 0);
    }
  }
}
function runClearTimeout$1(marker) {
  if (cachedClearTimeout$1 === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout$1 === defaultClearTimeout$1 || !cachedClearTimeout$1) && clearTimeout) {
    cachedClearTimeout$1 = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout$1(marker);
  } catch (e2) {
    try {
      return cachedClearTimeout$1.call(null, marker);
    } catch (e3) {
      return cachedClearTimeout$1.call(this, marker);
    }
  }
}
var queue$1 = [];
var draining$1 = false;
var currentQueue$1;
var queueIndex$1 = -1;
function cleanUpNextTick$1() {
  if (!draining$1 || !currentQueue$1) {
    return;
  }
  draining$1 = false;
  if (currentQueue$1.length) {
    queue$1 = currentQueue$1.concat(queue$1);
  } else {
    queueIndex$1 = -1;
  }
  if (queue$1.length) {
    drainQueue$1();
  }
}
function drainQueue$1() {
  if (draining$1) {
    return;
  }
  var timeout = runTimeout$1(cleanUpNextTick$1);
  draining$1 = true;
  var len = queue$1.length;
  while (len) {
    currentQueue$1 = queue$1;
    queue$1 = [];
    while (++queueIndex$1 < len) {
      if (currentQueue$1) {
        currentQueue$1[queueIndex$1].run();
      }
    }
    queueIndex$1 = -1;
    len = queue$1.length;
  }
  currentQueue$1 = null;
  draining$1 = false;
  runClearTimeout$1(timeout);
}
function nextTick$1(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue$1.push(new Item$1(fun, args));
  if (queue$1.length === 1 && !draining$1) {
    runTimeout$1(drainQueue$1);
  }
}
function Item$1(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item$1.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title$1 = "browser";
var platform$1 = "browser";
var browser$2 = true;
var env$1 = {};
var argv$1 = [];
var version$1 = "";
var versions$1 = {};
var release$1 = {};
var config$2 = {};
function noop$4() {
}
var on$1 = noop$4;
var addListener$1 = noop$4;
var once$3 = noop$4;
var off$1 = noop$4;
var removeListener$1 = noop$4;
var removeAllListeners$1 = noop$4;
var emit$1 = noop$4;
function binding$1$1(name) {
  throw new Error("process.binding is not supported");
}
function cwd$1() {
  return "/";
}
function chdir$1(dir) {
  throw new Error("process.chdir is not supported");
}
function umask$1() {
  return 0;
}
var performance$2 = global$1$2.performance || {};
var performanceNow$1 = performance$2.now || performance$2.mozNow || performance$2.msNow || performance$2.oNow || performance$2.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime$1(previousTimestamp) {
  var clocktime = performanceNow$1.call(performance$2) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime$1 = /* @__PURE__ */ new Date();
function uptime$1() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime$1;
  return dif / 1e3;
}
var browser$1$2 = {
  nextTick: nextTick$1,
  title: title$1,
  browser: browser$2,
  env: env$1,
  argv: argv$1,
  version: version$1,
  versions: versions$1,
  on: on$1,
  addListener: addListener$1,
  once: once$3,
  off: off$1,
  removeListener: removeListener$1,
  removeAllListeners: removeAllListeners$1,
  emit: emit$1,
  binding: binding$1$1,
  cwd: cwd$1,
  chdir: chdir$1,
  umask: umask$1,
  hrtime: hrtime$1,
  platform: platform$1,
  release: release$1,
  config: config$2,
  uptime: uptime$1
};
function getDefaultExportFromCjs$1(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace$1(n3) {
  if (n3.__esModule) return n3;
  var f2 = n3.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n3).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n3, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n3[k2];
      }
    });
  });
  return a2;
}
var lib$1 = {};
var require$$0$1 = /* @__PURE__ */ getAugmentedNamespace$1(_polyfillNode_buffer$1);
var domain$1;
function EventHandlers$1() {
}
EventHandlers$1.prototype = /* @__PURE__ */ Object.create(null);
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
EventEmitter$1.EventEmitter = EventEmitter$1;
EventEmitter$1.usingDomains = false;
EventEmitter$1.prototype.domain = void 0;
EventEmitter$1.prototype._events = void 0;
EventEmitter$1.prototype._maxListeners = void 0;
EventEmitter$1.defaultMaxListeners = 10;
EventEmitter$1.init = function() {
  this.domain = null;
  if (EventEmitter$1.usingDomains) {
    if (domain$1.active) ;
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers$1();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n3) {
  if (typeof n3 !== "number" || n3 < 0 || isNaN(n3))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n3;
  return this;
};
function $getMaxListeners$1(that) {
  if (that._maxListeners === void 0)
    return EventEmitter$1.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners$1(this);
};
function emitNone$1(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone$1(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners3[i2].call(self2);
  }
}
function emitOne$1(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners3 = arrayClone$1(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners3[i2].call(self2, arg1);
  }
}
function emitTwo$1(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone$1(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners3[i2].call(self2, arg1, arg2);
  }
}
function emitThree$1(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners3 = arrayClone$1(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners3[i2].call(self2, arg1, arg2, arg3);
  }
}
function emitMany$1(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners3 = arrayClone$1(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners3[i2].apply(self2, args);
  }
}
EventEmitter$1.prototype.emit = function emit(type) {
  var er, handler, len, args, i2, events2, domain2;
  var doError = type === "error";
  events2 = this._events;
  if (events2)
    doError = doError && events2.error == null;
  else if (!doError)
    return false;
  domain2 = this.domain;
  if (doError) {
    er = arguments[1];
    if (domain2) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain2;
      er.domainThrown = false;
      domain2.emit("error", er);
    } else if (er instanceof Error) {
      throw er;
    } else {
      var err2 = new Error('Uncaught, unspecified "error" event. (' + er + ")");
      err2.context = er;
      throw err2;
    }
    return false;
  }
  handler = events2[type];
  if (!handler)
    return false;
  var isFn = typeof handler === "function";
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone$1(handler, isFn, this);
      break;
    case 2:
      emitOne$1(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo$1(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree$1(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i2 = 1; i2 < len; i2++)
        args[i2 - 1] = arguments[i2];
      emitMany$1(handler, isFn, this, args);
  }
  return true;
};
function _addListener$1(target, type, listener, prepend) {
  var m2;
  var events2;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = target._events;
  if (!events2) {
    events2 = target._events = new EventHandlers$1();
    target._eventsCount = 0;
  } else {
    if (events2.newListener) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (!existing) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m2 = $getMaxListeners$1(target);
      if (m2 && m2 > 0 && existing.length > m2) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning$1(w);
      }
    }
  }
  return target;
}
function emitWarning$1(e2) {
  typeof console.warn === "function" ? console.warn(e2) : console.log(e2);
}
EventEmitter$1.prototype.addListener = function addListener(type, listener) {
  return _addListener$1(this, type, listener, false);
};
EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
EventEmitter$1.prototype.prependListener = function prependListener(type, listener) {
  return _addListener$1(this, type, listener, true);
};
function _onceWrap$1(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
EventEmitter$1.prototype.once = function once(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap$1(this, type, listener));
  return this;
};
EventEmitter$1.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.prependListener(type, _onceWrap$1(this, type, listener));
  return this;
};
EventEmitter$1.prototype.removeListener = function removeListener(type, listener) {
  var list, events2, position, i2, originalListener;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = this._events;
  if (!events2)
    return this;
  list = events2[type];
  if (!list)
    return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers$1();
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length; i2-- > 0; ) {
      if (list[i2] === listener || list[i2].listener && list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (list.length === 1) {
      list[0] = void 0;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers$1();
        return this;
      } else {
        delete events2[type];
      }
    } else {
      spliceOne$1(list, position);
    }
    if (events2.removeListener)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter$1.prototype.off = function(type, listener) {
  return this.removeListener(type, listener);
};
EventEmitter$1.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners3, events2;
  events2 = this._events;
  if (!events2)
    return this;
  if (!events2.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers$1();
      this._eventsCount = 0;
    } else if (events2[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers$1();
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys = Object.keys(events2);
    for (var i2 = 0, key; i2 < keys.length; ++i2) {
      key = keys[i2];
      if (key === "removeListener") continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = new EventHandlers$1();
    this._eventsCount = 0;
    return this;
  }
  listeners3 = events2[type];
  if (typeof listeners3 === "function") {
    this.removeListener(type, listeners3);
  } else if (listeners3) {
    do {
      this.removeListener(type, listeners3[listeners3.length - 1]);
    } while (listeners3[0]);
  }
  return this;
};
EventEmitter$1.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events2 = this._events;
  if (!events2)
    ret = [];
  else {
    evlistener = events2[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === "function")
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners$1(evlistener);
  }
  return ret;
};
EventEmitter$1.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount$1.call(emitter, type);
  }
};
EventEmitter$1.prototype.listenerCount = listenerCount$1;
function listenerCount$1(type) {
  var events2 = this._events;
  if (events2) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter$1.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function spliceOne$1(list, index2) {
  for (var i2 = index2, k2 = i2 + 1, n3 = list.length; k2 < n3; i2 += 1, k2 += 1)
    list[i2] = list[k2];
  list.pop();
}
function arrayClone$1(arr, i2) {
  var copy5 = new Array(i2);
  while (i2--)
    copy5[i2] = arr[i2];
  return copy5;
}
function unwrapListeners$1(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}
var inherits$3;
if (typeof Object.create === "function") {
  inherits$3 = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits$3 = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$1$1 = inherits$3;
var getOwnPropertyDescriptors$1 = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};
  for (var i2 = 0; i2 < keys.length; i2++) {
    descriptors[keys[i2]] = Object.getOwnPropertyDescriptor(obj, keys[i2]);
  }
  return descriptors;
};
var formatRegExp$1 = /%[sdj%]/g;
function format$1(f2) {
  if (!isString$3(f2)) {
    var objects = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      objects.push(inspect$1$1(arguments[i2]));
    }
    return objects.join(" ");
  }
  var i2 = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f2).replace(formatRegExp$1, function(x2) {
    if (x2 === "%%") return "%";
    if (i2 >= len) return x2;
    switch (x2) {
      case "%s":
        return String(args[i2++]);
      case "%d":
        return Number(args[i2++]);
      case "%j":
        try {
          return JSON.stringify(args[i2++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i2]; i2 < len; x = args[++i2]) {
    if (isNull$1(x) || !isObject$1(x)) {
      str += " " + x;
    } else {
      str += " " + inspect$1$1(x);
    }
  }
  return str;
}
function deprecate$2(fn, msg2) {
  if (isUndefined$1(global$1$2.process)) {
    return function() {
      return deprecate$2(fn, msg2).apply(this, arguments);
    };
  }
  if (browser$1$2.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1$2.throwDeprecation) {
        throw new Error(msg2);
      } else if (browser$1$2.traceDeprecation) {
        console.trace(msg2);
      } else {
        console.error(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
var debugs$1 = {};
var debugEnviron$1;
function debuglog$1(set5) {
  if (isUndefined$1(debugEnviron$1))
    debugEnviron$1 = browser$1$2.env.NODE_DEBUG || "";
  set5 = set5.toUpperCase();
  if (!debugs$1[set5]) {
    if (new RegExp("\\b" + set5 + "\\b", "i").test(debugEnviron$1)) {
      var pid = 0;
      debugs$1[set5] = function() {
        var msg2 = format$1.apply(null, arguments);
        console.error("%s %d: %s", set5, pid, msg2);
      };
    } else {
      debugs$1[set5] = function() {
      };
    }
  }
  return debugs$1[set5];
}
function inspect$1$1(obj, opts2) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor$1
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean$2(opts2)) {
    ctx.showHidden = opts2;
  } else if (opts2) {
    _extend$1(ctx, opts2);
  }
  if (isUndefined$1(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined$1(ctx.depth)) ctx.depth = 2;
  if (isUndefined$1(ctx.colors)) ctx.colors = false;
  if (isUndefined$1(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor$1;
  return formatValue$1(ctx, obj, ctx.depth);
}
inspect$1$1.colors = {
  "bold": [1, 22],
  "italic": [3, 23],
  "underline": [4, 24],
  "inverse": [7, 27],
  "white": [37, 39],
  "grey": [90, 39],
  "black": [30, 39],
  "blue": [34, 39],
  "cyan": [36, 39],
  "green": [32, 39],
  "magenta": [35, 39],
  "red": [31, 39],
  "yellow": [33, 39]
};
inspect$1$1.styles = {
  "special": "cyan",
  "number": "yellow",
  "boolean": "yellow",
  "undefined": "grey",
  "null": "bold",
  "string": "green",
  "date": "magenta",
  // "name": intentionally not styling
  "regexp": "red"
};
function stylizeWithColor$1(str, styleType) {
  var style = inspect$1$1.styles[styleType];
  if (style) {
    return "\x1B[" + inspect$1$1.colors[style][0] + "m" + str + "\x1B[" + inspect$1$1.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor$1(str, styleType) {
  return str;
}
function arrayToHash$1(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue$1(ctx, value2, recurseTimes) {
  if (ctx.customInspect && value2 && isFunction$1(value2.inspect) && // Filter out the util module, it's inspect function is special
  value2.inspect !== inspect$1$1 && // Also filter out any prototype objects using the circular check.
  !(value2.constructor && value2.constructor.prototype === value2)) {
    var ret = value2.inspect(recurseTimes, ctx);
    if (!isString$3(ret)) {
      ret = formatValue$1(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive$1(ctx, value2);
  if (primitive) {
    return primitive;
  }
  var keys = Object.keys(value2);
  var visibleKeys = arrayToHash$1(keys);
  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value2);
  }
  if (isError$1(value2) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
    return formatError$1(value2);
  }
  if (keys.length === 0) {
    if (isFunction$1(value2)) {
      var name = value2.name ? ": " + value2.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp$1(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    }
    if (isDate$1(value2)) {
      return ctx.stylize(Date.prototype.toString.call(value2), "date");
    }
    if (isError$1(value2)) {
      return formatError$1(value2);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray$3(value2)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction$1(value2)) {
    var n3 = value2.name ? ": " + value2.name : "";
    base = " [Function" + n3 + "]";
  }
  if (isRegExp$1(value2)) {
    base = " " + RegExp.prototype.toString.call(value2);
  }
  if (isDate$1(value2)) {
    base = " " + Date.prototype.toUTCString.call(value2);
  }
  if (isError$1(value2)) {
    base = " " + formatError$1(value2);
  }
  if (keys.length === 0 && (!array || value2.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp$1(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value2);
  var output;
  if (array) {
    output = formatArray$1(ctx, value2, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty$1(ctx, value2, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString$1(output, base, braces);
}
function formatPrimitive$1(ctx, value2) {
  if (isUndefined$1(value2))
    return ctx.stylize("undefined", "undefined");
  if (isString$3(value2)) {
    var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber$3(value2))
    return ctx.stylize("" + value2, "number");
  if (isBoolean$2(value2))
    return ctx.stylize("" + value2, "boolean");
  if (isNull$1(value2))
    return ctx.stylize("null", "null");
}
function formatError$1(value2) {
  return "[" + Error.prototype.toString.call(value2) + "]";
}
function formatArray$1(ctx, value2, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i2 = 0, l2 = value2.length; i2 < l2; ++i2) {
    if (hasOwnProperty$1(value2, String(i2))) {
      output.push(formatProperty$1(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        String(i2),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty$1(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty$1(ctx, value2, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value2, key) || { value: value2[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty$1(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull$1(recurseTimes)) {
        str = formatValue$1(ctx, desc.value, null);
      } else {
        str = formatValue$1(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line2) {
            return "  " + line2;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line2) {
            return "   " + line2;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined$1(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString$1(output, base, braces) {
  var length2 = output.reduce(function(prev, cur) {
    if (cur.indexOf("\n") >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length2 > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray$3(ar) {
  return Array.isArray(ar);
}
function isBoolean$2(arg) {
  return typeof arg === "boolean";
}
function isNull$1(arg) {
  return arg === null;
}
function isNullOrUndefined$1(arg) {
  return arg == null;
}
function isNumber$3(arg) {
  return typeof arg === "number";
}
function isString$3(arg) {
  return typeof arg === "string";
}
function isSymbol$1(arg) {
  return typeof arg === "symbol";
}
function isUndefined$1(arg) {
  return arg === void 0;
}
function isRegExp$1(re) {
  return isObject$1(re) && objectToString$1(re) === "[object RegExp]";
}
function isObject$1(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate$1(d2) {
  return isObject$1(d2) && objectToString$1(d2) === "[object Date]";
}
function isError$1(e2) {
  return isObject$1(e2) && (objectToString$1(e2) === "[object Error]" || e2 instanceof Error);
}
function isFunction$1(arg) {
  return typeof arg === "function";
}
function isPrimitive$1(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
  typeof arg === "undefined";
}
function isBuffer$3(maybeBuf) {
  return Buffer$4.isBuffer(maybeBuf);
}
function objectToString$1(o2) {
  return Object.prototype.toString.call(o2);
}
function pad$2(n3) {
  return n3 < 10 ? "0" + n3.toString(10) : n3.toString(10);
}
var months$1 = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp$1() {
  var d2 = /* @__PURE__ */ new Date();
  var time = [
    pad$2(d2.getHours()),
    pad$2(d2.getMinutes()),
    pad$2(d2.getSeconds())
  ].join(":");
  return [d2.getDate(), months$1[d2.getMonth()], time].join(" ");
}
function log$1() {
  console.log("%s - %s", timestamp$1(), format$1.apply(null, arguments));
}
function _extend$1(origin, add2) {
  if (!add2 || !isObject$1(add2)) return origin;
  var keys = Object.keys(add2);
  var i2 = keys.length;
  while (i2--) {
    origin[keys[i2]] = add2[keys[i2]];
  }
  return origin;
}
function hasOwnProperty$1(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol$1 = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
function promisify$1(original) {
  if (typeof original !== "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol$1 && original[kCustomPromisifiedSymbol$1]) {
    var fn = original[kCustomPromisifiedSymbol$1];
    if (typeof fn !== "function") {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol$1, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }
  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function(resolve2, reject) {
      promiseResolve = resolve2;
      promiseReject = reject;
    });
    var args = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      args.push(arguments[i2]);
    }
    args.push(function(err2, value2) {
      if (err2) {
        promiseReject(err2);
      } else {
        promiseResolve(value2);
      }
    });
    try {
      original.apply(this, args);
    } catch (err2) {
      promiseReject(err2);
    }
    return promise;
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol$1) Object.defineProperty(fn, kCustomPromisifiedSymbol$1, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors$1(original)
  );
}
promisify$1.custom = kCustomPromisifiedSymbol$1;
function callbackifyOnRejected$1(reason, cb) {
  if (!reason) {
    var newReason = new Error("Promise was rejected with a falsy value");
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}
function callbackify$1(original) {
  if (typeof original !== "function") {
    throw new TypeError('The "original" argument must be of type Function');
  }
  function callbackified() {
    var args = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      args.push(arguments[i2]);
    }
    var maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new TypeError("The last argument must be of type Function");
    }
    var self2 = this;
    var cb = function() {
      return maybeCb.apply(self2, arguments);
    };
    original.apply(this, args).then(
      function(ret) {
        browser$1$2.nextTick(cb.bind(null, null, ret));
      },
      function(rej) {
        browser$1$2.nextTick(callbackifyOnRejected$1.bind(null, rej, cb));
      }
    );
  }
  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors$1(original));
  return callbackified;
}
var _polyfillNode_util$2 = {
  inherits: inherits$1$1,
  _extend: _extend$1,
  log: log$1,
  isBuffer: isBuffer$3,
  isPrimitive: isPrimitive$1,
  isFunction: isFunction$1,
  isError: isError$1,
  isDate: isDate$1,
  isObject: isObject$1,
  isRegExp: isRegExp$1,
  isUndefined: isUndefined$1,
  isSymbol: isSymbol$1,
  isString: isString$3,
  isNumber: isNumber$3,
  isNullOrUndefined: isNullOrUndefined$1,
  isNull: isNull$1,
  isBoolean: isBoolean$2,
  isArray: isArray$3,
  inspect: inspect$1$1,
  deprecate: deprecate$2,
  format: format$1,
  debuglog: debuglog$1,
  promisify: promisify$1,
  callbackify: callbackify$1
};
var _polyfillNode_util$1$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  _extend: _extend$1,
  callbackify: callbackify$1,
  debuglog: debuglog$1,
  default: _polyfillNode_util$2,
  deprecate: deprecate$2,
  format: format$1,
  inherits: inherits$1$1,
  inspect: inspect$1$1,
  isArray: isArray$3,
  isBoolean: isBoolean$2,
  isBuffer: isBuffer$3,
  isDate: isDate$1,
  isError: isError$1,
  isFunction: isFunction$1,
  isNull: isNull$1,
  isNullOrUndefined: isNullOrUndefined$1,
  isNumber: isNumber$3,
  isObject: isObject$1,
  isPrimitive: isPrimitive$1,
  isRegExp: isRegExp$1,
  isString: isString$3,
  isSymbol: isSymbol$1,
  isUndefined: isUndefined$1,
  log: log$1,
  promisify: promisify$1
});
function BufferList$1() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
BufferList$1.prototype.push = function(v2) {
  var entry = { data: v2, next: null };
  if (this.length > 0) this.tail.next = entry;
  else this.head = entry;
  this.tail = entry;
  ++this.length;
};
BufferList$1.prototype.unshift = function(v2) {
  var entry = { data: v2, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};
BufferList$1.prototype.shift = function() {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;
  else this.head = this.head.next;
  --this.length;
  return ret;
};
BufferList$1.prototype.clear = function() {
  this.head = this.tail = null;
  this.length = 0;
};
BufferList$1.prototype.join = function(s2) {
  if (this.length === 0) return "";
  var p2 = this.head;
  var ret = "" + p2.data;
  while (p2 = p2.next) {
    ret += s2 + p2.data;
  }
  return ret;
};
BufferList$1.prototype.concat = function(n3) {
  if (this.length === 0) return Buffer$4.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = Buffer$4.allocUnsafe(n3 >>> 0);
  var p2 = this.head;
  var i2 = 0;
  while (p2) {
    p2.data.copy(ret, i2);
    i2 += p2.data.length;
    p2 = p2.next;
  }
  return ret;
};
var isBufferEncoding$1 = Buffer$4.isEncoding || function(encoding) {
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function assertEncoding$1(encoding) {
  if (encoding && !isBufferEncoding$1(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder$2(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding$1(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar$1;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar$1;
      break;
    default:
      this.write = passThroughWrite$1;
      return;
  }
  this.charBuffer = new Buffer$4(6);
  this.charReceived = 0;
  this.charLength = 0;
}
StringDecoder$2.prototype.write = function(buffer) {
  var charStr = "";
  while (this.charLength) {
    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;
    if (this.charReceived < this.charLength) {
      return "";
    }
    buffer = buffer.slice(available, buffer.length);
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 55296 && charCode <= 56319) {
      this.charLength += this.surrogateSize;
      charStr = "";
      continue;
    }
    this.charReceived = this.charLength = 0;
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }
  this.detectIncompleteChar(buffer);
  var end2 = buffer.length;
  if (this.charLength) {
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end2);
    end2 -= this.charReceived;
  }
  charStr += buffer.toString(this.encoding, 0, end2);
  var end2 = charStr.length - 1;
  var charCode = charStr.charCodeAt(end2);
  if (charCode >= 55296 && charCode <= 56319) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end2);
  }
  return charStr;
};
StringDecoder$2.prototype.detectIncompleteChar = function(buffer) {
  var i2 = buffer.length >= 3 ? 3 : buffer.length;
  for (; i2 > 0; i2--) {
    var c2 = buffer[buffer.length - i2];
    if (i2 == 1 && c2 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (i2 <= 2 && c2 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (i2 <= 3 && c2 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i2;
};
StringDecoder$2.prototype.end = function(buffer) {
  var res = "";
  if (buffer && buffer.length)
    res = this.write(buffer);
  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }
  return res;
};
function passThroughWrite$1(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar$1(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar$1(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
Readable$1.ReadableState = ReadableState$1;
var debug$1 = debuglog$1("stream");
inherits$1$1(Readable$1, EventEmitter$1);
function prependListener$1(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount$2(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState$1(options, stream2) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream2 instanceof Duplex$1) this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new BufferList$1();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder$2(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable$1(options) {
  if (!(this instanceof Readable$1)) return new Readable$1(options);
  this._readableState = new ReadableState$1(options, this);
  this.readable = true;
  if (options && typeof options.read === "function") this._read = options.read;
  EventEmitter$1.call(this);
}
Readable$1.prototype.push = function(chunk, encoding) {
  var state2 = this._readableState;
  if (!state2.objectMode && typeof chunk === "string") {
    encoding = encoding || state2.defaultEncoding;
    if (encoding !== state2.encoding) {
      chunk = Buffer$4.from(chunk, encoding);
      encoding = "";
    }
  }
  return readableAddChunk$1(this, state2, chunk, encoding, false);
};
Readable$1.prototype.unshift = function(chunk) {
  var state2 = this._readableState;
  return readableAddChunk$1(this, state2, chunk, "", true);
};
Readable$1.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
function readableAddChunk$1(stream2, state2, chunk, encoding, addToFront) {
  var er = chunkInvalid$1(state2, chunk);
  if (er) {
    stream2.emit("error", er);
  } else if (chunk === null) {
    state2.reading = false;
    onEofChunk$1(stream2, state2);
  } else if (state2.objectMode || chunk && chunk.length > 0) {
    if (state2.ended && !addToFront) {
      var e2 = new Error("stream.push() after EOF");
      stream2.emit("error", e2);
    } else if (state2.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream2.emit("error", _e);
    } else {
      var skipAdd;
      if (state2.decoder && !addToFront && !encoding) {
        chunk = state2.decoder.write(chunk);
        skipAdd = !state2.objectMode && chunk.length === 0;
      }
      if (!addToFront) state2.reading = false;
      if (!skipAdd) {
        if (state2.flowing && state2.length === 0 && !state2.sync) {
          stream2.emit("data", chunk);
          stream2.read(0);
        } else {
          state2.length += state2.objectMode ? 1 : chunk.length;
          if (addToFront) state2.buffer.unshift(chunk);
          else state2.buffer.push(chunk);
          if (state2.needReadable) emitReadable$1(stream2);
        }
      }
      maybeReadMore$1(stream2, state2);
    }
  } else if (!addToFront) {
    state2.reading = false;
  }
  return needMoreData(state2);
}
function needMoreData(state2) {
  return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
}
Readable$1.prototype.setEncoding = function(enc) {
  this._readableState.decoder = new StringDecoder$2(enc);
  this._readableState.encoding = enc;
  return this;
};
var MAX_HWM$1 = 8388608;
function computeNewHighWaterMark$1(n3) {
  if (n3 >= MAX_HWM$1) {
    n3 = MAX_HWM$1;
  } else {
    n3--;
    n3 |= n3 >>> 1;
    n3 |= n3 >>> 2;
    n3 |= n3 >>> 4;
    n3 |= n3 >>> 8;
    n3 |= n3 >>> 16;
    n3++;
  }
  return n3;
}
function howMuchToRead$1(n3, state2) {
  if (n3 <= 0 || state2.length === 0 && state2.ended) return 0;
  if (state2.objectMode) return 1;
  if (n3 !== n3) {
    if (state2.flowing && state2.length) return state2.buffer.head.data.length;
    else return state2.length;
  }
  if (n3 > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark$1(n3);
  if (n3 <= state2.length) return n3;
  if (!state2.ended) {
    state2.needReadable = true;
    return 0;
  }
  return state2.length;
}
Readable$1.prototype.read = function(n3) {
  debug$1("read", n3);
  n3 = parseInt(n3, 10);
  var state2 = this._readableState;
  var nOrig = n3;
  if (n3 !== 0) state2.emittedReadable = false;
  if (n3 === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
    debug$1("read: emitReadable", state2.length, state2.ended);
    if (state2.length === 0 && state2.ended) endReadable$1(this);
    else emitReadable$1(this);
    return null;
  }
  n3 = howMuchToRead$1(n3, state2);
  if (n3 === 0 && state2.ended) {
    if (state2.length === 0) endReadable$1(this);
    return null;
  }
  var doRead = state2.needReadable;
  debug$1("need readable", doRead);
  if (state2.length === 0 || state2.length - n3 < state2.highWaterMark) {
    doRead = true;
    debug$1("length less than watermark", doRead);
  }
  if (state2.ended || state2.reading) {
    doRead = false;
    debug$1("reading or ended", doRead);
  } else if (doRead) {
    debug$1("do read");
    state2.reading = true;
    state2.sync = true;
    if (state2.length === 0) state2.needReadable = true;
    this._read(state2.highWaterMark);
    state2.sync = false;
    if (!state2.reading) n3 = howMuchToRead$1(nOrig, state2);
  }
  var ret;
  if (n3 > 0) ret = fromList$1(n3, state2);
  else ret = null;
  if (ret === null) {
    state2.needReadable = true;
    n3 = 0;
  } else {
    state2.length -= n3;
  }
  if (state2.length === 0) {
    if (!state2.ended) state2.needReadable = true;
    if (nOrig !== n3 && state2.ended) endReadable$1(this);
  }
  if (ret !== null) this.emit("data", ret);
  return ret;
};
function chunkInvalid$1(state2, chunk) {
  var er = null;
  if (!Buffer$4.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state2.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk$1(stream2, state2) {
  if (state2.ended) return;
  if (state2.decoder) {
    var chunk = state2.decoder.end();
    if (chunk && chunk.length) {
      state2.buffer.push(chunk);
      state2.length += state2.objectMode ? 1 : chunk.length;
    }
  }
  state2.ended = true;
  emitReadable$1(stream2);
}
function emitReadable$1(stream2) {
  var state2 = stream2._readableState;
  state2.needReadable = false;
  if (!state2.emittedReadable) {
    debug$1("emitReadable", state2.flowing);
    state2.emittedReadable = true;
    if (state2.sync) nextTick$1(emitReadable_$1, stream2);
    else emitReadable_$1(stream2);
  }
}
function emitReadable_$1(stream2) {
  debug$1("emit readable");
  stream2.emit("readable");
  flow$1(stream2);
}
function maybeReadMore$1(stream2, state2) {
  if (!state2.readingMore) {
    state2.readingMore = true;
    nextTick$1(maybeReadMore_$1, stream2, state2);
  }
}
function maybeReadMore_$1(stream2, state2) {
  var len = state2.length;
  while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
    debug$1("maybeReadMore read 0");
    stream2.read(0);
    if (len === state2.length)
      break;
    else len = state2.length;
  }
  state2.readingMore = false;
}
Readable$1.prototype._read = function(n3) {
  this.emit("error", new Error("not implemented"));
};
Readable$1.prototype.pipe = function(dest, pipeOpts) {
  var src2 = this;
  var state2 = this._readableState;
  switch (state2.pipesCount) {
    case 0:
      state2.pipes = dest;
      break;
    case 1:
      state2.pipes = [state2.pipes, dest];
      break;
    default:
      state2.pipes.push(dest);
      break;
  }
  state2.pipesCount += 1;
  debug$1("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
  var doEnd = !pipeOpts || pipeOpts.end !== false;
  var endFn = doEnd ? onend2 : cleanup;
  if (state2.endEmitted) nextTick$1(endFn);
  else src2.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable) {
    debug$1("onunpipe");
    if (readable === src2) {
      cleanup();
    }
  }
  function onend2() {
    debug$1("onend");
    dest.end();
  }
  var ondrain = pipeOnDrain$1(src2);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug$1("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src2.removeListener("end", onend2);
    src2.removeListener("end", cleanup);
    src2.removeListener("data", ondata);
    cleanedUp = true;
    if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  var increasedAwaitDrain = false;
  src2.on("data", ondata);
  function ondata(chunk) {
    debug$1("ondata");
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf$1(state2.pipes, dest) !== -1) && !cleanedUp) {
        debug$1("false write response, pause", src2._readableState.awaitDrain);
        src2._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src2.pause();
    }
  }
  function onerror(er) {
    debug$1("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (listenerCount$2(dest, "error") === 0) dest.emit("error", er);
  }
  prependListener$1(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug$1("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug$1("unpipe");
    src2.unpipe(dest);
  }
  dest.emit("pipe", src2);
  if (!state2.flowing) {
    debug$1("pipe resume");
    src2.resume();
  }
  return dest;
};
function pipeOnDrain$1(src2) {
  return function() {
    var state2 = src2._readableState;
    debug$1("pipeOnDrain", state2.awaitDrain);
    if (state2.awaitDrain) state2.awaitDrain--;
    if (state2.awaitDrain === 0 && src2.listeners("data").length) {
      state2.flowing = true;
      flow$1(src2);
    }
  };
}
Readable$1.prototype.unpipe = function(dest) {
  var state2 = this._readableState;
  if (state2.pipesCount === 0) return this;
  if (state2.pipesCount === 1) {
    if (dest && dest !== state2.pipes) return this;
    if (!dest) dest = state2.pipes;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    if (dest) dest.emit("unpipe", this);
    return this;
  }
  if (!dest) {
    var dests = state2.pipes;
    var len = state2.pipesCount;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit("unpipe", this);
    }
    return this;
  }
  var i2 = indexOf$1(state2.pipes, dest);
  if (i2 === -1) return this;
  state2.pipes.splice(i2, 1);
  state2.pipesCount -= 1;
  if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
  dest.emit("unpipe", this);
  return this;
};
Readable$1.prototype.on = function(ev, fn) {
  var res = EventEmitter$1.prototype.on.call(this, ev, fn);
  if (ev === "data") {
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === "readable") {
    var state2 = this._readableState;
    if (!state2.endEmitted && !state2.readableListening) {
      state2.readableListening = state2.needReadable = true;
      state2.emittedReadable = false;
      if (!state2.reading) {
        nextTick$1(nReadingNextTick$1, this);
      } else if (state2.length) {
        emitReadable$1(this);
      }
    }
  }
  return res;
};
Readable$1.prototype.addListener = Readable$1.prototype.on;
function nReadingNextTick$1(self2) {
  debug$1("readable nexttick read 0");
  self2.read(0);
}
Readable$1.prototype.resume = function() {
  var state2 = this._readableState;
  if (!state2.flowing) {
    debug$1("resume");
    state2.flowing = true;
    resume$1(this, state2);
  }
  return this;
};
function resume$1(stream2, state2) {
  if (!state2.resumeScheduled) {
    state2.resumeScheduled = true;
    nextTick$1(resume_$1, stream2, state2);
  }
}
function resume_$1(stream2, state2) {
  if (!state2.reading) {
    debug$1("resume read 0");
    stream2.read(0);
  }
  state2.resumeScheduled = false;
  state2.awaitDrain = 0;
  stream2.emit("resume");
  flow$1(stream2);
  if (state2.flowing && !state2.reading) stream2.read(0);
}
Readable$1.prototype.pause = function() {
  debug$1("call pause flowing=%j", this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug$1("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  return this;
};
function flow$1(stream2) {
  var state2 = stream2._readableState;
  debug$1("flow", state2.flowing);
  while (state2.flowing && stream2.read() !== null) {
  }
}
Readable$1.prototype.wrap = function(stream2) {
  var state2 = this._readableState;
  var paused = false;
  var self2 = this;
  stream2.on("end", function() {
    debug$1("wrapped end");
    if (state2.decoder && !state2.ended) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) self2.push(chunk);
    }
    self2.push(null);
  });
  stream2.on("data", function(chunk) {
    debug$1("wrapped data");
    if (state2.decoder) chunk = state2.decoder.write(chunk);
    if (state2.objectMode && (chunk === null || chunk === void 0)) return;
    else if (!state2.objectMode && (!chunk || !chunk.length)) return;
    var ret = self2.push(chunk);
    if (!ret) {
      paused = true;
      stream2.pause();
    }
  });
  for (var i2 in stream2) {
    if (this[i2] === void 0 && typeof stream2[i2] === "function") {
      this[i2] = /* @__PURE__ */ function(method) {
        return function() {
          return stream2[method].apply(stream2, arguments);
        };
      }(i2);
    }
  }
  var events2 = ["error", "close", "destroy", "pause", "resume"];
  forEach(events2, function(ev) {
    stream2.on(ev, self2.emit.bind(self2, ev));
  });
  self2._read = function(n3) {
    debug$1("wrapped _read", n3);
    if (paused) {
      paused = false;
      stream2.resume();
    }
  };
  return self2;
};
Readable$1._fromList = fromList$1;
function fromList$1(n3, state2) {
  if (state2.length === 0) return null;
  var ret;
  if (state2.objectMode) ret = state2.buffer.shift();
  else if (!n3 || n3 >= state2.length) {
    if (state2.decoder) ret = state2.buffer.join("");
    else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
    else ret = state2.buffer.concat(state2.length);
    state2.buffer.clear();
  } else {
    ret = fromListPartial(n3, state2.buffer, state2.decoder);
  }
  return ret;
}
function fromListPartial(n3, list, hasStrings) {
  var ret;
  if (n3 < list.head.data.length) {
    ret = list.head.data.slice(0, n3);
    list.head.data = list.head.data.slice(n3);
  } else if (n3 === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n3, list) : copyFromBuffer(n3, list);
  }
  return ret;
}
function copyFromBufferString(n3, list) {
  var p2 = list.head;
  var c2 = 1;
  var ret = p2.data;
  n3 -= ret.length;
  while (p2 = p2.next) {
    var str = p2.data;
    var nb = n3 > str.length ? str.length : n3;
    if (nb === str.length) ret += str;
    else ret += str.slice(0, n3);
    n3 -= nb;
    if (n3 === 0) {
      if (nb === str.length) {
        ++c2;
        if (p2.next) list.head = p2.next;
        else list.head = list.tail = null;
      } else {
        list.head = p2;
        p2.data = str.slice(nb);
      }
      break;
    }
    ++c2;
  }
  list.length -= c2;
  return ret;
}
function copyFromBuffer(n3, list) {
  var ret = Buffer$4.allocUnsafe(n3);
  var p2 = list.head;
  var c2 = 1;
  p2.data.copy(ret);
  n3 -= p2.data.length;
  while (p2 = p2.next) {
    var buf = p2.data;
    var nb = n3 > buf.length ? buf.length : n3;
    buf.copy(ret, ret.length - n3, 0, nb);
    n3 -= nb;
    if (n3 === 0) {
      if (nb === buf.length) {
        ++c2;
        if (p2.next) list.head = p2.next;
        else list.head = list.tail = null;
      } else {
        list.head = p2;
        p2.data = buf.slice(nb);
      }
      break;
    }
    ++c2;
  }
  list.length -= c2;
  return ret;
}
function endReadable$1(stream2) {
  var state2 = stream2._readableState;
  if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
  if (!state2.endEmitted) {
    state2.ended = true;
    nextTick$1(endReadableNT$1, state2, stream2);
  }
}
function endReadableNT$1(state2, stream2) {
  if (!state2.endEmitted && state2.length === 0) {
    state2.endEmitted = true;
    stream2.readable = false;
    stream2.emit("end");
  }
}
function forEach(xs, f2) {
  for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
    f2(xs[i2], i2);
  }
}
function indexOf$1(xs, x) {
  for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
    if (xs[i2] === x) return i2;
  }
  return -1;
}
Writable$1.WritableState = WritableState$1;
inherits$1$1(Writable$1, EventEmitter$1);
function nop$1() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState$1(options, stream2) {
  Object.defineProperty(this, "buffer", {
    get: deprecate$2(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream2 instanceof Duplex$1) this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite$1(stream2, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest$1(this);
}
WritableState$1.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
function Writable$1(options) {
  if (!(this instanceof Writable$1) && !(this instanceof Duplex$1)) return new Writable$1(options);
  this._writableState = new WritableState$1(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function") this._write = options.write;
    if (typeof options.writev === "function") this._writev = options.writev;
  }
  EventEmitter$1.call(this);
}
Writable$1.prototype.pipe = function() {
  this.emit("error", new Error("Cannot pipe, not readable"));
};
function writeAfterEnd$1(stream2, cb) {
  var er = new Error("write after end");
  stream2.emit("error", er);
  nextTick$1(cb, er);
}
function validChunk$1(stream2, state2, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer$4.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream2.emit("error", er);
    nextTick$1(cb, er);
    valid = false;
  }
  return valid;
}
Writable$1.prototype.write = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  var ret = false;
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (Buffer$4.isBuffer(chunk)) encoding = "buffer";
  else if (!encoding) encoding = state2.defaultEncoding;
  if (typeof cb !== "function") cb = nop$1;
  if (state2.ended) writeAfterEnd$1(this, cb);
  else if (validChunk$1(this, state2, chunk, cb)) {
    state2.pendingcb++;
    ret = writeOrBuffer$1(this, state2, chunk, encoding, cb);
  }
  return ret;
};
Writable$1.prototype.cork = function() {
  var state2 = this._writableState;
  state2.corked++;
};
Writable$1.prototype.uncork = function() {
  var state2 = this._writableState;
  if (state2.corked) {
    state2.corked--;
    if (!state2.writing && !state2.corked && !state2.finished && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer$1(this, state2);
  }
};
Writable$1.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  if (typeof encoding === "string") encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
function decodeChunk$1(state2, chunk, encoding) {
  if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer$4.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer$1(stream2, state2, chunk, encoding, cb) {
  chunk = decodeChunk$1(state2, chunk, encoding);
  if (Buffer$4.isBuffer(chunk)) encoding = "buffer";
  var len = state2.objectMode ? 1 : chunk.length;
  state2.length += len;
  var ret = state2.length < state2.highWaterMark;
  if (!ret) state2.needDrain = true;
  if (state2.writing || state2.corked) {
    var last2 = state2.lastBufferedRequest;
    state2.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last2) {
      last2.next = state2.lastBufferedRequest;
    } else {
      state2.bufferedRequest = state2.lastBufferedRequest;
    }
    state2.bufferedRequestCount += 1;
  } else {
    doWrite$1(stream2, state2, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite$1(stream2, state2, writev, len, chunk, encoding, cb) {
  state2.writelen = len;
  state2.writecb = cb;
  state2.writing = true;
  state2.sync = true;
  if (writev) stream2._writev(chunk, state2.onwrite);
  else stream2._write(chunk, encoding, state2.onwrite);
  state2.sync = false;
}
function onwriteError$1(stream2, state2, sync, er, cb) {
  --state2.pendingcb;
  if (sync) nextTick$1(cb, er);
  else cb(er);
  stream2._writableState.errorEmitted = true;
  stream2.emit("error", er);
}
function onwriteStateUpdate$1(state2) {
  state2.writing = false;
  state2.writecb = null;
  state2.length -= state2.writelen;
  state2.writelen = 0;
}
function onwrite$1(stream2, er) {
  var state2 = stream2._writableState;
  var sync = state2.sync;
  var cb = state2.writecb;
  onwriteStateUpdate$1(state2);
  if (er) onwriteError$1(stream2, state2, sync, er, cb);
  else {
    var finished = needFinish$1(state2);
    if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
      clearBuffer$1(stream2, state2);
    }
    if (sync) {
      nextTick$1(afterWrite$1, stream2, state2, finished, cb);
    } else {
      afterWrite$1(stream2, state2, finished, cb);
    }
  }
}
function afterWrite$1(stream2, state2, finished, cb) {
  if (!finished) onwriteDrain$1(stream2, state2);
  state2.pendingcb--;
  cb();
  finishMaybe$1(stream2, state2);
}
function onwriteDrain$1(stream2, state2) {
  if (state2.length === 0 && state2.needDrain) {
    state2.needDrain = false;
    stream2.emit("drain");
  }
}
function clearBuffer$1(stream2, state2) {
  state2.bufferProcessing = true;
  var entry = state2.bufferedRequest;
  if (stream2._writev && entry && entry.next) {
    var l2 = state2.bufferedRequestCount;
    var buffer = new Array(l2);
    var holder = state2.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }
    doWrite$1(stream2, state2, true, state2.length, buffer, "", holder.finish);
    state2.pendingcb++;
    state2.lastBufferedRequest = null;
    if (holder.next) {
      state2.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state2.corkedRequestsFree = new CorkedRequest$1(state2);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state2.objectMode ? 1 : chunk.length;
      doWrite$1(stream2, state2, false, len, chunk, encoding, cb);
      entry = entry.next;
      if (state2.writing) {
        break;
      }
    }
    if (entry === null) state2.lastBufferedRequest = null;
  }
  state2.bufferedRequestCount = 0;
  state2.bufferedRequest = entry;
  state2.bufferProcessing = false;
}
Writable$1.prototype._write = function(chunk, encoding, cb) {
  cb(new Error("not implemented"));
};
Writable$1.prototype._writev = null;
Writable$1.prototype.end = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
  if (state2.corked) {
    state2.corked = 1;
    this.uncork();
  }
  if (!state2.ending && !state2.finished) endWritable$1(this, state2, cb);
};
function needFinish$1(state2) {
  return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
}
function prefinish$2(stream2, state2) {
  if (!state2.prefinished) {
    state2.prefinished = true;
    stream2.emit("prefinish");
  }
}
function finishMaybe$1(stream2, state2) {
  var need = needFinish$1(state2);
  if (need) {
    if (state2.pendingcb === 0) {
      prefinish$2(stream2, state2);
      state2.finished = true;
      stream2.emit("finish");
    } else {
      prefinish$2(stream2, state2);
    }
  }
  return need;
}
function endWritable$1(stream2, state2, cb) {
  state2.ending = true;
  finishMaybe$1(stream2, state2);
  if (cb) {
    if (state2.finished) nextTick$1(cb);
    else stream2.once("finish", cb);
  }
  state2.ended = true;
  stream2.writable = false;
}
function CorkedRequest$1(state2) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err2) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err2);
      entry = entry.next;
    }
    if (state2.corkedRequestsFree) {
      state2.corkedRequestsFree.next = _this;
    } else {
      state2.corkedRequestsFree = _this;
    }
  };
}
inherits$1$1(Duplex$1, Readable$1);
var keys$1 = Object.keys(Writable$1.prototype);
for (var v$2 = 0; v$2 < keys$1.length; v$2++) {
  var method$1 = keys$1[v$2];
  if (!Duplex$1.prototype[method$1]) Duplex$1.prototype[method$1] = Writable$1.prototype[method$1];
}
function Duplex$1(options) {
  if (!(this instanceof Duplex$1)) return new Duplex$1(options);
  Readable$1.call(this, options);
  Writable$1.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once("end", onend$1);
}
function onend$1() {
  if (this.allowHalfOpen || this._writableState.ended) return;
  nextTick$1(onEndNT$1, this);
}
function onEndNT$1(self2) {
  self2.end();
}
inherits$1$1(Transform$2, Duplex$1);
function TransformState(stream2) {
  this.afterTransform = function(er, data2) {
    return afterTransform$1(stream2, er, data2);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform$1(stream2, er, data2) {
  var ts = stream2._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb) return stream2.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 !== null && data2 !== void 0) stream2.push(data2);
  cb(er);
  var rs = stream2._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream2._read(rs.highWaterMark);
  }
}
function Transform$2(options) {
  if (!(this instanceof Transform$2)) return new Transform$2(options);
  Duplex$1.call(this, options);
  this._transformState = new TransformState(this);
  var stream2 = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function") this._transform = options.transform;
    if (typeof options.flush === "function") this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function") this._flush(function(er) {
      done$1(stream2, er);
    });
    else done$1(stream2);
  });
}
Transform$2.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex$1.prototype.push.call(this, chunk, encoding);
};
Transform$2.prototype._transform = function(chunk, encoding, cb) {
  throw new Error("Not implemented");
};
Transform$2.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};
Transform$2.prototype._read = function(n3) {
  var ts = this._transformState;
  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
function done$1(stream2, er) {
  if (er) return stream2.emit("error", er);
  var ws = stream2._writableState;
  var ts = stream2._transformState;
  if (ws.length) throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming) throw new Error("Calling transform done when still transforming");
  return stream2.push(null);
}
inherits$1$1(PassThrough$1, Transform$2);
function PassThrough$1(options) {
  if (!(this instanceof PassThrough$1)) return new PassThrough$1(options);
  Transform$2.call(this, options);
}
PassThrough$1.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
inherits$1$1(Stream$2, EventEmitter$1);
Stream$2.Readable = Readable$1;
Stream$2.Writable = Writable$1;
Stream$2.Duplex = Duplex$1;
Stream$2.Transform = Transform$2;
Stream$2.PassThrough = PassThrough$1;
Stream$2.Stream = Stream$2;
function Stream$2() {
  EventEmitter$1.call(this);
}
Stream$2.prototype.pipe = function(dest, options) {
  var source = this;
  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on("end", onend2);
    source.on("close", onclose);
  }
  var didOnEnd = false;
  function onend2() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === "function") dest.destroy();
  }
  function onerror(er) {
    cleanup();
    if (EventEmitter$1.listenerCount(this, "error") === 0) {
      throw er;
    }
  }
  source.on("error", onerror);
  dest.on("error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend2);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
var _polyfillNode_stream = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Duplex: Duplex$1,
  PassThrough: PassThrough$1,
  Readable: Readable$1,
  Stream: Stream$2,
  Transform: Transform$2,
  Writable: Writable$1,
  default: Stream$2
});
var require$$1$2 = /* @__PURE__ */ getAugmentedNamespace$1(_polyfillNode_stream);
var binding$2 = {};
function compare$1(a2, b2) {
  if (a2 === b2) {
    return 0;
  }
  var x = a2.length;
  var y2 = b2.length;
  for (var i2 = 0, len = Math.min(x, y2); i2 < len; ++i2) {
    if (a2[i2] !== b2[i2]) {
      x = a2[i2];
      y2 = b2[i2];
      break;
    }
  }
  if (x < y2) {
    return -1;
  }
  if (y2 < x) {
    return 1;
  }
  return 0;
}
var hasOwn$1 = Object.prototype.hasOwnProperty;
var objectKeys$2 = Object.keys || function(obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn$1.call(obj, key)) keys.push(key);
  }
  return keys;
};
var pSlice$1 = Array.prototype.slice;
var _functionsHaveNames$1;
function functionsHaveNames$1() {
  if (typeof _functionsHaveNames$1 !== "undefined") {
    return _functionsHaveNames$1;
  }
  return _functionsHaveNames$1 = function() {
    return (function foo() {
    }).name === "foo";
  }();
}
function pToString$1(obj) {
  return Object.prototype.toString.call(obj);
}
function isView$1(arrbuf) {
  if (isBuffer$1$2(arrbuf)) {
    return false;
  }
  if (typeof global$1$2.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
function assert$1(value2, message) {
  if (!value2) fail$1(value2, true, message, "==", ok$1);
}
var regex$2 = /\s*function\s+([^\(\s]*)\s*/;
function getName$1(func) {
  if (!isFunction$1(func)) {
    return;
  }
  if (functionsHaveNames$1()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex$2);
  return match && match[1];
}
assert$1.AssertionError = AssertionError$1;
function AssertionError$1(options) {
  this.name = "AssertionError";
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage$1(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail$1;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err2 = new Error();
    if (err2.stack) {
      var out = err2.stack;
      var fn_name = getName$1(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
}
inherits$1$1(AssertionError$1, Error);
function truncate$2(s2, n3) {
  if (typeof s2 === "string") {
    return s2.length < n3 ? s2 : s2.slice(0, n3);
  } else {
    return s2;
  }
}
function inspect$2(something) {
  if (functionsHaveNames$1() || !isFunction$1(something)) {
    return inspect$1$1(something);
  }
  var rawname = getName$1(something);
  var name = rawname ? ": " + rawname : "";
  return "[Function" + name + "]";
}
function getMessage$1(self2) {
  return truncate$2(inspect$2(self2.actual), 128) + " " + self2.operator + " " + truncate$2(inspect$2(self2.expected), 128);
}
function fail$1(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError$1({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
assert$1.fail = fail$1;
function ok$1(value2, message) {
  if (!value2) fail$1(value2, true, message, "==", ok$1);
}
assert$1.ok = ok$1;
assert$1.equal = equal$1;
function equal$1(actual, expected, message) {
  if (actual != expected) fail$1(actual, expected, message, "==", equal$1);
}
assert$1.notEqual = notEqual$1;
function notEqual$1(actual, expected, message) {
  if (actual == expected) {
    fail$1(actual, expected, message, "!=", notEqual$1);
  }
}
assert$1.deepEqual = deepEqual$1;
function deepEqual$1(actual, expected, message) {
  if (!_deepEqual$1(actual, expected, false)) {
    fail$1(actual, expected, message, "deepEqual", deepEqual$1);
  }
}
assert$1.deepStrictEqual = deepStrictEqual$1;
function deepStrictEqual$1(actual, expected, message) {
  if (!_deepEqual$1(actual, expected, true)) {
    fail$1(actual, expected, message, "deepStrictEqual", deepStrictEqual$1);
  }
}
function _deepEqual$1(actual, expected, strict, memos) {
  if (actual === expected) {
    return true;
  } else if (isBuffer$1$2(actual) && isBuffer$1$2(expected)) {
    return compare$1(actual, expected) === 0;
  } else if (isDate$1(actual) && isDate$1(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (isRegExp$1(actual) && isRegExp$1(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  } else if (isView$1(actual) && isView$1(expected) && pToString$1(actual) === pToString$1(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare$1(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0;
  } else if (isBuffer$1$2(actual) !== isBuffer$1$2(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv$1(actual, expected, strict, memos);
  }
}
function isArguments$1(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv$1(a2, b2, strict, actualVisitedObjects) {
  if (a2 === null || a2 === void 0 || b2 === null || b2 === void 0)
    return false;
  if (isPrimitive$1(a2) || isPrimitive$1(b2))
    return a2 === b2;
  if (strict && Object.getPrototypeOf(a2) !== Object.getPrototypeOf(b2))
    return false;
  var aIsArgs = isArguments$1(a2);
  var bIsArgs = isArguments$1(b2);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a2 = pSlice$1.call(a2);
    b2 = pSlice$1.call(b2);
    return _deepEqual$1(a2, b2, strict);
  }
  var ka = objectKeys$2(a2);
  var kb = objectKeys$2(b2);
  var key, i2;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i2 = ka.length - 1; i2 >= 0; i2--) {
    if (ka[i2] !== kb[i2])
      return false;
  }
  for (i2 = ka.length - 1; i2 >= 0; i2--) {
    key = ka[i2];
    if (!_deepEqual$1(a2[key], b2[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}
assert$1.notDeepEqual = notDeepEqual$1;
function notDeepEqual$1(actual, expected, message) {
  if (_deepEqual$1(actual, expected, false)) {
    fail$1(actual, expected, message, "notDeepEqual", notDeepEqual$1);
  }
}
assert$1.notDeepStrictEqual = notDeepStrictEqual$1;
function notDeepStrictEqual$1(actual, expected, message) {
  if (_deepEqual$1(actual, expected, true)) {
    fail$1(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual$1);
  }
}
assert$1.strictEqual = strictEqual$1;
function strictEqual$1(actual, expected, message) {
  if (actual !== expected) {
    fail$1(actual, expected, message, "===", strictEqual$1);
  }
}
assert$1.notStrictEqual = notStrictEqual$1;
function notStrictEqual$1(actual, expected, message) {
  if (actual === expected) {
    fail$1(actual, expected, message, "!==", notStrictEqual$1);
  }
}
function expectedException$1(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e2) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock$1(block) {
  var error;
  try {
    block();
  } catch (e2) {
    error = e2;
  }
  return error;
}
function _throws$1(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock$1(block);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail$1(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && isError$1(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException$1(actual, expected) || isUnexpectedException) {
    fail$1(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException$1(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
assert$1.throws = throws$1;
function throws$1(block, error, message) {
  _throws$1(true, block, error, message);
}
assert$1.doesNotThrow = doesNotThrow$1;
function doesNotThrow$1(block, error, message) {
  _throws$1(false, block, error, message);
}
assert$1.ifError = ifError$1;
function ifError$1(err2) {
  if (err2) throw err2;
}
var _polyfillNode_assert$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AssertionError: AssertionError$1,
  assert: ok$1,
  deepEqual: deepEqual$1,
  deepStrictEqual: deepStrictEqual$1,
  default: assert$1,
  doesNotThrow: doesNotThrow$1,
  equal: equal$1,
  fail: fail$1,
  ifError: ifError$1,
  notDeepEqual: notDeepEqual$1,
  notDeepStrictEqual: notDeepStrictEqual$1,
  notEqual: notEqual$1,
  notStrictEqual: notStrictEqual$1,
  ok: ok$1,
  strictEqual: strictEqual$1,
  throws: throws$1
});
var require$$4$1 = /* @__PURE__ */ getAugmentedNamespace$1(_polyfillNode_assert$1);
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var deflate$1 = {};
var common = {};
(function(exports) {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p2 in source) {
        if (_has(source, p2)) {
          obj[p2] = source[p2];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src2, src_offs, len, dest_offs) {
      if (src2.subarray && dest.subarray) {
        dest.set(src2.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i2 = 0; i2 < len; i2++) {
        dest[dest_offs + i2] = src2[src_offs + i2];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      var i2, l2, len, pos, chunk, result;
      len = 0;
      for (i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
        len += chunks[i2].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
        chunk = chunks[i2];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src2, src_offs, len, dest_offs) {
      for (var i2 = 0; i2 < len; i2++) {
        dest[dest_offs + i2] = src2[src_offs + i2];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports.setTyped = function(on2) {
    if (on2) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
})(common);
var trees$1 = {};
var utils$3 = common;
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
);
var extra_dbits = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
);
var extra_blbits = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
);
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
function put_short(s2, w) {
  s2.pending_buf[s2.pending++] = w & 255;
  s2.pending_buf[s2.pending++] = w >>> 8 & 255;
}
function send_bits(s2, value2, length2) {
  if (s2.bi_valid > Buf_size - length2) {
    s2.bi_buf |= value2 << s2.bi_valid & 65535;
    put_short(s2, s2.bi_buf);
    s2.bi_buf = value2 >> Buf_size - s2.bi_valid;
    s2.bi_valid += length2 - Buf_size;
  } else {
    s2.bi_buf |= value2 << s2.bi_valid & 65535;
    s2.bi_valid += length2;
  }
}
function send_code(s2, c2, tree) {
  send_bits(
    s2,
    tree[c2 * 2],
    tree[c2 * 2 + 1]
    /*.Len*/
  );
}
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}
function bi_flush(s2) {
  if (s2.bi_valid === 16) {
    put_short(s2, s2.bi_buf);
    s2.bi_buf = 0;
    s2.bi_valid = 0;
  } else if (s2.bi_valid >= 8) {
    s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
    s2.bi_buf >>= 8;
    s2.bi_valid -= 8;
  }
}
function gen_bitlen(s2, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  var n3, m2;
  var bits;
  var xbits;
  var f2;
  var overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s2.bl_count[bits] = 0;
  }
  tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
  for (h = s2.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n3 = s2.heap[h];
    bits = tree[tree[n3 * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n3 * 2 + 1] = bits;
    if (n3 > max_code) {
      continue;
    }
    s2.bl_count[bits]++;
    xbits = 0;
    if (n3 >= base) {
      xbits = extra[n3 - base];
    }
    f2 = tree[n3 * 2];
    s2.opt_len += f2 * (bits + xbits);
    if (has_stree) {
      s2.static_len += f2 * (stree[n3 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s2.bl_count[bits] === 0) {
      bits--;
    }
    s2.bl_count[bits]--;
    s2.bl_count[bits + 1] += 2;
    s2.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n3 = s2.bl_count[bits];
    while (n3 !== 0) {
      m2 = s2.heap[--h];
      if (m2 > max_code) {
        continue;
      }
      if (tree[m2 * 2 + 1] !== bits) {
        s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
        tree[m2 * 2 + 1] = bits;
      }
      n3--;
    }
  }
}
function gen_codes(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS$1 + 1);
  var code = 0;
  var bits;
  var n3;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  for (n3 = 0; n3 <= max_code; n3++) {
    var len = tree[n3 * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n3 * 2] = bi_reverse(next_code[len]++, len);
  }
}
function tr_static_init() {
  var n3;
  var bits;
  var length2;
  var code;
  var dist;
  var bl_count = new Array(MAX_BITS$1 + 1);
  length2 = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length2;
    for (n3 = 0; n3 < 1 << extra_lbits[code]; n3++) {
      _length_code[length2++] = code;
    }
  }
  _length_code[length2 - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n3 = 0; n3 < 1 << extra_dbits[code]; n3++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n3 = 0; n3 < 1 << extra_dbits[code] - 7; n3++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n3 = 0;
  while (n3 <= 143) {
    static_ltree[n3 * 2 + 1] = 8;
    n3++;
    bl_count[8]++;
  }
  while (n3 <= 255) {
    static_ltree[n3 * 2 + 1] = 9;
    n3++;
    bl_count[9]++;
  }
  while (n3 <= 279) {
    static_ltree[n3 * 2 + 1] = 7;
    n3++;
    bl_count[7]++;
  }
  while (n3 <= 287) {
    static_ltree[n3 * 2 + 1] = 8;
    n3++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n3 = 0; n3 < D_CODES$1; n3++) {
    static_dtree[n3 * 2 + 1] = 5;
    static_dtree[n3 * 2] = bi_reverse(n3, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
}
function init_block(s2) {
  var n3;
  for (n3 = 0; n3 < L_CODES$1; n3++) {
    s2.dyn_ltree[n3 * 2] = 0;
  }
  for (n3 = 0; n3 < D_CODES$1; n3++) {
    s2.dyn_dtree[n3 * 2] = 0;
  }
  for (n3 = 0; n3 < BL_CODES$1; n3++) {
    s2.bl_tree[n3 * 2] = 0;
  }
  s2.dyn_ltree[END_BLOCK * 2] = 1;
  s2.opt_len = s2.static_len = 0;
  s2.last_lit = s2.matches = 0;
}
function bi_windup(s2) {
  if (s2.bi_valid > 8) {
    put_short(s2, s2.bi_buf);
  } else if (s2.bi_valid > 0) {
    s2.pending_buf[s2.pending++] = s2.bi_buf;
  }
  s2.bi_buf = 0;
  s2.bi_valid = 0;
}
function copy_block(s2, buf, len, header) {
  bi_windup(s2);
  {
    put_short(s2, len);
    put_short(s2, ~len);
  }
  utils$3.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
  s2.pending += len;
}
function smaller(tree, n3, m2, depth) {
  var _n2 = n3 * 2;
  var _m2 = m2 * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n3] <= depth[m2];
}
function pqdownheap(s2, tree, k2) {
  var v2 = s2.heap[k2];
  var j = k2 << 1;
  while (j <= s2.heap_len) {
    if (j < s2.heap_len && smaller(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
      j++;
    }
    if (smaller(tree, v2, s2.heap[j], s2.depth)) {
      break;
    }
    s2.heap[k2] = s2.heap[j];
    k2 = j;
    j <<= 1;
  }
  s2.heap[k2] = v2;
}
function compress_block(s2, ltree, dtree) {
  var dist;
  var lc;
  var lx = 0;
  var code;
  var extra;
  if (s2.last_lit !== 0) {
    do {
      dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
      lc = s2.pending_buf[s2.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s2, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s2, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s2, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s2, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s2, dist, extra);
        }
      }
    } while (lx < s2.last_lit);
  }
  send_code(s2, END_BLOCK, ltree);
}
function build_tree(s2, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n3, m2;
  var max_code = -1;
  var node;
  s2.heap_len = 0;
  s2.heap_max = HEAP_SIZE$1;
  for (n3 = 0; n3 < elems; n3++) {
    if (tree[n3 * 2] !== 0) {
      s2.heap[++s2.heap_len] = max_code = n3;
      s2.depth[n3] = 0;
    } else {
      tree[n3 * 2 + 1] = 0;
    }
  }
  while (s2.heap_len < 2) {
    node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s2.depth[node] = 0;
    s2.opt_len--;
    if (has_stree) {
      s2.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n3 = s2.heap_len >> 1; n3 >= 1; n3--) {
    pqdownheap(s2, tree, n3);
  }
  node = elems;
  do {
    n3 = s2.heap[
      1
      /*SMALLEST*/
    ];
    s2.heap[
      1
      /*SMALLEST*/
    ] = s2.heap[s2.heap_len--];
    pqdownheap(
      s2,
      tree,
      1
      /*SMALLEST*/
    );
    m2 = s2.heap[
      1
      /*SMALLEST*/
    ];
    s2.heap[--s2.heap_max] = n3;
    s2.heap[--s2.heap_max] = m2;
    tree[node * 2] = tree[n3 * 2] + tree[m2 * 2];
    s2.depth[node] = (s2.depth[n3] >= s2.depth[m2] ? s2.depth[n3] : s2.depth[m2]) + 1;
    tree[n3 * 2 + 1] = tree[m2 * 2 + 1] = node;
    s2.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s2,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s2.heap_len >= 2);
  s2.heap[--s2.heap_max] = s2.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s2, desc);
  gen_codes(tree, max_code, s2.bl_count);
}
function scan_tree(s2, tree, max_code) {
  var n3;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n3 = 0; n3 <= max_code; n3++) {
    curlen = nextlen;
    nextlen = tree[(n3 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s2.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s2.bl_tree[curlen * 2]++;
      }
      s2.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s2.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s2.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function send_tree(s2, tree, max_code) {
  var n3;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n3 = 0; n3 <= max_code; n3++) {
    curlen = nextlen;
    nextlen = tree[(n3 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s2, curlen, s2.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s2, curlen, s2.bl_tree);
        count--;
      }
      send_code(s2, REP_3_6, s2.bl_tree);
      send_bits(s2, count - 3, 2);
    } else if (count <= 10) {
      send_code(s2, REPZ_3_10, s2.bl_tree);
      send_bits(s2, count - 3, 3);
    } else {
      send_code(s2, REPZ_11_138, s2.bl_tree);
      send_bits(s2, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function build_bl_tree(s2) {
  var max_blindex;
  scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
  scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
  build_tree(s2, s2.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
function send_all_trees(s2, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits(s2, lcodes - 257, 5);
  send_bits(s2, dcodes - 1, 5);
  send_bits(s2, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s2, s2.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s2, s2.dyn_ltree, lcodes - 1);
  send_tree(s2, s2.dyn_dtree, dcodes - 1);
}
function detect_data_type(s2) {
  var black_mask = 4093624447;
  var n3;
  for (n3 = 0; n3 <= 31; n3++, black_mask >>>= 1) {
    if (black_mask & 1 && s2.dyn_ltree[n3 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n3 = 32; n3 < LITERALS$1; n3++) {
    if (s2.dyn_ltree[n3 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
}
var static_init_done = false;
function _tr_init(s2) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
  s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
  s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
  s2.bi_buf = 0;
  s2.bi_valid = 0;
  init_block(s2);
}
function _tr_stored_block(s2, buf, stored_len, last2) {
  send_bits(s2, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
  copy_block(s2, buf, stored_len);
}
function _tr_align(s2) {
  send_bits(s2, STATIC_TREES << 1, 3);
  send_code(s2, END_BLOCK, static_ltree);
  bi_flush(s2);
}
function _tr_flush_block(s2, buf, stored_len, last2) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s2.level > 0) {
    if (s2.strm.data_type === Z_UNKNOWN$1) {
      s2.strm.data_type = detect_data_type(s2);
    }
    build_tree(s2, s2.l_desc);
    build_tree(s2, s2.d_desc);
    max_blindex = build_bl_tree(s2);
    opt_lenb = s2.opt_len + 3 + 7 >>> 3;
    static_lenb = s2.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s2, buf, stored_len, last2);
  } else if (s2.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s2, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
    compress_block(s2, static_ltree, static_dtree);
  } else {
    send_bits(s2, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
    send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
  }
  init_block(s2);
  if (last2) {
    bi_windup(s2);
  }
}
function _tr_tally(s2, dist, lc) {
  s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
  s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
  s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
  s2.last_lit++;
  if (dist === 0) {
    s2.dyn_ltree[lc * 2]++;
  } else {
    s2.matches++;
    dist--;
    s2.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s2.dyn_dtree[d_code(dist) * 2]++;
  }
  return s2.last_lit === s2.lit_bufsize - 1;
}
trees$1._tr_init = _tr_init;
trees$1._tr_stored_block = _tr_stored_block;
trees$1._tr_flush_block = _tr_flush_block;
trees$1._tr_tally = _tr_tally;
trees$1._tr_align = _tr_align;
function adler32$2(adler, buf, len, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n3 = 0;
  while (len !== 0) {
    n3 = len > 2e3 ? 2e3 : len;
    len -= n3;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n3);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
var adler32_1 = adler32$2;
function makeTable() {
  var c2, table = [];
  for (var n3 = 0; n3 < 256; n3++) {
    c2 = n3;
    for (var k2 = 0; k2 < 8; k2++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table[n3] = c2;
  }
  return table;
}
var crcTable = makeTable();
function crc32$2(crc, buf, len, pos) {
  var t2 = crcTable, end2 = pos + len;
  crc ^= -1;
  for (var i2 = pos; i2 < end2; i2++) {
    crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
  }
  return crc ^ -1;
}
var crc32_1 = crc32$2;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var utils$2 = common;
var trees = trees$1;
var adler32$1 = adler32_1;
var crc32$1 = crc32_1;
var msg = messages;
var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
var Z_FULL_FLUSH = 3;
var Z_FINISH$1 = 4;
var Z_BLOCK$1 = 5;
var Z_OK$1 = 0;
var Z_STREAM_END$1 = 1;
var Z_STREAM_ERROR$1 = -2;
var Z_DATA_ERROR$1 = -3;
var Z_BUF_ERROR$1 = -5;
var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;
var Z_UNKNOWN = 2;
var Z_DEFLATED$1 = 8;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}
function rank(f2) {
  return (f2 << 1) - (f2 > 4 ? 9 : 0);
}
function zero(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function flush_pending(strm) {
  var s2 = strm.state;
  var len = s2.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  utils$2.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
  strm.next_out += len;
  s2.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s2.pending -= len;
  if (s2.pending === 0) {
    s2.pending_out = 0;
  }
}
function flush_block_only(s2, last2) {
  trees._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last2);
  s2.block_start = s2.strstart;
  flush_pending(s2.strm);
}
function put_byte(s2, b2) {
  s2.pending_buf[s2.pending++] = b2;
}
function putShortMSB(s2, b2) {
  s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
  s2.pending_buf[s2.pending++] = b2 & 255;
}
function read_buf(strm, buf, start2, size) {
  var len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  utils$2.arraySet(buf, strm.input, strm.next_in, len, start2);
  if (strm.state.wrap === 1) {
    strm.adler = adler32$1(strm.adler, buf, len, start2);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32$1(strm.adler, buf, len, start2);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
}
function longest_match(s2, cur_match) {
  var chain_length = s2.max_chain_length;
  var scan = s2.strstart;
  var match;
  var len;
  var best_len = s2.prev_length;
  var nice_match = s2.nice_match;
  var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
  var _win = s2.window;
  var wmask = s2.w_mask;
  var prev = s2.prev;
  var strend = s2.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s2.prev_length >= s2.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s2.lookahead) {
    nice_match = s2.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s2.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s2.lookahead) {
    return best_len;
  }
  return s2.lookahead;
}
function fill_window(s2) {
  var _w_size = s2.w_size;
  var p2, n3, m2, more, str;
  do {
    more = s2.window_size - s2.lookahead - s2.strstart;
    if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      utils$2.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
      s2.match_start -= _w_size;
      s2.strstart -= _w_size;
      s2.block_start -= _w_size;
      n3 = s2.hash_size;
      p2 = n3;
      do {
        m2 = s2.head[--p2];
        s2.head[p2] = m2 >= _w_size ? m2 - _w_size : 0;
      } while (--n3);
      n3 = _w_size;
      p2 = n3;
      do {
        m2 = s2.prev[--p2];
        s2.prev[p2] = m2 >= _w_size ? m2 - _w_size : 0;
      } while (--n3);
      more += _w_size;
    }
    if (s2.strm.avail_in === 0) {
      break;
    }
    n3 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
    s2.lookahead += n3;
    if (s2.lookahead + s2.insert >= MIN_MATCH) {
      str = s2.strstart - s2.insert;
      s2.ins_h = s2.window[str];
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
      while (s2.insert) {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
        s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = str;
        str++;
        s2.insert--;
        if (s2.lookahead + s2.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
}
function deflate_stored(s2, flush) {
  var max_block_size = 65535;
  if (max_block_size > s2.pending_buf_size - 5) {
    max_block_size = s2.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s2.lookahead <= 1) {
      fill_window(s2);
      if (s2.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    s2.strstart += s2.lookahead;
    s2.lookahead = 0;
    var max_start = s2.block_start + max_block_size;
    if (s2.strstart === 0 || s2.strstart >= max_start) {
      s2.lookahead = s2.strstart - max_start;
      s2.strstart = max_start;
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.strstart > s2.block_start) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
}
function deflate_fast(s2, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
        s2.match_length--;
        do {
          s2.strstart++;
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        } while (--s2.match_length !== 0);
        s2.strstart++;
      } else {
        s2.strstart += s2.match_length;
        s2.match_length = 0;
        s2.ins_h = s2.window[s2.strstart];
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
      }
    } else {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_slow(s2, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    s2.prev_length = s2.match_length;
    s2.prev_match = s2.match_start;
    s2.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
      if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
        s2.match_length = MIN_MATCH - 1;
      }
    }
    if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
      max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
      bflush = trees._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
      s2.lookahead -= s2.prev_length - 1;
      s2.prev_length -= 2;
      do {
        if (++s2.strstart <= max_insert) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
      } while (--s2.prev_length !== 0);
      s2.match_available = 0;
      s2.match_length = MIN_MATCH - 1;
      s2.strstart++;
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s2.match_available) {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
      if (bflush) {
        flush_block_only(s2, false);
      }
      s2.strstart++;
      s2.lookahead--;
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s2.match_available = 1;
      s2.strstart++;
      s2.lookahead--;
    }
  }
  if (s2.match_available) {
    bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
    s2.match_available = 0;
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_rle(s2, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s2.window;
  for (; ; ) {
    if (s2.lookahead <= MAX_MATCH) {
      fill_window(s2);
      if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    s2.match_length = 0;
    if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
      scan = s2.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s2.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s2.match_length = MAX_MATCH - (strend - scan);
        if (s2.match_length > s2.lookahead) {
          s2.match_length = s2.lookahead;
        }
      }
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      s2.strstart += s2.match_length;
      s2.match_length = 0;
    } else {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_huff(s2, flush) {
  var bflush;
  for (; ; ) {
    if (s2.lookahead === 0) {
      fill_window(s2);
      if (s2.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s2.match_length = 0;
    bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
    s2.lookahead--;
    s2.strstart++;
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table;
configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
function lm_init(s2) {
  s2.window_size = 2 * s2.w_size;
  zero(s2.head);
  s2.max_lazy_match = configuration_table[s2.level].max_lazy;
  s2.good_match = configuration_table[s2.level].good_length;
  s2.nice_match = configuration_table[s2.level].nice_length;
  s2.max_chain_length = configuration_table[s2.level].max_chain;
  s2.strstart = 0;
  s2.block_start = 0;
  s2.lookahead = 0;
  s2.insert = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  s2.ins_h = 0;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$1;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new utils$2.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils$2.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils$2.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new utils$2.Buf16(MAX_BITS + 1);
  this.heap = new utils$2.Buf16(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new utils$2.Buf16(2 * L_CODES + 1);
  zero(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function deflateResetKeep(strm) {
  var s2;
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s2 = strm.state;
  s2.pending = 0;
  s2.pending_out = 0;
  if (s2.wrap < 0) {
    s2.wrap = -s2.wrap;
  }
  s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s2.wrap === 2 ? 0 : 1;
  s2.last_flush = Z_NO_FLUSH;
  trees._tr_init(s2);
  return Z_OK$1;
}
function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK$1) {
    lm_init(strm.state);
  }
  return ret;
}
function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$1;
  }
  strm.state.gzhead = head;
  return Z_OK$1;
}
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  var wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$1 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s2 = new DeflateState();
  strm.state = s2;
  s2.strm = strm;
  s2.wrap = wrap;
  s2.gzhead = null;
  s2.w_bits = windowBits;
  s2.w_size = 1 << s2.w_bits;
  s2.w_mask = s2.w_size - 1;
  s2.hash_bits = memLevel + 7;
  s2.hash_size = 1 << s2.hash_bits;
  s2.hash_mask = s2.hash_size - 1;
  s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s2.window = new utils$2.Buf8(s2.w_size * 2);
  s2.head = new utils$2.Buf16(s2.hash_size);
  s2.prev = new utils$2.Buf16(s2.w_size);
  s2.lit_bufsize = 1 << memLevel + 6;
  s2.pending_buf_size = s2.lit_bufsize * 4;
  s2.pending_buf = new utils$2.Buf8(s2.pending_buf_size);
  s2.d_buf = 1 * s2.lit_bufsize;
  s2.l_buf = (1 + 2) * s2.lit_bufsize;
  s2.level = level;
  s2.strategy = strategy;
  s2.method = method;
  return deflateReset(strm);
}
function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED$1, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}
function deflate(strm, flush) {
  var old_flush, s2;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$1) : Z_STREAM_ERROR$1;
  }
  s2 = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH$1) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$1);
  }
  s2.strm = strm;
  old_flush = s2.last_flush;
  s2.last_flush = flush;
  if (s2.status === INIT_STATE) {
    if (s2.wrap === 2) {
      strm.adler = 0;
      put_byte(s2, 31);
      put_byte(s2, 139);
      put_byte(s2, 8);
      if (!s2.gzhead) {
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
        put_byte(s2, OS_CODE);
        s2.status = BUSY_STATE;
      } else {
        put_byte(s2, (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16));
        put_byte(s2, s2.gzhead.time & 255);
        put_byte(s2, s2.gzhead.time >> 8 & 255);
        put_byte(s2, s2.gzhead.time >> 16 & 255);
        put_byte(s2, s2.gzhead.time >> 24 & 255);
        put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
        put_byte(s2, s2.gzhead.os & 255);
        if (s2.gzhead.extra && s2.gzhead.extra.length) {
          put_byte(s2, s2.gzhead.extra.length & 255);
          put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
        }
        if (s2.gzhead.hcrc) {
          strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending, 0);
        }
        s2.gzindex = 0;
        s2.status = EXTRA_STATE;
      }
    } else {
      var header = Z_DEFLATED$1 + (s2.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
        level_flags = 0;
      } else if (s2.level < 6) {
        level_flags = 1;
      } else if (s2.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s2.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s2.status = BUSY_STATE;
      putShortMSB(s2, header);
      if (s2.strstart !== 0) {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s2.status === EXTRA_STATE) {
    if (s2.gzhead.extra) {
      beg = s2.pending;
      while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            break;
          }
        }
        put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
        s2.gzindex++;
      }
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (s2.gzindex === s2.gzhead.extra.length) {
        s2.gzindex = 0;
        s2.status = NAME_STATE;
      }
    } else {
      s2.status = NAME_STATE;
    }
  }
  if (s2.status === NAME_STATE) {
    if (s2.gzhead.name) {
      beg = s2.pending;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s2.gzindex < s2.gzhead.name.length) {
          val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (val === 0) {
        s2.gzindex = 0;
        s2.status = COMMENT_STATE;
      }
    } else {
      s2.status = COMMENT_STATE;
    }
  }
  if (s2.status === COMMENT_STATE) {
    if (s2.gzhead.comment) {
      beg = s2.pending;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s2.gzindex < s2.gzhead.comment.length) {
          val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (val === 0) {
        s2.status = HCRC_STATE;
      }
    } else {
      s2.status = HCRC_STATE;
    }
  }
  if (s2.status === HCRC_STATE) {
    if (s2.gzhead.hcrc) {
      if (s2.pending + 2 > s2.pending_buf_size) {
        flush_pending(strm);
      }
      if (s2.pending + 2 <= s2.pending_buf_size) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        strm.adler = 0;
        s2.status = BUSY_STATE;
      }
    } else {
      s2.status = BUSY_STATE;
    }
  }
  if (s2.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s2.last_flush = -1;
      return Z_OK$1;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$1) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
    var bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s2.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
      }
      return Z_OK$1;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s2);
      } else if (flush !== Z_BLOCK$1) {
        trees._tr_stored_block(s2, 0, 0, false);
        if (flush === Z_FULL_FLUSH) {
          zero(s2.head);
          if (s2.lookahead === 0) {
            s2.strstart = 0;
            s2.block_start = 0;
            s2.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
        return Z_OK$1;
      }
    }
  }
  if (flush !== Z_FINISH$1) {
    return Z_OK$1;
  }
  if (s2.wrap <= 0) {
    return Z_STREAM_END$1;
  }
  if (s2.wrap === 2) {
    put_byte(s2, strm.adler & 255);
    put_byte(s2, strm.adler >> 8 & 255);
    put_byte(s2, strm.adler >> 16 & 255);
    put_byte(s2, strm.adler >> 24 & 255);
    put_byte(s2, strm.total_in & 255);
    put_byte(s2, strm.total_in >> 8 & 255);
    put_byte(s2, strm.total_in >> 16 & 255);
    put_byte(s2, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s2, strm.adler >>> 16);
    putShortMSB(s2, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s2.wrap > 0) {
    s2.wrap = -s2.wrap;
  }
  return s2.pending !== 0 ? Z_OK$1 : Z_STREAM_END$1;
}
function deflateEnd(strm) {
  var status;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$1) : Z_OK$1;
}
function deflateSetDictionary(strm, dictionary2) {
  var dictLength = dictionary2.length;
  var s2;
  var str, n3;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  s2 = strm.state;
  wrap = s2.wrap;
  if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
    return Z_STREAM_ERROR$1;
  }
  if (wrap === 1) {
    strm.adler = adler32$1(strm.adler, dictionary2, dictLength, 0);
  }
  s2.wrap = 0;
  if (dictLength >= s2.w_size) {
    if (wrap === 0) {
      zero(s2.head);
      s2.strstart = 0;
      s2.block_start = 0;
      s2.insert = 0;
    }
    tmpDict = new utils$2.Buf8(s2.w_size);
    utils$2.arraySet(tmpDict, dictionary2, dictLength - s2.w_size, s2.w_size, 0);
    dictionary2 = tmpDict;
    dictLength = s2.w_size;
  }
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary2;
  fill_window(s2);
  while (s2.lookahead >= MIN_MATCH) {
    str = s2.strstart;
    n3 = s2.lookahead - (MIN_MATCH - 1);
    do {
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
      s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = str;
      str++;
    } while (--n3);
    s2.strstart = str;
    s2.lookahead = MIN_MATCH - 1;
    fill_window(s2);
  }
  s2.strstart += s2.lookahead;
  s2.block_start = s2.strstart;
  s2.insert = s2.lookahead;
  s2.lookahead = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s2.wrap = wrap;
  return Z_OK$1;
}
deflate$1.deflateInit = deflateInit;
deflate$1.deflateInit2 = deflateInit2;
deflate$1.deflateReset = deflateReset;
deflate$1.deflateResetKeep = deflateResetKeep;
deflate$1.deflateSetHeader = deflateSetHeader;
deflate$1.deflate = deflate;
deflate$1.deflateEnd = deflateEnd;
deflate$1.deflateSetDictionary = deflateSetDictionary;
deflate$1.deflateInfo = "pako deflate (from Nodeca project)";
var inflate$1 = {};
var BAD$1 = 30;
var TYPE$1 = 12;
var inffast = function inflate_fast(strm, start2) {
  var state2;
  var _in;
  var last2;
  var _out;
  var beg;
  var end2;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len;
  var dist;
  var from2;
  var from_source;
  var input, output;
  state2 = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start2 - strm.avail_out);
  end2 = _out + (strm.avail_out - 257);
  dmax = state2.dmax;
  wsize = state2.wsize;
  whave = state2.whave;
  wnext = state2.wnext;
  s_window = state2.window;
  hold = state2.hold;
  bits = state2.bits;
  lcode = state2.lencode;
  dcode = state2.distcode;
  lmask = (1 << state2.lenbits) - 1;
  dmask = (1 << state2.distbits) - 1;
  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }
    here = lcode[hold & lmask];
    dolen: for (; ; ) {
      op = here >>> 24;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 255;
      if (op === 0) {
        output[_out++] = here & 65535;
      } else if (op & 16) {
        len = here & 65535;
        op &= 15;
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        }
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];
        dodist: for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op & 16) {
            dist = here & 65535;
            op &= 15;
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & (1 << op) - 1;
            if (dist > dmax) {
              strm.msg = "invalid distance too far back";
              state2.mode = BAD$1;
              break top;
            }
            hold >>>= op;
            bits -= op;
            op = _out - beg;
            if (dist > op) {
              op = dist - op;
              if (op > whave) {
                if (state2.sane) {
                  strm.msg = "invalid distance too far back";
                  state2.mode = BAD$1;
                  break top;
                }
              }
              from2 = 0;
              from_source = s_window;
              if (wnext === 0) {
                from2 += wsize - op;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from2++];
                  } while (--op);
                  from2 = _out - dist;
                  from_source = output;
                }
              } else if (wnext < op) {
                from2 += wsize + wnext - op;
                op -= wnext;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from2++];
                  } while (--op);
                  from2 = 0;
                  if (wnext < len) {
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from2++];
                    } while (--op);
                    from2 = _out - dist;
                    from_source = output;
                  }
                }
              } else {
                from2 += wnext - op;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from2++];
                  } while (--op);
                  from2 = _out - dist;
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from2++];
                output[_out++] = from_source[from2++];
                output[_out++] = from_source[from2++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from2++];
                if (len > 1) {
                  output[_out++] = from_source[from2++];
                }
              }
            } else {
              from2 = _out - dist;
              do {
                output[_out++] = output[from2++];
                output[_out++] = output[from2++];
                output[_out++] = output[from2++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from2++];
                if (len > 1) {
                  output[_out++] = output[from2++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = "invalid distance code";
            state2.mode = BAD$1;
            break top;
          }
          break;
        }
      } else if ((op & 64) === 0) {
        here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        state2.mode = TYPE$1;
        break top;
      } else {
        strm.msg = "invalid literal/length code";
        state2.mode = BAD$1;
        break top;
      }
      break;
    }
  } while (_in < last2 && _out < end2);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end2 ? 257 + (end2 - _out) : 257 - (_out - end2);
  state2.hold = hold;
  state2.bits = bits;
  return;
};
var utils$1 = common;
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
var inftrees = function inflate_table(type, lens, lens_index, codes2, table, table_index, work, opts2) {
  var bits = opts2.bits;
  var len = 0;
  var sym = 0;
  var min2 = 0, max2 = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill4;
  var low;
  var mask;
  var next;
  var base = null;
  var base_index = 0;
  var end2;
  var count = new utils$1.Buf16(MAXBITS + 1);
  var offs = new utils$1.Buf16(MAXBITS + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes2; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max2 = MAXBITS; max2 >= 1; max2--) {
    if (count[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts2.bits = 1;
    return 0;
  }
  for (min2 = 1; min2 < max2; min2++) {
    if (count[min2] !== 0) {
      break;
    }
  }
  if (root < min2) {
    root = min2;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max2 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes2; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    end2 = 19;
  } else if (type === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end2 = 256;
  } else {
    base = dbase;
    extra = dext;
    end2 = -1;
  }
  huff = 0;
  sym = 0;
  len = min2;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end2) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end2) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill4 = 1 << curr;
    min2 = fill4;
    do {
      fill4 -= incr;
      table[next + (huff >> drop) + fill4] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill4 !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max2) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min2;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts2.bits = root;
  return 0;
};
var utils = common;
var adler32 = adler32_1;
var crc32 = crc32_1;
var inflate_fast2 = inffast;
var inflate_table2 = inftrees;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
var Z_DEFLATED = 8;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
function zswap32(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new utils.Buf16(320);
  this.work = new utils.Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  strm.total_in = strm.total_out = state2.total = 0;
  strm.msg = "";
  if (state2.wrap) {
    strm.adler = state2.wrap & 1;
  }
  state2.mode = HEAD;
  state2.last = 0;
  state2.havedict = 0;
  state2.dmax = 32768;
  state2.head = null;
  state2.hold = 0;
  state2.bits = 0;
  state2.lencode = state2.lendyn = new utils.Buf32(ENOUGH_LENS);
  state2.distcode = state2.distdyn = new utils.Buf32(ENOUGH_DISTS);
  state2.sane = 1;
  state2.back = -1;
  return Z_OK;
}
function inflateReset(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  state2.wsize = 0;
  state2.whave = 0;
  state2.wnext = 0;
  return inflateResetKeep(strm);
}
function inflateReset2(strm, windowBits) {
  var wrap;
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state2.window !== null && state2.wbits !== windowBits) {
    state2.window = null;
  }
  state2.wrap = wrap;
  state2.wbits = windowBits;
  return inflateReset(strm);
}
function inflateInit2(strm, windowBits) {
  var ret;
  var state2;
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  state2 = new InflateState();
  strm.state = state2;
  state2.window = null;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null;
  }
  return ret;
}
function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}
var virgin = true;
var lenfix, distfix;
function fixedtables(state2) {
  if (virgin) {
    var sym;
    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);
    sym = 0;
    while (sym < 144) {
      state2.lens[sym++] = 8;
    }
    while (sym < 256) {
      state2.lens[sym++] = 9;
    }
    while (sym < 280) {
      state2.lens[sym++] = 7;
    }
    while (sym < 288) {
      state2.lens[sym++] = 8;
    }
    inflate_table2(LENS, state2.lens, 0, 288, lenfix, 0, state2.work, {
      bits: 9
    });
    sym = 0;
    while (sym < 32) {
      state2.lens[sym++] = 5;
    }
    inflate_table2(DISTS, state2.lens, 0, 32, distfix, 0, state2.work, {
      bits: 5
    });
    virgin = false;
  }
  state2.lencode = lenfix;
  state2.lenbits = 9;
  state2.distcode = distfix;
  state2.distbits = 5;
}
function updatewindow(strm, src2, end2, copy5) {
  var dist;
  var state2 = strm.state;
  if (state2.window === null) {
    state2.wsize = 1 << state2.wbits;
    state2.wnext = 0;
    state2.whave = 0;
    state2.window = new utils.Buf8(state2.wsize);
  }
  if (copy5 >= state2.wsize) {
    utils.arraySet(state2.window, src2, end2 - state2.wsize, state2.wsize, 0);
    state2.wnext = 0;
    state2.whave = state2.wsize;
  } else {
    dist = state2.wsize - state2.wnext;
    if (dist > copy5) {
      dist = copy5;
    }
    utils.arraySet(state2.window, src2, end2 - copy5, dist, state2.wnext);
    copy5 -= dist;
    if (copy5) {
      utils.arraySet(state2.window, src2, end2 - copy5, copy5, 0);
      state2.wnext = copy5;
      state2.whave = state2.wsize;
    } else {
      state2.wnext += dist;
      if (state2.wnext === state2.wsize) {
        state2.wnext = 0;
      }
      if (state2.whave < state2.wsize) {
        state2.whave += dist;
      }
    }
  }
  return 0;
}
function inflate(strm, flush) {
  var state2;
  var input, output;
  var next;
  var put;
  var have, left;
  var hold;
  var bits;
  var _in, _out;
  var copy5;
  var from2;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len;
  var ret;
  var hbuf = new utils.Buf8(4);
  var opts2;
  var n3;
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (state2.mode === TYPE) {
    state2.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state2.hold;
  bits = state2.bits;
  _in = have;
  _out = left;
  ret = Z_OK;
  inf_leave:
    for (; ; ) {
      switch (state2.mode) {
        case HEAD:
          if (state2.wrap === 0) {
            state2.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.wrap & 2 && hold === 35615) {
            state2.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state2.mode = FLAGS;
            break;
          }
          state2.flags = 0;
          if (state2.head) {
            state2.head.done = false;
          }
          if (!(state2.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state2.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state2.wbits === 0) {
            state2.wbits = len;
          } else if (len > state2.wbits) {
            strm.msg = "invalid window size";
            state2.mode = BAD;
            break;
          }
          state2.dmax = 1 << len;
          strm.adler = state2.check = 1;
          state2.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.flags = hold;
          if ((state2.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          if (state2.flags & 57344) {
            strm.msg = "unknown header flags set";
            state2.mode = BAD;
            break;
          }
          if (state2.head) {
            state2.head.text = hold >> 8 & 1;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.time = hold;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state2.check = crc32(state2.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.xflags = hold & 255;
            state2.head.os = hold >> 8;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state2.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length = hold;
            if (state2.head) {
              state2.head.extra_len = hold;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state2.head) {
            state2.head.extra = null;
          }
          state2.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state2.flags & 1024) {
            copy5 = state2.length;
            if (copy5 > have) {
              copy5 = have;
            }
            if (copy5) {
              if (state2.head) {
                len = state2.head.extra_len - state2.length;
                if (!state2.head.extra) {
                  state2.head.extra = new Array(state2.head.extra_len);
                }
                utils.arraySet(
                  state2.head.extra,
                  input,
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  copy5,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state2.flags & 512) {
                state2.check = crc32(state2.check, input, copy5, next);
              }
              have -= copy5;
              next += copy5;
              state2.length -= copy5;
            }
            if (state2.length) {
              break inf_leave;
            }
          }
          state2.length = 0;
          state2.mode = NAME;
        /* falls through */
        case NAME:
          if (state2.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy5 = 0;
            do {
              len = input[next + copy5++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.name += String.fromCharCode(len);
              }
            } while (len && copy5 < have);
            if (state2.flags & 512) {
              state2.check = crc32(state2.check, input, copy5, next);
            }
            have -= copy5;
            next += copy5;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.name = null;
          }
          state2.length = 0;
          state2.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state2.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy5 = 0;
            do {
              len = input[next + copy5++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.comment += String.fromCharCode(len);
              }
            } while (len && copy5 < have);
            if (state2.flags & 512) {
              state2.check = crc32(state2.check, input, copy5, next);
            }
            have -= copy5;
            next += copy5;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.comment = null;
          }
          state2.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state2.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state2.check & 65535)) {
              strm.msg = "header crc mismatch";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state2.head) {
            state2.head.hcrc = state2.flags >> 9 & 1;
            state2.head.done = true;
          }
          strm.adler = state2.check = 0;
          state2.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state2.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state2.mode = DICT;
        /* falls through */
        case DICT:
          if (state2.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            return Z_NEED_DICT;
          }
          strm.adler = state2.check = 1;
          state2.mode = TYPE;
        /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state2.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state2.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state2.mode = STORED;
              break;
            case 1:
              fixedtables(state2);
              state2.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state2.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state2.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state2.mode = BAD;
            break;
          }
          state2.length = hold & 65535;
          hold = 0;
          bits = 0;
          state2.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state2.mode = COPY;
        /* falls through */
        case COPY:
          copy5 = state2.length;
          if (copy5) {
            if (copy5 > have) {
              copy5 = have;
            }
            if (copy5 > left) {
              copy5 = left;
            }
            if (copy5 === 0) {
              break inf_leave;
            }
            utils.arraySet(output, input, next, copy5, put);
            have -= copy5;
            next += copy5;
            left -= copy5;
            put += copy5;
            state2.length -= copy5;
            break;
          }
          state2.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state2.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state2.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state2.nlen > 286 || state2.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state2.have < state2.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.lens[order[state2.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state2.have < 19) {
            state2.lens[order[state2.have++]] = 0;
          }
          state2.lencode = state2.lendyn;
          state2.lenbits = 7;
          opts2 = {
            bits: state2.lenbits
          };
          ret = inflate_table2(CODES, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts2);
          state2.lenbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state2.have < state2.nlen + state2.ndist) {
            for (; ; ) {
              here = state2.lencode[hold & (1 << state2.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state2.lens[state2.have++] = here_val;
            } else {
              if (here_val === 16) {
                n3 = here_bits + 2;
                while (bits < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state2.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state2.mode = BAD;
                  break;
                }
                len = state2.lens[state2.have - 1];
                copy5 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n3 = here_bits + 3;
                while (bits < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy5 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n3 = here_bits + 7;
                while (bits < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy5 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state2.have + copy5 > state2.nlen + state2.ndist) {
                strm.msg = "invalid bit length repeat";
                state2.mode = BAD;
                break;
              }
              while (copy5--) {
                state2.lens[state2.have++] = len;
              }
            }
          }
          if (state2.mode === BAD) {
            break;
          }
          if (state2.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state2.mode = BAD;
            break;
          }
          state2.lenbits = 9;
          opts2 = {
            bits: state2.lenbits
          };
          ret = inflate_table2(LENS, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts2);
          state2.lenbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state2.mode = BAD;
            break;
          }
          state2.distbits = 6;
          state2.distcode = state2.distdyn;
          opts2 = {
            bits: state2.distbits
          };
          ret = inflate_table2(DISTS, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts2);
          state2.distbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state2.mode = BAD;
            break;
          }
          state2.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state2.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            inflate_fast2(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state2.hold;
            bits = state2.bits;
            if (state2.mode === TYPE) {
              state2.back = -1;
            }
            break;
          }
          state2.back = 0;
          for (; ; ) {
            here = state2.lencode[hold & (1 << state2.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          state2.length = here_val;
          if (here_op === 0) {
            state2.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state2.back = -1;
            state2.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD;
            break;
          }
          state2.extra = here_op & 15;
          state2.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state2.extra) {
            n3 = state2.extra;
            while (bits < n3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          state2.was = state2.length;
          state2.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state2.distcode[hold & (1 << state2.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state2.mode = BAD;
            break;
          }
          state2.offset = here_val;
          state2.extra = here_op & 15;
          state2.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state2.extra) {
            n3 = state2.extra;
            while (bits < n3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.offset += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          if (state2.offset > state2.dmax) {
            strm.msg = "invalid distance too far back";
            state2.mode = BAD;
            break;
          }
          state2.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy5 = _out - left;
          if (state2.offset > copy5) {
            copy5 = state2.offset - copy5;
            if (copy5 > state2.whave) {
              if (state2.sane) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD;
                break;
              }
            }
            if (copy5 > state2.wnext) {
              copy5 -= state2.wnext;
              from2 = state2.wsize - copy5;
            } else {
              from2 = state2.wnext - copy5;
            }
            if (copy5 > state2.length) {
              copy5 = state2.length;
            }
            from_source = state2.window;
          } else {
            from_source = output;
            from2 = put - state2.offset;
            copy5 = state2.length;
          }
          if (copy5 > left) {
            copy5 = left;
          }
          left -= copy5;
          state2.length -= copy5;
          do {
            output[put++] = from_source[from2++];
          } while (--copy5);
          if (state2.length === 0) {
            state2.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state2.length;
          left--;
          state2.mode = LEN;
          break;
        case CHECK:
          if (state2.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state2.total += _out;
            if (_out) {
              strm.adler = state2.check = /*UPDATE(state.check, put - _out, _out);*/
              state2.flags ? crc32(state2.check, output, _out, put - _out) : adler32(state2.check, output, _out, put - _out);
            }
            _out = left;
            if ((state2.flags ? hold : zswap32(hold)) !== state2.check) {
              strm.msg = "incorrect data check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state2.wrap && state2.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state2.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state2.hold = hold;
  state2.bits = bits;
  if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD && (state2.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state2.total += _out;
  if (state2.wrap && _out) {
    strm.adler = state2.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state2.flags ? crc32(state2.check, output, _out, strm.next_out - _out) : adler32(state2.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE ? 128 : 0) + (state2.mode === LEN_ || state2.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}
function inflateEnd(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  var state2 = strm.state;
  if (state2.window) {
    state2.window = null;
  }
  strm.state = null;
  return Z_OK;
}
function inflateGetHeader(strm, head) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if ((state2.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }
  state2.head = head;
  head.done = false;
  return Z_OK;
}
function inflateSetDictionary(strm, dictionary2) {
  var dictLength = dictionary2.length;
  var state2;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (state2.wrap !== 0 && state2.mode !== DICT) {
    return Z_STREAM_ERROR;
  }
  if (state2.mode === DICT) {
    dictid = 1;
    dictid = adler32(dictid, dictionary2, dictLength, 0);
    if (dictid !== state2.check) {
      return Z_DATA_ERROR;
    }
  }
  ret = updatewindow(strm, dictionary2, dictLength, dictLength);
  if (ret) {
    state2.mode = MEM;
    return Z_MEM_ERROR;
  }
  state2.havedict = 1;
  return Z_OK;
}
inflate$1.inflateReset = inflateReset;
inflate$1.inflateReset2 = inflateReset2;
inflate$1.inflateResetKeep = inflateResetKeep;
inflate$1.inflateInit = inflateInit;
inflate$1.inflateInit2 = inflateInit2;
inflate$1.inflate = inflate;
inflate$1.inflateEnd = inflateEnd;
inflate$1.inflateGetHeader = inflateGetHeader;
inflate$1.inflateSetDictionary = inflateSetDictionary;
inflate$1.inflateInfo = "pako inflate (from Nodeca project)";
var constants$1 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
(function(exports) {
  var assert2 = require$$4$1;
  var Zstream = zstream;
  var zlib_deflate = deflate$1;
  var zlib_inflate = inflate$1;
  var constants$1$1 = constants$1;
  for (var key in constants$1$1) {
    exports[key] = constants$1$1[key];
  }
  exports.NONE = 0;
  exports.DEFLATE = 1;
  exports.INFLATE = 2;
  exports.GZIP = 3;
  exports.GUNZIP = 4;
  exports.DEFLATERAW = 5;
  exports.INFLATERAW = 6;
  exports.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib(mode) {
    if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  Zlib.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert2(this.init_done, "close before init");
    assert2(this.mode <= exports.UNZIP);
    if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports.NONE;
    this.dictionary = null;
  };
  Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert2.equal(arguments.length, 8);
    assert2(this.init_done, "write before init");
    assert2(this.mode !== exports.NONE, "already finalized");
    assert2.equal(false, this.write_in_progress, "write already in progress");
    assert2.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert2.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer$4.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    browser$1$2.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports.INFLATE;
              break;
            }
          // fallthrough
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports.GUNZIP;
            } else {
              this.mode = exports.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      // fallthrough
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports.Z_DATA_ERROR) {
            this.err = exports.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib.prototype._checkError = function() {
    switch (this.err) {
      case exports.Z_OK:
      case exports.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports.Z_STREAM_END:
        break;
      case exports.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary2) {
    assert2(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert2(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert2(level >= -1 && level <= 9, "invalid compression level");
    assert2(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert2(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary2);
    this._setDictionary();
  };
  Zlib.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary2) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports.Z_NO_FLUSH;
    this.err = exports.Z_OK;
    if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
      case exports.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary2;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib.prototype._reset = function() {
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
      case exports.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports.INFLATE:
      case exports.INFLATERAW:
      case exports.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports.Zlib = Zlib;
})(binding$2);
var require$$3$1 = /* @__PURE__ */ getAugmentedNamespace$1(_polyfillNode_util$1$1);
(function(exports) {
  var Buffer2 = require$$0$1.Buffer;
  var Transform2 = require$$1$2.Transform;
  var binding$12 = binding$2;
  var util = require$$3$1;
  var assert2 = require$$4$1.ok;
  var kMaxLength2 = require$$0$1.kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength2.toString(16) + " bytes";
  binding$12.Z_MIN_WINDOWBITS = 8;
  binding$12.Z_MAX_WINDOWBITS = 15;
  binding$12.Z_DEFAULT_WINDOWBITS = 15;
  binding$12.Z_MIN_CHUNK = 64;
  binding$12.Z_MAX_CHUNK = Infinity;
  binding$12.Z_DEFAULT_CHUNK = 16 * 1024;
  binding$12.Z_MIN_MEMLEVEL = 1;
  binding$12.Z_MAX_MEMLEVEL = 9;
  binding$12.Z_DEFAULT_MEMLEVEL = 8;
  binding$12.Z_MIN_LEVEL = -1;
  binding$12.Z_MAX_LEVEL = 9;
  binding$12.Z_DEFAULT_LEVEL = binding$12.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding$12);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports, bkey, {
        enumerable: true,
        value: binding$12[bkey],
        writable: false
      });
    }
  }
  var codes2 = {
    Z_OK: binding$12.Z_OK,
    Z_STREAM_END: binding$12.Z_STREAM_END,
    Z_NEED_DICT: binding$12.Z_NEED_DICT,
    Z_ERRNO: binding$12.Z_ERRNO,
    Z_STREAM_ERROR: binding$12.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding$12.Z_DATA_ERROR,
    Z_MEM_ERROR: binding$12.Z_MEM_ERROR,
    Z_BUF_ERROR: binding$12.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding$12.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes2);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes2[codes2[ckey]] = ckey;
  }
  Object.defineProperty(exports, "codes", {
    enumerable: true,
    value: Object.freeze(codes2),
    writable: false
  });
  exports.Deflate = Deflate;
  exports.Inflate = Inflate;
  exports.Gzip = Gzip;
  exports.Gunzip = Gunzip;
  exports.DeflateRaw = DeflateRaw;
  exports.InflateRaw = InflateRaw;
  exports.Unzip = Unzip;
  exports.createDeflate = function(o2) {
    return new Deflate(o2);
  };
  exports.createInflate = function(o2) {
    return new Inflate(o2);
  };
  exports.createDeflateRaw = function(o2) {
    return new DeflateRaw(o2);
  };
  exports.createInflateRaw = function(o2) {
    return new InflateRaw(o2);
  };
  exports.createGzip = function(o2) {
    return new Gzip(o2);
  };
  exports.createGunzip = function(o2) {
    return new Gunzip(o2);
  };
  exports.createUnzip = function(o2) {
    return new Unzip(o2);
  };
  exports.deflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Deflate(opts2), buffer, callback);
  };
  exports.deflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Deflate(opts2), buffer);
  };
  exports.gzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gzip(opts2), buffer, callback);
  };
  exports.gzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gzip(opts2), buffer);
  };
  exports.deflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new DeflateRaw(opts2), buffer, callback);
  };
  exports.deflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new DeflateRaw(opts2), buffer);
  };
  exports.unzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Unzip(opts2), buffer, callback);
  };
  exports.unzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Unzip(opts2), buffer);
  };
  exports.inflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Inflate(opts2), buffer, callback);
  };
  exports.inflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Inflate(opts2), buffer);
  };
  exports.gunzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gunzip(opts2), buffer, callback);
  };
  exports.gunzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gunzip(opts2), buffer);
  };
  exports.inflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new InflateRaw(opts2), buffer, callback);
  };
  exports.inflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new InflateRaw(opts2), buffer);
  };
  function zlibBuffer(engine2, buffer, callback) {
    var buffers = [];
    var nread = 0;
    engine2.on("error", onError);
    engine2.on("end", onEnd);
    engine2.end(buffer);
    flow2();
    function flow2() {
      var chunk;
      while (null !== (chunk = engine2.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine2.once("readable", flow2);
    }
    function onError(err2) {
      engine2.removeListener("end", onEnd);
      engine2.removeListener("readable", flow2);
      callback(err2);
    }
    function onEnd() {
      var buf;
      var err2 = null;
      if (nread >= kMaxLength2) {
        err2 = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer2.concat(buffers, nread);
      }
      buffers = [];
      engine2.close();
      callback(err2, buf);
    }
  }
  function zlibBufferSync(engine2, buffer) {
    if (typeof buffer === "string") buffer = Buffer2.from(buffer);
    if (!Buffer2.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
    var flushFlag = engine2._finishFlushFlag;
    return engine2._processChunk(buffer, flushFlag);
  }
  function Deflate(opts2) {
    if (!(this instanceof Deflate)) return new Deflate(opts2);
    Zlib.call(this, opts2, binding$12.DEFLATE);
  }
  function Inflate(opts2) {
    if (!(this instanceof Inflate)) return new Inflate(opts2);
    Zlib.call(this, opts2, binding$12.INFLATE);
  }
  function Gzip(opts2) {
    if (!(this instanceof Gzip)) return new Gzip(opts2);
    Zlib.call(this, opts2, binding$12.GZIP);
  }
  function Gunzip(opts2) {
    if (!(this instanceof Gunzip)) return new Gunzip(opts2);
    Zlib.call(this, opts2, binding$12.GUNZIP);
  }
  function DeflateRaw(opts2) {
    if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts2);
    Zlib.call(this, opts2, binding$12.DEFLATERAW);
  }
  function InflateRaw(opts2) {
    if (!(this instanceof InflateRaw)) return new InflateRaw(opts2);
    Zlib.call(this, opts2, binding$12.INFLATERAW);
  }
  function Unzip(opts2) {
    if (!(this instanceof Unzip)) return new Unzip(opts2);
    Zlib.call(this, opts2, binding$12.UNZIP);
  }
  function isValidFlushFlag(flag) {
    return flag === binding$12.Z_NO_FLUSH || flag === binding$12.Z_PARTIAL_FLUSH || flag === binding$12.Z_SYNC_FLUSH || flag === binding$12.Z_FULL_FLUSH || flag === binding$12.Z_FINISH || flag === binding$12.Z_BLOCK;
  }
  function Zlib(opts2, mode) {
    var _this = this;
    this._opts = opts2 = opts2 || {};
    this._chunkSize = opts2.chunkSize || exports.Z_DEFAULT_CHUNK;
    Transform2.call(this, opts2);
    if (opts2.flush && !isValidFlushFlag(opts2.flush)) {
      throw new Error("Invalid flush flag: " + opts2.flush);
    }
    if (opts2.finishFlush && !isValidFlushFlag(opts2.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts2.finishFlush);
    }
    this._flushFlag = opts2.flush || binding$12.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts2.finishFlush !== "undefined" ? opts2.finishFlush : binding$12.Z_FINISH;
    if (opts2.chunkSize) {
      if (opts2.chunkSize < exports.Z_MIN_CHUNK || opts2.chunkSize > exports.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts2.chunkSize);
      }
    }
    if (opts2.windowBits) {
      if (opts2.windowBits < exports.Z_MIN_WINDOWBITS || opts2.windowBits > exports.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts2.windowBits);
      }
    }
    if (opts2.level) {
      if (opts2.level < exports.Z_MIN_LEVEL || opts2.level > exports.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts2.level);
      }
    }
    if (opts2.memLevel) {
      if (opts2.memLevel < exports.Z_MIN_MEMLEVEL || opts2.memLevel > exports.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts2.memLevel);
      }
    }
    if (opts2.strategy) {
      if (opts2.strategy != exports.Z_FILTERED && opts2.strategy != exports.Z_HUFFMAN_ONLY && opts2.strategy != exports.Z_RLE && opts2.strategy != exports.Z_FIXED && opts2.strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts2.strategy);
      }
    }
    if (opts2.dictionary) {
      if (!Buffer2.isBuffer(opts2.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding$12.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
      _close(self2);
      self2._hadError = true;
      var error = new Error(message);
      error.errno = errno;
      error.code = exports.codes[errno];
      self2.emit("error", error);
    };
    var level = exports.Z_DEFAULT_COMPRESSION;
    if (typeof opts2.level === "number") level = opts2.level;
    var strategy = exports.Z_DEFAULT_STRATEGY;
    if (typeof opts2.strategy === "number") strategy = opts2.strategy;
    this._handle.init(opts2.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts2.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts2.dictionary);
    this._buffer = Buffer2.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: function() {
        return !_this._handle;
      },
      configurable: true,
      enumerable: true
    });
  }
  util.inherits(Zlib, Transform2);
  Zlib.prototype.params = function(level, strategy, callback) {
    if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding$12.Z_SYNC_FLUSH, function() {
        assert2(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback) callback();
        }
      });
    } else {
      browser$1$2.nextTick(callback);
    }
  };
  Zlib.prototype.reset = function() {
    assert2(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib.prototype._flush = function(callback) {
    this._transform(Buffer2.alloc(0), "", callback);
  };
  Zlib.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding$12.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback) browser$1$2.nextTick(callback);
    } else if (ws.ending) {
      if (callback) this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer2.alloc(0), "", callback);
    }
  };
  Zlib.prototype.close = function(callback) {
    _close(this, callback);
    browser$1$2.nextTick(emitCloseNT2, this);
  };
  function _close(engine2, callback) {
    if (callback) browser$1$2.nextTick(callback);
    if (!engine2._handle) return;
    engine2._handle.close();
    engine2._handle = null;
  }
  function emitCloseNT2(self2) {
    self2.emit("close");
  }
  Zlib.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last2 = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer2.isBuffer(chunk)) return cb(new Error("invalid input"));
    if (!this._handle) return cb(new Error("zlib binding closed"));
    if (last2) flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding$12.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(er) {
        error = er;
      });
      assert2(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength2) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer2.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert2(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError) return;
      var have = availOutBefore - availOutAfter;
      assert2(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer2.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async) return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async) return false;
      cb();
    }
  };
  util.inherits(Deflate, Zlib);
  util.inherits(Inflate, Zlib);
  util.inherits(Gzip, Zlib);
  util.inherits(Gunzip, Zlib);
  util.inherits(DeflateRaw, Zlib);
  util.inherits(InflateRaw, Zlib);
  util.inherits(Unzip, Zlib);
})(lib$1);
var zlib$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(lib$1);
let PNG$1 = class PNG {
  static decode(path, fn) {
    {
      throw new Error("PNG.decode not available in browser build");
    }
  }
  static load(path) {
    {
      throw new Error("PNG.load not available in browser build");
    }
  }
  constructor(data2) {
    let i2;
    this.data = data2;
    this.pos = 8;
    this.palette = [];
    this.imgData = [];
    this.transparency = {};
    this.text = {};
    while (true) {
      const chunkSize = this.readUInt32();
      let section = "";
      for (i2 = 0; i2 < 4; i2++) {
        section += String.fromCharCode(this.data[this.pos++]);
      }
      switch (section) {
        case "IHDR":
          this.width = this.readUInt32();
          this.height = this.readUInt32();
          this.bits = this.data[this.pos++];
          this.colorType = this.data[this.pos++];
          this.compressionMethod = this.data[this.pos++];
          this.filterMethod = this.data[this.pos++];
          this.interlaceMethod = this.data[this.pos++];
          break;
        case "PLTE":
          this.palette = this.read(chunkSize);
          break;
        case "IDAT":
          for (i2 = 0; i2 < chunkSize; i2++) {
            this.imgData.push(this.data[this.pos++]);
          }
          break;
        case "tRNS":
          this.transparency = {};
          switch (this.colorType) {
            case 3:
              this.transparency.indexed = this.read(chunkSize);
              var short = 255 - this.transparency.indexed.length;
              if (short > 0) {
                for (i2 = 0; i2 < short; i2++) {
                  this.transparency.indexed.push(255);
                }
              }
              break;
            case 0:
              this.transparency.grayscale = this.read(chunkSize)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(chunkSize);
              break;
          }
          break;
        case "tEXt":
          var text = this.read(chunkSize);
          var index2 = text.indexOf(0);
          var key = String.fromCharCode.apply(String, text.slice(0, index2));
          this.text[key] = String.fromCharCode.apply(String, text.slice(index2 + 1));
          break;
        case "IEND":
          switch (this.colorType) {
            case 0:
            case 3:
            case 4:
              this.colors = 1;
              break;
            case 2:
            case 6:
              this.colors = 3;
              break;
          }
          this.hasAlphaChannel = [4, 6].includes(this.colorType);
          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
          this.pixelBitlength = this.bits * colors;
          switch (this.colors) {
            case 1:
              this.colorSpace = "DeviceGray";
              break;
            case 3:
              this.colorSpace = "DeviceRGB";
              break;
          }
          this.imgData = Buffer$4.from(this.imgData);
          return;
        default:
          this.pos += chunkSize;
      }
      this.pos += 4;
      if (this.pos > this.data.length) {
        throw new Error("Incomplete or corrupt PNG file");
      }
    }
  }
  read(bytes) {
    const result = new Array(bytes);
    for (let i2 = 0; i2 < bytes; i2++) {
      result[i2] = this.data[this.pos++];
    }
    return result;
  }
  readUInt32() {
    const b1 = this.data[this.pos++] << 24;
    const b2 = this.data[this.pos++] << 16;
    const b3 = this.data[this.pos++] << 8;
    const b4 = this.data[this.pos++];
    return b1 | b2 | b3 | b4;
  }
  readUInt16() {
    const b1 = this.data[this.pos++] << 8;
    const b2 = this.data[this.pos++];
    return b1 | b2;
  }
  decodePixels(fn) {
    return zlib$1.inflate(this.imgData, (err2, data2) => {
      if (err2) throw err2;
      var pos = 0;
      const {
        width,
        height: height2
      } = this;
      var pixelBytes = this.pixelBitlength / 8;
      const pixels = Buffer$4.alloc(width * height2 * pixelBytes);
      function pass(x0, y0, dx, dy, singlePass) {
        if (singlePass === void 0) {
          singlePass = false;
        }
        const w = Math.ceil((width - x0) / dx);
        const h = Math.ceil((height2 - y0) / dy);
        const scanlineLength = pixelBytes * w;
        const buffer = singlePass ? pixels : Buffer$4.alloc(scanlineLength * h);
        let row = 0;
        let c2 = 0;
        while (row < h && pos < data2.length) {
          var byte;
          var col;
          var i2;
          var left;
          var upper;
          switch (data2[pos++]) {
            case 0:
              for (i2 = 0; i2 < scanlineLength; i2++) {
                buffer[c2++] = data2[pos++];
              }
              break;
            case 1:
              for (i2 = 0; i2 < scanlineLength; i2++) {
                byte = data2[pos++];
                left = i2 < pixelBytes ? 0 : buffer[c2 - pixelBytes];
                buffer[c2++] = (byte + left) % 256;
              }
              break;
            case 2:
              for (i2 = 0; i2 < scanlineLength; i2++) {
                byte = data2[pos++];
                col = (i2 - i2 % pixelBytes) / pixelBytes;
                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i2 % pixelBytes];
                buffer[c2++] = (upper + byte) % 256;
              }
              break;
            case 3:
              for (i2 = 0; i2 < scanlineLength; i2++) {
                byte = data2[pos++];
                col = (i2 - i2 % pixelBytes) / pixelBytes;
                left = i2 < pixelBytes ? 0 : buffer[c2 - pixelBytes];
                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i2 % pixelBytes];
                buffer[c2++] = (byte + Math.floor((left + upper) / 2)) % 256;
              }
              break;
            case 4:
              for (i2 = 0; i2 < scanlineLength; i2++) {
                var paeth;
                var upperLeft;
                byte = data2[pos++];
                col = (i2 - i2 % pixelBytes) / pixelBytes;
                left = i2 < pixelBytes ? 0 : buffer[c2 - pixelBytes];
                if (row === 0) {
                  upper = upperLeft = 0;
                } else {
                  upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i2 % pixelBytes];
                  upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i2 % pixelBytes];
                }
                const p2 = left + upper - upperLeft;
                const pa = Math.abs(p2 - left);
                const pb = Math.abs(p2 - upper);
                const pc = Math.abs(p2 - upperLeft);
                if (pa <= pb && pa <= pc) {
                  paeth = left;
                } else if (pb <= pc) {
                  paeth = upper;
                } else {
                  paeth = upperLeft;
                }
                buffer[c2++] = (byte + paeth) % 256;
              }
              break;
            default:
              throw new Error(`Invalid filter algorithm: ${data2[pos - 1]}`);
          }
          if (!singlePass) {
            let pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;
            let bufferPos = row * scanlineLength;
            for (i2 = 0; i2 < w; i2++) {
              for (let j = 0; j < pixelBytes; j++) pixels[pixelsPos++] = buffer[bufferPos++];
              pixelsPos += (dx - 1) * pixelBytes;
            }
          }
          row++;
        }
      }
      if (this.interlaceMethod === 1) {
        pass(0, 0, 8, 8);
        pass(4, 0, 8, 8);
        pass(0, 4, 4, 8);
        pass(2, 0, 4, 4);
        pass(0, 2, 2, 4);
        pass(1, 0, 2, 2);
        pass(0, 1, 1, 2);
      } else {
        pass(0, 0, 1, 1, true);
      }
      return fn(pixels);
    });
  }
  decodePalette() {
    const {
      palette
    } = this;
    const {
      length: length2
    } = palette;
    const transparency = this.transparency.indexed || [];
    const ret = Buffer$4.alloc(transparency.length + length2);
    let pos = 0;
    let c2 = 0;
    for (let i2 = 0; i2 < length2; i2 += 3) {
      var left;
      ret[pos++] = palette[i2];
      ret[pos++] = palette[i2 + 1];
      ret[pos++] = palette[i2 + 2];
      ret[pos++] = (left = transparency[c2++]) != null ? left : 255;
    }
    return ret;
  }
  copyToImageData(imageData, pixels) {
    let j;
    var k2;
    let {
      colors
    } = this;
    let palette = null;
    let alpha = this.hasAlphaChannel;
    if (this.palette.length) {
      palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());
      colors = 4;
      alpha = true;
    }
    const data2 = imageData.data || imageData;
    const {
      length: length2
    } = data2;
    const input = palette || pixels;
    let i2 = j = 0;
    if (colors === 1) {
      while (i2 < length2) {
        k2 = palette ? pixels[i2 / 4] * 4 : j;
        const v2 = input[k2++];
        data2[i2++] = v2;
        data2[i2++] = v2;
        data2[i2++] = v2;
        data2[i2++] = alpha ? input[k2++] : 255;
        j = k2;
      }
    } else {
      while (i2 < length2) {
        k2 = palette ? pixels[i2 / 4] * 4 : j;
        data2[i2++] = input[k2++];
        data2[i2++] = input[k2++];
        data2[i2++] = input[k2++];
        data2[i2++] = alpha ? input[k2++] : 255;
        j = k2;
      }
    }
  }
  decode(fn) {
    const ret = Buffer$4.alloc(this.width * this.height * 4);
    return this.decodePixels((pixels) => {
      this.copyToImageData(ret, pixels);
      return fn(ret);
    });
  }
};
var cryptoJs$1 = { exports: {} };
var x64Core$1 = { exports: {} };
var x64Core = x64Core$1.exports;
var hasRequiredX64Core;
function requireX64Core() {
  if (hasRequiredX64Core) return x64Core$1.exports;
  hasRequiredX64Core = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(x64Core, function(CryptoJS2) {
      (function(undefined$1) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        C_x64.Word = Base2.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        C_x64.WordArray = Base2.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i2 = 0; i2 < x64WordsLength; i2++) {
              var x64Word = x64Words[i2];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone2 = Base2.clone.call(this);
            var words = clone2.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i2 = 0; i2 < wordsLength; i2++) {
              words[i2] = words[i2].clone();
            }
            return clone2;
          }
        });
      })();
      return CryptoJS2;
    });
  })(x64Core$1);
  return x64Core$1.exports;
}
var libTypedarrays$1 = { exports: {} };
var libTypedarrays = libTypedarrays$1.exports;
var hasRequiredLibTypedarrays;
function requireLibTypedarrays() {
  if (hasRequiredLibTypedarrays) return libTypedarrays$1.exports;
  hasRequiredLibTypedarrays = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(libTypedarrays, function(CryptoJS2) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i2 = 0; i2 < typedArrayByteLength; i2++) {
              words[i2 >>> 2] |= typedArray[i2] << 24 - i2 % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS2.lib.WordArray;
    });
  })(libTypedarrays$1);
  return libTypedarrays$1.exports;
}
var encUtf16$1 = { exports: {} };
var encUtf16 = encUtf16$1.exports;
var hasRequiredEncUtf16;
function requireEncUtf16() {
  if (hasRequiredEncUtf16) return encUtf16$1.exports;
  hasRequiredEncUtf16 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(encUtf16, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 2) {
              var codePoint = words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i2 = 0; i2 < utf16StrLength; i2++) {
              words[i2 >>> 1] |= utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 2) {
              var codePoint = swapEndian(words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i2 = 0; i2 < utf16StrLength; i2++) {
              words[i2 >>> 1] |= swapEndian(utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS2.enc.Utf16;
    });
  })(encUtf16$1);
  return encUtf16$1.exports;
}
var encBase64$1 = { exports: {} };
var encBase64 = encBase64$1.exports;
var hasRequiredEncBase64;
function requireEncBase64() {
  if (hasRequiredEncBase64) return encBase64$1.exports;
  hasRequiredEncBase64 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(encBase64, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 3) {
              var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
              var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i2 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i2 = 0; i2 < base64StrLength; i2++) {
            if (i2 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64;
    });
  })(encBase64$1);
  return encBase64$1.exports;
}
var encBase64url$1 = { exports: {} };
var encBase64url = encBase64url$1.exports;
var hasRequiredEncBase64url;
function requireEncBase64url() {
  if (hasRequiredEncBase64url) return encBase64url$1.exports;
  hasRequiredEncBase64url = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(encBase64url, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        C_enc.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(wordArray, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 3) {
              var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
              var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i2 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(base64Str, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var base64StrLength = base64Str.length;
            var map = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i2 = 0; i2 < base64StrLength; i2++) {
            if (i2 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64url;
    });
  })(encBase64url$1);
  return encBase64url$1.exports;
}
var sha1$1 = { exports: {} };
var sha1 = sha1$1.exports;
var hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1$1.exports;
  hasRequiredSha1 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(sha1, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset2) {
            var H = this._hash.words;
            var a2 = H[0];
            var b2 = H[1];
            var c2 = H[2];
            var d2 = H[3];
            var e2 = H[4];
            for (var i2 = 0; i2 < 80; i2++) {
              if (i2 < 16) {
                W[i2] = M[offset2 + i2] | 0;
              } else {
                var n3 = W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16];
                W[i2] = n3 << 1 | n3 >>> 31;
              }
              var t2 = (a2 << 5 | a2 >>> 27) + e2 + W[i2];
              if (i2 < 20) {
                t2 += (b2 & c2 | ~b2 & d2) + 1518500249;
              } else if (i2 < 40) {
                t2 += (b2 ^ c2 ^ d2) + 1859775393;
              } else if (i2 < 60) {
                t2 += (b2 & c2 | b2 & d2 | c2 & d2) - 1894007588;
              } else {
                t2 += (b2 ^ c2 ^ d2) - 899497514;
              }
              e2 = d2;
              d2 = c2;
              c2 = b2 << 30 | b2 >>> 2;
              b2 = a2;
              a2 = t2;
            }
            H[0] = H[0] + a2 | 0;
            H[1] = H[1] + b2 | 0;
            H[2] = H[2] + c2 | 0;
            H[3] = H[3] + d2 | 0;
            H[4] = H[4] + e2 | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS2.SHA1;
    });
  })(sha1$1);
  return sha1$1.exports;
}
var sha256$1 = { exports: {} };
var sha256 = sha256$1.exports;
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$1.exports;
  hasRequiredSha256 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(sha256, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n4) {
            var sqrtN = Math2.sqrt(n4);
            for (var factor2 = 2; factor2 <= sqrtN; factor2++) {
              if (!(n4 % factor2)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n4) {
            return (n4 - (n4 | 0)) * 4294967296 | 0;
          }
          var n3 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n3)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n3, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n3, 1 / 3));
              nPrime++;
            }
            n3++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset2) {
            var H2 = this._hash.words;
            var a2 = H2[0];
            var b2 = H2[1];
            var c2 = H2[2];
            var d2 = H2[3];
            var e2 = H2[4];
            var f2 = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i2 = 0; i2 < 64; i2++) {
              if (i2 < 16) {
                W[i2] = M[offset2 + i2] | 0;
              } else {
                var gamma0x = W[i2 - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i2 - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i2] = gamma0 + W[i2 - 7] + gamma1 + W[i2 - 16];
              }
              var ch = e2 & f2 ^ ~e2 & g;
              var maj = a2 & b2 ^ a2 & c2 ^ b2 & c2;
              var sigma0 = (a2 << 30 | a2 >>> 2) ^ (a2 << 19 | a2 >>> 13) ^ (a2 << 10 | a2 >>> 22);
              var sigma1 = (e2 << 26 | e2 >>> 6) ^ (e2 << 21 | e2 >>> 11) ^ (e2 << 7 | e2 >>> 25);
              var t1 = h + sigma1 + ch + K[i2] + W[i2];
              var t2 = sigma0 + maj;
              h = g;
              g = f2;
              f2 = e2;
              e2 = d2 + t1 | 0;
              d2 = c2;
              c2 = b2;
              b2 = a2;
              a2 = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a2 | 0;
            H2[1] = H2[1] + b2 | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d2 | 0;
            H2[4] = H2[4] + e2 | 0;
            H2[5] = H2[5] + f2 | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS2.SHA256;
    });
  })(sha256$1);
  return sha256$1.exports;
}
var sha224$1 = { exports: {} };
var sha224 = sha224$1.exports;
var hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1.exports;
  hasRequiredSha224 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireSha256());
      }
    })(sha224, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C.SHA224 = SHA256._createHelper(SHA224);
        C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS2.SHA224;
    });
  })(sha224$1);
  return sha224$1.exports;
}
var sha512$1 = { exports: {} };
var sha512 = sha512$1.exports;
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$1.exports;
  hasRequiredSha512 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireX64Core());
      }
    })(sha512, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i2 = 0; i2 < 80; i2++) {
            W[i2] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M, offset2) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i2 = 0; i2 < 80; i2++) {
              var Wil;
              var Wih;
              var Wi = W[i2];
              if (i2 < 16) {
                Wih = Wi.high = M[offset2 + i2 * 2] | 0;
                Wil = Wi.low = M[offset2 + i2 * 2 + 1] | 0;
              } else {
                var gamma0x = W[i2 - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i2 - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i2 - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i2 - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i2];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          },
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS2.SHA512;
    });
  })(sha512$1);
  return sha512$1.exports;
}
var sha384$1 = { exports: {} };
var sha384 = sha384$1.exports;
var hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1.exports;
  hasRequiredSha384 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireX64Core(), requireSha512());
      }
    })(sha384, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS2.SHA384;
    });
  })(sha384$1);
  return sha384$1.exports;
}
var sha3$1 = { exports: {} };
var sha3 = sha3$1.exports;
var hasRequiredSha3;
function requireSha3() {
  if (hasRequiredSha3) return sha3$1.exports;
  hasRequiredSha3 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireX64Core());
      }
    })(sha3, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y2 = 0;
          for (var t2 = 0; t2 < 24; t2++) {
            RHO_OFFSETS[x + 5 * y2] = (t2 + 1) * (t2 + 2) / 2 % 64;
            var newX = y2 % 5;
            var newY = (2 * x + 3 * y2) % 5;
            x = newX;
            y2 = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y2 = 0; y2 < 5; y2++) {
              PI_INDEXES[x + 5 * y2] = y2 + (2 * x + 3 * y2) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i2 = 0; i2 < 24; i2++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i2] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i2 = 0; i2 < 25; i2++) {
            T[i2] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state2 = this._state = [];
            for (var i2 = 0; i2 < 25; i2++) {
              state2[i2] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M, offset2) {
            var state2 = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i2 = 0; i2 < nBlockSizeLanes; i2++) {
              var M2i = M[offset2 + 2 * i2];
              var M2i1 = M[offset2 + 2 * i2 + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state2[i2];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y2 = 0; y2 < 5; y2++) {
                  var lane = state2[x + 5 * y2];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y2 = 0; y2 < 5; y2++) {
                  var lane = state2[x + 5 * y2];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state2[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state2[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y2 = 0; y2 < 5; y2++) {
                  var laneIndex = x + 5 * y2;
                  var lane = state2[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y2];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y2];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state2[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            var state2 = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i2 = 0; i2 < outputLengthLanes; i2++) {
              var lane = state2[i2];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            var state2 = clone2._state = this._state.slice(0);
            for (var i2 = 0; i2 < 25; i2++) {
              state2[i2] = state2[i2].clone();
            }
            return clone2;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS2.SHA3;
    });
  })(sha3$1);
  return sha3$1.exports;
}
var ripemd160$1 = { exports: {} };
var ripemd160 = ripemd160$1.exports;
var hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160$1.exports;
  hasRequiredRipemd160 = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(ripemd160, function(CryptoJS2) {
      /** @preserve
      			(c) 2012 by Cdric Mesnil. All rights reserved.
      
      			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
      			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
      			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      			*/
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M, offset2) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset2 + i2;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t2;
            for (var i2 = 0; i2 < 80; i2 += 1) {
              t2 = al + M[offset2 + zl[i2]] | 0;
              if (i2 < 16) {
                t2 += f1(bl, cl, dl) + hl[0];
              } else if (i2 < 32) {
                t2 += f2(bl, cl, dl) + hl[1];
              } else if (i2 < 48) {
                t2 += f3(bl, cl, dl) + hl[2];
              } else if (i2 < 64) {
                t2 += f4(bl, cl, dl) + hl[3];
              } else {
                t2 += f5(bl, cl, dl) + hl[4];
              }
              t2 = t2 | 0;
              t2 = rotl(t2, sl[i2]);
              t2 = t2 + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t2;
              t2 = ar + M[offset2 + zr[i2]] | 0;
              if (i2 < 16) {
                t2 += f5(br, cr, dr) + hr[0];
              } else if (i2 < 32) {
                t2 += f4(br, cr, dr) + hr[1];
              } else if (i2 < 48) {
                t2 += f3(br, cr, dr) + hr[2];
              } else if (i2 < 64) {
                t2 += f2(br, cr, dr) + hr[3];
              } else {
                t2 += f1(br, cr, dr) + hr[4];
              }
              t2 = t2 | 0;
              t2 = rotl(t2, sr[i2]);
              t2 = t2 + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t2;
            }
            t2 = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t2;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i2 = 0; i2 < 5; i2++) {
              var H_i = H[i2];
              H[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        function f1(x, y2, z) {
          return x ^ y2 ^ z;
        }
        function f2(x, y2, z) {
          return x & y2 | ~x & z;
        }
        function f3(x, y2, z) {
          return (x | ~y2) ^ z;
        }
        function f4(x, y2, z) {
          return x & z | y2 & ~z;
        }
        function f5(x, y2, z) {
          return x ^ (y2 | ~z);
        }
        function rotl(x, n3) {
          return x << n3 | x >>> 32 - n3;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })();
      return CryptoJS2.RIPEMD160;
    });
  })(ripemd160$1);
  return ripemd160$1.exports;
}
var hmac$1 = { exports: {} };
var hmac = hmac$1.exports;
var hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac$1.exports;
  hasRequiredHmac = 1;
  (function(module, exports) {
    (function(root, factory) {
      {
        module.exports = factory(requireCore());
      }
    })(hmac, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        C_algo.HMAC = Base2.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i2 = 0; i2 < hasherBlockSize; i2++) {
              oKeyWords[i2] ^= 1549556828;
              iKeyWords[i2] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac2;
          }
        });
      })();
    });
  })(hmac$1);
  return hmac$1.exports;
}
var pbkdf2$1 = { exports: {} };
var pbkdf2 = pbkdf2$1.exports;
var hasRequiredPbkdf2;
function requirePbkdf2() {
  if (hasRequiredPbkdf2) return pbkdf2$1.exports;
  hasRequiredPbkdf2 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireSha256(), requireHmac());
      }
    })(pbkdf2, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: Base2.extend({
            keySize: 128 / 32,
            hasher: SHA256,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac2 = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac2.update(salt).finalize(blockIndex);
              hmac2.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i2 = 1; i2 < iterations; i2++) {
                intermediate = hmac2.finalize(intermediate);
                hmac2.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.PBKDF2;
    });
  })(pbkdf2$1);
  return pbkdf2$1.exports;
}
var evpkdf$1 = { exports: {} };
var evpkdf = evpkdf$1.exports;
var hasRequiredEvpkdf;
function requireEvpkdf() {
  if (hasRequiredEvpkdf) return evpkdf$1.exports;
  hasRequiredEvpkdf = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireSha1(), requireHmac());
      }
    })(evpkdf, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD52 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base2.extend({
            keySize: 128 / 32,
            hasher: MD52,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i2 = 1; i2 < iterations; i2++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.EvpKDF;
    });
  })(evpkdf$1);
  return evpkdf$1.exports;
}
var cipherCore$1 = { exports: {} };
var cipherCore = cipherCore$1.exports;
var hasRequiredCipherCore;
function requireCipherCore() {
  if (hasRequiredCipherCore) return cipherCore$1.exports;
  hasRequiredCipherCore = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEvpkdf());
      }
    })(cipherCore, function(CryptoJS2) {
      CryptoJS2.lib.Cipher || function(undefined$1) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base2.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: /* @__PURE__ */ function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base2.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset2) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset2, blockSize);
              cipher.encryptBlock(words, offset2);
              this._prevBlock = words.slice(offset2, offset2 + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset2) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset2, offset2 + blockSize);
              cipher.decryptBlock(words, offset2);
              xorBlock.call(this, words, offset2, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset2, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined$1;
            } else {
              block = this._prevBlock;
            }
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset2 + i2] ^= block[i2];
            }
          }
          return CBC2;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data2, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data2.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i2 = 0; i2 < nPaddingBytes; i2 += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data2.concat(padding);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data2) {
            var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
            data2.sigBytes -= nPaddingBytes;
          }
        };
        C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset2) {
            this._mode.processBlock(words, offset2);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base2.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base2.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format2) {
            if (typeof ciphertext == "string") {
              return format2.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt, hasher) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            if (!hasher) {
              var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            } else {
              var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
            }
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  })(cipherCore$1);
  return cipherCore$1.exports;
}
var modeCfb$1 = { exports: {} };
var modeCfb = modeCfb$1.exports;
var hasRequiredModeCfb;
function requireModeCfb() {
  if (hasRequiredModeCfb) return modeCfb$1.exports;
  hasRequiredModeCfb = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(modeCfb, function(CryptoJS2) {
      CryptoJS2.mode.CFB = function() {
        var CFB = CryptoJS2.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset2, blockSize, cipher);
            this._prevBlock = words.slice(offset2, offset2 + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset2, offset2 + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset2, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset2, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i2 = 0; i2 < blockSize; i2++) {
            words[offset2 + i2] ^= keystream[i2];
          }
        }
        return CFB;
      }();
      return CryptoJS2.mode.CFB;
    });
  })(modeCfb$1);
  return modeCfb$1.exports;
}
var modeCtr$1 = { exports: {} };
var modeCtr = modeCtr$1.exports;
var hasRequiredModeCtr;
function requireModeCtr() {
  if (hasRequiredModeCtr) return modeCtr$1.exports;
  hasRequiredModeCtr = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(modeCtr, function(CryptoJS2) {
      CryptoJS2.mode.CTR = function() {
        var CTR = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset2 + i2] ^= keystream[i2];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS2.mode.CTR;
    });
  })(modeCtr$1);
  return modeCtr$1.exports;
}
var modeCtrGladman$1 = { exports: {} };
var modeCtrGladman = modeCtrGladman$1.exports;
var hasRequiredModeCtrGladman;
function requireModeCtrGladman() {
  if (hasRequiredModeCtrGladman) return modeCtrGladman$1.exports;
  hasRequiredModeCtrGladman = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(modeCtrGladman, function(CryptoJS2) {
      /** @preserve
       * Counter block mode compatible with  Dr Brian Gladman fileenc.c
       * derived from CryptoJS.mode.CTR
       * Jan Hruby jhruby.web@gmail.com
       */
      CryptoJS2.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS2.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset2 + i2] ^= keystream[i2];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS2.mode.CTRGladman;
    });
  })(modeCtrGladman$1);
  return modeCtrGladman$1.exports;
}
var modeOfb$1 = { exports: {} };
var modeOfb = modeOfb$1.exports;
var hasRequiredModeOfb;
function requireModeOfb() {
  if (hasRequiredModeOfb) return modeOfb$1.exports;
  hasRequiredModeOfb = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(modeOfb, function(CryptoJS2) {
      CryptoJS2.mode.OFB = function() {
        var OFB = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset2) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset2 + i2] ^= keystream[i2];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS2.mode.OFB;
    });
  })(modeOfb$1);
  return modeOfb$1.exports;
}
var modeEcb$1 = { exports: {} };
var modeEcb = modeEcb$1.exports;
var hasRequiredModeEcb;
function requireModeEcb() {
  if (hasRequiredModeEcb) return modeEcb$1.exports;
  hasRequiredModeEcb = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(modeEcb, function(CryptoJS2) {
      CryptoJS2.mode.ECB = function() {
        var ECB = CryptoJS2.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset2) {
            this._cipher.encryptBlock(words, offset2);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset2) {
            this._cipher.decryptBlock(words, offset2);
          }
        });
        return ECB;
      }();
      return CryptoJS2.mode.ECB;
    });
  })(modeEcb$1);
  return modeEcb$1.exports;
}
var padAnsix923$1 = { exports: {} };
var padAnsix923 = padAnsix923$1.exports;
var hasRequiredPadAnsix923;
function requirePadAnsix923() {
  if (hasRequiredPadAnsix923) return padAnsix923$1.exports;
  hasRequiredPadAnsix923 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(padAnsix923, function(CryptoJS2) {
      CryptoJS2.pad.AnsiX923 = {
        pad: function(data2, blockSize) {
          var dataSigBytes = data2.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data2.clamp();
          data2.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data2.sigBytes += nPaddingBytes;
        },
        unpad: function(data2) {
          var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
          data2.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Ansix923;
    });
  })(padAnsix923$1);
  return padAnsix923$1.exports;
}
var padIso10126$1 = { exports: {} };
var padIso10126 = padIso10126$1.exports;
var hasRequiredPadIso10126;
function requirePadIso10126() {
  if (hasRequiredPadIso10126) return padIso10126$1.exports;
  hasRequiredPadIso10126 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(padIso10126, function(CryptoJS2) {
      CryptoJS2.pad.Iso10126 = {
        pad: function(data2, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data2.sigBytes % blockSizeBytes;
          data2.concat(CryptoJS2.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS2.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data2) {
          var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
          data2.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Iso10126;
    });
  })(padIso10126$1);
  return padIso10126$1.exports;
}
var padIso97971$1 = { exports: {} };
var padIso97971 = padIso97971$1.exports;
var hasRequiredPadIso97971;
function requirePadIso97971() {
  if (hasRequiredPadIso97971) return padIso97971$1.exports;
  hasRequiredPadIso97971 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(padIso97971, function(CryptoJS2) {
      CryptoJS2.pad.Iso97971 = {
        pad: function(data2, blockSize) {
          data2.concat(CryptoJS2.lib.WordArray.create([2147483648], 1));
          CryptoJS2.pad.ZeroPadding.pad(data2, blockSize);
        },
        unpad: function(data2) {
          CryptoJS2.pad.ZeroPadding.unpad(data2);
          data2.sigBytes--;
        }
      };
      return CryptoJS2.pad.Iso97971;
    });
  })(padIso97971$1);
  return padIso97971$1.exports;
}
var padZeropadding$1 = { exports: {} };
var padZeropadding = padZeropadding$1.exports;
var hasRequiredPadZeropadding;
function requirePadZeropadding() {
  if (hasRequiredPadZeropadding) return padZeropadding$1.exports;
  hasRequiredPadZeropadding = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(padZeropadding, function(CryptoJS2) {
      CryptoJS2.pad.ZeroPadding = {
        pad: function(data2, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data2.clamp();
          data2.sigBytes += blockSizeBytes - (data2.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data2) {
          var dataWords = data2.words;
          var i2 = data2.sigBytes - 1;
          for (var i2 = data2.sigBytes - 1; i2 >= 0; i2--) {
            if (dataWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255) {
              data2.sigBytes = i2 + 1;
              break;
            }
          }
        }
      };
      return CryptoJS2.pad.ZeroPadding;
    });
  })(padZeropadding$1);
  return padZeropadding$1.exports;
}
var padNopadding$1 = { exports: {} };
var padNopadding = padNopadding$1.exports;
var hasRequiredPadNopadding;
function requirePadNopadding() {
  if (hasRequiredPadNopadding) return padNopadding$1.exports;
  hasRequiredPadNopadding = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(padNopadding, function(CryptoJS2) {
      CryptoJS2.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS2.pad.NoPadding;
    });
  })(padNopadding$1);
  return padNopadding$1.exports;
}
var formatHex$1 = { exports: {} };
var formatHex = formatHex$1.exports;
var hasRequiredFormatHex;
function requireFormatHex() {
  if (hasRequiredFormatHex) return formatHex$1.exports;
  hasRequiredFormatHex = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireCipherCore());
      }
    })(formatHex, function(CryptoJS2) {
      (function(undefined$1) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS2.format.Hex;
    });
  })(formatHex$1);
  return formatHex$1.exports;
}
var aes$1 = { exports: {} };
var aes = aes$1.exports;
var hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes$1.exports;
  hasRequiredAes = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(aes, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d2 = [];
          for (var i2 = 0; i2 < 256; i2++) {
            if (i2 < 128) {
              d2[i2] = i2 << 1;
            } else {
              d2[i2] = i2 << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i2 = 0; i2 < 256; i2++) {
            var sx2 = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx2 = sx2 >>> 8 ^ sx2 & 255 ^ 99;
            SBOX[x] = sx2;
            INV_SBOX[sx2] = x;
            var x2 = d2[x];
            var x4 = d2[x2];
            var x8 = d2[x4];
            var t2 = d2[sx2] * 257 ^ sx2 * 16843008;
            SUB_MIX_0[x] = t2 << 24 | t2 >>> 8;
            SUB_MIX_1[x] = t2 << 16 | t2 >>> 16;
            SUB_MIX_2[x] = t2 << 8 | t2 >>> 24;
            SUB_MIX_3[x] = t2;
            var t2 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx2] = t2 << 24 | t2 >>> 8;
            INV_SUB_MIX_1[sx2] = t2 << 16 | t2 >>> 16;
            INV_SUB_MIX_2[sx2] = t2 << 8 | t2 >>> 24;
            INV_SUB_MIX_3[sx2] = t2;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d2[d2[d2[x8 ^ x2]]];
              xi ^= d2[d2[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t2;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t2 = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t2 = t2 << 8 | t2 >>> 24;
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                  t2 ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t2;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t2 = keySchedule[ksRow];
              } else {
                var t2 = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t2;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t2 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t2 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t2 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t2 & 255]];
              }
            }
          },
          encryptBlock: function(M, offset2) {
            this._doCryptBlock(M, offset2, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M, offset2) {
            var t2 = M[offset2 + 1];
            M[offset2 + 1] = M[offset2 + 3];
            M[offset2 + 3] = t2;
            this._doCryptBlock(M, offset2, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t2 = M[offset2 + 1];
            M[offset2 + 1] = M[offset2 + 3];
            M[offset2 + 3] = t2;
          },
          _doCryptBlock: function(M, offset2, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M[offset2] ^ keySchedule[0];
            var s1 = M[offset2 + 1] ^ keySchedule[1];
            var s2 = M[offset2 + 2] ^ keySchedule[2];
            var s3 = M[offset2 + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset2] = t0;
            M[offset2 + 1] = t1;
            M[offset2 + 2] = t2;
            M[offset2 + 3] = t3;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS2.AES;
    });
  })(aes$1);
  return aes$1.exports;
}
var tripledes$1 = { exports: {} };
var tripledes = tripledes$1.exports;
var hasRequiredTripledes;
function requireTripledes() {
  if (hasRequiredTripledes) return tripledes$1.exports;
  hasRequiredTripledes = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(tripledes, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i2 = 0; i2 < 56; i2++) {
              var keyBitPos = PC1[i2] - 1;
              keyBits[i2] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i2 = 0; i2 < 24; i2++) {
                subKey[i2 / 6 | 0] |= keyBits[(PC2[i2] - 1 + bitShift) % 28] << 31 - i2 % 6;
                subKey[4 + (i2 / 6 | 0)] |= keyBits[28 + (PC2[i2 + 24] - 1 + bitShift) % 28] << 31 - i2 % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i2 = 1; i2 < 7; i2++) {
                subKey[i2] = subKey[i2] >>> (i2 - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i2 = 0; i2 < 16; i2++) {
              invSubKeys[i2] = subKeys[15 - i2];
            }
          },
          encryptBlock: function(M, offset2) {
            this._doCryptBlock(M, offset2, this._subKeys);
          },
          decryptBlock: function(M, offset2) {
            this._doCryptBlock(M, offset2, this._invSubKeys);
          },
          _doCryptBlock: function(M, offset2, subKeys) {
            this._lBlock = M[offset2];
            this._rBlock = M[offset2 + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f2 = 0;
              for (var i2 = 0; i2 < 8; i2++) {
                f2 |= SBOX_P[i2][((rBlock ^ subKey[i2]) & SBOX_MASK[i2]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f2;
            }
            var t2 = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t2;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset2] = this._lBlock;
            M[offset2 + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset2, mask) {
          var t2 = (this._lBlock >>> offset2 ^ this._rBlock) & mask;
          this._rBlock ^= t2;
          this._lBlock ^= t2 << offset2;
        }
        function exchangeRL(offset2, mask) {
          var t2 = (this._rBlock >>> offset2 ^ this._lBlock) & mask;
          this._lBlock ^= t2;
          this._rBlock ^= t2 << offset2;
        }
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M, offset2) {
            this._des1.encryptBlock(M, offset2);
            this._des2.decryptBlock(M, offset2);
            this._des3.encryptBlock(M, offset2);
          },
          decryptBlock: function(M, offset2) {
            this._des3.decryptBlock(M, offset2);
            this._des2.encryptBlock(M, offset2);
            this._des1.decryptBlock(M, offset2);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS2.TripleDES;
    });
  })(tripledes$1);
  return tripledes$1.exports;
}
var rc4$1 = { exports: {} };
var rc4 = rc4$1.exports;
var hasRequiredRc4;
function requireRc4() {
  if (hasRequiredRc4) return rc4$1.exports;
  hasRequiredRc4 = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(rc4, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S2 = this._S = [];
            for (var i2 = 0; i2 < 256; i2++) {
              S2[i2] = i2;
            }
            for (var i2 = 0, j = 0; i2 < 256; i2++) {
              var keyByteIndex = i2 % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S2[i2] + keyByte) % 256;
              var t2 = S2[i2];
              S2[i2] = S2[j];
              S2[j] = t2;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M, offset2) {
            M[offset2] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S2 = this._S;
          var i2 = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n3 = 0; n3 < 4; n3++) {
            i2 = (i2 + 1) % 256;
            j = (j + S2[i2]) % 256;
            var t2 = S2[i2];
            S2[i2] = S2[j];
            S2[j] = t2;
            keystreamWord |= S2[(S2[i2] + S2[j]) % 256] << 24 - n3 * 8;
          }
          this._i = i2;
          this._j = j;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i2 = this.cfg.drop; i2 > 0; i2--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS2.RC4;
    });
  })(rc4$1);
  return rc4$1.exports;
}
var rabbit$1 = { exports: {} };
var rabbit = rabbit$1.exports;
var hasRequiredRabbit;
function requireRabbit() {
  if (hasRequiredRabbit) return rabbit$1.exports;
  hasRequiredRabbit = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(rabbit, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S2 = [];
        var C_ = [];
        var G2 = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i2 = 0; i2 < 4; i2++) {
              K[i2] = (K[i2] << 8 | K[i2] >>> 24) & 16711935 | (K[i2] << 24 | K[i2] >>> 8) & 4278255360;
            }
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i2 = 0; i2 < 4; i2++) {
              nextState.call(this);
            }
            for (var i2 = 0; i2 < 8; i2++) {
              C2[i2] ^= X[i2 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i3 = i22 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i22;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i22;
              C2[7] ^= i3;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset2) {
            var X = this._X;
            nextState.call(this);
            S2[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S2[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S2[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S2[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i2 = 0; i2 < 4; i2++) {
              S2[i2] = (S2[i2] << 8 | S2[i2] >>> 24) & 16711935 | (S2[i2] << 24 | S2[i2] >>> 8) & 4278255360;
              M[offset2 + i2] ^= S2[i2];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i2 = 0; i2 < 8; i2++) {
            C_[i2] = C2[i2];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i2 = 0; i2 < 8; i2++) {
            var gx = X[i2] + C2[i2];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i2] = gh ^ gl;
          }
          X[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS2.Rabbit;
    });
  })(rabbit$1);
  return rabbit$1.exports;
}
var rabbitLegacy$1 = { exports: {} };
var rabbitLegacy = rabbitLegacy$1.exports;
var hasRequiredRabbitLegacy;
function requireRabbitLegacy() {
  if (hasRequiredRabbitLegacy) return rabbitLegacy$1.exports;
  hasRequiredRabbitLegacy = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(rabbitLegacy, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S2 = [];
        var C_ = [];
        var G2 = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i2 = 0; i2 < 4; i2++) {
              nextState.call(this);
            }
            for (var i2 = 0; i2 < 8; i2++) {
              C2[i2] ^= X[i2 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i3 = i22 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i22;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i22;
              C2[7] ^= i3;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset2) {
            var X = this._X;
            nextState.call(this);
            S2[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S2[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S2[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S2[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i2 = 0; i2 < 4; i2++) {
              S2[i2] = (S2[i2] << 8 | S2[i2] >>> 24) & 16711935 | (S2[i2] << 24 | S2[i2] >>> 8) & 4278255360;
              M[offset2 + i2] ^= S2[i2];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i2 = 0; i2 < 8; i2++) {
            C_[i2] = C2[i2];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i2 = 0; i2 < 8; i2++) {
            var gx = X[i2] + C2[i2];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G2[i2] = gh ^ gl;
          }
          X[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
          X[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
          X[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
          X[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
          X[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
          X[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
          X[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
          X[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS2.RabbitLegacy;
    });
  })(rabbitLegacy$1);
  return rabbitLegacy$1.exports;
}
var blowfish$1 = { exports: {} };
var blowfish = blowfish$1.exports;
var hasRequiredBlowfish;
function requireBlowfish() {
  if (hasRequiredBlowfish) return blowfish$1.exports;
  hasRequiredBlowfish = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(blowfish, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        const N = 16;
        const ORIG_P = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ];
        const ORIG_S = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var BLOWFISH_CTX = {
          pbox: [],
          sbox: []
        };
        function F(ctx, x) {
          let a2 = x >> 24 & 255;
          let b2 = x >> 16 & 255;
          let c2 = x >> 8 & 255;
          let d2 = x & 255;
          let y2 = ctx.sbox[0][a2] + ctx.sbox[1][b2];
          y2 = y2 ^ ctx.sbox[2][c2];
          y2 = y2 + ctx.sbox[3][d2];
          return y2;
        }
        function BlowFish_Encrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i2 = 0; i2 < N; ++i2) {
            Xl = Xl ^ ctx.pbox[i2];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[N];
          Xl = Xl ^ ctx.pbox[N + 1];
          return { left: Xl, right: Xr };
        }
        function BlowFish_Decrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i2 = N + 1; i2 > 1; --i2) {
            Xl = Xl ^ ctx.pbox[i2];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[1];
          Xl = Xl ^ ctx.pbox[0];
          return { left: Xl, right: Xr };
        }
        function BlowFishInit(ctx, key, keysize) {
          for (let Row = 0; Row < 4; Row++) {
            ctx.sbox[Row] = [];
            for (let Col = 0; Col < 256; Col++) {
              ctx.sbox[Row][Col] = ORIG_S[Row][Col];
            }
          }
          let keyIndex = 0;
          for (let index2 = 0; index2 < N + 2; index2++) {
            ctx.pbox[index2] = ORIG_P[index2] ^ key[keyIndex];
            keyIndex++;
            if (keyIndex >= keysize) {
              keyIndex = 0;
            }
          }
          let Data1 = 0;
          let Data2 = 0;
          let res = 0;
          for (let i2 = 0; i2 < N + 2; i2 += 2) {
            res = BlowFish_Encrypt(ctx, Data1, Data2);
            Data1 = res.left;
            Data2 = res.right;
            ctx.pbox[i2] = Data1;
            ctx.pbox[i2 + 1] = Data2;
          }
          for (let i2 = 0; i2 < 4; i2++) {
            for (let j = 0; j < 256; j += 2) {
              res = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res.left;
              Data2 = res.right;
              ctx.sbox[i2][j] = Data1;
              ctx.sbox[i2][j + 1] = Data2;
            }
          }
          return true;
        }
        var Blowfish = C_algo.Blowfish = BlockCipher.extend({
          _doReset: function() {
            if (this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
          },
          encryptBlock: function(M, offset2) {
            var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset2], M[offset2 + 1]);
            M[offset2] = res.left;
            M[offset2 + 1] = res.right;
          },
          decryptBlock: function(M, offset2) {
            var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset2], M[offset2 + 1]);
            M[offset2] = res.left;
            M[offset2 + 1] = res.right;
          },
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        C.Blowfish = BlockCipher._createHelper(Blowfish);
      })();
      return CryptoJS2.Blowfish;
    });
  })(blowfish$1);
  return blowfish$1.exports;
}
var cryptoJs = cryptoJs$1.exports;
var hasRequiredCryptoJs;
function requireCryptoJs() {
  if (hasRequiredCryptoJs) return cryptoJs$1.exports;
  hasRequiredCryptoJs = 1;
  (function(module, exports) {
    (function(root, factory, undef) {
      {
        module.exports = factory(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy(), requireBlowfish());
      }
    })(cryptoJs, function(CryptoJS2) {
      return CryptoJS2;
    });
  })(cryptoJs$1);
  return cryptoJs$1.exports;
}
var cryptoJsExports = requireCryptoJs();
const CryptoJS = /* @__PURE__ */ getDefaultExportFromCjs$2(cryptoJsExports);
var global$1$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup$1 = [];
var revLookup$1 = [];
var Arr$1 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited$1 = false;
function init$1() {
  inited$1 = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code.length; i2 < len; ++i2) {
    lookup$1[i2] = code[i2];
    revLookup$1[code.charCodeAt(i2)] = i2;
  }
  revLookup$1["-".charCodeAt(0)] = 62;
  revLookup$1["_".charCodeAt(0)] = 63;
}
function toByteArray$1(b642) {
  if (!inited$1) {
    init$1();
  }
  var i2, j, l2, tmp, placeHolders, arr;
  var len = b642.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b642[len - 2] === "=" ? 2 : b642[len - 1] === "=" ? 1 : 0;
  arr = new Arr$1(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i2 = 0, j = 0; i2 < l2; i2 += 4, j += 3) {
    tmp = revLookup$1[b642.charCodeAt(i2)] << 18 | revLookup$1[b642.charCodeAt(i2 + 1)] << 12 | revLookup$1[b642.charCodeAt(i2 + 2)] << 6 | revLookup$1[b642.charCodeAt(i2 + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup$1[b642.charCodeAt(i2)] << 2 | revLookup$1[b642.charCodeAt(i2 + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup$1[b642.charCodeAt(i2)] << 10 | revLookup$1[b642.charCodeAt(i2 + 1)] << 4 | revLookup$1[b642.charCodeAt(i2 + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64$1(num) {
  return lookup$1[num >> 18 & 63] + lookup$1[num >> 12 & 63] + lookup$1[num >> 6 & 63] + lookup$1[num & 63];
}
function encodeChunk$1(uint82, start2, end2) {
  var tmp;
  var output = [];
  for (var i2 = start2; i2 < end2; i2 += 3) {
    tmp = (uint82[i2] << 16) + (uint82[i2 + 1] << 8) + uint82[i2 + 2];
    output.push(tripletToBase64$1(tmp));
  }
  return output.join("");
}
function fromByteArray$1(uint82) {
  if (!inited$1) {
    init$1();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(encodeChunk$1(uint82, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup$1[tmp >> 2];
    output += lookup$1[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup$1[tmp >> 10];
    output += lookup$1[tmp >> 4 & 63];
    output += lookup$1[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read$1(buffer, offset2, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer[offset2 + i2];
  i2 += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
}
function write$1(buffer, value2, offset2, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer[offset2 + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer[offset2 + i2 - d2] |= s2 * 128;
}
var toString$1 = {}.toString;
var isArray$1 = Array.isArray || function(arr) {
  return toString$1.call(arr) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var INSPECT_MAX_BYTES$1 = 50;
Buffer$2.TYPED_ARRAY_SUPPORT = global$1$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1$1.TYPED_ARRAY_SUPPORT : true;
var _kMaxLength = kMaxLength$1();
function kMaxLength$1() {
  return Buffer$2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer$1(that, length2) {
  if (kMaxLength$1() < length2) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length2);
    that.__proto__ = Buffer$2.prototype;
  } else {
    if (that === null) {
      that = new Buffer$2(length2);
    }
    that.length = length2;
  }
  return that;
}
function Buffer$2(arg, encodingOrOffset, length2) {
  if (!Buffer$2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$2)) {
    return new Buffer$2(arg, encodingOrOffset, length2);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe$1(this, arg);
  }
  return from$1(this, arg, encodingOrOffset, length2);
}
Buffer$2.poolSize = 8192;
Buffer$2._augment = function(arr) {
  arr.__proto__ = Buffer$2.prototype;
  return arr;
};
function from$1(that, value2, encodingOrOffset, length2) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer$1(that, value2, encodingOrOffset, length2);
  }
  if (typeof value2 === "string") {
    return fromString$1(that, value2, encodingOrOffset);
  }
  return fromObject$1(that, value2);
}
Buffer$2.from = function(value2, encodingOrOffset, length2) {
  return from$1(null, value2, encodingOrOffset, length2);
};
if (Buffer$2.TYPED_ARRAY_SUPPORT) {
  Buffer$2.prototype.__proto__ = Uint8Array.prototype;
  Buffer$2.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer$2[Symbol.species] === Buffer$2) ;
}
function assertSize$1(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc$1(that, size, fill4, encoding) {
  assertSize$1(size);
  if (size <= 0) {
    return createBuffer$1(that, size);
  }
  if (fill4 !== void 0) {
    return typeof encoding === "string" ? createBuffer$1(that, size).fill(fill4, encoding) : createBuffer$1(that, size).fill(fill4);
  }
  return createBuffer$1(that, size);
}
Buffer$2.alloc = function(size, fill4, encoding) {
  return alloc$1(null, size, fill4, encoding);
};
function allocUnsafe$1(that, size) {
  assertSize$1(size);
  that = createBuffer$1(that, size < 0 ? 0 : checked$1(size) | 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (var i2 = 0; i2 < size; ++i2) {
      that[i2] = 0;
    }
  }
  return that;
}
Buffer$2.allocUnsafe = function(size) {
  return allocUnsafe$1(null, size);
};
Buffer$2.allocUnsafeSlow = function(size) {
  return allocUnsafe$1(null, size);
};
function fromString$1(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer$2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length2 = byteLength$1(string, encoding) | 0;
  that = createBuffer$1(that, length2);
  var actual = that.write(string, encoding);
  if (actual !== length2) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike$1(that, array) {
  var length2 = array.length < 0 ? 0 : checked$1(array.length) | 0;
  that = createBuffer$1(that, length2);
  for (var i2 = 0; i2 < length2; i2 += 1) {
    that[i2] = array[i2] & 255;
  }
  return that;
}
function fromArrayBuffer$1(that, array, byteOffset, length2) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length2 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length2 === void 0) {
    array = new Uint8Array(array);
  } else if (length2 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length2);
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer$2.prototype;
  } else {
    that = fromArrayLike$1(that, array);
  }
  return that;
}
function fromObject$1(that, obj) {
  if (internalIsBuffer$1(obj)) {
    var len = checked$1(obj.length) | 0;
    that = createBuffer$1(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan$1(obj.length)) {
        return createBuffer$1(that, 0);
      }
      return fromArrayLike$1(that, obj);
    }
    if (obj.type === "Buffer" && isArray$1(obj.data)) {
      return fromArrayLike$1(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked$1(length2) {
  if (length2 >= kMaxLength$1()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength$1().toString(16) + " bytes");
  }
  return length2 | 0;
}
function SlowBuffer(length2) {
  if (+length2 != length2) {
    length2 = 0;
  }
  return Buffer$2.alloc(+length2);
}
Buffer$2.isBuffer = isBuffer$1$1;
function internalIsBuffer$1(b2) {
  return !!(b2 != null && b2._isBuffer);
}
Buffer$2.compare = function compare3(a2, b2) {
  if (!internalIsBuffer$1(a2) || !internalIsBuffer$1(b2)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a2 === b2) return 0;
  var x = a2.length;
  var y2 = b2.length;
  for (var i2 = 0, len = Math.min(x, y2); i2 < len; ++i2) {
    if (a2[i2] !== b2[i2]) {
      x = a2[i2];
      y2 = b2[i2];
      break;
    }
  }
  if (x < y2) return -1;
  if (y2 < x) return 1;
  return 0;
};
Buffer$2.isEncoding = function isEncoding2(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer$2.concat = function concat2(list, length2) {
  if (!isArray$1(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer$2.alloc(0);
  }
  var i2;
  if (length2 === void 0) {
    length2 = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      length2 += list[i2].length;
    }
  }
  var buffer = Buffer$2.allocUnsafe(length2);
  var pos = 0;
  for (i2 = 0; i2 < list.length; ++i2) {
    var buf = list[i2];
    if (!internalIsBuffer$1(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength$1(string, encoding) {
  if (internalIsBuffer$1(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0) return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes$1(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes$1(string).length;
      default:
        if (loweredCase) return utf8ToBytes$1(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$2.byteLength = byteLength$1;
function slowToString$1(encoding, start2, end2) {
  var loweredCase = false;
  if (start2 === void 0 || start2 < 0) {
    start2 = 0;
  }
  if (start2 > this.length) {
    return "";
  }
  if (end2 === void 0 || end2 > this.length) {
    end2 = this.length;
  }
  if (end2 <= 0) {
    return "";
  }
  end2 >>>= 0;
  start2 >>>= 0;
  if (end2 <= start2) {
    return "";
  }
  if (!encoding) encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice$1(this, start2, end2);
      case "utf8":
      case "utf-8":
        return utf8Slice$1(this, start2, end2);
      case "ascii":
        return asciiSlice$1(this, start2, end2);
      case "latin1":
      case "binary":
        return latin1Slice$1(this, start2, end2);
      case "base64":
        return base64Slice$1(this, start2, end2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice$1(this, start2, end2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$2.prototype._isBuffer = true;
function swap$1(b2, n3, m2) {
  var i2 = b2[n3];
  b2[n3] = b2[m2];
  b2[m2] = i2;
}
Buffer$2.prototype.swap16 = function swap162() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 2) {
    swap$1(this, i2, i2 + 1);
  }
  return this;
};
Buffer$2.prototype.swap32 = function swap322() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 4) {
    swap$1(this, i2, i2 + 3);
    swap$1(this, i2 + 1, i2 + 2);
  }
  return this;
};
Buffer$2.prototype.swap64 = function swap642() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 8) {
    swap$1(this, i2, i2 + 7);
    swap$1(this, i2 + 1, i2 + 6);
    swap$1(this, i2 + 2, i2 + 5);
    swap$1(this, i2 + 3, i2 + 4);
  }
  return this;
};
Buffer$2.prototype.toString = function toString2() {
  var length2 = this.length | 0;
  if (length2 === 0) return "";
  if (arguments.length === 0) return utf8Slice$1(this, 0, length2);
  return slowToString$1.apply(this, arguments);
};
Buffer$2.prototype.equals = function equals2(b2) {
  if (!internalIsBuffer$1(b2)) throw new TypeError("Argument must be a Buffer");
  if (this === b2) return true;
  return Buffer$2.compare(this, b2) === 0;
};
Buffer$2.prototype.inspect = function inspect2() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES$1;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2) str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer$2.prototype.compare = function compare4(target, start2, end2, thisStart, thisEnd) {
  if (!internalIsBuffer$1(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start2 === void 0) {
    start2 = 0;
  }
  if (end2 === void 0) {
    end2 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start2 >= end2) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start2 >= end2) {
    return 1;
  }
  start2 >>>= 0;
  end2 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y2 = end2 - start2;
  var len = Math.min(x, y2);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start2, end2);
  for (var i2 = 0; i2 < len; ++i2) {
    if (thisCopy[i2] !== targetCopy[i2]) {
      x = thisCopy[i2];
      y2 = targetCopy[i2];
      break;
    }
  }
  if (x < y2) return -1;
  if (y2 < x) return 1;
  return 0;
};
function bidirectionalIndexOf$1(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1;
  }
  if (typeof val === "string") {
    val = Buffer$2.from(val, encoding);
  }
  if (internalIsBuffer$1(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf$1(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer$2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf$1(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf$1(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i3) {
    if (indexSize === 1) {
      return buf[i3];
    } else {
      return buf.readUInt16BE(i3 * indexSize);
    }
  }
  var i2;
  if (dir) {
    var foundIndex = -1;
    for (i2 = byteOffset; i2 < arrLength; i2++) {
      if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1) foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i2 = byteOffset; i2 >= 0; i2--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i2 + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i2;
    }
  }
  return -1;
}
Buffer$2.prototype.includes = function includes2(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer$2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
  return bidirectionalIndexOf$1(this, val, byteOffset, encoding, true);
};
Buffer$2.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
  return bidirectionalIndexOf$1(this, val, byteOffset, encoding, false);
};
function hexWrite$1(buf, string, offset2, length2) {
  offset2 = Number(offset2) || 0;
  var remaining = buf.length - offset2;
  if (!length2) {
    length2 = remaining;
  } else {
    length2 = Number(length2);
    if (length2 > remaining) {
      length2 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
  if (length2 > strLen / 2) {
    length2 = strLen / 2;
  }
  for (var i2 = 0; i2 < length2; ++i2) {
    var parsed = parseInt(string.substr(i2 * 2, 2), 16);
    if (isNaN(parsed)) return i2;
    buf[offset2 + i2] = parsed;
  }
  return i2;
}
function utf8Write$1(buf, string, offset2, length2) {
  return blitBuffer$1(utf8ToBytes$1(string, buf.length - offset2), buf, offset2, length2);
}
function asciiWrite$1(buf, string, offset2, length2) {
  return blitBuffer$1(asciiToBytes$1(string), buf, offset2, length2);
}
function latin1Write$1(buf, string, offset2, length2) {
  return asciiWrite$1(buf, string, offset2, length2);
}
function base64Write$1(buf, string, offset2, length2) {
  return blitBuffer$1(base64ToBytes$1(string), buf, offset2, length2);
}
function ucs2Write$1(buf, string, offset2, length2) {
  return blitBuffer$1(utf16leToBytes$1(string, buf.length - offset2), buf, offset2, length2);
}
Buffer$2.prototype.write = function write2(string, offset2, length2, encoding) {
  if (offset2 === void 0) {
    encoding = "utf8";
    length2 = this.length;
    offset2 = 0;
  } else if (length2 === void 0 && typeof offset2 === "string") {
    encoding = offset2;
    length2 = this.length;
    offset2 = 0;
  } else if (isFinite(offset2)) {
    offset2 = offset2 | 0;
    if (isFinite(length2)) {
      length2 = length2 | 0;
      if (encoding === void 0) encoding = "utf8";
    } else {
      encoding = length2;
      length2 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset2;
  if (length2 === void 0 || length2 > remaining) length2 = remaining;
  if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding) encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite$1(this, string, offset2, length2);
      case "utf8":
      case "utf-8":
        return utf8Write$1(this, string, offset2, length2);
      case "ascii":
        return asciiWrite$1(this, string, offset2, length2);
      case "latin1":
      case "binary":
        return latin1Write$1(this, string, offset2, length2);
      case "base64":
        return base64Write$1(this, string, offset2, length2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write$1(this, string, offset2, length2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer$2.prototype.toJSON = function toJSON2() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice$1(buf, start2, end2) {
  if (start2 === 0 && end2 === buf.length) {
    return fromByteArray$1(buf);
  } else {
    return fromByteArray$1(buf.slice(start2, end2));
  }
}
function utf8Slice$1(buf, start2, end2) {
  end2 = Math.min(buf.length, end2);
  var res = [];
  var i2 = start2;
  while (i2 < end2) {
    var firstByte = buf[i2];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i2 + bytesPerSequence <= end2) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i2 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          fourthByte = buf[i2 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i2 += bytesPerSequence;
  }
  return decodeCodePointsArray$1(res);
}
var MAX_ARGUMENTS_LENGTH$1 = 4096;
function decodeCodePointsArray$1(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH$1) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH$1)
    );
  }
  return res;
}
function asciiSlice$1(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i2 = start2; i2 < end2; ++i2) {
    ret += String.fromCharCode(buf[i2] & 127);
  }
  return ret;
}
function latin1Slice$1(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i2 = start2; i2 < end2; ++i2) {
    ret += String.fromCharCode(buf[i2]);
  }
  return ret;
}
function hexSlice$1(buf, start2, end2) {
  var len = buf.length;
  if (!start2 || start2 < 0) start2 = 0;
  if (!end2 || end2 < 0 || end2 > len) end2 = len;
  var out = "";
  for (var i2 = start2; i2 < end2; ++i2) {
    out += toHex$1(buf[i2]);
  }
  return out;
}
function utf16leSlice$1(buf, start2, end2) {
  var bytes = buf.slice(start2, end2);
  var res = "";
  for (var i2 = 0; i2 < bytes.length; i2 += 2) {
    res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
  }
  return res;
}
Buffer$2.prototype.slice = function slice2(start2, end2) {
  var len = this.length;
  start2 = ~~start2;
  end2 = end2 === void 0 ? len : ~~end2;
  if (start2 < 0) {
    start2 += len;
    if (start2 < 0) start2 = 0;
  } else if (start2 > len) {
    start2 = len;
  }
  if (end2 < 0) {
    end2 += len;
    if (end2 < 0) end2 = 0;
  } else if (end2 > len) {
    end2 = len;
  }
  if (end2 < start2) end2 = start2;
  var newBuf;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start2, end2);
    newBuf.__proto__ = Buffer$2.prototype;
  } else {
    var sliceLen = end2 - start2;
    newBuf = new Buffer$2(sliceLen, void 0);
    for (var i2 = 0; i2 < sliceLen; ++i2) {
      newBuf[i2] = this[i2 + start2];
    }
  }
  return newBuf;
};
function checkOffset$1(offset2, ext, length2) {
  if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
  if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
}
Buffer$2.prototype.readUIntLE = function readUIntLE2(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) checkOffset$1(offset2, byteLength2, this.length);
  var val = this[offset2];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength2 && (mul *= 256)) {
    val += this[offset2 + i2] * mul;
  }
  return val;
};
Buffer$2.prototype.readUIntBE = function readUIntBE2(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    checkOffset$1(offset2, byteLength2, this.length);
  }
  var val = this[offset2 + --byteLength2];
  var mul = 1;
  while (byteLength2 > 0 && (mul *= 256)) {
    val += this[offset2 + --byteLength2] * mul;
  }
  return val;
};
Buffer$2.prototype.readUInt8 = function readUInt83(offset2, noAssert) {
  if (!noAssert) checkOffset$1(offset2, 1, this.length);
  return this[offset2];
};
Buffer$2.prototype.readUInt16LE = function readUInt16LE3(offset2, noAssert) {
  if (!noAssert) checkOffset$1(offset2, 2, this.length);
  return this[offset2] | this[offset2 + 1] << 8;
};
Buffer$2.prototype.readUInt16BE = function readUInt16BE3(offset2, noAssert) {
  if (!noAssert) checkOffset$1(offset2, 2, this.length);
  return this[offset2] << 8 | this[offset2 + 1];
};
Buffer$2.prototype.readUInt32LE = function readUInt32LE3(offset2, noAssert) {
  if (!noAssert) checkOffset$1(offset2, 4, this.length);
  return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
};
Buffer$2.prototype.readUInt32BE = function readUInt32BE3(offset2, noAssert) {
  if (!noAssert) checkOffset$1(offset2, 4, this.length);
  return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
};
Buffer$2.prototype.readIntLE = function readIntLE2(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) checkOffset$1(offset2, byteLength2, this.length);
  var val = this[offset2];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength2 && (mul *= 256)) {
    val += this[offset2 + i2] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer$2.prototype.readIntBE = function readIntBE2(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) checkOffset$1(offset2, byteLength2, this.length);
  var i2 = byteLength2;
  var mul = 1;
  var val = this[offset2 + --i2];
  while (i2 > 0 && (mul *= 256)) {
    val += this[offset2 + --i2] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer$2.prototype.readInt8 = function readInt82(offset2, noAssert) {
  if (!noAssert) checkOffset$1(offset2, 1, this.length);
  if (!(this[offset2] & 128)) return this[offset2];
  return (255 - this[offset2] + 1) * -1;
};
Buffer$2.prototype.readInt16LE = function readInt16LE2(offset2, noAssert) {
  if (!noAssert) checkOffset$1(offset2, 2, this.length);
  var val = this[offset2] | this[offset2 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$2.prototype.readInt16BE = function readInt16BE2(offset2, noAssert) {
  if (!noAssert) checkOffset$1(offset2, 2, this.length);
  var val = this[offset2 + 1] | this[offset2] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$2.prototype.readInt32LE = function readInt32LE3(offset2, noAssert) {
  if (!noAssert) checkOffset$1(offset2, 4, this.length);
  return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
};
Buffer$2.prototype.readInt32BE = function readInt32BE3(offset2, noAssert) {
  if (!noAssert) checkOffset$1(offset2, 4, this.length);
  return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
};
Buffer$2.prototype.readFloatLE = function readFloatLE2(offset2, noAssert) {
  if (!noAssert) checkOffset$1(offset2, 4, this.length);
  return read$1(this, offset2, true, 23, 4);
};
Buffer$2.prototype.readFloatBE = function readFloatBE2(offset2, noAssert) {
  if (!noAssert) checkOffset$1(offset2, 4, this.length);
  return read$1(this, offset2, false, 23, 4);
};
Buffer$2.prototype.readDoubleLE = function readDoubleLE2(offset2, noAssert) {
  if (!noAssert) checkOffset$1(offset2, 8, this.length);
  return read$1(this, offset2, true, 52, 8);
};
Buffer$2.prototype.readDoubleBE = function readDoubleBE2(offset2, noAssert) {
  if (!noAssert) checkOffset$1(offset2, 8, this.length);
  return read$1(this, offset2, false, 52, 8);
};
function checkInt$1(buf, value2, offset2, ext, max2, min2) {
  if (!internalIsBuffer$1(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max2 || value2 < min2) throw new RangeError('"value" argument is out of bounds');
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer$2.prototype.writeUIntLE = function writeUIntLE2(value2, offset2, byteLength2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt$1(this, value2, offset2, byteLength2, maxBytes, 0);
  }
  var mul = 1;
  var i2 = 0;
  this[offset2] = value2 & 255;
  while (++i2 < byteLength2 && (mul *= 256)) {
    this[offset2 + i2] = value2 / mul & 255;
  }
  return offset2 + byteLength2;
};
Buffer$2.prototype.writeUIntBE = function writeUIntBE2(value2, offset2, byteLength2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt$1(this, value2, offset2, byteLength2, maxBytes, 0);
  }
  var i2 = byteLength2 - 1;
  var mul = 1;
  this[offset2 + i2] = value2 & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    this[offset2 + i2] = value2 / mul & 255;
  }
  return offset2 + byteLength2;
};
Buffer$2.prototype.writeUInt8 = function writeUInt82(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$1(this, value2, offset2, 1, 255, 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
function objectWriteUInt16$1(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 65535 + value2 + 1;
  for (var i2 = 0, j = Math.min(buf.length - offset2, 2); i2 < j; ++i2) {
    buf[offset2 + i2] = (value2 & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
  }
}
Buffer$2.prototype.writeUInt16LE = function writeUInt16LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$1(this, value2, offset2, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16$1(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer$2.prototype.writeUInt16BE = function writeUInt16BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$1(this, value2, offset2, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt16$1(this, value2, offset2, false);
  }
  return offset2 + 2;
};
function objectWriteUInt32$1(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  for (var i2 = 0, j = Math.min(buf.length - offset2, 4); i2 < j; ++i2) {
    buf[offset2 + i2] = value2 >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
  }
}
Buffer$2.prototype.writeUInt32LE = function writeUInt32LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$1(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2 + 3] = value2 >>> 24;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2] = value2 & 255;
  } else {
    objectWriteUInt32$1(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer$2.prototype.writeUInt32BE = function writeUInt32BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$1(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt32$1(this, value2, offset2, false);
  }
  return offset2 + 4;
};
Buffer$2.prototype.writeIntLE = function writeIntLE2(value2, offset2, byteLength2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt$1(this, value2, offset2, byteLength2, limit - 1, -limit);
  }
  var i2 = 0;
  var mul = 1;
  var sub = 0;
  this[offset2] = value2 & 255;
  while (++i2 < byteLength2 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i2 - 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i2] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength2;
};
Buffer$2.prototype.writeIntBE = function writeIntBE2(value2, offset2, byteLength2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt$1(this, value2, offset2, byteLength2, limit - 1, -limit);
  }
  var i2 = byteLength2 - 1;
  var mul = 1;
  var sub = 0;
  this[offset2 + i2] = value2 & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i2 + 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i2] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength2;
};
Buffer$2.prototype.writeInt8 = function writeInt82(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$1(this, value2, offset2, 1, 127, -128);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  if (value2 < 0) value2 = 255 + value2 + 1;
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
Buffer$2.prototype.writeInt16LE = function writeInt16LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$1(this, value2, offset2, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16$1(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer$2.prototype.writeInt16BE = function writeInt16BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$1(this, value2, offset2, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt16$1(this, value2, offset2, false);
  }
  return offset2 + 2;
};
Buffer$2.prototype.writeInt32LE = function writeInt32LE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$1(this, value2, offset2, 4, 2147483647, -2147483648);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt32$1(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer$2.prototype.writeInt32BE = function writeInt32BE2(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt$1(this, value2, offset2, 4, 2147483647, -2147483648);
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt32$1(this, value2, offset2, false);
  }
  return offset2 + 4;
};
function checkIEEE754$1(buf, value2, offset2, ext, max2, min2) {
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  if (offset2 < 0) throw new RangeError("Index out of range");
}
function writeFloat$1(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754$1(buf, value2, offset2, 4);
  }
  write$1(buf, value2, offset2, littleEndian, 23, 4);
  return offset2 + 4;
}
Buffer$2.prototype.writeFloatLE = function writeFloatLE2(value2, offset2, noAssert) {
  return writeFloat$1(this, value2, offset2, true, noAssert);
};
Buffer$2.prototype.writeFloatBE = function writeFloatBE2(value2, offset2, noAssert) {
  return writeFloat$1(this, value2, offset2, false, noAssert);
};
function writeDouble$1(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754$1(buf, value2, offset2, 8);
  }
  write$1(buf, value2, offset2, littleEndian, 52, 8);
  return offset2 + 8;
}
Buffer$2.prototype.writeDoubleLE = function writeDoubleLE2(value2, offset2, noAssert) {
  return writeDouble$1(this, value2, offset2, true, noAssert);
};
Buffer$2.prototype.writeDoubleBE = function writeDoubleBE2(value2, offset2, noAssert) {
  return writeDouble$1(this, value2, offset2, false, noAssert);
};
Buffer$2.prototype.copy = function copy2(target, targetStart, start2, end2) {
  if (!start2) start2 = 0;
  if (!end2 && end2 !== 0) end2 = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end2 > 0 && end2 < start2) end2 = start2;
  if (end2 === start2) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start2 < 0 || start2 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
  if (end2 > this.length) end2 = this.length;
  if (target.length - targetStart < end2 - start2) {
    end2 = target.length - targetStart + start2;
  }
  var len = end2 - start2;
  var i2;
  if (this === target && start2 < targetStart && targetStart < end2) {
    for (i2 = len - 1; i2 >= 0; --i2) {
      target[i2 + targetStart] = this[i2 + start2];
    }
  } else if (len < 1e3 || !Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (i2 = 0; i2 < len; ++i2) {
      target[i2 + targetStart] = this[i2 + start2];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start2, start2 + len),
      targetStart
    );
  }
  return len;
};
Buffer$2.prototype.fill = function fill2(val, start2, end2, encoding) {
  if (typeof val === "string") {
    if (typeof start2 === "string") {
      encoding = start2;
      start2 = 0;
      end2 = this.length;
    } else if (typeof end2 === "string") {
      encoding = end2;
      end2 = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer$2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start2 < 0 || this.length < start2 || this.length < end2) {
    throw new RangeError("Out of range index");
  }
  if (end2 <= start2) {
    return this;
  }
  start2 = start2 >>> 0;
  end2 = end2 === void 0 ? this.length : end2 >>> 0;
  if (!val) val = 0;
  var i2;
  if (typeof val === "number") {
    for (i2 = start2; i2 < end2; ++i2) {
      this[i2] = val;
    }
  } else {
    var bytes = internalIsBuffer$1(val) ? val : utf8ToBytes$1(new Buffer$2(val, encoding).toString());
    var len = bytes.length;
    for (i2 = 0; i2 < end2 - start2; ++i2) {
      this[i2 + start2] = bytes[i2 % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE$1 = /[^+\/0-9A-Za-z-_]/g;
function base64clean$1(str) {
  str = stringtrim$1(str).replace(INVALID_BASE64_RE$1, "");
  if (str.length < 2) return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim$1(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex$1(n3) {
  if (n3 < 16) return "0" + n3.toString(16);
  return n3.toString(16);
}
function utf8ToBytes$1(string, units) {
  units = units || Infinity;
  var codePoint;
  var length2 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i2 = 0; i2 < length2; ++i2) {
    codePoint = string.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length2) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes$1(str) {
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    byteArray.push(str.charCodeAt(i2) & 255);
  }
  return byteArray;
}
function utf16leToBytes$1(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    if ((units -= 2) < 0) break;
    c2 = str.charCodeAt(i2);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes$1(str) {
  return toByteArray$1(base64clean$1(str));
}
function blitBuffer$1(src2, dst, offset2, length2) {
  for (var i2 = 0; i2 < length2; ++i2) {
    if (i2 + offset2 >= dst.length || i2 >= src2.length) break;
    dst[i2 + offset2] = src2[i2];
  }
  return i2;
}
function isnan$1(val) {
  return val !== val;
}
function isBuffer$1$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer$1(obj) || isSlowBuffer$1(obj));
}
function isFastBuffer$1(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer$1(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer$1(obj.slice(0, 0));
}
var _polyfillNode_buffer = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Buffer: Buffer$2,
  INSPECT_MAX_BYTES: INSPECT_MAX_BYTES$1,
  SlowBuffer,
  isBuffer: isBuffer$1$1,
  kMaxLength: _kMaxLength
});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n3) {
  if (n3.__esModule) return n3;
  var f2 = n3.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n3).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n3, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n3[k2];
      }
    });
  });
  return a2;
}
var readableBrowser = { exports: {} };
var _registry = {};
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1$1.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof global$1$1.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e2) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e3) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e2) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e3) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var platform = "browser";
var browser$1 = true;
var env = {};
var argv = [];
var version = "";
var versions = {};
var release = {};
var config$1 = {};
function noop$2() {
}
var on = noop$2;
var addListener2 = noop$2;
var once$2 = noop$2;
var off = noop$2;
var removeListener2 = noop$2;
var removeAllListeners2 = noop$2;
var emit2 = noop$2;
function binding$1(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance$1 = global$1$1.performance || {};
var performanceNow = performance$1.now || performance$1.mozNow || performance$1.msNow || performance$1.oNow || performance$1.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance$1) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = /* @__PURE__ */ new Date();
function uptime() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var browser$1$1 = {
  nextTick,
  title,
  browser: browser$1,
  env,
  argv,
  version,
  versions,
  on,
  addListener: addListener2,
  once: once$2,
  off,
  removeListener: removeListener2,
  removeAllListeners: removeAllListeners2,
  emit: emit2,
  binding: binding$1,
  cwd,
  chdir,
  umask,
  hrtime,
  platform,
  release,
  config: config$1,
  uptime
};
var domain;
function EventHandlers() {
}
EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
function EventEmitter() {
  EventEmitter.init.call(this);
}
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.prototype.domain = void 0;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._maxListeners = void 0;
EventEmitter.defaultMaxListeners = 10;
EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    if (domain.active && !(this instanceof domain.Domain)) {
      this.domain = domain.active;
    }
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners2(n3) {
  if (typeof n3 !== "number" || n3 < 0 || isNaN(n3))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n3;
  return this;
};
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners2() {
  return $getMaxListeners(this);
};
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners3[i2].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners3[i2].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners3[i2].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners3[i2].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i2 = 0; i2 < len; ++i2)
      listeners3[i2].apply(self2, args);
  }
}
EventEmitter.prototype.emit = function emit3(type) {
  var er, handler, len, args, i2, events2, domain2;
  var doError = type === "error";
  events2 = this._events;
  if (events2)
    doError = doError && events2.error == null;
  else if (!doError)
    return false;
  domain2 = this.domain;
  if (doError) {
    er = arguments[1];
    if (domain2) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain2;
      er.domainThrown = false;
      domain2.emit("error", er);
    } else if (er instanceof Error) {
      throw er;
    } else {
      var err2 = new Error('Uncaught, unspecified "error" event. (' + er + ")");
      err2.context = er;
      throw err2;
    }
    return false;
  }
  handler = events2[type];
  if (!handler)
    return false;
  var isFn = typeof handler === "function";
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i2 = 1; i2 < len; i2++)
        args[i2 - 1] = arguments[i2];
      emitMany(handler, isFn, this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m2;
  var events2;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = target._events;
  if (!events2) {
    events2 = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events2.newListener) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (!existing) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m2 = $getMaxListeners(target);
      if (m2 && m2 > 0 && existing.length > m2) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e2) {
  typeof console.warn === "function" ? console.warn(e2) : console.log(e2);
}
EventEmitter.prototype.addListener = function addListener3(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener2(type, listener) {
  return _addListener(this, type, listener, true);
};
function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
EventEmitter.prototype.once = function once2(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener2(type, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener3(type, listener) {
  var list, events2, position, i2, originalListener;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = this._events;
  if (!events2)
    return this;
  list = events2[type];
  if (!list)
    return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length; i2-- > 0; ) {
      if (list[i2] === listener || list[i2].listener && list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (list.length === 1) {
      list[0] = void 0;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events2[type];
      }
    } else {
      spliceOne(list, position);
    }
    if (events2.removeListener)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = function(type, listener) {
  return this.removeListener(type, listener);
};
EventEmitter.prototype.removeAllListeners = function removeAllListeners3(type) {
  var listeners3, events2;
  events2 = this._events;
  if (!events2)
    return this;
  if (!events2.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events2[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys = Object.keys(events2);
    for (var i2 = 0, key; i2 < keys.length; ++i2) {
      key = keys[i2];
      if (key === "removeListener") continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }
  listeners3 = events2[type];
  if (typeof listeners3 === "function") {
    this.removeListener(type, listeners3);
  } else if (listeners3) {
    do {
      this.removeListener(type, listeners3[listeners3.length - 1]);
    } while (listeners3[0]);
  }
  return this;
};
EventEmitter.prototype.listeners = function listeners2(type) {
  var evlistener;
  var ret;
  var events2 = this._events;
  if (!events2)
    ret = [];
  else {
    evlistener = events2[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === "function")
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }
  return ret;
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames2() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function spliceOne(list, index2) {
  for (var i2 = index2, k2 = i2 + 1, n3 = list.length; k2 < n3; i2 += 1, k2 += 1)
    list[i2] = list[k2];
  list.pop();
}
function arrayClone(arr, i2) {
  var copy5 = new Array(i2);
  while (i2--)
    copy5[i2] = arr[i2];
  return copy5;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}
var _polyfillNode_events = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EventEmitter,
  default: EventEmitter
});
var require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_events);
var streamBrowser = require$$1$1.EventEmitter;
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_buffer);
var inherits$2;
if (typeof Object.create === "function") {
  inherits$2 = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits$2 = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var getOwnPropertyDescriptors2 = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors3(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};
  for (var i2 = 0; i2 < keys.length; i2++) {
    descriptors[keys[i2]] = Object.getOwnPropertyDescriptor(obj, keys[i2]);
  }
  return descriptors;
};
var formatRegExp = /%[sdj%]/g;
function format(f2) {
  if (!isString$2(f2)) {
    var objects = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      objects.push(inspect$1(arguments[i2]));
    }
    return objects.join(" ");
  }
  var i2 = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f2).replace(formatRegExp, function(x2) {
    if (x2 === "%%") return "%";
    if (i2 >= len) return x2;
    switch (x2) {
      case "%s":
        return String(args[i2++]);
      case "%d":
        return Number(args[i2++]);
      case "%j":
        try {
          return JSON.stringify(args[i2++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i2]; i2 < len; x = args[++i2]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x;
    } else {
      str += " " + inspect$1(x);
    }
  }
  return str;
}
function deprecate$1(fn, msg2) {
  if (isUndefined(global$1$1.process)) {
    return function() {
      return deprecate$1(fn, msg2).apply(this, arguments);
    };
  }
  if (browser$1$1.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1$1.throwDeprecation) {
        throw new Error(msg2);
      } else if (browser$1$1.traceDeprecation) {
        console.trace(msg2);
      } else {
        console.error(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
var debugs = {};
var debugEnviron;
function debuglog(set5) {
  if (isUndefined(debugEnviron))
    debugEnviron = browser$1$1.env.NODE_DEBUG || "";
  set5 = set5.toUpperCase();
  if (!debugs[set5]) {
    if (new RegExp("\\b" + set5 + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set5] = function() {
        var msg2 = format.apply(null, arguments);
        console.error("%s %d: %s", set5, pid, msg2);
      };
    } else {
      debugs[set5] = function() {
      };
    }
  }
  return debugs[set5];
}
function inspect$1(obj, opts2) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean$1(opts2)) {
    ctx.showHidden = opts2;
  } else if (opts2) {
    _extend(ctx, opts2);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
inspect$1.colors = {
  "bold": [1, 22],
  "italic": [3, 23],
  "underline": [4, 24],
  "inverse": [7, 27],
  "white": [37, 39],
  "grey": [90, 39],
  "black": [30, 39],
  "blue": [34, 39],
  "cyan": [36, 39],
  "green": [32, 39],
  "magenta": [35, 39],
  "red": [31, 39],
  "yellow": [33, 39]
};
inspect$1.styles = {
  "special": "cyan",
  "number": "yellow",
  "boolean": "yellow",
  "undefined": "grey",
  "null": "bold",
  "string": "green",
  "date": "magenta",
  // "name": intentionally not styling
  "regexp": "red"
};
function stylizeWithColor(str, styleType) {
  var style = inspect$1.styles[styleType];
  if (style) {
    return "\x1B[" + inspect$1.colors[style][0] + "m" + str + "\x1B[" + inspect$1.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value2, recurseTimes) {
  if (ctx.customInspect && value2 && isFunction(value2.inspect) && // Filter out the util module, it's inspect function is special
  value2.inspect !== inspect$1 && // Also filter out any prototype objects using the circular check.
  !(value2.constructor && value2.constructor.prototype === value2)) {
    var ret = value2.inspect(recurseTimes, ctx);
    if (!isString$2(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value2);
  if (primitive) {
    return primitive;
  }
  var keys = Object.keys(value2);
  var visibleKeys = arrayToHash(keys);
  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value2);
  }
  if (isError(value2) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
    return formatError(value2);
  }
  if (keys.length === 0) {
    if (isFunction(value2)) {
      var name = value2.name ? ": " + value2.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    }
    if (isDate(value2)) {
      return ctx.stylize(Date.prototype.toString.call(value2), "date");
    }
    if (isError(value2)) {
      return formatError(value2);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray$2(value2)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value2)) {
    var n3 = value2.name ? ": " + value2.name : "";
    base = " [Function" + n3 + "]";
  }
  if (isRegExp(value2)) {
    base = " " + RegExp.prototype.toString.call(value2);
  }
  if (isDate(value2)) {
    base = " " + Date.prototype.toUTCString.call(value2);
  }
  if (isError(value2)) {
    base = " " + formatError(value2);
  }
  if (keys.length === 0 && (!array || value2.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value2);
  var output;
  if (array) {
    output = formatArray(ctx, value2, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value2) {
  if (isUndefined(value2))
    return ctx.stylize("undefined", "undefined");
  if (isString$2(value2)) {
    var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber$2(value2))
    return ctx.stylize("" + value2, "number");
  if (isBoolean$1(value2))
    return ctx.stylize("" + value2, "boolean");
  if (isNull(value2))
    return ctx.stylize("null", "null");
}
function formatError(value2) {
  return "[" + Error.prototype.toString.call(value2) + "]";
}
function formatArray(ctx, value2, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i2 = 0, l2 = value2.length; i2 < l2; ++i2) {
    if (hasOwnProperty(value2, String(i2))) {
      output.push(formatProperty(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        String(i2),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value2, key) || { value: value2[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line2) {
            return "  " + line2;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line2) {
            return "   " + line2;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var length2 = output.reduce(function(prev, cur) {
    if (cur.indexOf("\n") >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length2 > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray$2(ar) {
  return Array.isArray(ar);
}
function isBoolean$1(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber$2(arg) {
  return typeof arg === "number";
}
function isString$2(arg) {
  return typeof arg === "string";
}
function isSymbol(arg) {
  return typeof arg === "symbol";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d2) {
  return isObject(d2) && objectToString(d2) === "[object Date]";
}
function isError(e2) {
  return isObject(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
  typeof arg === "undefined";
}
function isBuffer$2(maybeBuf) {
  return Buffer$2.isBuffer(maybeBuf);
}
function objectToString(o2) {
  return Object.prototype.toString.call(o2);
}
function pad$1(n3) {
  return n3 < 10 ? "0" + n3.toString(10) : n3.toString(10);
}
var months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp() {
  var d2 = /* @__PURE__ */ new Date();
  var time = [
    pad$1(d2.getHours()),
    pad$1(d2.getMinutes()),
    pad$1(d2.getSeconds())
  ].join(":");
  return [d2.getDate(), months[d2.getMonth()], time].join(" ");
}
function log() {
  console.log("%s - %s", timestamp(), format.apply(null, arguments));
}
function _extend(origin, add2) {
  if (!add2 || !isObject(add2)) return origin;
  var keys = Object.keys(add2);
  var i2 = keys.length;
  while (i2--) {
    origin[keys[i2]] = add2[keys[i2]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
function promisify(original) {
  if (typeof original !== "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== "function") {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }
  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function(resolve2, reject) {
      promiseResolve = resolve2;
      promiseReject = reject;
    });
    var args = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      args.push(arguments[i2]);
    }
    args.push(function(err2, value2) {
      if (err2) {
        promiseReject(err2);
      } else {
        promiseResolve(value2);
      }
    });
    try {
      original.apply(this, args);
    } catch (err2) {
      promiseReject(err2);
    }
    return promise;
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors2(original)
  );
}
promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
  if (!reason) {
    var newReason = new Error("Promise was rejected with a falsy value");
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}
function callbackify(original) {
  if (typeof original !== "function") {
    throw new TypeError('The "original" argument must be of type Function');
  }
  function callbackified() {
    var args = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      args.push(arguments[i2]);
    }
    var maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new TypeError("The last argument must be of type Function");
    }
    var self2 = this;
    var cb = function() {
      return maybeCb.apply(self2, arguments);
    };
    original.apply(this, args).then(
      function(ret) {
        browser$1$1.nextTick(cb.bind(null, null, ret));
      },
      function(rej) {
        browser$1$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
      }
    );
  }
  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors2(original));
  return callbackified;
}
var _polyfillNode_util = {
  inherits: inherits$2,
  _extend,
  log,
  isBuffer: isBuffer$2,
  isPrimitive,
  isFunction,
  isError,
  isDate,
  isObject,
  isRegExp,
  isUndefined,
  isSymbol,
  isString: isString$2,
  isNumber: isNumber$2,
  isNullOrUndefined,
  isNull,
  isBoolean: isBoolean$1,
  isArray: isArray$2,
  inspect: inspect$1,
  deprecate: deprecate$1,
  format,
  debuglog,
  promisify,
  callbackify
};
var _polyfillNode_util$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  _extend,
  callbackify,
  debuglog,
  default: _polyfillNode_util,
  deprecate: deprecate$1,
  format,
  inherits: inherits$2,
  inspect: inspect$1,
  isArray: isArray$2,
  isBoolean: isBoolean$1,
  isBuffer: isBuffer$2,
  isDate,
  isError,
  isFunction,
  isNull,
  isNullOrUndefined,
  isNumber: isNumber$2,
  isObject,
  isPrimitive,
  isRegExp,
  isString: isString$2,
  isSymbol,
  isUndefined,
  log,
  promisify
});
var require$$3 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_util$1);
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    return Constructor;
  }
  var _require2 = require$$0, Buffer2 = _require2.Buffer;
  var _require22 = require$$3, inspect5 = _require22.inspect;
  var custom = inspect5 && inspect5.custom || "inspect";
  function copyBuffer(src2, target, offset2) {
    Buffer2.prototype.copy.call(src2, target, offset2);
  }
  buffer_list = /* @__PURE__ */ function() {
    function BufferList2() {
      _classCallCheck(this, BufferList2);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList2, [{
      key: "push",
      value: function push(v2) {
        var entry = {
          data: v2,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v2) {
        var entry = {
          data: v2,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s2) {
        if (this.length === 0) return "";
        var p2 = this.head;
        var ret = "" + p2.data;
        while (p2 = p2.next) {
          ret += s2 + p2.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat5(n3) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n3 >>> 0);
        var p2 = this.head;
        var i2 = 0;
        while (p2) {
          copyBuffer(p2.data, ret, i2);
          i2 += p2.data.length;
          p2 = p2.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n3, hasStrings) {
        var ret;
        if (n3 < this.head.data.length) {
          ret = this.head.data.slice(0, n3);
          this.head.data = this.head.data.slice(n3);
        } else if (n3 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n3) : this._getBuffer(n3);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n3) {
        var p2 = this.head;
        var c2 = 1;
        var ret = p2.data;
        n3 -= ret.length;
        while (p2 = p2.next) {
          var str = p2.data;
          var nb = n3 > str.length ? str.length : n3;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n3);
          n3 -= nb;
          if (n3 === 0) {
            if (nb === str.length) {
              ++c2;
              if (p2.next) this.head = p2.next;
              else this.head = this.tail = null;
            } else {
              this.head = p2;
              p2.data = str.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n3) {
        var ret = Buffer2.allocUnsafe(n3);
        var p2 = this.head;
        var c2 = 1;
        p2.data.copy(ret);
        n3 -= p2.data.length;
        while (p2 = p2.next) {
          var buf = p2.data;
          var nb = n3 > buf.length ? buf.length : n3;
          buf.copy(ret, ret.length - n3, 0, nb);
          n3 -= nb;
          if (n3 === 0) {
            if (nb === buf.length) {
              ++c2;
              if (p2.next) this.head = p2.next;
              else this.head = this.tail = null;
            } else {
              this.head = p2;
              p2.data = buf.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value2(_, options) {
        return inspect5(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList2;
  }();
  return buffer_list;
}
function destroy(err2, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err2);
    } else if (err2) {
      if (!this._writableState) {
        browser$1$1.nextTick(emitErrorNT, this, err2);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        browser$1$1.nextTick(emitErrorNT, this, err2);
      }
    }
    return this;
  }
  if (this._readableState) {
    this._readableState.destroyed = true;
  }
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err2 || null, function(err3) {
    if (!cb && err3) {
      if (!_this._writableState) {
        browser$1$1.nextTick(emitErrorAndCloseNT, _this, err3);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        browser$1$1.nextTick(emitErrorAndCloseNT, _this, err3);
      } else {
        browser$1$1.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      browser$1$1.nextTick(emitCloseNT, _this);
      cb(err3);
    } else {
      browser$1$1.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self2, err2) {
  emitErrorNT(self2, err2);
  emitCloseNT(self2);
}
function emitCloseNT(self2) {
  if (self2._writableState && !self2._writableState.emitClose) return;
  if (self2._readableState && !self2._readableState.emitClose) return;
  self2.emit("close");
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self2, err2) {
  self2.emit("error", err2);
}
function errorOrDestroy$2(stream2, err2) {
  var rState = stream2._readableState;
  var wState = stream2._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream2.destroy(err2);
  else stream2.emit("error", err2);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy: errorOrDestroy$2
};
var errorsBrowser = {};
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code, message, Base2) {
  if (!Base2) {
    Base2 = Error;
  }
  function getMessage2(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /* @__PURE__ */ function(_Base) {
    _inheritsLoose(NodeError2, _Base);
    function NodeError2(arg1, arg2, arg3) {
      return _Base.call(this, getMessage2(arg1, arg2, arg3)) || this;
    }
    return NodeError2;
  }(Base2);
  NodeError.prototype.name = Base2.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
}
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function(i2) {
      return String(i2);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}
function startsWith(str, search, pos) {
  return str.substr(0, search.length) === search;
}
function endsWith(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function includes3(str, search, start2) {
  if (typeof start2 !== "number") {
    start2 = 0;
  }
  if (start2 + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start2) !== -1;
  }
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name, value2) {
  return 'The value "' + value2 + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
  var determiner;
  if (typeof expected === "string" && startsWith(expected, "not ")) {
    determiner = "must not be";
    expected = expected.replace(/^not /, "");
  } else {
    determiner = "must be";
  }
  var msg2;
  if (endsWith(name, " argument")) {
    msg2 = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  } else {
    var type = includes3(name, ".") ? "property" : "argument";
    msg2 = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  }
  msg2 += ". Received type ".concat(typeof actual);
  return msg2;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
  return "The " + name + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name) {
  return "Cannot call " + name + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
  return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark$2(state2, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }
  return state2.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark: getHighWaterMark$2
};
var inherits;
if (typeof Object.create === "function") {
  inherits = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits2(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$1 = inherits;
var _polyfillNode_inherits = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: inherits$1
});
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_inherits);
var isBufferEncoding = Buffer$2.isEncoding || function(encoding) {
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder$1(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer$2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
StringDecoder$1.prototype.write = function(buffer) {
  var charStr = "";
  while (this.charLength) {
    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;
    if (this.charReceived < this.charLength) {
      return "";
    }
    buffer = buffer.slice(available, buffer.length);
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 55296 && charCode <= 56319) {
      this.charLength += this.surrogateSize;
      charStr = "";
      continue;
    }
    this.charReceived = this.charLength = 0;
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }
  this.detectIncompleteChar(buffer);
  var end2 = buffer.length;
  if (this.charLength) {
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end2);
    end2 -= this.charReceived;
  }
  charStr += buffer.toString(this.encoding, 0, end2);
  var end2 = charStr.length - 1;
  var charCode = charStr.charCodeAt(end2);
  if (charCode >= 55296 && charCode <= 56319) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end2);
  }
  return charStr;
};
StringDecoder$1.prototype.detectIncompleteChar = function(buffer) {
  var i2 = buffer.length >= 3 ? 3 : buffer.length;
  for (; i2 > 0; i2--) {
    var c2 = buffer[buffer.length - i2];
    if (i2 == 1 && c2 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (i2 <= 2 && c2 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (i2 <= 3 && c2 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i2;
};
StringDecoder$1.prototype.end = function(buffer) {
  var res = "";
  if (buffer && buffer.length)
    res = this.write(buffer);
  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }
  return res;
};
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var _polyfillNode_string_decoder = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  StringDecoder: StringDecoder$1
});
var require$$10 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_string_decoder);
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(callback) {
  var called = false;
  return function() {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop$1() {
}
function isRequest$1(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function eos$1(stream2, opts2, callback) {
  if (typeof opts2 === "function") return eos$1(stream2, null, opts2);
  if (!opts2) opts2 = {};
  callback = once$1(callback || noop$1);
  var readable = opts2.readable || opts2.readable !== false && stream2.readable;
  var writable = opts2.writable || opts2.writable !== false && stream2.writable;
  var onlegacyfinish = function onlegacyfinish2() {
    if (!stream2.writable) onfinish();
  };
  var writableEnded = stream2._writableState && stream2._writableState.finished;
  var onfinish = function onfinish2() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream2);
  };
  var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
  var onend2 = function onend3() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream2);
  };
  var onerror = function onerror2(err2) {
    callback.call(stream2, err2);
  };
  var onclose = function onclose2() {
    var err2;
    if (readable && !readableEnded) {
      if (!stream2._readableState || !stream2._readableState.ended) err2 = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err2);
    }
    if (writable && !writableEnded) {
      if (!stream2._writableState || !stream2._writableState.ended) err2 = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err2);
    }
  };
  var onrequest = function onrequest2() {
    stream2.req.on("finish", onfinish);
  };
  if (isRequest$1(stream2)) {
    stream2.on("complete", onfinish);
    stream2.on("abort", onclose);
    if (stream2.req) onrequest();
    else stream2.on("request", onrequest);
  } else if (writable && !stream2._writableState) {
    stream2.on("end", onlegacyfinish);
    stream2.on("close", onlegacyfinish);
  }
  stream2.on("end", onend2);
  stream2.on("finish", onfinish);
  if (opts2.error !== false) stream2.on("error", onerror);
  stream2.on("close", onclose);
  return function() {
    stream2.removeListener("complete", onfinish);
    stream2.removeListener("abort", onclose);
    stream2.removeListener("request", onrequest);
    if (stream2.req) stream2.req.removeListener("finish", onfinish);
    stream2.removeListener("end", onlegacyfinish);
    stream2.removeListener("close", onlegacyfinish);
    stream2.removeListener("finish", onfinish);
    stream2.removeListener("end", onend2);
    stream2.removeListener("error", onerror);
    stream2.removeListener("close", onclose);
  };
}
var endOfStream = eos$1;
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  var finished = endOfStream;
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value2, done2) {
    return {
      value: value2,
      done: done2
    };
  }
  function readAndResolve(iter) {
    var resolve2 = iter[kLastResolve];
    if (resolve2 !== null) {
      var data2 = iter[kStream].read();
      if (data2 !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve2(createIterResult(data2, false));
      }
    }
  }
  function onReadable(iter) {
    browser$1$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve2, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve2(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve2, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve2, reject) {
          browser$1$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve2(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data2 = this[kStream].read();
        if (data2 !== null) {
          return Promise.resolve(createIterResult(data2, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve2, reject) {
      _this2[kStream].destroy(null, function(err2) {
        if (err2) {
          reject(err2);
          return;
        }
        resolve2(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator2 = function createReadableStreamAsyncIterator3(stream2) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream2,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream2._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value2(resolve2, reject) {
        var data2 = iterator[kStream].read();
        if (data2) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve2(createIterResult(data2, false));
        } else {
          iterator[kLastResolve] = resolve2;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream2, function(err2) {
      if (err2 && err2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err2);
        }
        iterator[kError] = err2;
        return;
      }
      var resolve2 = iterator[kLastResolve];
      if (resolve2 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve2(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream2.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator2;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser) return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
const Registry$4 = _registry;
Registry$4.Readable = Readable;
Readable.ReadableState = ReadableState;
require$$1$1.EventEmitter;
var EElistenerCount = function EElistenerCount2(emitter, type) {
  return emitter.listeners(type).length;
};
var Stream$1 = streamBrowser;
var Buffer$1$1 = require$$0.Buffer;
var OurUint8Array$1 = commonjsGlobal.Uint8Array || function() {
};
function _uint8ArrayToBuffer$1(chunk) {
  return Buffer$1$1.from(chunk);
}
function _isUint8Array$1(obj) {
  return Buffer$1$1.isBuffer(obj) || obj instanceof OurUint8Array$1;
}
var debugUtil = require$$3;
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog("stream");
} else {
  debug = function debug2() {
  };
}
var BufferList = requireBuffer_list();
var destroyImpl$1 = destroy_1;
var _require$1 = state, getHighWaterMark$1 = _require$1.getHighWaterMark;
var _require$codes$3 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE$1 = _require$codes$3.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes$3.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED$2 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes$3.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
var StringDecoder;
var createReadableStreamAsyncIterator;
var from$2;
require$$1(Readable, Stream$1);
var errorOrDestroy$1 = destroyImpl$1.errorOrDestroy;
var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
function prependListener3(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
  else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
  else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream2, isDuplex) {
  options = options || {};
  if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Registry$4.Duplex;
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
  this.highWaterMark = getHighWaterMark$1(this, options, "readableHighWaterMark", isDuplex);
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;
  this.emitClose = options.emitClose !== false;
  this.autoDestroy = !!options.autoDestroy;
  this.destroyed = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require$$10.StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable)) return new Readable(options);
  var isDuplex = this instanceof Registry$4.Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);
  this.readable = true;
  if (options) {
    if (typeof options.read === "function") this._read = options.read;
    if (typeof options.destroy === "function") this._destroy = options.destroy;
  }
  Stream$1.call(this);
}
Object.defineProperty(Readable.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === void 0) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value2) {
    if (!this._readableState) {
      return;
    }
    this._readableState.destroyed = value2;
  }
});
Readable.prototype.destroy = destroyImpl$1.destroy;
Readable.prototype._undestroy = destroyImpl$1.undestroy;
Readable.prototype._destroy = function(err2, cb) {
  cb(err2);
};
Readable.prototype.push = function(chunk, encoding) {
  var state2 = this._readableState;
  var skipChunkCheck;
  if (!state2.objectMode) {
    if (typeof chunk === "string") {
      encoding = encoding || state2.defaultEncoding;
      if (encoding !== state2.encoding) {
        chunk = Buffer$1$1.from(chunk, encoding);
        encoding = "";
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
Readable.prototype.unshift = function(chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
  debug("readableAddChunk", chunk);
  var state2 = stream2._readableState;
  if (chunk === null) {
    state2.reading = false;
    onEofChunk(stream2, state2);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
    if (er) {
      errorOrDestroy$1(stream2, er);
    } else if (state2.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer$1$1.prototype) {
        chunk = _uint8ArrayToBuffer$1(chunk);
      }
      if (addToFront) {
        if (state2.endEmitted) errorOrDestroy$1(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
        else addChunk(stream2, state2, chunk, true);
      } else if (state2.ended) {
        errorOrDestroy$1(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state2.destroyed) {
        return false;
      } else {
        state2.reading = false;
        if (state2.decoder && !encoding) {
          chunk = state2.decoder.write(chunk);
          if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
          else maybeReadMore(stream2, state2);
        } else {
          addChunk(stream2, state2, chunk, false);
        }
      }
    } else if (!addToFront) {
      state2.reading = false;
      maybeReadMore(stream2, state2);
    }
  }
  return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
}
function addChunk(stream2, state2, chunk, addToFront) {
  if (state2.flowing && state2.length === 0 && !state2.sync) {
    state2.awaitDrain = 0;
    stream2.emit("data", chunk);
  } else {
    state2.length += state2.objectMode ? 1 : chunk.length;
    if (addToFront) state2.buffer.unshift(chunk);
    else state2.buffer.push(chunk);
    if (state2.needReadable) emitReadable(stream2);
  }
  maybeReadMore(stream2, state2);
}
function chunkInvalid(state2, chunk) {
  var er;
  if (!_isUint8Array$1(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
    er = new ERR_INVALID_ARG_TYPE$1("chunk", ["string", "Buffer", "Uint8Array"], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder) StringDecoder = require$$10.StringDecoder;
  var decoder2 = new StringDecoder(enc);
  this._readableState.decoder = decoder2;
  this._readableState.encoding = this._readableState.decoder.encoding;
  var p2 = this._readableState.buffer.head;
  var content = "";
  while (p2 !== null) {
    content += decoder2.write(p2.data);
    p2 = p2.next;
  }
  this._readableState.buffer.clear();
  if (content !== "") this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};
var MAX_HWM = 1073741824;
function computeNewHighWaterMark(n3) {
  if (n3 >= MAX_HWM) {
    n3 = MAX_HWM;
  } else {
    n3--;
    n3 |= n3 >>> 1;
    n3 |= n3 >>> 2;
    n3 |= n3 >>> 4;
    n3 |= n3 >>> 8;
    n3 |= n3 >>> 16;
    n3++;
  }
  return n3;
}
function howMuchToRead(n3, state2) {
  if (n3 <= 0 || state2.length === 0 && state2.ended) return 0;
  if (state2.objectMode) return 1;
  if (n3 !== n3) {
    if (state2.flowing && state2.length) return state2.buffer.head.data.length;
    else return state2.length;
  }
  if (n3 > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n3);
  if (n3 <= state2.length) return n3;
  if (!state2.ended) {
    state2.needReadable = true;
    return 0;
  }
  return state2.length;
}
Readable.prototype.read = function(n3) {
  debug("read", n3);
  n3 = parseInt(n3, 10);
  var state2 = this._readableState;
  var nOrig = n3;
  if (n3 !== 0) state2.emittedReadable = false;
  if (n3 === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
    debug("read: emitReadable", state2.length, state2.ended);
    if (state2.length === 0 && state2.ended) endReadable(this);
    else emitReadable(this);
    return null;
  }
  n3 = howMuchToRead(n3, state2);
  if (n3 === 0 && state2.ended) {
    if (state2.length === 0) endReadable(this);
    return null;
  }
  var doRead = state2.needReadable;
  debug("need readable", doRead);
  if (state2.length === 0 || state2.length - n3 < state2.highWaterMark) {
    doRead = true;
    debug("length less than watermark", doRead);
  }
  if (state2.ended || state2.reading) {
    doRead = false;
    debug("reading or ended", doRead);
  } else if (doRead) {
    debug("do read");
    state2.reading = true;
    state2.sync = true;
    if (state2.length === 0) state2.needReadable = true;
    this._read(state2.highWaterMark);
    state2.sync = false;
    if (!state2.reading) n3 = howMuchToRead(nOrig, state2);
  }
  var ret;
  if (n3 > 0) ret = fromList(n3, state2);
  else ret = null;
  if (ret === null) {
    state2.needReadable = state2.length <= state2.highWaterMark;
    n3 = 0;
  } else {
    state2.length -= n3;
    state2.awaitDrain = 0;
  }
  if (state2.length === 0) {
    if (!state2.ended) state2.needReadable = true;
    if (nOrig !== n3 && state2.ended) endReadable(this);
  }
  if (ret !== null) this.emit("data", ret);
  return ret;
};
function onEofChunk(stream2, state2) {
  debug("onEofChunk");
  if (state2.ended) return;
  if (state2.decoder) {
    var chunk = state2.decoder.end();
    if (chunk && chunk.length) {
      state2.buffer.push(chunk);
      state2.length += state2.objectMode ? 1 : chunk.length;
    }
  }
  state2.ended = true;
  if (state2.sync) {
    emitReadable(stream2);
  } else {
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      state2.emittedReadable = true;
      emitReadable_(stream2);
    }
  }
}
function emitReadable(stream2) {
  var state2 = stream2._readableState;
  debug("emitReadable", state2.needReadable, state2.emittedReadable);
  state2.needReadable = false;
  if (!state2.emittedReadable) {
    debug("emitReadable", state2.flowing);
    state2.emittedReadable = true;
    browser$1$1.nextTick(emitReadable_, stream2);
  }
}
function emitReadable_(stream2) {
  var state2 = stream2._readableState;
  debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
  if (!state2.destroyed && (state2.length || state2.ended)) {
    stream2.emit("readable");
    state2.emittedReadable = false;
  }
  state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
  flow(stream2);
}
function maybeReadMore(stream2, state2) {
  if (!state2.readingMore) {
    state2.readingMore = true;
    browser$1$1.nextTick(maybeReadMore_, stream2, state2);
  }
}
function maybeReadMore_(stream2, state2) {
  while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
    var len = state2.length;
    debug("maybeReadMore read 0");
    stream2.read(0);
    if (len === state2.length)
      break;
  }
  state2.readingMore = false;
}
Readable.prototype._read = function(n3) {
  errorOrDestroy$1(this, new ERR_METHOD_NOT_IMPLEMENTED$2("_read()"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
  var src2 = this;
  var state2 = this._readableState;
  switch (state2.pipesCount) {
    case 0:
      state2.pipes = dest;
      break;
    case 1:
      state2.pipes = [state2.pipes, dest];
      break;
    default:
      state2.pipes.push(dest);
      break;
  }
  state2.pipesCount += 1;
  debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== browser$1$1.stdout && dest !== browser$1$1.stderr;
  var endFn = doEnd ? onend2 : unpipe;
  if (state2.endEmitted) browser$1$1.nextTick(endFn);
  else src2.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug("onunpipe");
    if (readable === src2) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend2() {
    debug("onend");
    dest.end();
  }
  var ondrain = pipeOnDrain(src2);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src2.removeListener("end", onend2);
    src2.removeListener("end", unpipe);
    src2.removeListener("data", ondata);
    cleanedUp = true;
    if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src2.on("data", ondata);
  function ondata(chunk) {
    debug("ondata");
    var ret = dest.write(chunk);
    debug("dest.write", ret);
    if (ret === false) {
      if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf3(state2.pipes, dest) !== -1) && !cleanedUp) {
        debug("false write response, pause", state2.awaitDrain);
        state2.awaitDrain++;
      }
      src2.pause();
    }
  }
  function onerror(er) {
    debug("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (EElistenerCount(dest, "error") === 0) errorOrDestroy$1(dest, er);
  }
  prependListener3(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug("unpipe");
    src2.unpipe(dest);
  }
  dest.emit("pipe", src2);
  if (!state2.flowing) {
    debug("pipe resume");
    src2.resume();
  }
  return dest;
};
function pipeOnDrain(src2) {
  return function pipeOnDrainFunctionResult() {
    var state2 = src2._readableState;
    debug("pipeOnDrain", state2.awaitDrain);
    if (state2.awaitDrain) state2.awaitDrain--;
    if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
      state2.flowing = true;
      flow(src2);
    }
  };
}
Readable.prototype.unpipe = function(dest) {
  var state2 = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };
  if (state2.pipesCount === 0) return this;
  if (state2.pipesCount === 1) {
    if (dest && dest !== state2.pipes) return this;
    if (!dest) dest = state2.pipes;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    if (dest) dest.emit("unpipe", this, unpipeInfo);
    return this;
  }
  if (!dest) {
    var dests = state2.pipes;
    var len = state2.pipesCount;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    for (var i2 = 0; i2 < len; i2++) {
      dests[i2].emit("unpipe", this, {
        hasUnpiped: false
      });
    }
    return this;
  }
  var index2 = indexOf3(state2.pipes, dest);
  if (index2 === -1) return this;
  state2.pipes.splice(index2, 1);
  state2.pipesCount -= 1;
  if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
  dest.emit("unpipe", this, unpipeInfo);
  return this;
};
Readable.prototype.on = function(ev, fn) {
  var res = Stream$1.prototype.on.call(this, ev, fn);
  var state2 = this._readableState;
  if (ev === "data") {
    state2.readableListening = this.listenerCount("readable") > 0;
    if (state2.flowing !== false) this.resume();
  } else if (ev === "readable") {
    if (!state2.endEmitted && !state2.readableListening) {
      state2.readableListening = state2.needReadable = true;
      state2.flowing = false;
      state2.emittedReadable = false;
      debug("on readable", state2.length, state2.reading);
      if (state2.length) {
        emitReadable(this);
      } else if (!state2.reading) {
        browser$1$1.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
  var res = Stream$1.prototype.removeListener.call(this, ev, fn);
  if (ev === "readable") {
    browser$1$1.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function(ev) {
  var res = Stream$1.prototype.removeAllListeners.apply(this, arguments);
  if (ev === "readable" || ev === void 0) {
    browser$1$1.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self2) {
  var state2 = self2._readableState;
  state2.readableListening = self2.listenerCount("readable") > 0;
  if (state2.resumeScheduled && !state2.paused) {
    state2.flowing = true;
  } else if (self2.listenerCount("data") > 0) {
    self2.resume();
  }
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
Readable.prototype.resume = function() {
  var state2 = this._readableState;
  if (!state2.flowing) {
    debug("resume");
    state2.flowing = !state2.readableListening;
    resume(this, state2);
  }
  state2.paused = false;
  return this;
};
function resume(stream2, state2) {
  if (!state2.resumeScheduled) {
    state2.resumeScheduled = true;
    browser$1$1.nextTick(resume_, stream2, state2);
  }
}
function resume_(stream2, state2) {
  debug("resume", state2.reading);
  if (!state2.reading) {
    stream2.read(0);
  }
  state2.resumeScheduled = false;
  stream2.emit("resume");
  flow(stream2);
  if (state2.flowing && !state2.reading) stream2.read(0);
}
Readable.prototype.pause = function() {
  debug("call pause flowing=%j", this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream2) {
  var state2 = stream2._readableState;
  debug("flow", state2.flowing);
  while (state2.flowing && stream2.read() !== null) {
  }
}
Readable.prototype.wrap = function(stream2) {
  var _this = this;
  var state2 = this._readableState;
  var paused = false;
  stream2.on("end", function() {
    debug("wrapped end");
    if (state2.decoder && !state2.ended) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream2.on("data", function(chunk) {
    debug("wrapped data");
    if (state2.decoder) chunk = state2.decoder.write(chunk);
    if (state2.objectMode && (chunk === null || chunk === void 0)) return;
    else if (!state2.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream2.pause();
    }
  });
  for (var i2 in stream2) {
    if (this[i2] === void 0 && typeof stream2[i2] === "function") {
      this[i2] = /* @__PURE__ */ function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream2[method].apply(stream2, arguments);
        };
      }(i2);
    }
  }
  for (var n3 = 0; n3 < kProxyEvents.length; n3++) {
    stream2.on(kProxyEvents[n3], this.emit.bind(this, kProxyEvents[n3]));
  }
  this._read = function(n4) {
    debug("wrapped _read", n4);
    if (paused) {
      paused = false;
      stream2.resume();
    }
  };
  return this;
};
if (typeof Symbol === "function") {
  Readable.prototype[Symbol.asyncIterator] = function() {
    if (createReadableStreamAsyncIterator === void 0) {
      createReadableStreamAsyncIterator = requireAsync_iterator();
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get2() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, "readableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get3() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, "readableFlowing", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get4() {
    return this._readableState.flowing;
  },
  set: function set2(state2) {
    if (this._readableState) {
      this._readableState.flowing = state2;
    }
  }
});
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, "readableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get5() {
    return this._readableState.length;
  }
});
function fromList(n3, state2) {
  if (state2.length === 0) return null;
  var ret;
  if (state2.objectMode) ret = state2.buffer.shift();
  else if (!n3 || n3 >= state2.length) {
    if (state2.decoder) ret = state2.buffer.join("");
    else if (state2.buffer.length === 1) ret = state2.buffer.first();
    else ret = state2.buffer.concat(state2.length);
    state2.buffer.clear();
  } else {
    ret = state2.buffer.consume(n3, state2.decoder);
  }
  return ret;
}
function endReadable(stream2) {
  var state2 = stream2._readableState;
  debug("endReadable", state2.endEmitted);
  if (!state2.endEmitted) {
    state2.ended = true;
    browser$1$1.nextTick(endReadableNT, state2, stream2);
  }
}
function endReadableNT(state2, stream2) {
  debug("endReadableNT", state2.endEmitted, state2.length);
  if (!state2.endEmitted && state2.length === 0) {
    state2.endEmitted = true;
    stream2.readable = false;
    stream2.emit("end");
    if (state2.autoDestroy) {
      var wState = stream2._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream2.destroy();
      }
    }
  }
}
if (typeof Symbol === "function") {
  Readable.from = function(iterable, opts2) {
    if (from$2 === void 0) {
      from$2 = requireFromBrowser();
    }
    return from$2(Readable, iterable, opts2);
  };
}
function indexOf3(xs, x) {
  for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
    if (xs[i2] === x) return i2;
  }
  return -1;
}
var browser = deprecate;
function deprecate(fn, msg2) {
  if (config("noDeprecation")) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config("throwDeprecation")) {
        throw new Error(msg2);
      } else if (config("traceDeprecation")) {
        console.trace(msg2);
      } else {
        console.warn(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function config(name) {
  try {
    if (!commonjsGlobal.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = commonjsGlobal.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === "true";
}
const Registry$3 = _registry;
Registry$3.Writable = Writable;
function CorkedRequest(state2) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function() {
    onCorkedFinish(_this, state2);
  };
}
Writable.WritableState = WritableState;
var internalUtil = {
  deprecate: browser
};
var Stream = streamBrowser;
var Buffer$3 = require$$0.Buffer;
var OurUint8Array = commonjsGlobal.Uint8Array || function() {
};
function _uint8ArrayToBuffer(chunk) {
  return Buffer$3.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer$3.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = destroy_1;
var _require = state, getHighWaterMark = _require.getHighWaterMark;
var _require$codes$2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes$2.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$2.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK$1 = _require$codes$2.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes$2.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED$1 = _require$codes$2.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes$2.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes$2.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes$2.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require$$1(Writable, Stream);
function nop() {
}
function WritableState(options, stream2, isDuplex) {
  options = options || {};
  if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Registry$3.Duplex;
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
  this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
  this.finalCalled = false;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  this.destroyed = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream2, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.emitClose = options.emitClose !== false;
  this.autoDestroy = !!options.autoDestroy;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function() {
  try {
    Object.defineProperty(WritableState.prototype, "buffer", {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
    });
  } catch (_) {
  }
})();
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value2(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance2(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  var isDuplex = this instanceof Registry$3.Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function") this._write = options.write;
    if (typeof options.writev === "function") this._writev = options.writev;
    if (typeof options.destroy === "function") this._destroy = options.destroy;
    if (typeof options.final === "function") this._final = options.final;
  }
  Stream.call(this);
}
Writable.prototype.pipe = function() {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream2, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  errorOrDestroy(stream2, er);
  browser$1$1.nextTick(cb, er);
}
function validChunk(stream2, state2, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== "string" && !state2.objectMode) {
    er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
  }
  if (er) {
    errorOrDestroy(stream2, er);
    browser$1$1.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  var ret = false;
  var isBuf = !state2.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer$3.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = "buffer";
  else if (!encoding) encoding = state2.defaultEncoding;
  if (typeof cb !== "function") cb = nop;
  if (state2.ending) writeAfterEnd(this, cb);
  else if (isBuf || validChunk(this, state2, chunk, cb)) {
    state2.pendingcb++;
    ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function() {
  this._writableState.corked++;
};
Writable.prototype.uncork = function() {
  var state2 = this._writableState;
  if (state2.corked) {
    state2.corked--;
    if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
  if (typeof encoding === "string") encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, "writableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get6() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state2, chunk, encoding) {
  if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer$3.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get7() {
    return this._writableState.highWaterMark;
  }
});
function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state2, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = "buffer";
      chunk = newChunk;
    }
  }
  var len = state2.objectMode ? 1 : chunk.length;
  state2.length += len;
  var ret = state2.length < state2.highWaterMark;
  if (!ret) state2.needDrain = true;
  if (state2.writing || state2.corked) {
    var last2 = state2.lastBufferedRequest;
    state2.lastBufferedRequest = {
      chunk,
      encoding,
      isBuf,
      callback: cb,
      next: null
    };
    if (last2) {
      last2.next = state2.lastBufferedRequest;
    } else {
      state2.bufferedRequest = state2.lastBufferedRequest;
    }
    state2.bufferedRequestCount += 1;
  } else {
    doWrite(stream2, state2, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
  state2.writelen = len;
  state2.writecb = cb;
  state2.writing = true;
  state2.sync = true;
  if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED$1("write"));
  else if (writev) stream2._writev(chunk, state2.onwrite);
  else stream2._write(chunk, encoding, state2.onwrite);
  state2.sync = false;
}
function onwriteError(stream2, state2, sync, er, cb) {
  --state2.pendingcb;
  if (sync) {
    browser$1$1.nextTick(cb, er);
    browser$1$1.nextTick(finishMaybe, stream2, state2);
    stream2._writableState.errorEmitted = true;
    errorOrDestroy(stream2, er);
  } else {
    cb(er);
    stream2._writableState.errorEmitted = true;
    errorOrDestroy(stream2, er);
    finishMaybe(stream2, state2);
  }
}
function onwriteStateUpdate(state2) {
  state2.writing = false;
  state2.writecb = null;
  state2.length -= state2.writelen;
  state2.writelen = 0;
}
function onwrite(stream2, er) {
  var state2 = stream2._writableState;
  var sync = state2.sync;
  var cb = state2.writecb;
  if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK$1();
  onwriteStateUpdate(state2);
  if (er) onwriteError(stream2, state2, sync, er, cb);
  else {
    var finished = needFinish(state2) || stream2.destroyed;
    if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
      clearBuffer(stream2, state2);
    }
    if (sync) {
      browser$1$1.nextTick(afterWrite, stream2, state2, finished, cb);
    } else {
      afterWrite(stream2, state2, finished, cb);
    }
  }
}
function afterWrite(stream2, state2, finished, cb) {
  if (!finished) onwriteDrain(stream2, state2);
  state2.pendingcb--;
  cb();
  finishMaybe(stream2, state2);
}
function onwriteDrain(stream2, state2) {
  if (state2.length === 0 && state2.needDrain) {
    state2.needDrain = false;
    stream2.emit("drain");
  }
}
function clearBuffer(stream2, state2) {
  state2.bufferProcessing = true;
  var entry = state2.bufferedRequest;
  if (stream2._writev && entry && entry.next) {
    var l2 = state2.bufferedRequestCount;
    var buffer = new Array(l2);
    var holder = state2.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
    state2.pendingcb++;
    state2.lastBufferedRequest = null;
    if (holder.next) {
      state2.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state2.corkedRequestsFree = new CorkedRequest(state2);
    }
    state2.bufferedRequestCount = 0;
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state2.objectMode ? 1 : chunk.length;
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
      entry = entry.next;
      state2.bufferedRequestCount--;
      if (state2.writing) {
        break;
      }
    }
    if (entry === null) state2.lastBufferedRequest = null;
  }
  state2.bufferedRequest = entry;
  state2.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED$1("_write()"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
  if (state2.corked) {
    state2.corked = 1;
    this.uncork();
  }
  if (!state2.ending) endWritable(this, state2, cb);
  return this;
};
Object.defineProperty(Writable.prototype, "writableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get8() {
    return this._writableState.length;
  }
});
function needFinish(state2) {
  return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
}
function callFinal(stream2, state2) {
  stream2._final(function(err2) {
    state2.pendingcb--;
    if (err2) {
      errorOrDestroy(stream2, err2);
    }
    state2.prefinished = true;
    stream2.emit("prefinish");
    finishMaybe(stream2, state2);
  });
}
function prefinish$1(stream2, state2) {
  if (!state2.prefinished && !state2.finalCalled) {
    if (typeof stream2._final === "function" && !state2.destroyed) {
      state2.pendingcb++;
      state2.finalCalled = true;
      browser$1$1.nextTick(callFinal, stream2, state2);
    } else {
      state2.prefinished = true;
      stream2.emit("prefinish");
    }
  }
}
function finishMaybe(stream2, state2) {
  var need = needFinish(state2);
  if (need) {
    prefinish$1(stream2, state2);
    if (state2.pendingcb === 0) {
      state2.finished = true;
      stream2.emit("finish");
      if (state2.autoDestroy) {
        var rState = stream2._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream2.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream2, state2, cb) {
  state2.ending = true;
  finishMaybe(stream2, state2);
  if (cb) {
    if (state2.finished) browser$1$1.nextTick(cb);
    else stream2.once("finish", cb);
  }
  state2.ended = true;
  stream2.writable = false;
}
function onCorkedFinish(corkReq, state2, err2) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state2.pendingcb--;
    cb(err2);
    entry = entry.next;
  }
  state2.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get9() {
    if (this._writableState === void 0) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set3(value2) {
    if (!this._writableState) {
      return;
    }
    this._writableState.destroyed = value2;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err2, cb) {
  cb(err2);
};
var objectKeys$1 = Object.keys || function(obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }
  return keys;
};
const Registry$2 = _registry;
Registry$2.Duplex = Duplex;
require$$1(Duplex, Registry$2.Readable);
{
  var keys = objectKeys$1(Registry$2.Writable.prototype);
  for (var v$1 = 0; v$1 < keys.length; v$1++) {
    var method = keys[v$1];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Registry$2.Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Registry$2.Readable.call(this, options);
  Registry$2.Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once("end", onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get10() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, "writableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get11() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, "writableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get12() {
    return this._writableState.length;
  }
});
function onend() {
  if (this._writableState.ended) return;
  browser$1$1.nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
Object.defineProperty(Duplex.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get13() {
    if (this._readableState === void 0 || this._writableState === void 0) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set4(value2) {
    if (this._readableState === void 0 || this._writableState === void 0) {
      return;
    }
    this._readableState.destroyed = value2;
    this._writableState.destroyed = value2;
  }
});
const Registry$1 = _registry;
Registry$1.Transform = Transform$1;
var _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
require$$1(Transform$1, Registry$1.Duplex);
function afterTransform(er, data2) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 != null)
    this.push(data2);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform$1(options) {
  if (!(this instanceof Transform$1)) return new Transform$1(options);
  Registry$1.Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function") this._transform = options.transform;
    if (typeof options.flush === "function") this._flush = options.flush;
  }
  this.on("prefinish", prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === "function" && !this._readableState.destroyed) {
    this._flush(function(er, data2) {
      done(_this, er, data2);
    });
  } else {
    done(this, null, null);
  }
}
Transform$1.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Registry$1.Duplex.prototype.push.call(this, chunk, encoding);
};
Transform$1.prototype._transform = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$1.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};
Transform$1.prototype._read = function(n3) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
Transform$1.prototype._destroy = function(err2, cb) {
  Registry$1.Duplex.prototype._destroy.call(this, err2, function(err22) {
    cb(err22);
  });
};
function done(stream2, er, data2) {
  if (er) return stream2.emit("error", er);
  if (data2 != null)
    stream2.push(data2);
  if (stream2._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream2._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream2.push(null);
}
const Registry = _registry;
Registry.PassThrough = PassThrough;
require$$1(PassThrough, Registry.Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
var eos;
function once3(callback) {
  var called = false;
  return function() {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop$3(err2) {
  if (err2) throw err2;
}
function isRequest(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function destroyer(stream2, reading, writing, callback) {
  callback = once3(callback);
  var closed = false;
  stream2.on("close", function() {
    closed = true;
  });
  if (eos === void 0) eos = endOfStream;
  eos(stream2, {
    readable: reading,
    writable: writing
  }, function(err2) {
    if (err2) return callback(err2);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function(err2) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;
    if (isRequest(stream2)) return stream2.abort();
    if (typeof stream2.destroy === "function") return stream2.destroy();
    callback(err2 || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function call(fn) {
  fn();
}
function pipe(from2, to) {
  return from2.pipe(to);
}
function popCallback(streams2) {
  if (!streams2.length) return noop$3;
  if (typeof streams2[streams2.length - 1] !== "function") return noop$3;
  return streams2.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams2 = new Array(_len), _key = 0; _key < _len; _key++) {
    streams2[_key] = arguments[_key];
  }
  var callback = popCallback(streams2);
  if (Array.isArray(streams2[0])) streams2 = streams2[0];
  if (streams2.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  var error;
  var destroys = streams2.map(function(stream2, i2) {
    var reading = i2 < streams2.length - 1;
    var writing = i2 > 0;
    return destroyer(stream2, reading, writing, function(err2) {
      if (!error) error = err2;
      if (err2) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams2.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(module, exports) {
  const Registry2 = _registry;
  exports = module.exports = Registry2.Readable;
  exports.Stream = Registry2.Readable;
  exports.Readable = Registry2.Readable;
  exports.Writable = Registry2.Writable;
  exports.Duplex = Registry2.Duplex;
  exports.Transform = Registry2.Transform;
  exports.PassThrough = Registry2.PassThrough;
  exports.finished = endOfStream;
  exports.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports;
var stream = /* @__PURE__ */ getDefaultExportFromCjs(readableBrowserExports);
var lib = {};
var binding = {};
function compare5(a2, b2) {
  if (a2 === b2) {
    return 0;
  }
  var x = a2.length;
  var y2 = b2.length;
  for (var i2 = 0, len = Math.min(x, y2); i2 < len; ++i2) {
    if (a2[i2] !== b2[i2]) {
      x = a2[i2];
      y2 = b2[i2];
      break;
    }
  }
  if (x < y2) {
    return -1;
  }
  if (y2 < x) {
    return 1;
  }
  return 0;
}
var hasOwn = Object.prototype.hasOwnProperty;
var objectKeys = Object.keys || function(obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};
var pSlice = Array.prototype.slice;
var _functionsHaveNames;
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== "undefined") {
    return _functionsHaveNames;
  }
  return _functionsHaveNames = function() {
    return (function foo() {
    }).name === "foo";
  }();
}
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer$1$1(arrbuf)) {
    return false;
  }
  if (typeof global$1$1.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
function assert(value2, message) {
  if (!value2) fail(value2, true, message, "==", ok);
}
var regex$1 = /\s*function\s+([^\(\s]*)\s*/;
function getName(func) {
  if (!isFunction(func)) {
    return;
  }
  if (functionsHaveNames()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex$1);
  return match && match[1];
}
assert.AssertionError = AssertionError;
function AssertionError(options) {
  this.name = "AssertionError";
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err2 = new Error();
    if (err2.stack) {
      var out = err2.stack;
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
}
inherits$2(AssertionError, Error);
function truncate$1(s2, n3) {
  if (typeof s2 === "string") {
    return s2.length < n3 ? s2 : s2.slice(0, n3);
  } else {
    return s2;
  }
}
function inspect3(something) {
  if (functionsHaveNames() || !isFunction(something)) {
    return inspect$1(something);
  }
  var rawname = getName(something);
  var name = rawname ? ": " + rawname : "";
  return "[Function" + name + "]";
}
function getMessage(self2) {
  return truncate$1(inspect3(self2.actual), 128) + " " + self2.operator + " " + truncate$1(inspect3(self2.expected), 128);
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
assert.fail = fail;
function ok(value2, message) {
  if (!value2) fail(value2, true, message, "==", ok);
}
assert.ok = ok;
assert.equal = equal;
function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, "==", equal);
}
assert.notEqual = notEqual;
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, "!=", notEqual);
  }
}
assert.deepEqual = deepEqual;
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "deepEqual", deepEqual);
  }
}
assert.deepStrictEqual = deepStrictEqual;
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "deepStrictEqual", deepStrictEqual);
  }
}
function _deepEqual(actual, expected, strict, memos) {
  if (actual === expected) {
    return true;
  } else if (isBuffer$1$1(actual) && isBuffer$1$1(expected)) {
    return compare5(actual, expected) === 0;
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare5(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0;
  } else if (isBuffer$1$1(actual) !== isBuffer$1$1(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}
function isArguments(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv(a2, b2, strict, actualVisitedObjects) {
  if (a2 === null || a2 === void 0 || b2 === null || b2 === void 0)
    return false;
  if (isPrimitive(a2) || isPrimitive(b2))
    return a2 === b2;
  if (strict && Object.getPrototypeOf(a2) !== Object.getPrototypeOf(b2))
    return false;
  var aIsArgs = isArguments(a2);
  var bIsArgs = isArguments(b2);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a2 = pSlice.call(a2);
    b2 = pSlice.call(b2);
    return _deepEqual(a2, b2, strict);
  }
  var ka = objectKeys(a2);
  var kb = objectKeys(b2);
  var key, i2;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i2 = ka.length - 1; i2 >= 0; i2--) {
    if (ka[i2] !== kb[i2])
      return false;
  }
  for (i2 = ka.length - 1; i2 >= 0; i2--) {
    key = ka[i2];
    if (!_deepEqual(a2[key], b2[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}
assert.notDeepEqual = notDeepEqual;
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "notDeepEqual", notDeepEqual);
  }
}
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
  }
}
assert.strictEqual = strictEqual;
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, "===", strictEqual);
  }
}
assert.notStrictEqual = notStrictEqual;
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, "!==", notStrictEqual);
  }
}
function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e2) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e2) {
    error = e2;
  }
  return error;
}
function _throws(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock(block);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
assert.throws = throws;
function throws(block, error, message) {
  _throws(true, block, error, message);
}
assert.doesNotThrow = doesNotThrow;
function doesNotThrow(block, error, message) {
  _throws(false, block, error, message);
}
assert.ifError = ifError;
function ifError(err2) {
  if (err2) throw err2;
}
var _polyfillNode_assert = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AssertionError,
  assert: ok,
  deepEqual,
  deepStrictEqual,
  default: assert,
  doesNotThrow,
  equal,
  fail,
  ifError,
  notDeepEqual,
  notDeepStrictEqual,
  notEqual,
  notStrictEqual,
  ok,
  strictEqual,
  throws
});
var require$$4 = /* @__PURE__ */ getAugmentedNamespace(_polyfillNode_assert);
(function(exports) {
  var assert2 = require$$4;
  var Zstream = require$$1$2$1;
  var zlib_deflate = require$$2;
  var zlib_inflate = require$$3$1$1;
  var constants2 = require$$4$1$1;
  for (var key in constants2) {
    exports[key] = constants2[key];
  }
  exports.NONE = 0;
  exports.DEFLATE = 1;
  exports.INFLATE = 2;
  exports.GZIP = 3;
  exports.GUNZIP = 4;
  exports.DEFLATERAW = 5;
  exports.INFLATERAW = 6;
  exports.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib(mode) {
    if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  Zlib.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert2(this.init_done, "close before init");
    assert2(this.mode <= exports.UNZIP);
    if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports.NONE;
    this.dictionary = null;
  };
  Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert2.equal(arguments.length, 8);
    assert2(this.init_done, "write before init");
    assert2(this.mode !== exports.NONE, "already finalized");
    assert2.equal(false, this.write_in_progress, "write already in progress");
    assert2.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert2.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer$2.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    browser$1$1.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports.INFLATE;
              break;
            }
          // fallthrough
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports.GUNZIP;
            } else {
              this.mode = exports.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      // fallthrough
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports.Z_DATA_ERROR) {
            this.err = exports.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib.prototype._checkError = function() {
    switch (this.err) {
      case exports.Z_OK:
      case exports.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports.Z_STREAM_END:
        break;
      case exports.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary2) {
    assert2(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert2(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert2(level >= -1 && level <= 9, "invalid compression level");
    assert2(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert2(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary2);
    this._setDictionary();
  };
  Zlib.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary2) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports.Z_NO_FLUSH;
    this.err = exports.Z_OK;
    if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
      case exports.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary2;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib.prototype._reset = function() {
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
      case exports.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports.INFLATE:
      case exports.INFLATERAW:
      case exports.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports.Zlib = Zlib;
})(binding);
(function(exports) {
  var Buffer2 = require$$0.Buffer;
  var Transform2 = readableBrowserExports.Transform;
  var binding$12 = binding;
  var util = require$$3;
  var assert2 = require$$4.ok;
  var kMaxLength2 = require$$0.kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength2.toString(16) + " bytes";
  binding$12.Z_MIN_WINDOWBITS = 8;
  binding$12.Z_MAX_WINDOWBITS = 15;
  binding$12.Z_DEFAULT_WINDOWBITS = 15;
  binding$12.Z_MIN_CHUNK = 64;
  binding$12.Z_MAX_CHUNK = Infinity;
  binding$12.Z_DEFAULT_CHUNK = 16 * 1024;
  binding$12.Z_MIN_MEMLEVEL = 1;
  binding$12.Z_MAX_MEMLEVEL = 9;
  binding$12.Z_DEFAULT_MEMLEVEL = 8;
  binding$12.Z_MIN_LEVEL = -1;
  binding$12.Z_MAX_LEVEL = 9;
  binding$12.Z_DEFAULT_LEVEL = binding$12.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding$12);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports, bkey, {
        enumerable: true,
        value: binding$12[bkey],
        writable: false
      });
    }
  }
  var codes2 = {
    Z_OK: binding$12.Z_OK,
    Z_STREAM_END: binding$12.Z_STREAM_END,
    Z_NEED_DICT: binding$12.Z_NEED_DICT,
    Z_ERRNO: binding$12.Z_ERRNO,
    Z_STREAM_ERROR: binding$12.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding$12.Z_DATA_ERROR,
    Z_MEM_ERROR: binding$12.Z_MEM_ERROR,
    Z_BUF_ERROR: binding$12.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding$12.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes2);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes2[codes2[ckey]] = ckey;
  }
  Object.defineProperty(exports, "codes", {
    enumerable: true,
    value: Object.freeze(codes2),
    writable: false
  });
  exports.Deflate = Deflate;
  exports.Inflate = Inflate;
  exports.Gzip = Gzip;
  exports.Gunzip = Gunzip;
  exports.DeflateRaw = DeflateRaw;
  exports.InflateRaw = InflateRaw;
  exports.Unzip = Unzip;
  exports.createDeflate = function(o2) {
    return new Deflate(o2);
  };
  exports.createInflate = function(o2) {
    return new Inflate(o2);
  };
  exports.createDeflateRaw = function(o2) {
    return new DeflateRaw(o2);
  };
  exports.createInflateRaw = function(o2) {
    return new InflateRaw(o2);
  };
  exports.createGzip = function(o2) {
    return new Gzip(o2);
  };
  exports.createGunzip = function(o2) {
    return new Gunzip(o2);
  };
  exports.createUnzip = function(o2) {
    return new Unzip(o2);
  };
  exports.deflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Deflate(opts2), buffer, callback);
  };
  exports.deflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Deflate(opts2), buffer);
  };
  exports.gzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gzip(opts2), buffer, callback);
  };
  exports.gzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gzip(opts2), buffer);
  };
  exports.deflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new DeflateRaw(opts2), buffer, callback);
  };
  exports.deflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new DeflateRaw(opts2), buffer);
  };
  exports.unzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Unzip(opts2), buffer, callback);
  };
  exports.unzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Unzip(opts2), buffer);
  };
  exports.inflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Inflate(opts2), buffer, callback);
  };
  exports.inflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Inflate(opts2), buffer);
  };
  exports.gunzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gunzip(opts2), buffer, callback);
  };
  exports.gunzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gunzip(opts2), buffer);
  };
  exports.inflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new InflateRaw(opts2), buffer, callback);
  };
  exports.inflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new InflateRaw(opts2), buffer);
  };
  function zlibBuffer(engine2, buffer, callback) {
    var buffers = [];
    var nread = 0;
    engine2.on("error", onError);
    engine2.on("end", onEnd);
    engine2.end(buffer);
    flow2();
    function flow2() {
      var chunk;
      while (null !== (chunk = engine2.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine2.once("readable", flow2);
    }
    function onError(err2) {
      engine2.removeListener("end", onEnd);
      engine2.removeListener("readable", flow2);
      callback(err2);
    }
    function onEnd() {
      var buf;
      var err2 = null;
      if (nread >= kMaxLength2) {
        err2 = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer2.concat(buffers, nread);
      }
      buffers = [];
      engine2.close();
      callback(err2, buf);
    }
  }
  function zlibBufferSync(engine2, buffer) {
    if (typeof buffer === "string") buffer = Buffer2.from(buffer);
    if (!Buffer2.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
    var flushFlag = engine2._finishFlushFlag;
    return engine2._processChunk(buffer, flushFlag);
  }
  function Deflate(opts2) {
    if (!(this instanceof Deflate)) return new Deflate(opts2);
    Zlib.call(this, opts2, binding$12.DEFLATE);
  }
  function Inflate(opts2) {
    if (!(this instanceof Inflate)) return new Inflate(opts2);
    Zlib.call(this, opts2, binding$12.INFLATE);
  }
  function Gzip(opts2) {
    if (!(this instanceof Gzip)) return new Gzip(opts2);
    Zlib.call(this, opts2, binding$12.GZIP);
  }
  function Gunzip(opts2) {
    if (!(this instanceof Gunzip)) return new Gunzip(opts2);
    Zlib.call(this, opts2, binding$12.GUNZIP);
  }
  function DeflateRaw(opts2) {
    if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts2);
    Zlib.call(this, opts2, binding$12.DEFLATERAW);
  }
  function InflateRaw(opts2) {
    if (!(this instanceof InflateRaw)) return new InflateRaw(opts2);
    Zlib.call(this, opts2, binding$12.INFLATERAW);
  }
  function Unzip(opts2) {
    if (!(this instanceof Unzip)) return new Unzip(opts2);
    Zlib.call(this, opts2, binding$12.UNZIP);
  }
  function isValidFlushFlag(flag) {
    return flag === binding$12.Z_NO_FLUSH || flag === binding$12.Z_PARTIAL_FLUSH || flag === binding$12.Z_SYNC_FLUSH || flag === binding$12.Z_FULL_FLUSH || flag === binding$12.Z_FINISH || flag === binding$12.Z_BLOCK;
  }
  function Zlib(opts2, mode) {
    var _this = this;
    this._opts = opts2 = opts2 || {};
    this._chunkSize = opts2.chunkSize || exports.Z_DEFAULT_CHUNK;
    Transform2.call(this, opts2);
    if (opts2.flush && !isValidFlushFlag(opts2.flush)) {
      throw new Error("Invalid flush flag: " + opts2.flush);
    }
    if (opts2.finishFlush && !isValidFlushFlag(opts2.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts2.finishFlush);
    }
    this._flushFlag = opts2.flush || binding$12.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts2.finishFlush !== "undefined" ? opts2.finishFlush : binding$12.Z_FINISH;
    if (opts2.chunkSize) {
      if (opts2.chunkSize < exports.Z_MIN_CHUNK || opts2.chunkSize > exports.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts2.chunkSize);
      }
    }
    if (opts2.windowBits) {
      if (opts2.windowBits < exports.Z_MIN_WINDOWBITS || opts2.windowBits > exports.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts2.windowBits);
      }
    }
    if (opts2.level) {
      if (opts2.level < exports.Z_MIN_LEVEL || opts2.level > exports.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts2.level);
      }
    }
    if (opts2.memLevel) {
      if (opts2.memLevel < exports.Z_MIN_MEMLEVEL || opts2.memLevel > exports.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts2.memLevel);
      }
    }
    if (opts2.strategy) {
      if (opts2.strategy != exports.Z_FILTERED && opts2.strategy != exports.Z_HUFFMAN_ONLY && opts2.strategy != exports.Z_RLE && opts2.strategy != exports.Z_FIXED && opts2.strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts2.strategy);
      }
    }
    if (opts2.dictionary) {
      if (!Buffer2.isBuffer(opts2.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding$12.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
      _close(self2);
      self2._hadError = true;
      var error = new Error(message);
      error.errno = errno;
      error.code = exports.codes[errno];
      self2.emit("error", error);
    };
    var level = exports.Z_DEFAULT_COMPRESSION;
    if (typeof opts2.level === "number") level = opts2.level;
    var strategy = exports.Z_DEFAULT_STRATEGY;
    if (typeof opts2.strategy === "number") strategy = opts2.strategy;
    this._handle.init(opts2.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts2.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts2.dictionary);
    this._buffer = Buffer2.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: function() {
        return !_this._handle;
      },
      configurable: true,
      enumerable: true
    });
  }
  util.inherits(Zlib, Transform2);
  Zlib.prototype.params = function(level, strategy, callback) {
    if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding$12.Z_SYNC_FLUSH, function() {
        assert2(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback) callback();
        }
      });
    } else {
      browser$1$1.nextTick(callback);
    }
  };
  Zlib.prototype.reset = function() {
    assert2(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib.prototype._flush = function(callback) {
    this._transform(Buffer2.alloc(0), "", callback);
  };
  Zlib.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding$12.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback) browser$1$1.nextTick(callback);
    } else if (ws.ending) {
      if (callback) this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer2.alloc(0), "", callback);
    }
  };
  Zlib.prototype.close = function(callback) {
    _close(this, callback);
    browser$1$1.nextTick(emitCloseNT2, this);
  };
  function _close(engine2, callback) {
    if (callback) browser$1$1.nextTick(callback);
    if (!engine2._handle) return;
    engine2._handle.close();
    engine2._handle = null;
  }
  function emitCloseNT2(self2) {
    self2.emit("close");
  }
  Zlib.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last2 = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer2.isBuffer(chunk)) return cb(new Error("invalid input"));
    if (!this._handle) return cb(new Error("zlib binding closed"));
    if (last2) flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding$12.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(er) {
        error = er;
      });
      assert2(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength2) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer2.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert2(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError) return;
      var have = availOutBefore - availOutAfter;
      assert2(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer2.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async) return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async) return false;
      cb();
    }
  };
  util.inherits(Deflate, Zlib);
  util.inherits(Inflate, Zlib);
  util.inherits(Gzip, Zlib);
  util.inherits(Gunzip, Zlib);
  util.inherits(DeflateRaw, Zlib);
  util.inherits(InflateRaw, Zlib);
  util.inherits(Unzip, Zlib);
})(lib);
var zlib = /* @__PURE__ */ getDefaultExportFromCjs(lib);
class PDFReference extends stream.Writable {
  constructor(document2, id, data2) {
    super({
      decodeStrings: false
    });
    this.finalize = this.finalize.bind(this);
    this.document = document2;
    this.id = id;
    if (data2 == null) {
      data2 = {};
    }
    this.data = data2;
    this.gen = 0;
    this.deflate = null;
    this.compress = this.document.compress && !this.data.Filter;
    this.uncompressedLength = 0;
    this.chunks = [];
  }
  initDeflate() {
    this.data.Filter = "FlateDecode";
    this.deflate = zlib.createDeflate();
    this.deflate.on("data", (chunk) => {
      this.chunks.push(chunk);
      return this.data.Length += chunk.length;
    });
    return this.deflate.on("end", this.finalize);
  }
  _write(chunk, encoding, callback) {
    if (!(chunk instanceof Uint8Array)) {
      chunk = Buffer$2.from(chunk + "\n", "binary");
    }
    this.uncompressedLength += chunk.length;
    if (this.data.Length == null) {
      this.data.Length = 0;
    }
    if (this.compress) {
      if (!this.deflate) {
        this.initDeflate();
      }
      this.deflate.write(chunk);
    } else {
      this.chunks.push(chunk);
      this.data.Length += chunk.length;
    }
    return callback();
  }
  end() {
    super.end(...arguments);
    if (this.deflate) {
      return this.deflate.end();
    }
    return this.finalize();
  }
  finalize() {
    this.offset = this.document._offset;
    this.document._write(`${this.id} ${this.gen} obj`);
    this.document._write(PDFObject.convert(this.data));
    if (this.chunks.length) {
      this.document._write("stream");
      for (let chunk of Array.from(this.chunks)) {
        this.document._write(chunk);
      }
      this.chunks.length = 0;
      this.document._write("\nendstream");
    }
    this.document._write("endobj");
    return this.document._refEnd(this);
  }
  toString() {
    return `${this.id} ${this.gen} R`;
  }
}
class PDFTree {
  constructor(options) {
    if (options === void 0) {
      options = {};
    }
    this._items = {};
    this.limits = typeof options.limits === "boolean" ? options.limits : true;
  }
  add(key, val) {
    return this._items[key] = val;
  }
  get(key) {
    return this._items[key];
  }
  toString() {
    const sortedKeys = Object.keys(this._items).sort((a2, b2) => this._compareKeys(a2, b2));
    const out = ["<<"];
    if (this.limits && sortedKeys.length > 1) {
      const first = sortedKeys[0], last2 = sortedKeys[sortedKeys.length - 1];
      out.push(`  /Limits ${PDFObject.convert([this._dataForKey(first), this._dataForKey(last2)])}`);
    }
    out.push(`  /${this._keysName()} [`);
    for (let key of sortedKeys) {
      out.push(`    ${PDFObject.convert(this._dataForKey(key))} ${PDFObject.convert(this._items[key])}`);
    }
    out.push("]");
    out.push(">>");
    return out.join("\n");
  }
  _compareKeys() {
    throw new Error("Must be implemented by subclasses");
  }
  _keysName() {
    throw new Error("Must be implemented by subclasses");
  }
  _dataForKey() {
    throw new Error("Must be implemented by subclasses");
  }
}
class PDFNameTree extends PDFTree {
  _compareKeys(a2, b2) {
    return a2.localeCompare(b2);
  }
  _keysName() {
    return "Names";
  }
  _dataForKey(k2) {
    return new String(k2);
  }
}
const pad = (str, length2) => (Array(length2 + 1).join("0") + str).slice(-length2);
const escapableRe = /[\n\r\t\b\f()\\]/g;
const escapable = {
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\b": "\\b",
  "\f": "\\f",
  "\\": "\\\\",
  "(": "\\(",
  ")": "\\)"
};
const swapBytes = function(buff) {
  const l2 = buff.length;
  if (l2 & 1) {
    throw new Error("Buffer length must be even");
  } else {
    for (let i2 = 0, end2 = l2 - 1; i2 < end2; i2 += 2) {
      const a2 = buff[i2];
      buff[i2] = buff[i2 + 1];
      buff[i2 + 1] = a2;
    }
  }
  return buff;
};
class PDFObject {
  static convert(object) {
    if (typeof object === "string") {
      return `/${object}`;
    }
    if (object instanceof String) {
      let string = object;
      let isUnicode = false;
      for (let i2 = 0, end2 = string.length; i2 < end2; i2++) {
        if (string.charCodeAt(i2) > 127) {
          isUnicode = true;
          break;
        }
      }
      if (isUnicode) {
        string = swapBytes(Buffer$2.from(`\uFEFF${string}`, "utf16le")).toString("binary");
      }
      string = string.replace(escapableRe, (c2) => escapable[c2]);
      return `(${string})`;
    }
    if (Buffer$2.isBuffer(object)) {
      return `<${object.toString("hex")}>`;
    }
    if (object instanceof PDFReference || object instanceof PDFNameTree) {
      return object.toString();
    }
    if (object instanceof Date) {
      return `(D:${pad(object.getUTCFullYear(), 4)}` + pad(object.getUTCMonth() + 1, 2) + pad(object.getUTCDate(), 2) + pad(object.getUTCHours(), 2) + pad(object.getUTCMinutes(), 2) + pad(object.getUTCSeconds(), 2) + "Z)";
    }
    if (Array.isArray(object)) {
      const items = Array.from(object).map((e2) => PDFObject.convert(e2)).join(" ");
      return `[${items}]`;
    }
    if ({}.toString.call(object) === "[object Object]") {
      const out = ["<<"];
      for (let key in object) {
        const val = object[key];
        out.push(`/${key} ${PDFObject.convert(val)}`);
      }
      out.push(">>");
      return out.join("\n");
    }
    if (typeof object === "number") {
      return PDFObject.number(object);
    }
    return `${object}`;
  }
  static number(n3) {
    if (n3 > -1e21 && n3 < 1e21) {
      return Math.round(n3 * 1e6) / 1e6;
    }
    throw new Error(`unsupported number: ${n3}`);
  }
}
const DEFAULT_MARGINS = {
  top: 72,
  left: 72,
  bottom: 72,
  right: 72
};
const SIZES = {
  "4A0": [4767.87, 6740.79],
  "2A0": [3370.39, 4767.87],
  A0: [2383.94, 3370.39],
  A1: [1683.78, 2383.94],
  A2: [1190.55, 1683.78],
  A3: [841.89, 1190.55],
  A4: [595.28, 841.89],
  A5: [419.53, 595.28],
  A6: [297.64, 419.53],
  A7: [209.76, 297.64],
  A8: [147.4, 209.76],
  A9: [104.88, 147.4],
  A10: [73.7, 104.88],
  B0: [2834.65, 4008.19],
  B1: [2004.09, 2834.65],
  B2: [1417.32, 2004.09],
  B3: [1000.63, 1417.32],
  B4: [708.66, 1000.63],
  B5: [498.9, 708.66],
  B6: [354.33, 498.9],
  B7: [249.45, 354.33],
  B8: [175.75, 249.45],
  B9: [124.72, 175.75],
  B10: [87.87, 124.72],
  C0: [2599.37, 3676.54],
  C1: [1836.85, 2599.37],
  C2: [1298.27, 1836.85],
  C3: [918.43, 1298.27],
  C4: [649.13, 918.43],
  C5: [459.21, 649.13],
  C6: [323.15, 459.21],
  C7: [229.61, 323.15],
  C8: [161.57, 229.61],
  C9: [113.39, 161.57],
  C10: [79.37, 113.39],
  RA0: [2437.8, 3458.27],
  RA1: [1729.13, 2437.8],
  RA2: [1218.9, 1729.13],
  RA3: [864.57, 1218.9],
  RA4: [609.45, 864.57],
  SRA0: [2551.18, 3628.35],
  SRA1: [1814.17, 2551.18],
  SRA2: [1275.59, 1814.17],
  SRA3: [907.09, 1275.59],
  SRA4: [637.8, 907.09],
  EXECUTIVE: [521.86, 756],
  FOLIO: [612, 936],
  LEGAL: [612, 1008],
  LETTER: [612, 792],
  TABLOID: [792, 1224]
};
class PDFPage {
  constructor(document2, options) {
    if (options === void 0) {
      options = {};
    }
    this.document = document2;
    this._options = options;
    this.size = options.size || "letter";
    this.layout = options.layout || "portrait";
    this.userUnit = options.userUnit || 1;
    if (typeof options.margin === "number") {
      this.margins = {
        top: options.margin,
        left: options.margin,
        bottom: options.margin,
        right: options.margin
      };
    } else {
      this.margins = options.margins || DEFAULT_MARGINS;
    }
    const dimensions = Array.isArray(this.size) ? this.size : SIZES[this.size.toUpperCase()];
    this.width = dimensions[this.layout === "portrait" ? 0 : 1];
    this.height = dimensions[this.layout === "portrait" ? 1 : 0];
    this.content = this.document.ref();
    if (options.font) document2.font(options.font, options.fontFamily);
    if (options.fontSize) document2.fontSize(options.fontSize);
    this.resources = this.document.ref({
      ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"]
    });
    this.dictionary = this.document.ref({
      Type: "Page",
      Parent: this.document._root.data.Pages,
      MediaBox: [0, 0, this.width, this.height],
      Contents: this.content,
      Resources: this.resources,
      UserUnit: this.userUnit
    });
    this.markings = [];
  }
  // Lazily create these objects
  get fonts() {
    const data2 = this.resources.data;
    return data2.Font != null ? data2.Font : data2.Font = {};
  }
  get xobjects() {
    const data2 = this.resources.data;
    return data2.XObject != null ? data2.XObject : data2.XObject = {};
  }
  get ext_gstates() {
    const data2 = this.resources.data;
    return data2.ExtGState != null ? data2.ExtGState : data2.ExtGState = {};
  }
  get patterns() {
    const data2 = this.resources.data;
    return data2.Pattern != null ? data2.Pattern : data2.Pattern = {};
  }
  get colorSpaces() {
    const data2 = this.resources.data;
    return data2.ColorSpace || (data2.ColorSpace = {});
  }
  get annotations() {
    const data2 = this.dictionary.data;
    return data2.Annots != null ? data2.Annots : data2.Annots = [];
  }
  get structParentTreeKey() {
    const data2 = this.dictionary.data;
    return data2.StructParents != null ? data2.StructParents : data2.StructParents = this.document.createStructParentTreeNextKey();
  }
  maxY() {
    return this.height - this.margins.bottom;
  }
  write(chunk) {
    return this.content.write(chunk);
  }
  // Set tab order if document is tagged for accessibility.
  _setTabOrder() {
    if (!this.dictionary.Tabs && this.document.hasMarkInfoDictionary()) {
      this.dictionary.data.Tabs = "S";
    }
  }
  end() {
    this._setTabOrder();
    this.dictionary.end();
    this.resources.data.ColorSpace = this.resources.data.ColorSpace || {};
    for (let color of Object.values(this.document.spotColors)) {
      this.resources.data.ColorSpace[color.id] = color;
    }
    this.resources.end();
    return this.content.end();
  }
}
const wordArrayToBuffer = (wordArray) => {
  const byteArray = [];
  for (let i2 = 0; i2 < wordArray.sigBytes; i2++) {
    byteArray.push(wordArray.words[Math.floor(i2 / 4)] >> 8 * (3 - i2 % 4) & 255);
  }
  return Buffer$2.from(byteArray);
};
class PDFSecurity {
  static generateFileID(info) {
    if (info === void 0) {
      info = {};
    }
    let infoStr = `${info.CreationDate.getTime()}
`;
    for (let key in info) {
      if (!info.hasOwnProperty(key)) continue;
      infoStr += `${key}: ${info[key].valueOf()}
`;
    }
    return wordArrayToBuffer(MD5(infoStr));
  }
}
const {
  number: number$2
} = PDFObject;
let PDFGradient$1 = class PDFGradient {
  constructor(doc) {
    this.doc = doc;
    this.stops = [];
    this.embedded = false;
    this.transform = [1, 0, 0, 1, 0, 0];
  }
  stop(pos, color, opacity) {
    if (opacity == null) {
      opacity = 1;
    }
    color = this.doc._normalizeColor(color);
    if (this.stops.length === 0) {
      if (color.length === 3) {
        this._colorSpace = "DeviceRGB";
      } else if (color.length === 4) {
        this._colorSpace = "DeviceCMYK";
      } else if (color.length === 1) {
        this._colorSpace = "DeviceGray";
      } else {
        throw new Error("Unknown color space");
      }
    } else if (this._colorSpace === "DeviceRGB" && color.length !== 3 || this._colorSpace === "DeviceCMYK" && color.length !== 4 || this._colorSpace === "DeviceGray" && color.length !== 1) {
      throw new Error("All gradient stops must use the same color space");
    }
    opacity = Math.max(0, Math.min(1, opacity));
    this.stops.push([pos, color, opacity]);
    return this;
  }
  setTransform(m11, m12, m21, m22, dx, dy) {
    this.transform = [m11, m12, m21, m22, dx, dy];
    return this;
  }
  embed(m2) {
    let fn;
    const stopsLength = this.stops.length;
    if (stopsLength === 0) {
      return;
    }
    this.embedded = true;
    this.matrix = m2;
    const last2 = this.stops[stopsLength - 1];
    if (last2[0] < 1) {
      this.stops.push([1, last2[1], last2[2]]);
    }
    const bounds = [];
    const encode = [];
    const stops = [];
    for (let i2 = 0; i2 < stopsLength - 1; i2++) {
      encode.push(0, 1);
      if (i2 + 2 !== stopsLength) {
        bounds.push(this.stops[i2 + 1][0]);
      }
      fn = this.doc.ref({
        FunctionType: 2,
        Domain: [0, 1],
        C0: this.stops[i2 + 0][1],
        C1: this.stops[i2 + 1][1],
        N: 1
      });
      stops.push(fn);
      fn.end();
    }
    if (stopsLength === 1) {
      fn = stops[0];
    } else {
      fn = this.doc.ref({
        FunctionType: 3,
        // stitching function
        Domain: [0, 1],
        Functions: stops,
        Bounds: bounds,
        Encode: encode
      });
      fn.end();
    }
    this.id = `Sh${++this.doc._gradCount}`;
    const shader = this.shader(fn);
    shader.end();
    const pattern2 = this.doc.ref({
      Type: "Pattern",
      PatternType: 2,
      Shading: shader,
      Matrix: this.matrix.map(number$2)
    });
    pattern2.end();
    if (this.stops.some((stop) => stop[2] < 1)) {
      let grad = this.opacityGradient();
      grad._colorSpace = "DeviceGray";
      for (let stop of this.stops) {
        grad.stop(stop[0], [stop[2]]);
      }
      grad = grad.embed(this.matrix);
      const pageBBox = [0, 0, this.doc.page.width, this.doc.page.height];
      const form = this.doc.ref({
        Type: "XObject",
        Subtype: "Form",
        FormType: 1,
        BBox: pageBBox,
        Group: {
          Type: "Group",
          S: "Transparency",
          CS: "DeviceGray"
        },
        Resources: {
          ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
          Pattern: {
            Sh1: grad
          }
        }
      });
      form.write("/Pattern cs /Sh1 scn");
      form.end(`${pageBBox.join(" ")} re f`);
      const gstate = this.doc.ref({
        Type: "ExtGState",
        SMask: {
          Type: "Mask",
          S: "Luminosity",
          G: form
        }
      });
      gstate.end();
      const opacityPattern = this.doc.ref({
        Type: "Pattern",
        PatternType: 1,
        PaintType: 1,
        TilingType: 2,
        BBox: pageBBox,
        XStep: pageBBox[2],
        YStep: pageBBox[3],
        Resources: {
          ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
          Pattern: {
            Sh1: pattern2
          },
          ExtGState: {
            Gs1: gstate
          }
        }
      });
      opacityPattern.write("/Gs1 gs /Pattern cs /Sh1 scn");
      opacityPattern.end(`${pageBBox.join(" ")} re f`);
      this.doc.page.patterns[this.id] = opacityPattern;
    } else {
      this.doc.page.patterns[this.id] = pattern2;
    }
    return pattern2;
  }
  apply(stroke) {
    const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;
    const [m11, m12, m21, m22, dx, dy] = this.transform;
    const m6 = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];
    if (!this.embedded || m6.join(" ") !== this.matrix.join(" ")) {
      this.embed(m6);
    }
    this.doc._setColorSpace("Pattern", stroke);
    const op = stroke ? "SCN" : "scn";
    return this.doc.addContent(`/${this.id} ${op}`);
  }
};
let PDFLinearGradient$1 = class PDFLinearGradient extends PDFGradient$1 {
  constructor(doc, x1, y1, x2, y2) {
    super(doc);
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }
  shader(fn) {
    return this.doc.ref({
      ShadingType: 2,
      ColorSpace: this._colorSpace,
      Coords: [this.x1, this.y1, this.x2, this.y2],
      Function: fn,
      Extend: [true, true]
    });
  }
  opacityGradient() {
    return new PDFLinearGradient(this.doc, this.x1, this.y1, this.x2, this.y2);
  }
};
let PDFRadialGradient$1 = class PDFRadialGradient extends PDFGradient$1 {
  constructor(doc, x1, y1, r1, x2, y2, r2) {
    super(doc);
    this.doc = doc;
    this.x1 = x1;
    this.y1 = y1;
    this.r1 = r1;
    this.x2 = x2;
    this.y2 = y2;
    this.r2 = r2;
  }
  shader(fn) {
    return this.doc.ref({
      ShadingType: 3,
      ColorSpace: this._colorSpace,
      Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2],
      Function: fn,
      Extend: [true, true]
    });
  }
  opacityGradient() {
    return new PDFRadialGradient(this.doc, this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);
  }
};
var Gradient = {
  PDFGradient: PDFGradient$1,
  PDFLinearGradient: PDFLinearGradient$1,
  PDFRadialGradient: PDFRadialGradient$1
};
const underlyingColorSpaces = ["DeviceCMYK", "DeviceRGB"];
let PDFTilingPattern$1 = class PDFTilingPattern {
  constructor(doc, bBox, xStep, yStep, stream2) {
    this.doc = doc;
    this.bBox = bBox;
    this.xStep = xStep;
    this.yStep = yStep;
    this.stream = stream2;
  }
  createPattern() {
    const resources = this.doc.ref();
    resources.end();
    const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;
    const [m11, m12, m21, m22, dx, dy] = [1, 0, 0, 1, 0, 0];
    const m6 = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];
    const pattern2 = this.doc.ref({
      Type: "Pattern",
      PatternType: 1,
      // tiling
      PaintType: 2,
      // 1-colored, 2-uncolored
      TilingType: 2,
      // 2-no distortion
      BBox: this.bBox,
      XStep: this.xStep,
      YStep: this.yStep,
      Matrix: m6.map((v2) => +v2.toFixed(5)),
      Resources: resources
    });
    pattern2.end(this.stream);
    return pattern2;
  }
  embedPatternColorSpaces() {
    underlyingColorSpaces.forEach((csName) => {
      const csId = this.getPatternColorSpaceId(csName);
      if (this.doc.page.colorSpaces[csId]) return;
      const cs = this.doc.ref(["Pattern", csName]);
      cs.end();
      this.doc.page.colorSpaces[csId] = cs;
    });
  }
  getPatternColorSpaceId(underlyingColorspace) {
    return `CsP${underlyingColorspace}`;
  }
  embed() {
    if (!this.id) {
      this.doc._patternCount = this.doc._patternCount + 1;
      this.id = "P" + this.doc._patternCount;
      this.pattern = this.createPattern();
    }
    if (!this.doc.page.patterns[this.id]) {
      this.doc.page.patterns[this.id] = this.pattern;
    }
  }
  apply(stroke, patternColor) {
    this.embedPatternColorSpaces();
    this.embed();
    const normalizedColor = this.doc._normalizeColor(patternColor);
    if (!normalizedColor) throw Error(`invalid pattern color. (value: ${patternColor})`);
    const csId = this.getPatternColorSpaceId(this.doc._getColorSpace(normalizedColor));
    this.doc._setColorSpace(csId, stroke);
    const op = stroke ? "SCN" : "scn";
    return this.doc.addContent(`${normalizedColor.join(" ")} /${this.id} ${op}`);
  }
};
var pattern$1 = {
  PDFTilingPattern: PDFTilingPattern$1
};
class SpotColor {
  constructor(doc, name, C, M, Y, K) {
    this.id = "CS" + Object.keys(doc.spotColors).length;
    this.name = name;
    this.values = [C, M, Y, K];
    this.ref = doc.ref(["Separation", this.name, "DeviceCMYK", {
      Range: [0, 1, 0, 1, 0, 1, 0, 1],
      C0: [0, 0, 0, 0],
      C1: this.values.map((value2) => value2 / 100),
      FunctionType: 2,
      Domain: [0, 1],
      N: 1
    }]);
    this.ref.end();
  }
  toString() {
    return `${this.ref.id} 0 R`;
  }
}
const {
  PDFGradient: PDFGradient2,
  PDFLinearGradient: PDFLinearGradient2,
  PDFRadialGradient: PDFRadialGradient2
} = Gradient;
const {
  PDFTilingPattern: PDFTilingPattern2
} = pattern$1;
var ColorMixin = {
  initColor() {
    this.spotColors = {};
    this._opacityRegistry = {};
    this._opacityCount = 0;
    this._patternCount = 0;
    return this._gradCount = 0;
  },
  _normalizeColor(color) {
    if (typeof color === "string") {
      if (color.charAt(0) === "#") {
        if (color.length === 4) {
          color = color.replace(/#([0-9A-F])([0-9A-F])([0-9A-F])/i, "#$1$1$2$2$3$3");
        }
        const hex = parseInt(color.slice(1), 16);
        color = [hex >> 16, hex >> 8 & 255, hex & 255];
      } else if (namedColors[color]) {
        color = namedColors[color];
      } else if (this.spotColors[color]) {
        return this.spotColors[color];
      }
    }
    if (Array.isArray(color)) {
      if (color.length === 3) {
        color = color.map((part) => part / 255);
      } else if (color.length === 4) {
        color = color.map((part) => part / 100);
      }
      return color;
    }
    return null;
  },
  _setColor(color, stroke) {
    if (color instanceof PDFGradient2) {
      color.apply(stroke);
      return true;
    } else if (Array.isArray(color) && color[0] instanceof PDFTilingPattern2) {
      color[0].apply(stroke, color[1]);
      return true;
    }
    return this._setColorCore(color, stroke);
  },
  _setColorCore(color, stroke) {
    color = this._normalizeColor(color);
    if (!color) {
      return false;
    }
    const op = stroke ? "SCN" : "scn";
    const space = this._getColorSpace(color);
    this._setColorSpace(space, stroke);
    if (color instanceof SpotColor) {
      this.page.colorSpaces[color.id] = color.ref;
      this.addContent(`1 ${op}`);
    } else {
      this.addContent(`${color.join(" ")} ${op}`);
    }
    return true;
  },
  _setColorSpace(space, stroke) {
    const op = stroke ? "CS" : "cs";
    return this.addContent(`/${space} ${op}`);
  },
  _getColorSpace(color) {
    if (color instanceof SpotColor) {
      return color.id;
    }
    return color.length === 4 ? "DeviceCMYK" : "DeviceRGB";
  },
  fillColor(color, opacity) {
    const set5 = this._setColor(color, false);
    if (set5) {
      this.fillOpacity(opacity);
    }
    this._fillColor = [color, opacity];
    return this;
  },
  strokeColor(color, opacity) {
    const set5 = this._setColor(color, true);
    if (set5) {
      this.strokeOpacity(opacity);
    }
    return this;
  },
  opacity(opacity) {
    this._doOpacity(opacity, opacity);
    return this;
  },
  fillOpacity(opacity) {
    this._doOpacity(opacity, null);
    return this;
  },
  strokeOpacity(opacity) {
    this._doOpacity(null, opacity);
    return this;
  },
  _doOpacity(fillOpacity, strokeOpacity) {
    let dictionary2, name;
    if (fillOpacity == null && strokeOpacity == null) {
      return;
    }
    if (fillOpacity != null) {
      fillOpacity = Math.max(0, Math.min(1, fillOpacity));
    }
    if (strokeOpacity != null) {
      strokeOpacity = Math.max(0, Math.min(1, strokeOpacity));
    }
    const key = `${fillOpacity}_${strokeOpacity}`;
    if (this._opacityRegistry[key]) {
      [dictionary2, name] = this._opacityRegistry[key];
    } else {
      dictionary2 = {
        Type: "ExtGState"
      };
      if (fillOpacity != null) {
        dictionary2.ca = fillOpacity;
      }
      if (strokeOpacity != null) {
        dictionary2.CA = strokeOpacity;
      }
      dictionary2 = this.ref(dictionary2);
      dictionary2.end();
      const id = ++this._opacityCount;
      name = `Gs${id}`;
      this._opacityRegistry[key] = [dictionary2, name];
    }
    this.page.ext_gstates[name] = dictionary2;
    return this.addContent(`/${name} gs`);
  },
  linearGradient(x1, y1, x2, y2) {
    return new PDFLinearGradient2(this, x1, y1, x2, y2);
  },
  radialGradient(x1, y1, r1, x2, y2, r2) {
    return new PDFRadialGradient2(this, x1, y1, r1, x2, y2, r2);
  },
  pattern(bbox, xStep, yStep, stream2) {
    return new PDFTilingPattern2(this, bbox, xStep, yStep, stream2);
  },
  addSpotColor(name, C, M, Y, K) {
    const color = new SpotColor(this, name, C, M, Y, K);
    this.spotColors[name] = color;
    return this;
  }
};
var namedColors = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  grey: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
let cx;
let cy;
let px;
let py;
let sx;
let sy;
cx = cy = px = py = sx = sy = 0;
const argsCountPerCommand = {
  M: 2,
  m: 2,
  Z: 0,
  z: 0,
  L: 2,
  l: 2,
  H: 1,
  h: 1,
  V: 1,
  v: 1,
  C: 6,
  c: 6,
  S: 4,
  s: 4,
  Q: 4,
  q: 4,
  T: 2,
  t: 2,
  A: 7,
  a: 7
};
const isCommand = (c2) => {
  return c2 in argsCountPerCommand;
};
const isWsp = (c2) => {
  const codePoint = c2.codePointAt(0);
  return codePoint === 32 || codePoint === 9 || codePoint === 13 || codePoint === 10;
};
const isDigit = (c2) => {
  const codePoint = c2.codePointAt(0);
  if (codePoint == null) {
    return false;
  }
  return 48 <= codePoint && codePoint <= 57;
};
const readNumber = (string, cursor) => {
  let i2 = cursor;
  let value2 = "";
  let state2 = (
    /** @type {ReadNumberState} */
    "none"
  );
  for (; i2 < string.length; i2 += 1) {
    const c2 = string[i2];
    if (c2 === "+" || c2 === "-") {
      if (state2 === "none") {
        state2 = "sign";
        value2 += c2;
        continue;
      }
      if (state2 === "e") {
        state2 = "exponent_sign";
        value2 += c2;
        continue;
      }
    }
    if (isDigit(c2)) {
      if (state2 === "none" || state2 === "sign" || state2 === "whole") {
        state2 = "whole";
        value2 += c2;
        continue;
      }
      if (state2 === "decimal_point" || state2 === "decimal") {
        state2 = "decimal";
        value2 += c2;
        continue;
      }
      if (state2 === "e" || state2 === "exponent_sign" || state2 === "exponent") {
        state2 = "exponent";
        value2 += c2;
        continue;
      }
    }
    if (c2 === ".") {
      if (state2 === "none" || state2 === "sign" || state2 === "whole") {
        state2 = "decimal_point";
        value2 += c2;
        continue;
      }
    }
    if (c2 === "E" || c2 === "e") {
      if (state2 === "whole" || state2 === "decimal_point" || state2 === "decimal") {
        state2 = "e";
        value2 += c2;
        continue;
      }
    }
    break;
  }
  const number2 = Number.parseFloat(value2);
  if (Number.isNaN(number2)) {
    return [cursor, null];
  }
  return [i2 - 1, number2];
};
const parsePathData = (string) => {
  const pathData = [];
  let command = null;
  let args = (
    /** @type {number[]} */
    []
  );
  let argsCount = 0;
  let canHaveComma = false;
  let hadComma = false;
  for (let i2 = 0; i2 < string.length; i2 += 1) {
    const c2 = string.charAt(i2);
    if (isWsp(c2)) {
      continue;
    }
    if (canHaveComma && c2 === ",") {
      if (hadComma) {
        break;
      }
      hadComma = true;
      continue;
    }
    if (isCommand(c2)) {
      if (hadComma) {
        return pathData;
      }
      if (command == null) {
        if (c2 !== "M" && c2 !== "m") {
          return pathData;
        }
      } else {
        if (args.length !== 0) {
          return pathData;
        }
      }
      command = c2;
      args = [];
      argsCount = argsCountPerCommand[command];
      canHaveComma = false;
      if (argsCount === 0) {
        pathData.push({
          command,
          args
        });
      }
      continue;
    }
    if (command == null) {
      return pathData;
    }
    let newCursor = i2;
    let number2 = null;
    if (command === "A" || command === "a") {
      const position = args.length;
      if (position === 0 || position === 1) {
        if (c2 !== "+" && c2 !== "-") {
          [newCursor, number2] = readNumber(string, i2);
        }
      }
      if (position === 2 || position === 5 || position === 6) {
        [newCursor, number2] = readNumber(string, i2);
      }
      if (position === 3 || position === 4) {
        if (c2 === "0") {
          number2 = 0;
        }
        if (c2 === "1") {
          number2 = 1;
        }
      }
    } else {
      [newCursor, number2] = readNumber(string, i2);
    }
    if (number2 == null) {
      return pathData;
    }
    args.push(number2);
    canHaveComma = true;
    hadComma = false;
    i2 = newCursor;
    if (args.length === argsCount) {
      pathData.push({
        command,
        args
      });
      if (command === "M") {
        command = "L";
      }
      if (command === "m") {
        command = "l";
      }
      args = [];
    }
  }
  return pathData;
};
const apply = function(commands, doc) {
  cx = cy = px = py = sx = sy = 0;
  for (let i2 = 0; i2 < commands.length; i2++) {
    const {
      command,
      args
    } = commands[i2];
    if (typeof runners[command] === "function") {
      runners[command](doc, args);
    }
  }
};
const runners = {
  M(doc, a2) {
    cx = a2[0];
    cy = a2[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return doc.moveTo(cx, cy);
  },
  m(doc, a2) {
    cx += a2[0];
    cy += a2[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return doc.moveTo(cx, cy);
  },
  C(doc, a2) {
    cx = a2[4];
    cy = a2[5];
    px = a2[2];
    py = a2[3];
    return doc.bezierCurveTo(...a2);
  },
  c(doc, a2) {
    doc.bezierCurveTo(a2[0] + cx, a2[1] + cy, a2[2] + cx, a2[3] + cy, a2[4] + cx, a2[5] + cy);
    px = cx + a2[2];
    py = cy + a2[3];
    cx += a2[4];
    return cy += a2[5];
  },
  S(doc, a2) {
    if (px === null) {
      px = cx;
      py = cy;
    }
    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a2[0], a2[1], a2[2], a2[3]);
    px = a2[0];
    py = a2[1];
    cx = a2[2];
    return cy = a2[3];
  },
  s(doc, a2) {
    if (px === null) {
      px = cx;
      py = cy;
    }
    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + a2[0], cy + a2[1], cx + a2[2], cy + a2[3]);
    px = cx + a2[0];
    py = cy + a2[1];
    cx += a2[2];
    return cy += a2[3];
  },
  Q(doc, a2) {
    px = a2[0];
    py = a2[1];
    cx = a2[2];
    cy = a2[3];
    return doc.quadraticCurveTo(a2[0], a2[1], cx, cy);
  },
  q(doc, a2) {
    doc.quadraticCurveTo(a2[0] + cx, a2[1] + cy, a2[2] + cx, a2[3] + cy);
    px = cx + a2[0];
    py = cy + a2[1];
    cx += a2[2];
    return cy += a2[3];
  },
  T(doc, a2) {
    if (px === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    doc.quadraticCurveTo(px, py, a2[0], a2[1]);
    px = cx - (px - cx);
    py = cy - (py - cy);
    cx = a2[0];
    return cy = a2[1];
  },
  t(doc, a2) {
    if (px === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    doc.quadraticCurveTo(px, py, cx + a2[0], cy + a2[1]);
    cx += a2[0];
    return cy += a2[1];
  },
  A(doc, a2) {
    solveArc(doc, cx, cy, a2);
    cx = a2[5];
    return cy = a2[6];
  },
  a(doc, a2) {
    a2[5] += cx;
    a2[6] += cy;
    solveArc(doc, cx, cy, a2);
    cx = a2[5];
    return cy = a2[6];
  },
  L(doc, a2) {
    cx = a2[0];
    cy = a2[1];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  l(doc, a2) {
    cx += a2[0];
    cy += a2[1];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  H(doc, a2) {
    cx = a2[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  h(doc, a2) {
    cx += a2[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  V(doc, a2) {
    cy = a2[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  v(doc, a2) {
    cy += a2[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  Z(doc) {
    doc.closePath();
    cx = sx;
    return cy = sy;
  },
  z(doc) {
    doc.closePath();
    cx = sx;
    return cy = sy;
  }
};
const solveArc = function(doc, x, y2, coords) {
  const [rx, ry, rot, large, sweep, ex, ey] = coords;
  const segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y2);
  for (let seg of segs) {
    const bez = segmentToBezier(...seg);
    doc.bezierCurveTo(...bez);
  }
};
const arcToSegments = function(x, y2, rx, ry, large, sweep, rotateX, ox, oy) {
  const th = rotateX * (Math.PI / 180);
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y2) * 0.5;
  py = cos_th * (oy - y2) * 0.5 - sin_th * (ox - x) * 0.5;
  let pl = px * px / (rx * rx) + py * py / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x0 = a00 * ox + a01 * oy;
  const y0 = a10 * ox + a11 * oy;
  const x1 = a00 * x + a01 * y2;
  const y1 = a10 * x + a11 * y2;
  const d2 = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
  let sfactor_sq = 1 / d2 - 0.25;
  if (sfactor_sq < 0) {
    sfactor_sq = 0;
  }
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep === large) {
    sfactor = -sfactor;
  }
  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
  const th0 = Math.atan2(y0 - yc, x0 - xc);
  const th1 = Math.atan2(y1 - yc, x1 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += 2 * Math.PI;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= 2 * Math.PI;
  }
  const segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 1e-3)));
  const result = [];
  for (let i2 = 0; i2 < segments; i2++) {
    const th2 = th0 + i2 * th_arc / segments;
    const th3 = th0 + (i2 + 1) * th_arc / segments;
    result[i2] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return result;
};
const segmentToBezier = function(cx2, cy2, th0, th1, rx, ry, sin_th, cos_th) {
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const th_half = 0.5 * (th1 - th0);
  const t2 = 8 / 3 * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);
  const x1 = cx2 + Math.cos(th0) - t2 * Math.sin(th0);
  const y1 = cy2 + Math.sin(th0) + t2 * Math.cos(th0);
  const x3 = cx2 + Math.cos(th1);
  const y3 = cy2 + Math.sin(th1);
  const x2 = x3 + t2 * Math.sin(th1);
  const y2 = y3 - t2 * Math.cos(th1);
  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
};
class SVGPath {
  static apply(doc, path) {
    const commands = parsePathData(path);
    apply(commands, doc);
  }
}
const {
  number: number$1
} = PDFObject;
const KAPPA$4 = 4 * ((Math.sqrt(2) - 1) / 3);
var VectorMixin = {
  initVector() {
    this._ctm = [1, 0, 0, 1, 0, 0];
    return this._ctmStack = [];
  },
  save() {
    this._ctmStack.push(this._ctm.slice());
    return this.addContent("q");
  },
  restore() {
    this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0];
    return this.addContent("Q");
  },
  closePath() {
    return this.addContent("h");
  },
  lineWidth(w) {
    return this.addContent(`${number$1(w)} w`);
  },
  _CAP_STYLES: {
    BUTT: 0,
    ROUND: 1,
    SQUARE: 2
  },
  lineCap(c2) {
    if (typeof c2 === "string") {
      c2 = this._CAP_STYLES[c2.toUpperCase()];
    }
    return this.addContent(`${c2} J`);
  },
  _JOIN_STYLES: {
    MITER: 0,
    ROUND: 1,
    BEVEL: 2
  },
  lineJoin(j) {
    if (typeof j === "string") {
      j = this._JOIN_STYLES[j.toUpperCase()];
    }
    return this.addContent(`${j} j`);
  },
  miterLimit(m2) {
    return this.addContent(`${number$1(m2)} M`);
  },
  dash(length2, options) {
    if (options === void 0) {
      options = {};
    }
    const originalLength = length2;
    if (!Array.isArray(length2)) {
      length2 = [length2, options.space || length2];
    }
    const valid = length2.every((x) => Number.isFinite(x) && x > 0);
    if (!valid) {
      throw new Error(`dash(${JSON.stringify(originalLength)}, ${JSON.stringify(options)}) invalid, lengths must be numeric and greater than zero`);
    }
    length2 = length2.map(number$1).join(" ");
    return this.addContent(`[${length2}] ${number$1(options.phase || 0)} d`);
  },
  undash() {
    return this.addContent("[] 0 d");
  },
  moveTo(x, y2) {
    return this.addContent(`${number$1(x)} ${number$1(y2)} m`);
  },
  lineTo(x, y2) {
    return this.addContent(`${number$1(x)} ${number$1(y2)} l`);
  },
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y2) {
    return this.addContent(`${number$1(cp1x)} ${number$1(cp1y)} ${number$1(cp2x)} ${number$1(cp2y)} ${number$1(x)} ${number$1(y2)} c`);
  },
  quadraticCurveTo(cpx, cpy, x, y2) {
    return this.addContent(`${number$1(cpx)} ${number$1(cpy)} ${number$1(x)} ${number$1(y2)} v`);
  },
  rect(x, y2, w, h) {
    return this.addContent(`${number$1(x)} ${number$1(y2)} ${number$1(w)} ${number$1(h)} re`);
  },
  roundedRect(x, y2, w, h, r2) {
    if (r2 == null) {
      r2 = 0;
    }
    r2 = Math.min(r2, 0.5 * w, 0.5 * h);
    const c2 = r2 * (1 - KAPPA$4);
    this.moveTo(x + r2, y2);
    this.lineTo(x + w - r2, y2);
    this.bezierCurveTo(x + w - c2, y2, x + w, y2 + c2, x + w, y2 + r2);
    this.lineTo(x + w, y2 + h - r2);
    this.bezierCurveTo(x + w, y2 + h - c2, x + w - c2, y2 + h, x + w - r2, y2 + h);
    this.lineTo(x + r2, y2 + h);
    this.bezierCurveTo(x + c2, y2 + h, x, y2 + h - c2, x, y2 + h - r2);
    this.lineTo(x, y2 + r2);
    this.bezierCurveTo(x, y2 + c2, x + c2, y2, x + r2, y2);
    return this.closePath();
  },
  ellipse(x, y2, r1, r2) {
    if (r2 == null) {
      r2 = r1;
    }
    x -= r1;
    y2 -= r2;
    const ox = r1 * KAPPA$4;
    const oy = r2 * KAPPA$4;
    const xe = x + r1 * 2;
    const ye = y2 + r2 * 2;
    const xm = x + r1;
    const ym = y2 + r2;
    this.moveTo(x, ym);
    this.bezierCurveTo(x, ym - oy, xm - ox, y2, xm, y2);
    this.bezierCurveTo(xm + ox, y2, xe, ym - oy, xe, ym);
    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
    return this.closePath();
  },
  circle(x, y2, radius) {
    return this.ellipse(x, y2, radius);
  },
  arc(x, y2, radius, startAngle, endAngle, anticlockwise) {
    if (anticlockwise == null) {
      anticlockwise = false;
    }
    const TWO_PI = 2 * Math.PI;
    const HALF_PI = 0.5 * Math.PI;
    let deltaAng = endAngle - startAngle;
    if (Math.abs(deltaAng) > TWO_PI) {
      deltaAng = TWO_PI;
    } else if (deltaAng !== 0 && anticlockwise !== deltaAng < 0) {
      const dir = anticlockwise ? -1 : 1;
      deltaAng = dir * TWO_PI + deltaAng;
    }
    const numSegs = Math.ceil(Math.abs(deltaAng) / HALF_PI);
    const segAng = deltaAng / numSegs;
    const handleLen = segAng / HALF_PI * KAPPA$4 * radius;
    let curAng = startAngle;
    let deltaCx = -Math.sin(curAng) * handleLen;
    let deltaCy = Math.cos(curAng) * handleLen;
    let ax = x + Math.cos(curAng) * radius;
    let ay = y2 + Math.sin(curAng) * radius;
    this.moveTo(ax, ay);
    for (let segIdx = 0; segIdx < numSegs; segIdx++) {
      const cp1x = ax + deltaCx;
      const cp1y = ay + deltaCy;
      curAng += segAng;
      ax = x + Math.cos(curAng) * radius;
      ay = y2 + Math.sin(curAng) * radius;
      deltaCx = -Math.sin(curAng) * handleLen;
      deltaCy = Math.cos(curAng) * handleLen;
      const cp2x = ax - deltaCx;
      const cp2y = ay - deltaCy;
      this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ax, ay);
    }
    return this;
  },
  polygon() {
    for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
      points[_key] = arguments[_key];
    }
    this.moveTo(...points.shift() || []);
    for (let point of points) {
      this.lineTo(...point || []);
    }
    return this.closePath();
  },
  path(path) {
    SVGPath.apply(this, path);
    return this;
  },
  _windingRule(rule) {
    if (/even-?odd/.test(rule)) {
      return "*";
    }
    return "";
  },
  fill(color, rule) {
    if (/(even-?odd)|(non-?zero)/.test(color)) {
      rule = color;
      color = null;
    }
    if (color) {
      this.fillColor(color);
    }
    return this.addContent(`f${this._windingRule(rule)}`);
  },
  stroke(color) {
    if (color) {
      this.strokeColor(color);
    }
    return this.addContent("S");
  },
  fillAndStroke(fillColor, strokeColor, rule) {
    if (strokeColor == null) {
      strokeColor = fillColor;
    }
    const isFillRule = /(even-?odd)|(non-?zero)/;
    if (isFillRule.test(fillColor)) {
      rule = fillColor;
      fillColor = null;
    }
    if (isFillRule.test(strokeColor)) {
      rule = strokeColor;
      strokeColor = fillColor;
    }
    if (fillColor) {
      this.fillColor(fillColor);
      this.strokeColor(strokeColor);
    }
    return this.addContent(`B${this._windingRule(rule)}`);
  },
  clip(rule) {
    return this.addContent(`W${this._windingRule(rule)} n`);
  },
  transform(m11, m12, m21, m22, dx, dy) {
    if (m11 === 1 && m12 === 0 && m21 === 0 && m22 === 1 && dx === 0 && dy === 0) {
      return this;
    }
    const m2 = this._ctm;
    const [m0, m1, m23, m3, m4, m5] = m2;
    m2[0] = m0 * m11 + m23 * m12;
    m2[1] = m1 * m11 + m3 * m12;
    m2[2] = m0 * m21 + m23 * m22;
    m2[3] = m1 * m21 + m3 * m22;
    m2[4] = m0 * dx + m23 * dy + m4;
    m2[5] = m1 * dx + m3 * dy + m5;
    const values = [m11, m12, m21, m22, dx, dy].map((v2) => number$1(v2)).join(" ");
    return this.addContent(`${values} cm`);
  },
  translate(x, y2) {
    return this.transform(1, 0, 0, 1, x, y2);
  },
  rotate(angle, options) {
    if (options === void 0) {
      options = {};
    }
    let y2;
    const rad = angle * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    let x = y2 = 0;
    if (options.origin != null) {
      [x, y2] = options.origin;
      const x1 = x * cos - y2 * sin;
      const y1 = x * sin + y2 * cos;
      x -= x1;
      y2 -= y1;
    }
    return this.transform(cos, sin, -sin, cos, x, y2);
  },
  scale(xFactor, yFactor, options) {
    if (options === void 0) {
      options = {};
    }
    let y2;
    if (yFactor == null) {
      yFactor = xFactor;
    }
    if (typeof yFactor === "object") {
      options = yFactor;
      yFactor = xFactor;
    }
    let x = y2 = 0;
    if (options.origin != null) {
      [x, y2] = options.origin;
      x -= xFactor * x;
      y2 -= yFactor * y2;
    }
    return this.transform(xFactor, 0, 0, yFactor, x, y2);
  }
};
var fs = {};
const range = (left, right, inclusive) => {
  let range2 = [];
  let end2 = right + 1;
  for (let i2 = left; i2 < end2; i2++) {
    range2.push(i2);
  }
  return range2;
};
const WIN_ANSI_MAP = {
  402: 131,
  8211: 150,
  8212: 151,
  8216: 145,
  8217: 146,
  8218: 130,
  8220: 147,
  8221: 148,
  8222: 132,
  8224: 134,
  8225: 135,
  8226: 149,
  8230: 133,
  8364: 128,
  8240: 137,
  8249: 139,
  8250: 155,
  710: 136,
  8482: 153,
  338: 140,
  339: 156,
  732: 152,
  352: 138,
  353: 154,
  376: 159,
  381: 142,
  382: 158
};
const characters = `.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef
.notdef       .notdef        .notdef        .notdef

space         exclam         quotedbl       numbersign
dollar        percent        ampersand      quotesingle
parenleft     parenright     asterisk       plus
comma         hyphen         period         slash
zero          one            two            three
four          five           six            seven
eight         nine           colon          semicolon
less          equal          greater        question

at            A              B              C
D             E              F              G
H             I              J              K
L             M              N              O
P             Q              R              S
T             U              V              W
X             Y              Z              bracketleft
backslash     bracketright   asciicircum    underscore

grave         a              b              c
d             e              f              g
h             i              j              k
l             m              n              o
p             q              r              s
t             u              v              w
x             y              z              braceleft
bar           braceright     asciitilde     .notdef

Euro          .notdef        quotesinglbase florin
quotedblbase  ellipsis       dagger         daggerdbl
circumflex    perthousand    Scaron         guilsinglleft
OE            .notdef        Zcaron         .notdef
.notdef       quoteleft      quoteright     quotedblleft
quotedblright bullet         endash         emdash
tilde         trademark      scaron         guilsinglright
oe            .notdef        zcaron         ydieresis

space         exclamdown     cent           sterling
currency      yen            brokenbar      section
dieresis      copyright      ordfeminine    guillemotleft
logicalnot    hyphen         registered     macron
degree        plusminus      twosuperior    threesuperior
acute         mu             paragraph      periodcentered
cedilla       onesuperior    ordmasculine   guillemotright
onequarter    onehalf        threequarters  questiondown

Agrave        Aacute         Acircumflex    Atilde
Adieresis     Aring          AE             Ccedilla
Egrave        Eacute         Ecircumflex    Edieresis
Igrave        Iacute         Icircumflex    Idieresis
Eth           Ntilde         Ograve         Oacute
Ocircumflex   Otilde         Odieresis      multiply
Oslash        Ugrave         Uacute         Ucircumflex
Udieresis     Yacute         Thorn          germandbls

agrave        aacute         acircumflex    atilde
adieresis     aring          ae             ccedilla
egrave        eacute         ecircumflex    edieresis
igrave        iacute         icircumflex    idieresis
eth           ntilde         ograve         oacute
ocircumflex   otilde         odieresis      divide
oslash        ugrave         uacute         ucircumflex
udieresis     yacute         thorn          ydieresis`.split(/\s+/);
function parse$3(contents) {
  const obj = {
    attributes: {},
    glyphWidths: {},
    kernPairs: {}
  };
  let section = "";
  for (let line2 of contents.split("\n")) {
    var match;
    var a2;
    if (match = line2.match(/^Start(\w+)/)) {
      section = match[1];
      continue;
    } else if (match = line2.match(/^End(\w+)/)) {
      section = "";
      continue;
    }
    switch (section) {
      case "FontMetrics":
        match = line2.match(/(^\w+)\s+(.*)/);
        var key = match[1];
        var value2 = match[2];
        if (a2 = obj.attributes[key]) {
          if (!Array.isArray(a2)) {
            a2 = obj.attributes[key] = [a2];
          }
          a2.push(value2);
        } else {
          obj.attributes[key] = value2;
        }
        break;
      case "CharMetrics":
        if (!/^CH?\s/.test(line2)) {
          continue;
        }
        var name = line2.match(/\bN\s+(\.?\w+)\s*;/)[1];
        obj.glyphWidths[name] = +line2.match(/\bWX\s+(\d+)\s*;/)[1];
        break;
      case "KernPairs":
        match = line2.match(/^KPX\s+(\.?\w+)\s+(\.?\w+)\s+(-?\d+)/);
        if (match) {
          obj.kernPairs[match[1] + match[2]] = parseInt(match[3]);
        }
        break;
    }
  }
  return obj;
}
class AFMFont {
  static open(filename) {
    {
      throw new Error("AFMFont.open not available on browser build");
    }
  }
  static fromJson(json) {
    return new AFMFont(json);
  }
  constructor(contents) {
    if (typeof contents === "string") {
      this.contents = contents;
      this.parse();
    } else {
      this.attributes = contents.attributes;
      this.glyphWidths = contents.glyphWidths;
      this.kernPairs = contents.kernPairs;
    }
    this.charWidths = range(0, 255).map((i2) => this.glyphWidths[characters[i2]]);
    this.bbox = Array.from(this.attributes.FontBBox.split(/\s+/)).map((e2) => +e2);
    this.ascender = +(this.attributes.Ascender || 0);
    this.descender = +(this.attributes.Descender || 0);
    this.xHeight = +(this.attributes.XHeight || 0);
    this.capHeight = +(this.attributes.CapHeight || 0);
    this.lineGap = this.bbox[3] - this.bbox[1] - (this.ascender - this.descender);
  }
  parse() {
    const parsed = parse$3(this.contents);
    this.attributes = parsed.attributes;
    this.glyphWidths = parsed.glyphWidths;
    this.kernPairs = parsed.kernPairs;
  }
  encodeText(text) {
    const res = [];
    for (let i2 = 0, end2 = text.length, asc = 0 <= end2; asc ? i2 < end2 : i2 > end2; asc ? i2++ : i2--) {
      let char = text.charCodeAt(i2);
      char = WIN_ANSI_MAP[char] || char;
      res.push(char.toString(16));
    }
    return res;
  }
  glyphsForString(string) {
    const glyphs = [];
    for (let i2 = 0, end2 = string.length, asc = 0 <= end2; asc ? i2 < end2 : i2 > end2; asc ? i2++ : i2--) {
      const charCode = string.charCodeAt(i2);
      glyphs.push(this.characterToGlyph(charCode));
    }
    return glyphs;
  }
  characterToGlyph(character) {
    return characters[WIN_ANSI_MAP[character] || character] || ".notdef";
  }
  widthOfGlyph(glyph) {
    return this.glyphWidths[glyph] || 0;
  }
  getKernPair(left, right) {
    return this.kernPairs[left + right] || 0;
  }
  advancesForGlyphs(glyphs) {
    const advances = [];
    for (let index2 = 0; index2 < glyphs.length; index2++) {
      const left = glyphs[index2];
      const right = glyphs[index2 + 1];
      advances.push(this.widthOfGlyph(left) + this.getKernPair(left, right));
    }
    return advances;
  }
}
var attributes = [
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:43:52 1997",
      "UniqueID 43052",
      "VMusage 37169 48194"
    ],
    FontName: "Helvetica-Bold",
    FullName: "Helvetica Bold",
    FamilyName: "Helvetica",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-170 -228 1003 962 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "532",
    Ascender: "718",
    Descender: "-207",
    StdHW: "118",
    StdVW: "140"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:45:12 1997",
      "UniqueID 43053",
      "VMusage 14482 68586"
    ],
    FontName: "Helvetica-BoldOblique",
    FullName: "Helvetica Bold Oblique",
    FamilyName: "Helvetica",
    Weight: "Bold",
    ItalicAngle: "-12",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-174 -228 1114 962",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "532",
    Ascender: "718",
    Descender: "-207",
    StdHW: "118",
    StdVW: "140"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:44:31 1997",
      "UniqueID 43055",
      "VMusage 14960 69346"
    ],
    FontName: "Helvetica-Oblique",
    FullName: "Helvetica Oblique",
    FamilyName: "Helvetica",
    Weight: "Medium",
    ItalicAngle: "-12",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-170 -225 1116 931 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "523",
    Ascender: "718",
    Descender: "-207",
    StdHW: "76",
    StdVW: "88"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:38:23 1997",
      "UniqueID 43054",
      "VMusage 37069 48094"
    ],
    FontName: "Helvetica",
    FullName: "Helvetica",
    FamilyName: "Helvetica",
    Weight: "Medium",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-166 -225 1000 931 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "523",
    Ascender: "718",
    Descender: "-207",
    StdHW: "76",
    StdVW: "88"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:52:56 1997",
      "UniqueID 43065",
      "VMusage 41636 52661"
    ],
    FontName: "Times-Bold",
    FullName: "Times Bold",
    FamilyName: "Times",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-168 -218 1000 935 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "676",
    XHeight: "461",
    Ascender: "683",
    Descender: "-217",
    StdHW: "44",
    StdVW: "139"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 13:04:06 1997",
      "UniqueID 43066",
      "VMusage 45874 56899"
    ],
    FontName: "Times-BoldItalic",
    FullName: "Times Bold Italic",
    FamilyName: "Times",
    Weight: "Bold",
    ItalicAngle: "-15",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-200 -218 996 921",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "669",
    XHeight: "462",
    Ascender: "683",
    Descender: "-217",
    StdHW: "42",
    StdVW: "121"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:56:55 1997",
      "UniqueID 43067",
      "VMusage 47727 58752"
    ],
    FontName: "Times-Italic",
    FullName: "Times Italic",
    FamilyName: "Times",
    Weight: "Medium",
    ItalicAngle: "-15.5",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-169 -217 1010 883 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "653",
    XHeight: "441",
    Ascender: "683",
    Descender: "-217",
    StdHW: "32",
    StdVW: "76"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:49:17 1997",
      "UniqueID 43068",
      "VMusage 43909 54934"
    ],
    FontName: "Times-Roman",
    FullName: "Times Roman",
    FamilyName: "Times",
    Weight: "Roman",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-168 -218 1000 898 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "662",
    XHeight: "450",
    Ascender: "683",
    Descender: "-217",
    StdHW: "28",
    StdVW: "84"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Mon Jun 23 16:28:00 1997",
      "UniqueID 43048",
      "VMusage 41139 52164"
    ],
    FontName: "Courier-Bold",
    FullName: "Courier Bold",
    FamilyName: "Courier",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-113 -250 749 801 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "439",
    Ascender: "629",
    Descender: "-157",
    StdHW: "84",
    StdVW: "106"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Mon Jun 23 16:28:46 1997",
      "UniqueID 43049",
      "VMusage 17529 79244"
    ],
    FontName: "Courier-BoldOblique",
    FullName: "Courier Bold Oblique",
    FamilyName: "Courier",
    Weight: "Bold",
    ItalicAngle: "-12",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-57 -250 869 801",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "439",
    Ascender: "629",
    Descender: "-157",
    StdHW: "84",
    StdVW: "106"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 17:37:52 1997",
      "UniqueID 43051",
      "VMusage 16248 75829"
    ],
    FontName: "Courier-Oblique",
    FullName: "Courier Oblique",
    FamilyName: "Courier",
    Weight: "Medium",
    ItalicAngle: "-12",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-27 -250 849 805 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "426",
    Ascender: "629",
    Descender: "-157",
    StdHW: "51",
    StdVW: "51"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 17:27:09 1997",
      "UniqueID 43050",
      "VMusage 39754 50779"
    ],
    FontName: "Courier",
    FullName: "Courier",
    FamilyName: "Courier",
    Weight: "Medium",
    ItalicAngle: "0",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-23 -250 715 805 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "426",
    Ascender: "629",
    Descender: "-157",
    StdHW: "51",
    StdVW: "51"
  }
];
var glyphWidths = {
  space: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  exclam: [
    333,
    333,
    278,
    278,
    333,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  quotedbl: [
    474,
    474,
    355,
    355,
    555,
    555,
    420,
    408,
    600,
    600,
    600,
    600
  ],
  numbersign: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  dollar: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  percent: [
    889,
    889,
    889,
    889,
    1e3,
    833,
    833,
    833,
    600,
    600,
    600,
    600
  ],
  ampersand: [
    722,
    722,
    667,
    667,
    833,
    778,
    778,
    778,
    600,
    600,
    600,
    600
  ],
  quoteright: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  parenleft: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  parenright: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  asterisk: [
    389,
    389,
    389,
    389,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  plus: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  comma: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  hyphen: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  period: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  slash: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  zero: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  one: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  two: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  three: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  four: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  five: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  six: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  seven: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  eight: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  nine: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  colon: [
    333,
    333,
    278,
    278,
    333,
    333,
    333,
    278,
    600,
    600,
    600,
    600
  ],
  semicolon: [
    333,
    333,
    278,
    278,
    333,
    333,
    333,
    278,
    600,
    600,
    600,
    600
  ],
  less: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  equal: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  greater: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  question: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  at: [
    975,
    975,
    1015,
    1015,
    930,
    832,
    920,
    921,
    600,
    600,
    600,
    600
  ],
  A: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  B: [
    722,
    722,
    667,
    667,
    667,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  C: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  D: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  E: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  F: [
    611,
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  G: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  H: [
    722,
    722,
    722,
    722,
    778,
    778,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  I: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  J: [
    556,
    556,
    500,
    500,
    500,
    500,
    444,
    389,
    600,
    600,
    600,
    600
  ],
  K: [
    722,
    722,
    667,
    667,
    778,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  L: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  M: [
    833,
    833,
    833,
    833,
    944,
    889,
    833,
    889,
    600,
    600,
    600,
    600
  ],
  N: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  O: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  P: [
    667,
    667,
    667,
    667,
    611,
    611,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  Q: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  R: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  S: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  T: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  U: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  V: [
    667,
    667,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  W: [
    944,
    944,
    944,
    944,
    1e3,
    889,
    833,
    944,
    600,
    600,
    600,
    600
  ],
  X: [
    667,
    667,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Y: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  Z: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  bracketleft: [
    333,
    333,
    278,
    278,
    333,
    333,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  backslash: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  bracketright: [
    333,
    333,
    278,
    278,
    333,
    333,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  asciicircum: [
    584,
    584,
    469,
    469,
    581,
    570,
    422,
    469,
    600,
    600,
    600,
    600
  ],
  underscore: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  quoteleft: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  a: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  b: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  c: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  d: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  e: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  f: [
    333,
    333,
    278,
    278,
    333,
    333,
    278,
    333,
    600,
    600,
    600,
    600
  ],
  g: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  h: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  i: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  j: [
    278,
    278,
    222,
    222,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  k: [
    556,
    556,
    500,
    500,
    556,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  l: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  m: [
    889,
    889,
    833,
    833,
    833,
    778,
    722,
    778,
    600,
    600,
    600,
    600
  ],
  n: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  o: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  p: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  q: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  r: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  s: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  t: [
    333,
    333,
    278,
    278,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  u: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  v: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  w: [
    778,
    778,
    722,
    722,
    722,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  x: [
    556,
    556,
    500,
    500,
    500,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  y: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  z: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  braceleft: [
    389,
    389,
    334,
    334,
    394,
    348,
    400,
    480,
    600,
    600,
    600,
    600
  ],
  bar: [
    280,
    280,
    260,
    260,
    220,
    220,
    275,
    200,
    600,
    600,
    600,
    600
  ],
  braceright: [
    389,
    389,
    334,
    334,
    394,
    348,
    400,
    480,
    600,
    600,
    600,
    600
  ],
  asciitilde: [
    584,
    584,
    584,
    584,
    520,
    570,
    541,
    541,
    600,
    600,
    600,
    600
  ],
  exclamdown: [
    333,
    333,
    333,
    333,
    333,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  cent: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  sterling: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  fraction: [
    167,
    167,
    167,
    167,
    167,
    167,
    167,
    167,
    600,
    600,
    600,
    600
  ],
  yen: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  florin: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  section: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  currency: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  quotesingle: [
    238,
    238,
    191,
    191,
    278,
    278,
    214,
    180,
    600,
    600,
    600,
    600
  ],
  quotedblleft: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  guillemotleft: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  guilsinglleft: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  guilsinglright: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  fi: [
    611,
    611,
    500,
    500,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  fl: [
    611,
    611,
    500,
    500,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  endash: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  dagger: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  daggerdbl: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  periodcentered: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  paragraph: [
    556,
    556,
    537,
    537,
    540,
    500,
    523,
    453,
    600,
    600,
    600,
    600
  ],
  bullet: [
    350,
    350,
    350,
    350,
    350,
    350,
    350,
    350,
    600,
    600,
    600,
    600
  ],
  quotesinglbase: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  quotedblbase: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  quotedblright: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  guillemotright: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ellipsis: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    889,
    1e3,
    600,
    600,
    600,
    600
  ],
  perthousand: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    600,
    600,
    600,
    600
  ],
  questiondown: [
    611,
    611,
    611,
    611,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  grave: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  acute: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  circumflex: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  tilde: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  macron: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  breve: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  dotaccent: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  dieresis: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ring: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  cedilla: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  hungarumlaut: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ogonek: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  caron: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  emdash: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    889,
    1e3,
    600,
    600,
    600,
    600
  ],
  AE: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    944,
    889,
    889,
    600,
    600,
    600,
    600
  ],
  ordfeminine: [
    370,
    370,
    370,
    370,
    300,
    266,
    276,
    276,
    600,
    600,
    600,
    600
  ],
  Lslash: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Oslash: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  OE: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    944,
    944,
    889,
    600,
    600,
    600,
    600
  ],
  ordmasculine: [
    365,
    365,
    365,
    365,
    330,
    300,
    310,
    310,
    600,
    600,
    600,
    600
  ],
  ae: [
    889,
    889,
    889,
    889,
    722,
    722,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  dotlessi: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  lslash: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  oslash: [
    611,
    611,
    611,
    611,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  oe: [
    944,
    944,
    944,
    944,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  germandbls: [
    611,
    611,
    611,
    611,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Idieresis: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  eacute: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  abreve: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  uhungarumlaut: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ecaron: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Ydieresis: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  divide: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  Yacute: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  Acircumflex: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  aacute: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Ucircumflex: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  yacute: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  scommaaccent: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  ecircumflex: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Uring: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Udieresis: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  aogonek: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Uacute: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  uogonek: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Edieresis: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  Dcroat: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  commaaccent: [
    250,
    250,
    250,
    250,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  copyright: [
    737,
    737,
    737,
    737,
    747,
    747,
    760,
    760,
    600,
    600,
    600,
    600
  ],
  Emacron: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  ccaron: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  aring: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Ncommaaccent: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  lacute: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  agrave: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Tcommaaccent: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Cacute: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  atilde: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Edotaccent: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  scaron: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  scedilla: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  iacute: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  lozenge: [
    494,
    494,
    471,
    471,
    494,
    494,
    471,
    471,
    600,
    600,
    600,
    600
  ],
  Rcaron: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Gcommaaccent: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  ucircumflex: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  acircumflex: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Amacron: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  rcaron: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  ccedilla: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Zdotaccent: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Thorn: [
    667,
    667,
    667,
    667,
    611,
    611,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  Omacron: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Racute: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Sacute: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  dcaron: [
    743,
    743,
    643,
    643,
    672,
    608,
    544,
    588,
    600,
    600,
    600,
    600
  ],
  Umacron: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  uring: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  threesuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  Ograve: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Agrave: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Abreve: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  multiply: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  uacute: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Tcaron: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  partialdiff: [
    494,
    494,
    476,
    476,
    494,
    494,
    476,
    476,
    600,
    600,
    600,
    600
  ],
  ydieresis: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  Nacute: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  icircumflex: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Ecircumflex: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  adieresis: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  edieresis: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  cacute: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  nacute: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  umacron: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Ncaron: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  Iacute: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  plusminus: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  brokenbar: [
    280,
    280,
    260,
    260,
    220,
    220,
    275,
    200,
    600,
    600,
    600,
    600
  ],
  registered: [
    737,
    737,
    737,
    737,
    747,
    747,
    760,
    760,
    600,
    600,
    600,
    600
  ],
  Gbreve: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Idotaccent: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  summation: [
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600
  ],
  Egrave: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  racute: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  omacron: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Zacute: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Zcaron: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  greaterequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  Eth: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Ccedilla: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  lcommaaccent: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  tcaron: [
    389,
    389,
    317,
    317,
    416,
    366,
    300,
    326,
    600,
    600,
    600,
    600
  ],
  eogonek: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Uogonek: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Aacute: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Adieresis: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  egrave: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  zacute: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  iogonek: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Oacute: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  oacute: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  amacron: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  sacute: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  idieresis: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Ocircumflex: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Ugrave: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Delta: [
    612,
    612,
    612,
    612,
    612,
    612,
    612,
    612,
    600,
    600,
    600,
    600
  ],
  thorn: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  twosuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  Odieresis: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  mu: [
    611,
    611,
    556,
    556,
    556,
    576,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  igrave: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  ohungarumlaut: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Eogonek: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  dcroat: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  threequarters: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  Scedilla: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  lcaron: [
    400,
    400,
    299,
    299,
    394,
    382,
    300,
    344,
    600,
    600,
    600,
    600
  ],
  Kcommaaccent: [
    722,
    722,
    667,
    667,
    778,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  Lacute: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  trademark: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    980,
    980,
    600,
    600,
    600,
    600
  ],
  edotaccent: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Igrave: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  Imacron: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  Lcaron: [
    611,
    611,
    556,
    556,
    667,
    611,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  onehalf: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  lessequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  ocircumflex: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ntilde: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Uhungarumlaut: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Eacute: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  emacron: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  gbreve: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  onequarter: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  Scaron: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  Scommaaccent: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  Ohungarumlaut: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  degree: [
    400,
    400,
    400,
    400,
    400,
    400,
    400,
    400,
    600,
    600,
    600,
    600
  ],
  ograve: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Ccaron: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  ugrave: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  radical: [
    549,
    549,
    453,
    453,
    549,
    549,
    453,
    453,
    600,
    600,
    600,
    600
  ],
  Dcaron: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  rcommaaccent: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  Ntilde: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  otilde: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Rcommaaccent: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Lcommaaccent: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Atilde: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Aogonek: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Aring: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Otilde: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  zdotaccent: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  Ecaron: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  Iogonek: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  kcommaaccent: [
    556,
    556,
    500,
    500,
    556,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  minus: [
    584,
    584,
    584,
    584,
    570,
    606,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  Icircumflex: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ncaron: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  tcommaaccent: [
    333,
    333,
    278,
    278,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  logicalnot: [
    584,
    584,
    584,
    584,
    570,
    606,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  odieresis: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  udieresis: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  notequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  gcommaaccent: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  eth: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  zcaron: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  ncommaaccent: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  onesuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  imacron: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Euro: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ]
};
var kernPairs = {
  AC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  ATcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  ATcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Au: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Audieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Augrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Av: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Ay: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Ayacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AacuteC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AacuteT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AacuteW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AacuteY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AacuteYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AacuteYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aacuteu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacutev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aacutew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Aacutey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aacuteyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aacuteydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AbreveC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AbreveT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AbreveW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AbreveY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AbreveYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AbreveYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Abreveu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abrevev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Abrevew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Abrevey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Abreveyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Abreveydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AcircumflexC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AcircumflexT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AcircumflexW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AcircumflexY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AcircumflexYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AcircumflexYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Acircumflexu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Acircumflexw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Acircumflexy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Acircumflexyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Acircumflexydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AdieresisC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AdieresisT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AdieresisW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AdieresisY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AdieresisYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AdieresisYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Adieresisu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Adieresisw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Adieresisy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Adieresisyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Adieresisydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AgraveC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AgraveT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AgraveW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AgraveY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AgraveYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AgraveYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Agraveu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agravev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Agravew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Agravey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Agraveyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Agraveydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AmacronC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AmacronT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AmacronW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AmacronY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AmacronYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AmacronYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Amacronu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Amacronw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Amacrony: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Amacronyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Amacronydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AogonekC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AogonekT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AogonekW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AogonekY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AogonekYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AogonekYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aogoneku: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aogonekw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -52
  ],
  Aogoneky: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  Aogonekyacute: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  Aogonekydieresis: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  AringC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AringT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AringW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AringY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AringYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AringYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aringu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aringw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Aringy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aringyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aringydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AtildeC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AtildeT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AtildeW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AtildeY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AtildeYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AtildeYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Atildeu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Atildew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Atildey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Atildeyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Atildeydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  BA: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAacute: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAbreve: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAcircumflex: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAdieresis: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAgrave: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAmacron: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAogonek: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAring: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAtilde: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BU: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUacute: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUcircumflex: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUdieresis: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUgrave: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUhungarumlaut: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUmacron: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUogonek: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUring: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  DA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  DcaronA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DcaronW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DcaronY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcaronYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcaronYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcaroncomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dcaronperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  DcroatA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DcroatW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DcroatY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcroatYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcroatYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcroatcomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dcroatperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  FA: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAacute: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAbreve: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAcircumflex: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAdieresis: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAgrave: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAmacron: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAogonek: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAring: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAtilde: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  Fa: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faacute: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fabreve: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Facircumflex: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fadieresis: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fagrave: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Famacron: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faogonek: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faring: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fatilde: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fcomma: [
    -100,
    -100,
    -150,
    -150,
    -92,
    -129,
    -135,
    -80
  ],
  Fperiod: [
    -100,
    -100,
    -150,
    -150,
    -110,
    -129,
    -135,
    -80
  ],
  JA: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAbreve: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAogonek: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAring: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  Jcomma: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    -25
  ],
  Jperiod: [
    -20,
    -20,
    -30,
    -30,
    -20,
    -10,
    -25
  ],
  Ju: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juacute: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jucircumflex: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Judieresis: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jugrave: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jumacron: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juogonek: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juring: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  KO: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOacute: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOcircumflex: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOdieresis: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOgrave: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOhungarumlaut: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOmacron: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOslash: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOtilde: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  Ke: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Keacute: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kecaron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kecircumflex: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kedieresis: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kedotaccent: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kegrave: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kemacron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Keogonek: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Ko: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Koacute: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kocircumflex: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kodieresis: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kograve: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kohungarumlaut: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Komacron: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Koslash: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kotilde: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Ku: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuacute: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kudieresis: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kugrave: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kumacron: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuogonek: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuring: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Ky: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kyacute: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kydieresis: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  KcommaaccentO: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOacute: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOcircumflex: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOdieresis: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOgrave: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOhungarumlaut: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOmacron: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOslash: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOtilde: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  Kcommaaccente: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccenteacute: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentecaron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentecircumflex: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentedieresis: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentedotaccent: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentegrave: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentemacron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccenteogonek: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccento: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentoacute: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentocircumflex: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentodieresis: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentograve: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentohungarumlaut: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentomacron: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentoslash: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentotilde: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentu: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuacute: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentudieresis: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentugrave: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentumacron: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuogonek: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccenturing: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccenty: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kcommaaccentyacute: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kcommaaccentydieresis: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  LT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Ly: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LacuteT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LacuteW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LacuteY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LacuteYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LacuteYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lacutequotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lacutequoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lacutey: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lacuteyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lacuteydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LcommaaccentT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LcommaaccentW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LcommaaccentY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LcommaaccentYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LcommaaccentYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lcommaaccentquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lcommaaccentquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lcommaaccenty: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lcommaaccentyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lcommaaccentydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LslashT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LslashW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LslashY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LslashYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LslashYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lslashquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lslashquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lslashy: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lslashyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lslashydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  OA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ocomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Operiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OacuteA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OacuteX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Oacutecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Oacuteperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OcircumflexX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ocircumflexcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ocircumflexperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OdieresisX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Odieresiscomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Odieresisperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OgraveA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OgraveX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ogravecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ograveperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OhungarumlautX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ohungarumlautcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ohungarumlautperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OmacronA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OmacronX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Omacroncomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Omacronperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OslashA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OslashW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OslashX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OslashY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OslashYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OslashYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Oslashcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Oslashperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OtildeA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OtildeX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Otildecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Otildeperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  PA: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAacute: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAbreve: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAcircumflex: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAdieresis: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAgrave: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAmacron: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAogonek: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAring: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAtilde: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  Pa: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paacute: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pabreve: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pacircumflex: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Padieresis: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pagrave: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pamacron: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paogonek: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paring: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Patilde: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pcomma: [
    -120,
    -120,
    -180,
    -180,
    -92,
    -129,
    -135,
    -111
  ],
  Pe: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Peacute: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pecaron: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pecircumflex: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pedieresis: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pedotaccent: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pegrave: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pemacron: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Peogonek: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Po: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Poacute: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pocircumflex: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Podieresis: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pograve: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pohungarumlaut: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pomacron: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Poslash: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Potilde: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pperiod: [
    -120,
    -120,
    -180,
    -180,
    -110,
    -129,
    -135,
    -111
  ],
  QU: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUacute: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUcircumflex: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUdieresis: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUgrave: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUhungarumlaut: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUmacron: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUogonek: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUring: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  Qcomma: [
    20,
    20
  ],
  Qperiod: [
    20,
    20,
    0,
    0,
    -20
  ],
  RO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RacuteW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RacuteY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RcaronW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RcaronY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RcommaaccentW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RcommaaccentY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  TA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Ta: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Taacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Taogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Taring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Te: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Teacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -70
  ],
  Tedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Temacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Teogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Thyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  To: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Toacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Todieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Toslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Totilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Trcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Turing: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Ty: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  TcaronA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Tcarona: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronaacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tcaronacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tcaronadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronaogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronaring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaroncolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcaroncomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Tcarone: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaroneacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -30
  ],
  Tcaronedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tcaronedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Tcaronemacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Tcaroneogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronhyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  Tcarono: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronoacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronodieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronoslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronotilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tcaronr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronrcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tcaronu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuring: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Tcarony: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcaronyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcaronydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  TcommaaccentA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Tcommaaccenta: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentaacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tcommaaccentacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tcommaaccentadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentaogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentaring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentcolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcommaaccentcomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Tcommaaccente: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccenteacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -30
  ],
  Tcommaaccentedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tcommaaccentedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Tcommaaccentemacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Tcommaaccenteogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccenthyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  Tcommaaccento: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentoacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentodieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentoslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentotilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tcommaaccentr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentrcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tcommaaccentu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccenturing: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Tcommaaccenty: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcommaaccentyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcommaaccentydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  UA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ucomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UacuteA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uacutecomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uacuteperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UcircumflexA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ucircumflexcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Ucircumflexperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UdieresisA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Udieresiscomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Udieresisperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UgraveA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ugravecomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Ugraveperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UhungarumlautA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uhungarumlautcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uhungarumlautperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UmacronA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Umacroncomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Umacronperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UogonekA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uogonekcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uogonekperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UringA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uringcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uringperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  VA: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAacute: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAbreve: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAcircumflex: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAdieresis: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAgrave: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAmacron: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAogonek: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAring: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAtilde: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VG: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VGbreve: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VGcommaaccent: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VO: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOacute: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOdieresis: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOgrave: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOhungarumlaut: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOmacron: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOslash: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOtilde: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  Va: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vaacute: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vabreve: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vacircumflex: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vadieresis: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vagrave: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vamacron: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vaogonek: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Varing: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vatilde: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vcolon: [
    -40,
    -40,
    -40,
    -40,
    -92,
    -74,
    -65,
    -74
  ],
  Vcomma: [
    -120,
    -120,
    -125,
    -125,
    -129,
    -129,
    -129,
    -129
  ],
  Ve: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Veacute: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vecaron: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -71
  ],
  Vecircumflex: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -71
  ],
  Vedieresis: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Vedotaccent: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vegrave: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Vemacron: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Veogonek: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vhyphen: [
    -80,
    -80,
    -80,
    -80,
    -74,
    -70,
    -55,
    -100
  ],
  Vo: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Voacute: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vocircumflex: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vodieresis: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vograve: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vohungarumlaut: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vomacron: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Voslash: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Votilde: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vperiod: [
    -120,
    -120,
    -125,
    -125,
    -145,
    -129,
    -129,
    -129
  ],
  Vsemicolon: [
    -40,
    -40,
    -40,
    -40,
    -92,
    -74,
    -74,
    -74
  ],
  Vu: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuacute: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vucircumflex: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vudieresis: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vugrave: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuhungarumlaut: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vumacron: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuogonek: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuring: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  WA: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAacute: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAbreve: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAcircumflex: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAdieresis: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAgrave: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAmacron: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAogonek: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAring: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAtilde: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WO: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOacute: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOgrave: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOmacron: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOslash: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOtilde: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  Wa: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waacute: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wabreve: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wacircumflex: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wadieresis: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wagrave: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wamacron: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waogonek: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waring: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Watilde: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wcolon: [
    -10,
    -10,
    0,
    0,
    -55,
    -55,
    -65,
    -37
  ],
  Wcomma: [
    -80,
    -80,
    -80,
    -80,
    -92,
    -74,
    -92,
    -92
  ],
  We: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Weacute: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wecaron: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wecircumflex: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wedieresis: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Wedotaccent: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wegrave: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Wemacron: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Weogonek: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Whyphen: [
    -40,
    -40,
    -40,
    -40,
    -37,
    -50,
    -37,
    -65
  ],
  Wo: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Woacute: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wocircumflex: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wodieresis: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wograve: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wohungarumlaut: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Womacron: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Woslash: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wotilde: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wperiod: [
    -80,
    -80,
    -80,
    -80,
    -92,
    -74,
    -92,
    -92
  ],
  Wsemicolon: [
    -10,
    -10,
    0,
    0,
    -55,
    -55,
    -65,
    -37
  ],
  Wu: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuacute: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wucircumflex: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wudieresis: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wugrave: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuhungarumlaut: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wumacron: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuogonek: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuring: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wy: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  Wyacute: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  Wydieresis: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  YA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Ya: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Yacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yaring: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yatilde: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ycolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ycomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Ye: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yeacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Yedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Yeogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yo: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yomacron: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Ysemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  YacuteA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Yacutea: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacutearing: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteatilde: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yacutecolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yacutecomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Yacutee: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteeacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Yacuteedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteeogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteo: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteomacron: [
    -100,
    -100,
    -70,
    -70,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Yacutesemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yacuteu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  YdieresisA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Ydieresisa: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisaring: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisatilde: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresiscolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ydieresiscomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Ydieresise: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresiseacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Ydieresisedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresisedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresisemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresiseogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresiso: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisomacron: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Ydieresissemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ydieresisu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  ag: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  av: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  ay: [
    -20,
    -20,
    -30,
    -30
  ],
  ayacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aacutew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aacutey: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  abrevew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  abrevey: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  acircumflexw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  acircumflexy: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  adieresisw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  adieresisy: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  agravew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  agravey: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  amacrong: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacrongbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacrongcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacronv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  amacronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  amacrony: [
    -20,
    -20,
    -30,
    -30
  ],
  amacronyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  amacronydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aogonekw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aogoneky: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aringg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aringw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aringy: [
    -20,
    -20,
    -30,
    -30
  ],
  aringyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aringydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  atildew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  atildey: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  bl: [
    -10,
    -10,
    -20,
    -20
  ],
  blacute: [
    -10,
    -10,
    -20,
    -20
  ],
  blcommaaccent: [
    -10,
    -10,
    -20,
    -20
  ],
  blslash: [
    -10,
    -10,
    -20,
    -20
  ],
  bu: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buacute: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bucircumflex: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  budieresis: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bugrave: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bumacron: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buogonek: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buring: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bv: [
    -20,
    -20,
    -20,
    -20,
    -15,
    0,
    0,
    -15
  ],
  by: [
    -20,
    -20,
    -20,
    -20
  ],
  byacute: [
    -20,
    -20,
    -20,
    -20
  ],
  bydieresis: [
    -20,
    -20,
    -20,
    -20
  ],
  ch: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ck: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ckcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cl: [
    -20,
    -20
  ],
  clacute: [
    -20,
    -20
  ],
  clcommaaccent: [
    -20,
    -20
  ],
  clslash: [
    -20,
    -20
  ],
  cy: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteh: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  cacutek: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cacutekcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cacutel: [
    -20,
    -20
  ],
  cacutelacute: [
    -20,
    -20
  ],
  cacutelcommaaccent: [
    -20,
    -20
  ],
  cacutelslash: [
    -20,
    -20
  ],
  cacutey: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronh: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ccaronk: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccaronkcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccaronl: [
    -20,
    -20
  ],
  ccaronlacute: [
    -20,
    -20
  ],
  ccaronlcommaaccent: [
    -20,
    -20
  ],
  ccaronlslash: [
    -20,
    -20
  ],
  ccarony: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillah: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ccedillak: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccedillakcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccedillal: [
    -20,
    -20
  ],
  ccedillalacute: [
    -20,
    -20
  ],
  ccedillalcommaaccent: [
    -20,
    -20
  ],
  ccedillalslash: [
    -20,
    -20
  ],
  ccedillay: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillayacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillaydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  colonspace: [
    -40,
    -40,
    -50,
    -50
  ],
  commaquotedblright: [
    -120,
    -120,
    -100,
    -100,
    -45,
    -95,
    -140,
    -70
  ],
  commaquoteright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  commaspace: [
    -40,
    -40
  ],
  dd: [
    -10,
    -10
  ],
  ddcroat: [
    -10,
    -10
  ],
  dv: [
    -15,
    -15
  ],
  dw: [
    -15,
    -15,
    0,
    0,
    -15
  ],
  dy: [
    -15,
    -15
  ],
  dyacute: [
    -15,
    -15
  ],
  dydieresis: [
    -15,
    -15
  ],
  dcroatd: [
    -10,
    -10
  ],
  dcroatdcroat: [
    -10,
    -10
  ],
  dcroatv: [
    -15,
    -15
  ],
  dcroatw: [
    -15,
    -15,
    0,
    0,
    -15
  ],
  dcroaty: [
    -15,
    -15
  ],
  dcroatyacute: [
    -15,
    -15
  ],
  dcroatydieresis: [
    -15,
    -15
  ],
  ecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacutecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eacuteperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  eacutev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  eacutew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  eacutex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  eacutey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacuteyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacuteydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaroncomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  ecaronperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ecaronv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ecaronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ecaronx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ecarony: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaronyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaronydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  ecircumflexperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ecircumflexv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ecircumflexw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ecircumflexx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ecircumflexy: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresiscomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  edieresisperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  edieresisv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  edieresisw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  edieresisx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  edieresisy: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresisyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresisydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  edotaccentperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  edotaccentv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  edotaccentw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  edotaccentx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  edotaccenty: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egravecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  egraveperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  egravev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  egravew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  egravex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  egravey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egraveyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egraveydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacroncomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  emacronperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  emacronv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  emacronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  emacronx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  emacrony: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacronyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacronydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eogonekperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  eogonekv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  eogonekw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  eogonekx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  eogoneky: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  fcomma: [
    -10,
    -10,
    -30,
    -30,
    -15,
    -10,
    -10
  ],
  fe: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  feacute: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fecaron: [
    -10,
    -10,
    -30,
    -30
  ],
  fecircumflex: [
    -10,
    -10,
    -30,
    -30
  ],
  fedieresis: [
    -10,
    -10,
    -30,
    -30
  ],
  fedotaccent: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fegrave: [
    -10,
    -10,
    -30,
    -30
  ],
  femacron: [
    -10,
    -10,
    -30,
    -30
  ],
  feogonek: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fo: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  foacute: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  focircumflex: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fodieresis: [
    -20,
    -20,
    -30,
    -30,
    -25
  ],
  fograve: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fohungarumlaut: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fomacron: [
    -20,
    -20,
    -30,
    -30,
    -25
  ],
  foslash: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fotilde: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fperiod: [
    -10,
    -10,
    -30,
    -30,
    -15,
    -10,
    -15
  ],
  fquotedblright: [
    30,
    30,
    60,
    60,
    50
  ],
  fquoteright: [
    30,
    30,
    50,
    50,
    55,
    55,
    92,
    55
  ],
  ge: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  geacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  geogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  ggbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  ggcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevee: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveeacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveeogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccente: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccenteacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccenteogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  hy: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  hyacute: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  hydieresis: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  ko: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  koacute: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kocircumflex: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kodieresis: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kograve: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kohungarumlaut: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  komacron: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  koslash: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kotilde: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccento: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentoacute: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentocircumflex: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentodieresis: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentograve: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentohungarumlaut: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentomacron: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentoslash: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentotilde: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  lw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ly: [
    -15,
    -15
  ],
  lyacute: [
    -15,
    -15
  ],
  lydieresis: [
    -15,
    -15
  ],
  lacutew: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lacutey: [
    -15,
    -15
  ],
  lacuteyacute: [
    -15,
    -15
  ],
  lacuteydieresis: [
    -15,
    -15
  ],
  lcommaaccentw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lcommaaccenty: [
    -15,
    -15
  ],
  lcommaaccentyacute: [
    -15,
    -15
  ],
  lcommaaccentydieresis: [
    -15,
    -15
  ],
  lslashw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lslashy: [
    -15,
    -15
  ],
  lslashyacute: [
    -15,
    -15
  ],
  lslashydieresis: [
    -15,
    -15
  ],
  mu: [
    -20,
    -20,
    -10,
    -10
  ],
  muacute: [
    -20,
    -20,
    -10,
    -10
  ],
  mucircumflex: [
    -20,
    -20,
    -10,
    -10
  ],
  mudieresis: [
    -20,
    -20,
    -10,
    -10
  ],
  mugrave: [
    -20,
    -20,
    -10,
    -10
  ],
  muhungarumlaut: [
    -20,
    -20,
    -10,
    -10
  ],
  mumacron: [
    -20,
    -20,
    -10,
    -10
  ],
  muogonek: [
    -20,
    -20,
    -10,
    -10
  ],
  muring: [
    -20,
    -20,
    -10,
    -10
  ],
  my: [
    -30,
    -30,
    -15,
    -15
  ],
  myacute: [
    -30,
    -30,
    -15,
    -15
  ],
  mydieresis: [
    -30,
    -30,
    -15,
    -15
  ],
  nu: [
    -10,
    -10,
    -10,
    -10
  ],
  nuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  nucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  nudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  nugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  nuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  numacron: [
    -10,
    -10,
    -10,
    -10
  ],
  nuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  nuring: [
    -10,
    -10,
    -10,
    -10
  ],
  nv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ny: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteu: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuring: [
    -10,
    -10,
    -10,
    -10
  ],
  nacutev: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  nacutey: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronu: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuring: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ncarony: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentu: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccenturing: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ncommaaccenty: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeu: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuring: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildev: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ntildey: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ov: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ow: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ox: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  oy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacutev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  oacutew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  oacutex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  oacutey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacuteyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacuteydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ocircumflexw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ocircumflexx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ocircumflexy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  odieresisw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  odieresisx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  odieresisy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ogravev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ogravew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ogravex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ogravey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ograveyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ograveydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ohungarumlautw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ohungarumlautx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ohungarumlauty: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  omacronw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  omacronx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  omacrony: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oslashv: [
    -20,
    -20,
    -70,
    -70,
    -10,
    -15,
    -10,
    -15
  ],
  oslashw: [
    -15,
    -15,
    -70,
    -70,
    -10,
    -25,
    0,
    -25
  ],
  oslashx: [
    -30,
    -30,
    -85,
    -85,
    0,
    -10
  ],
  oslashy: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  oslashyacute: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  oslashydieresis: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  otildev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  otildew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  otildex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  otildey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  otildeyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  otildeydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  py: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  pyacute: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  pydieresis: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  periodquotedblright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  periodquoteright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  periodspace: [
    -40,
    -40,
    -60,
    -60
  ],
  quotedblrightspace: [
    -80,
    -80,
    -40,
    -40
  ],
  quoteleftquoteleft: [
    -46,
    -46,
    -57,
    -57,
    -63,
    -74,
    -111,
    -74
  ],
  quoterightd: [
    -80,
    -80,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightdcroat: [
    -80,
    -80,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightl: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlacute: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlcommaaccent: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlslash: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightquoteright: [
    -46,
    -46,
    -57,
    -57,
    -63,
    -74,
    -111,
    -74
  ],
  quoterightr: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightracute: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightrcaron: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightrcommaaccent: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterights: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightsacute: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscaron: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscedilla: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscommaaccent: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightspace: [
    -80,
    -80,
    -70,
    -70,
    -74,
    -74,
    -111,
    -74
  ],
  quoterightv: [
    -20,
    -20,
    0,
    0,
    -20,
    -15,
    -10,
    -50
  ],
  rc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rd: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rdcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rgbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rgcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rhyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  ro: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  roacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  romacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  roslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rs: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rt: [
    20,
    20,
    40,
    40
  ],
  rtcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rv: [
    10,
    10,
    30,
    30,
    -10
  ],
  ry: [
    10,
    10,
    30,
    30
  ],
  ryacute: [
    10,
    10,
    30,
    30
  ],
  rydieresis: [
    10,
    10,
    30,
    30
  ],
  racutec: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutecacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutecomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  racuted: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  racutedcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  racuteg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutegbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutegcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutehyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  racuteo: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  racuteq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutes: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutesacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutet: [
    20,
    20,
    40,
    40
  ],
  racutetcommaaccent: [
    20,
    20,
    40,
    40
  ],
  racutev: [
    10,
    10,
    30,
    30,
    -10
  ],
  racutey: [
    10,
    10,
    30,
    30
  ],
  racuteyacute: [
    10,
    10,
    30,
    30
  ],
  racuteydieresis: [
    10,
    10,
    30,
    30
  ],
  rcaronc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroncacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroncomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rcarond: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcarondcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcarong: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcarongbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcarongcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcaronhyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  rcarono: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rcaronq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcarons: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaront: [
    20,
    20,
    40,
    40
  ],
  rcarontcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rcaronv: [
    10,
    10,
    30,
    30,
    -10
  ],
  rcarony: [
    10,
    10,
    30,
    30
  ],
  rcaronyacute: [
    10,
    10,
    30,
    30
  ],
  rcaronydieresis: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentcacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentcomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rcommaaccentd: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcommaaccentdcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcommaaccentg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccentgbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccentgcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccenthyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  rcommaaccento: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rcommaaccentq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccents: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentt: [
    20,
    20,
    40,
    40
  ],
  rcommaaccenttcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rcommaaccentv: [
    10,
    10,
    30,
    30,
    -10
  ],
  rcommaaccenty: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentyacute: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentydieresis: [
    10,
    10,
    30,
    30
  ],
  sw: [
    -15,
    -15,
    -30,
    -30
  ],
  sacutew: [
    -15,
    -15,
    -30,
    -30
  ],
  scaronw: [
    -15,
    -15,
    -30,
    -30
  ],
  scedillaw: [
    -15,
    -15,
    -30,
    -30
  ],
  scommaaccentw: [
    -15,
    -15,
    -30,
    -30
  ],
  semicolonspace: [
    -40,
    -40,
    -50,
    -50
  ],
  spaceT: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceTcaron: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceTcommaaccent: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceV: [
    -80,
    -80,
    -50,
    -50,
    -45,
    -70,
    -35,
    -50
  ],
  spaceW: [
    -80,
    -80,
    -40,
    -40,
    -30,
    -70,
    -40,
    -30
  ],
  spaceY: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spaceYacute: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spaceYdieresis: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spacequotedblleft: [
    -80,
    -80,
    -30,
    -30
  ],
  spacequoteleft: [
    -60,
    -60,
    -60,
    -60
  ],
  va: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vaacute: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vabreve: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vacircumflex: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vadieresis: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vagrave: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vamacron: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vaogonek: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  varing: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vatilde: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vcomma: [
    -80,
    -80,
    -80,
    -80,
    -55,
    -37,
    -74,
    -65
  ],
  vo: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  voacute: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vocircumflex: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vodieresis: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vograve: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vohungarumlaut: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vomacron: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  voslash: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  votilde: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vperiod: [
    -80,
    -80,
    -80,
    -80,
    -70,
    -37,
    -74,
    -65
  ],
  wcomma: [
    -40,
    -40,
    -60,
    -60,
    -55,
    -37,
    -74,
    -65
  ],
  wo: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  woacute: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wocircumflex: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wodieresis: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wograve: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wohungarumlaut: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  womacron: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  woslash: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wotilde: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wperiod: [
    -40,
    -40,
    -60,
    -60,
    -70,
    -37,
    -74,
    -65
  ],
  xe: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xeacute: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xecaron: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xecircumflex: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xedieresis: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xedotaccent: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xegrave: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xemacron: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xeogonek: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  ya: [
    -30,
    -30,
    -20,
    -20
  ],
  yaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  yabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  yacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  yadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  yagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  yamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  yaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  yaring: [
    -30,
    -30,
    -20,
    -20
  ],
  yatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  ycomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  ye: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yeacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yeogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yo: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  yacutea: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  yacutearing: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  yacutecomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  yacutee: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteeacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteeogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteo: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  ydieresisa: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaring: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresiscomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  ydieresise: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiseacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiseogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiso: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  ze: [
    10,
    10,
    -15,
    -15
  ],
  zeacute: [
    10,
    10,
    -15,
    -15
  ],
  zecaron: [
    10,
    10,
    -15,
    -15
  ],
  zecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zegrave: [
    10,
    10,
    -15,
    -15
  ],
  zemacron: [
    10,
    10,
    -15,
    -15
  ],
  zeogonek: [
    10,
    10,
    -15,
    -15
  ],
  zacutee: [
    10,
    10,
    -15,
    -15
  ],
  zacuteeacute: [
    10,
    10,
    -15,
    -15
  ],
  zacuteecaron: [
    10,
    10,
    -15,
    -15
  ],
  zacuteecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zacuteedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zacuteedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zacuteegrave: [
    10,
    10,
    -15,
    -15
  ],
  zacuteemacron: [
    10,
    10,
    -15,
    -15
  ],
  zacuteeogonek: [
    10,
    10,
    -15,
    -15
  ],
  zcarone: [
    10,
    10,
    -15,
    -15
  ],
  zcaroneacute: [
    10,
    10,
    -15,
    -15
  ],
  zcaronecaron: [
    10,
    10,
    -15,
    -15
  ],
  zcaronecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zcaronedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zcaronedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zcaronegrave: [
    10,
    10,
    -15,
    -15
  ],
  zcaronemacron: [
    10,
    10,
    -15,
    -15
  ],
  zcaroneogonek: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccente: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccenteacute: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentecaron: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentegrave: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentemacron: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccenteogonek: [
    10,
    10,
    -15,
    -15
  ],
  Bcomma: [
    0,
    0,
    -20,
    -20
  ],
  Bperiod: [
    0,
    0,
    -20,
    -20
  ],
  Ccomma: [
    0,
    0,
    -30,
    -30
  ],
  Cperiod: [
    0,
    0,
    -30,
    -30
  ],
  Cacutecomma: [
    0,
    0,
    -30,
    -30
  ],
  Cacuteperiod: [
    0,
    0,
    -30,
    -30
  ],
  Ccaroncomma: [
    0,
    0,
    -30,
    -30
  ],
  Ccaronperiod: [
    0,
    0,
    -30,
    -30
  ],
  Ccedillacomma: [
    0,
    0,
    -30,
    -30
  ],
  Ccedillaperiod: [
    0,
    0,
    -30,
    -30
  ],
  Fe: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Feacute: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fecaron: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fecircumflex: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fedieresis: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fedotaccent: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fegrave: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Femacron: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Feogonek: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fo: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Foacute: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Focircumflex: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fodieresis: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fograve: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fohungarumlaut: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fomacron: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Foslash: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fotilde: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fr: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Fracute: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Frcaron: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Frcommaaccent: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Ja: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaacute: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jabreve: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jacircumflex: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jadieresis: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jagrave: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jamacron: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaogonek: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaring: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jatilde: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  LcaronT: [
    0,
    0,
    -110,
    -110
  ],
  LcaronTcaron: [
    0,
    0,
    -110,
    -110
  ],
  LcaronTcommaaccent: [
    0,
    0,
    -110,
    -110
  ],
  LcaronV: [
    0,
    0,
    -110,
    -110
  ],
  LcaronW: [
    0,
    0,
    -70,
    -70
  ],
  LcaronY: [
    0,
    0,
    -140,
    -140
  ],
  LcaronYacute: [
    0,
    0,
    -140,
    -140
  ],
  LcaronYdieresis: [
    0,
    0,
    -140,
    -140
  ],
  Lcaronquotedblright: [
    0,
    0,
    -140,
    -140
  ],
  Lcaronquoteright: [
    0,
    0,
    -160,
    -160,
    0,
    0,
    0,
    -92
  ],
  Lcarony: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Lcaronyacute: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Lcaronydieresis: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Scomma: [
    0,
    0,
    -20,
    -20
  ],
  Speriod: [
    0,
    0,
    -20,
    -20
  ],
  Sacutecomma: [
    0,
    0,
    -20,
    -20
  ],
  Sacuteperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scaroncomma: [
    0,
    0,
    -20,
    -20
  ],
  Scaronperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scedillacomma: [
    0,
    0,
    -20,
    -20
  ],
  Scedillaperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scommaaccentcomma: [
    0,
    0,
    -20,
    -20
  ],
  Scommaaccentperiod: [
    0,
    0,
    -20,
    -20
  ],
  Trcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronrcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentrcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Yhyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Yi: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacutehyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Yacutei: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacuteiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacuteiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresishyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Ydieresisi: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresisiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresisiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  bb: [
    0,
    0,
    -10,
    -10,
    -10,
    -10
  ],
  bcomma: [
    0,
    0,
    -40,
    -40
  ],
  bperiod: [
    0,
    0,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  ccomma: [
    0,
    0,
    -15,
    -15
  ],
  cacutecomma: [
    0,
    0,
    -15,
    -15
  ],
  ccaroncomma: [
    0,
    0,
    -15,
    -15
  ],
  ccedillacomma: [
    0,
    0,
    -15,
    -15
  ],
  fa: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faacute: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fabreve: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  facircumflex: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fadieresis: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fagrave: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  famacron: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faogonek: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faring: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fatilde: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fdotlessi: [
    0,
    0,
    -28,
    -28,
    -35,
    -30,
    -60,
    -50
  ],
  gr: [
    0,
    0,
    -10,
    -10
  ],
  gracute: [
    0,
    0,
    -10,
    -10
  ],
  grcaron: [
    0,
    0,
    -10,
    -10
  ],
  grcommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  gbrever: [
    0,
    0,
    -10,
    -10
  ],
  gbreveracute: [
    0,
    0,
    -10,
    -10
  ],
  gbrevercaron: [
    0,
    0,
    -10,
    -10
  ],
  gbrevercommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentr: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentracute: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentrcaron: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentrcommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  ke: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  keacute: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kecaron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kecircumflex: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kedieresis: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kedotaccent: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kegrave: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kemacron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  keogonek: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccente: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccenteacute: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentecaron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentecircumflex: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentedieresis: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentedotaccent: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentegrave: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentemacron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccenteogonek: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  ocomma: [
    0,
    0,
    -40,
    -40
  ],
  operiod: [
    0,
    0,
    -40,
    -40
  ],
  oacutecomma: [
    0,
    0,
    -40,
    -40
  ],
  oacuteperiod: [
    0,
    0,
    -40,
    -40
  ],
  ocircumflexcomma: [
    0,
    0,
    -40,
    -40
  ],
  ocircumflexperiod: [
    0,
    0,
    -40,
    -40
  ],
  odieresiscomma: [
    0,
    0,
    -40,
    -40
  ],
  odieresisperiod: [
    0,
    0,
    -40,
    -40
  ],
  ogravecomma: [
    0,
    0,
    -40,
    -40
  ],
  ograveperiod: [
    0,
    0,
    -40,
    -40
  ],
  ohungarumlautcomma: [
    0,
    0,
    -40,
    -40
  ],
  ohungarumlautperiod: [
    0,
    0,
    -40,
    -40
  ],
  omacroncomma: [
    0,
    0,
    -40,
    -40
  ],
  omacronperiod: [
    0,
    0,
    -40,
    -40
  ],
  oslasha: [
    0,
    0,
    -55,
    -55
  ],
  oslashaacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashabreve: [
    0,
    0,
    -55,
    -55
  ],
  oslashacircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashadieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashagrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashamacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashaogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslasharing: [
    0,
    0,
    -55,
    -55
  ],
  oslashatilde: [
    0,
    0,
    -55,
    -55
  ],
  oslashb: [
    0,
    0,
    -55,
    -55
  ],
  oslashc: [
    0,
    0,
    -55,
    -55
  ],
  oslashcacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashccaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashccedilla: [
    0,
    0,
    -55,
    -55
  ],
  oslashcomma: [
    0,
    0,
    -95,
    -95
  ],
  oslashd: [
    0,
    0,
    -55,
    -55
  ],
  oslashdcroat: [
    0,
    0,
    -55,
    -55
  ],
  oslashe: [
    0,
    0,
    -55,
    -55
  ],
  oslasheacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashecaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashecircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashedieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashedotaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashegrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashemacron: [
    0,
    0,
    -55,
    -55
  ],
  oslasheogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashf: [
    0,
    0,
    -55,
    -55
  ],
  oslashg: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashgbreve: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashgcommaaccent: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashh: [
    0,
    0,
    -55,
    -55
  ],
  oslashi: [
    0,
    0,
    -55,
    -55
  ],
  oslashiacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashicircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashidieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashigrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashimacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashiogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashj: [
    0,
    0,
    -55,
    -55
  ],
  oslashk: [
    0,
    0,
    -55,
    -55
  ],
  oslashkcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashl: [
    0,
    0,
    -55,
    -55
  ],
  oslashlacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashlcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashlslash: [
    0,
    0,
    -55,
    -55
  ],
  oslashm: [
    0,
    0,
    -55,
    -55
  ],
  oslashn: [
    0,
    0,
    -55,
    -55
  ],
  oslashnacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashncaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashncommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashntilde: [
    0,
    0,
    -55,
    -55
  ],
  oslasho: [
    0,
    0,
    -55,
    -55
  ],
  oslashoacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashocircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashodieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashograve: [
    0,
    0,
    -55,
    -55
  ],
  oslashohungarumlaut: [
    0,
    0,
    -55,
    -55
  ],
  oslashomacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashoslash: [
    0,
    0,
    -55,
    -55
  ],
  oslashotilde: [
    0,
    0,
    -55,
    -55
  ],
  oslashp: [
    0,
    0,
    -55,
    -55
  ],
  oslashperiod: [
    0,
    0,
    -95,
    -95
  ],
  oslashq: [
    0,
    0,
    -55,
    -55
  ],
  oslashr: [
    0,
    0,
    -55,
    -55
  ],
  oslashracute: [
    0,
    0,
    -55,
    -55
  ],
  oslashrcaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashrcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashs: [
    0,
    0,
    -55,
    -55
  ],
  oslashsacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashscaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashscedilla: [
    0,
    0,
    -55,
    -55
  ],
  oslashscommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslasht: [
    0,
    0,
    -55,
    -55
  ],
  oslashtcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashu: [
    0,
    0,
    -55,
    -55
  ],
  oslashuacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashucircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashudieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashugrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashuhungarumlaut: [
    0,
    0,
    -55,
    -55
  ],
  oslashumacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashuogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashuring: [
    0,
    0,
    -55,
    -55
  ],
  oslashz: [
    0,
    0,
    -55,
    -55
  ],
  oslashzacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashzcaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashzdotaccent: [
    0,
    0,
    -55,
    -55
  ],
  otildecomma: [
    0,
    0,
    -40,
    -40
  ],
  otildeperiod: [
    0,
    0,
    -40,
    -40
  ],
  pcomma: [
    0,
    0,
    -35,
    -35
  ],
  pperiod: [
    0,
    0,
    -35,
    -35
  ],
  ra: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  radieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ragrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ramacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ratilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcolon: [
    0,
    0,
    30,
    30
  ],
  ri: [
    0,
    0,
    15,
    15
  ],
  riacute: [
    0,
    0,
    15,
    15
  ],
  ricircumflex: [
    0,
    0,
    15,
    15
  ],
  ridieresis: [
    0,
    0,
    15,
    15
  ],
  rigrave: [
    0,
    0,
    15,
    15
  ],
  rimacron: [
    0,
    0,
    15,
    15
  ],
  riogonek: [
    0,
    0,
    15,
    15
  ],
  rk: [
    0,
    0,
    15,
    15
  ],
  rkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rl: [
    0,
    0,
    15,
    15
  ],
  rlacute: [
    0,
    0,
    15,
    15
  ],
  rlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rlslash: [
    0,
    0,
    15,
    15
  ],
  rm: [
    0,
    0,
    25,
    25
  ],
  rn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rsemicolon: [
    0,
    0,
    30,
    30
  ],
  ru: [
    0,
    0,
    15,
    15
  ],
  ruacute: [
    0,
    0,
    15,
    15
  ],
  rucircumflex: [
    0,
    0,
    15,
    15
  ],
  rudieresis: [
    0,
    0,
    15,
    15
  ],
  rugrave: [
    0,
    0,
    15,
    15
  ],
  ruhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rumacron: [
    0,
    0,
    15,
    15
  ],
  ruogonek: [
    0,
    0,
    15,
    15
  ],
  ruring: [
    0,
    0,
    15,
    15
  ],
  racutea: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racutearing: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racutecolon: [
    0,
    0,
    30,
    30
  ],
  racutei: [
    0,
    0,
    15,
    15
  ],
  racuteiacute: [
    0,
    0,
    15,
    15
  ],
  racuteicircumflex: [
    0,
    0,
    15,
    15
  ],
  racuteidieresis: [
    0,
    0,
    15,
    15
  ],
  racuteigrave: [
    0,
    0,
    15,
    15
  ],
  racuteimacron: [
    0,
    0,
    15,
    15
  ],
  racuteiogonek: [
    0,
    0,
    15,
    15
  ],
  racutek: [
    0,
    0,
    15,
    15
  ],
  racutekcommaaccent: [
    0,
    0,
    15,
    15
  ],
  racutel: [
    0,
    0,
    15,
    15
  ],
  racutelacute: [
    0,
    0,
    15,
    15
  ],
  racutelcommaaccent: [
    0,
    0,
    15,
    15
  ],
  racutelslash: [
    0,
    0,
    15,
    15
  ],
  racutem: [
    0,
    0,
    25,
    25
  ],
  racuten: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutenacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutencaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutencommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutentilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutep: [
    0,
    0,
    30,
    30,
    -10
  ],
  racutesemicolon: [
    0,
    0,
    30,
    30
  ],
  racuteu: [
    0,
    0,
    15,
    15
  ],
  racuteuacute: [
    0,
    0,
    15,
    15
  ],
  racuteucircumflex: [
    0,
    0,
    15,
    15
  ],
  racuteudieresis: [
    0,
    0,
    15,
    15
  ],
  racuteugrave: [
    0,
    0,
    15,
    15
  ],
  racuteuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  racuteumacron: [
    0,
    0,
    15,
    15
  ],
  racuteuogonek: [
    0,
    0,
    15,
    15
  ],
  racuteuring: [
    0,
    0,
    15,
    15
  ],
  rcarona: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaroncolon: [
    0,
    0,
    30,
    30
  ],
  rcaroni: [
    0,
    0,
    15,
    15
  ],
  rcaroniacute: [
    0,
    0,
    15,
    15
  ],
  rcaronicircumflex: [
    0,
    0,
    15,
    15
  ],
  rcaronidieresis: [
    0,
    0,
    15,
    15
  ],
  rcaronigrave: [
    0,
    0,
    15,
    15
  ],
  rcaronimacron: [
    0,
    0,
    15,
    15
  ],
  rcaroniogonek: [
    0,
    0,
    15,
    15
  ],
  rcaronk: [
    0,
    0,
    15,
    15
  ],
  rcaronkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcaronl: [
    0,
    0,
    15,
    15
  ],
  rcaronlacute: [
    0,
    0,
    15,
    15
  ],
  rcaronlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcaronlslash: [
    0,
    0,
    15,
    15
  ],
  rcaronm: [
    0,
    0,
    25,
    25
  ],
  rcaronn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rcaronsemicolon: [
    0,
    0,
    30,
    30
  ],
  rcaronu: [
    0,
    0,
    15,
    15
  ],
  rcaronuacute: [
    0,
    0,
    15,
    15
  ],
  rcaronucircumflex: [
    0,
    0,
    15,
    15
  ],
  rcaronudieresis: [
    0,
    0,
    15,
    15
  ],
  rcaronugrave: [
    0,
    0,
    15,
    15
  ],
  rcaronuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rcaronumacron: [
    0,
    0,
    15,
    15
  ],
  rcaronuogonek: [
    0,
    0,
    15,
    15
  ],
  rcaronuring: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenta: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentcolon: [
    0,
    0,
    30,
    30
  ],
  rcommaaccenti: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentiacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenticircumflex: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentidieresis: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentigrave: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentimacron: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentiogonek: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentk: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentl: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlslash: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentm: [
    0,
    0,
    25,
    25
  ],
  rcommaaccentn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rcommaaccentsemicolon: [
    0,
    0,
    30,
    30
  ],
  rcommaaccentu: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentucircumflex: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentudieresis: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentugrave: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentumacron: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuogonek: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenturing: [
    0,
    0,
    15,
    15
  ],
  scomma: [
    0,
    0,
    -15,
    -15
  ],
  speriod: [
    0,
    0,
    -15,
    -15
  ],
  sacutecomma: [
    0,
    0,
    -15,
    -15
  ],
  sacuteperiod: [
    0,
    0,
    -15,
    -15
  ],
  scaroncomma: [
    0,
    0,
    -15,
    -15
  ],
  scaronperiod: [
    0,
    0,
    -15,
    -15
  ],
  scedillacomma: [
    0,
    0,
    -15,
    -15
  ],
  scedillaperiod: [
    0,
    0,
    -15,
    -15
  ],
  scommaaccentcomma: [
    0,
    0,
    -15,
    -15
  ],
  scommaaccentperiod: [
    0,
    0,
    -15,
    -15
  ],
  ve: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  veacute: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vecaron: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vecircumflex: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vedieresis: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vedotaccent: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vegrave: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vemacron: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  veogonek: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  wa: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waacute: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wabreve: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wacircumflex: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wadieresis: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wagrave: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wamacron: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waogonek: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waring: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  watilde: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  we: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  weacute: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wecaron: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wecircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wedieresis: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wedotaccent: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wegrave: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wemacron: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  weogonek: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  zo: [
    0,
    0,
    -15,
    -15
  ],
  zoacute: [
    0,
    0,
    -15,
    -15
  ],
  zocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zograve: [
    0,
    0,
    -15,
    -15
  ],
  zohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zomacron: [
    0,
    0,
    -15,
    -15
  ],
  zoslash: [
    0,
    0,
    -15,
    -15
  ],
  zotilde: [
    0,
    0,
    -15,
    -15
  ],
  zacuteo: [
    0,
    0,
    -15,
    -15
  ],
  zacuteoacute: [
    0,
    0,
    -15,
    -15
  ],
  zacuteocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zacuteodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zacuteograve: [
    0,
    0,
    -15,
    -15
  ],
  zacuteohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zacuteomacron: [
    0,
    0,
    -15,
    -15
  ],
  zacuteoslash: [
    0,
    0,
    -15,
    -15
  ],
  zacuteotilde: [
    0,
    0,
    -15,
    -15
  ],
  zcarono: [
    0,
    0,
    -15,
    -15
  ],
  zcaronoacute: [
    0,
    0,
    -15,
    -15
  ],
  zcaronocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zcaronodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zcaronograve: [
    0,
    0,
    -15,
    -15
  ],
  zcaronohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zcaronomacron: [
    0,
    0,
    -15,
    -15
  ],
  zcaronoslash: [
    0,
    0,
    -15,
    -15
  ],
  zcaronotilde: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccento: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentoacute: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentograve: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentomacron: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentoslash: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentotilde: [
    0,
    0,
    -15,
    -15
  ],
  Ap: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aacutep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aacutequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Abrevep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Abrevequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Acircumflexp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Acircumflexquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Adieresisp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Adieresisquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Agravep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Agravequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Amacronp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Amacronquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aogonekp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aogonekquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aringp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aringquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Atildep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Atildequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Je: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jeacute: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jecaron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jecircumflex: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jedieresis: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jedotaccent: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jegrave: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jemacron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jeogonek: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jo: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Joacute: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jocircumflex: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jodieresis: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jograve: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Johungarumlaut: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jomacron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Joslash: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jotilde: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  NA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  Ti: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroni: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroniacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroniogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccenti: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccentiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccentiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Vi: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Viacute: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Vicircumflex: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vidieresis: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vigrave: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vimacron: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Viogonek: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Wi: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  Wiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  Wiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  fi: [
    0,
    0,
    0,
    0,
    -25,
    0,
    -20,
    -20
  ],
  gperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  gbreveperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  gcommaaccentperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  iv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  iacutev: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  icircumflexv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  idieresisv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  igravev: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  imacronv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  iogonekv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  ky: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kyacute: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kydieresis: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccenty: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccentyacute: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccentydieresis: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  quotedblleftA: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAacute: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAbreve: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAcircumflex: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAdieresis: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAgrave: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAmacron: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAogonek: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAring: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAtilde: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftA: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAacute: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAbreve: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAcircumflex: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAdieresis: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAgrave: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAmacron: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAogonek: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAring: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAtilde: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  re: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  reacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  recaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  recircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  redieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  redotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  regrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  remacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  reogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutee: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteeacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteeogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcarone: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroneacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroneogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccente: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccenteacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccenteogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  spaceA: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAacute: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAbreve: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAcircumflex: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAdieresis: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAgrave: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAmacron: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAogonek: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAring: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAtilde: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  Fi: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fiacute: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Ficircumflex: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fidieresis: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Figrave: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fimacron: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fiogonek: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  eb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  eacuteb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ecaronb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ecircumflexb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  edieresisb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  edotaccentb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  egraveb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  emacronb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  eogonekb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ff: [
    0,
    0,
    0,
    0,
    0,
    -18,
    -18,
    -25
  ],
  quoterightt: [
    0,
    0,
    0,
    0,
    0,
    -37,
    -30,
    -18
  ],
  quoterighttcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    -37,
    -30,
    -18
  ],
  Yicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  eg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacuteg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacutegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacutegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egraveg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egravegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egravegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  fiogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    -20
  ],
  gcomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevecomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentcomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  og: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacuteg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacutegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacutegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ograveg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogravegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogravegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildeg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  fiacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -20
  ],
  ga: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  garing: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbrevea: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbrevearing: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccenta: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaring: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ]
};
var data = {
  attributes,
  glyphWidths,
  kernPairs
};
const initFont = (font) => {
  return [font.FontName, {
    attributes: font,
    glyphWidths: {},
    kernPairs: {}
  }];
};
const expandData = (data2) => {
  const {
    attributes: attributes2,
    glyphWidths: glyphWidths2,
    kernPairs: kernPairs2
  } = data2;
  const fonts = attributes2.map(initFont);
  Object.keys(glyphWidths2).forEach((key) => {
    glyphWidths2[key].forEach((value2, index2) => {
      if (value2) fonts[index2][1].glyphWidths[key] = value2;
    });
  });
  Object.keys(kernPairs2).forEach((key) => {
    kernPairs2[key].forEach((value2, index2) => {
      if (value2) fonts[index2][1].kernPairs[key] = value2;
    });
  });
  return Object.fromEntries(fonts);
};
const STANDARD_FONTS$1 = expandData(data);
const createStandardFont = (PDFFont2) => class StandardFont extends PDFFont2 {
  constructor(document2, name, id) {
    super();
    this.document = document2;
    this.name = name;
    this.id = id;
    this.font = AFMFont.fromJson(STANDARD_FONTS$1[this.name]);
    this.ascender = this.font.ascender;
    this.descender = this.font.descender;
    this.bbox = this.font.bbox;
    this.lineGap = this.font.lineGap;
  }
  embed() {
    this.dictionary.data = {
      Type: "Font",
      BaseFont: this.name,
      Subtype: "Type1",
      Encoding: "WinAnsiEncoding"
    };
    return this.dictionary.end();
  }
  encode(text) {
    const encoded = this.font.encodeText(text);
    const glyphs = this.font.glyphsForString(`${text}`);
    const advances = this.font.advancesForGlyphs(glyphs);
    const positions = [];
    for (let i2 = 0; i2 < glyphs.length; i2++) {
      const glyph = glyphs[i2];
      positions.push({
        xAdvance: advances[i2],
        yAdvance: 0,
        xOffset: 0,
        yOffset: 0,
        advanceWidth: this.font.widthOfGlyph(glyph)
      });
    }
    return [encoded, positions];
  }
  encodeGlyphs(glyphs) {
    const res = [];
    for (let glyph of Array.from(glyphs)) {
      res.push(`00${glyph.id.toString(16)}`.slice(-2));
    }
    return res;
  }
  widthOfString(string, size) {
    const glyphs = this.font.glyphsForString(`${string}`);
    const advances = this.font.advancesForGlyphs(glyphs);
    let width = 0;
    for (let advance of Array.from(advances)) {
      width += advance;
    }
    const scale2 = size / 1e3;
    return width * scale2;
  }
  static isStandardFont(name) {
    return name in STANDARD_FONTS$1;
  }
};
const toHex$2 = function() {
  for (var _len = arguments.length, codePoints = new Array(_len), _key = 0; _key < _len; _key++) {
    codePoints[_key] = arguments[_key];
  }
  const codes2 = Array.from(codePoints).map((code) => `0000${code.toString(16)}`.slice(-4));
  return codes2.join("");
};
const createEmbeddedFont = (PDFFont2) => class EmbeddedFont extends PDFFont2 {
  constructor(document2, font, id) {
    super();
    this.document = document2;
    this.font = font;
    this.id = id;
    this.subset = this.font.createSubset();
    this.unicode = [[0]];
    this.widths = [this.font.getGlyph(0).advanceWidth];
    this.name = this.font.postscriptName;
    this.scale = 1e3 / this.font.unitsPerEm;
    this.ascender = this.font.ascent * this.scale;
    this.descender = this.font.descent * this.scale;
    this.xHeight = this.font.xHeight * this.scale;
    this.capHeight = this.font.capHeight * this.scale;
    this.lineGap = this.font.lineGap * this.scale;
    this.bbox = this.font.bbox;
    this.layoutCache = /* @__PURE__ */ Object.create(null);
  }
  layoutRun(text, features) {
    const run = this.font.layout(text, features, void 0, void 0, "ltr");
    for (let i2 = 0; i2 < run.positions.length; i2++) {
      const position = run.positions[i2];
      for (let key in position) {
        position[key] *= this.scale;
      }
      position.advanceWidth = run.glyphs[i2].advanceWidth * this.scale;
    }
    return run;
  }
  layoutCached(text) {
    let cached;
    if (cached = this.layoutCache[text]) {
      return cached;
    }
    const run = this.layoutRun(text);
    this.layoutCache[text] = run;
    return run;
  }
  layout(text, features, onlyWidth) {
    if (onlyWidth == null) {
      onlyWidth = false;
    }
    if (features) {
      return this.layoutRun(text, features);
    }
    const glyphs = onlyWidth ? null : [];
    const positions = onlyWidth ? null : [];
    let advanceWidth2 = 0;
    let last2 = 0;
    let index2 = 0;
    while (index2 <= text.length) {
      let needle;
      if (index2 === text.length && last2 < index2 || (needle = text.charAt(index2), [" ", "	"].includes(needle))) {
        const run = this.layoutCached(text.slice(last2, ++index2));
        if (!onlyWidth) {
          glyphs.push(...Array.from(run.glyphs || []));
          positions.push(...Array.from(run.positions || []));
        }
        advanceWidth2 += run.advanceWidth;
        last2 = index2;
      } else {
        index2++;
      }
    }
    return {
      glyphs,
      positions,
      advanceWidth: advanceWidth2
    };
  }
  encode(text, features) {
    const {
      glyphs,
      positions
    } = this.layout(text, features);
    const res = [];
    for (let i2 = 0; i2 < glyphs.length; i2++) {
      const glyph = glyphs[i2];
      const gid = this.subset.includeGlyph(glyph.id);
      res.push(`0000${gid.toString(16)}`.slice(-4));
      if (this.widths[gid] == null) {
        this.widths[gid] = glyph.advanceWidth * this.scale;
      }
      if (this.unicode[gid] == null) {
        this.unicode[gid] = glyph.codePoints;
      }
    }
    return [res, positions];
  }
  encodeGlyphs(glyphs) {
    const res = [];
    for (let i2 = 0; i2 < glyphs.length; i2++) {
      const glyph = glyphs[i2];
      const gid = this.subset.includeGlyph(glyph.id);
      res.push(`0000${gid.toString(16)}`.slice(-4));
      if (this.widths[gid] == null) {
        this.widths[gid] = glyph.advanceWidth * this.scale;
      }
      if (this.unicode[gid] == null) {
        this.unicode[gid] = glyph.codePoints;
      }
    }
    return res;
  }
  widthOfString(string, size, features) {
    const width = this.layout(string, features, true).advanceWidth;
    const scale2 = size / 1e3;
    return width * scale2;
  }
  embed() {
    const isCFF = this.subset.cff != null;
    const fontFile = this.document.ref();
    if (isCFF) {
      fontFile.data.Subtype = "CIDFontType0C";
    }
    fontFile.end(this.subset.encode());
    const familyClass = ((this.font["OS/2"] != null ? this.font["OS/2"].sFamilyClass : void 0) || 0) >> 8;
    let flags = 0;
    if (this.font.post.isFixedPitch) {
      flags |= 1 << 0;
    }
    if (1 <= familyClass && familyClass <= 7) {
      flags |= 1 << 1;
    }
    flags |= 1 << 2;
    if (familyClass === 10) {
      flags |= 1 << 3;
    }
    if (this.font.head.macStyle.italic) {
      flags |= 1 << 6;
    }
    const tag = [0, 1, 2, 3, 4, 5].map(() => String.fromCharCode(Math.random() * 26 + 65)).join("");
    const name = tag + "+" + this.font.postscriptName;
    const {
      bbox
    } = this.font;
    const descriptor = this.document.ref({
      Type: "FontDescriptor",
      FontName: name,
      Flags: flags,
      FontBBox: [bbox.minX * this.scale, bbox.minY * this.scale, bbox.maxX * this.scale, bbox.maxY * this.scale],
      ItalicAngle: this.font.italicAngle,
      Ascent: this.ascender,
      Descent: this.descender,
      CapHeight: (this.font.capHeight || this.font.ascent) * this.scale,
      XHeight: (this.font.xHeight || 0) * this.scale,
      StemV: 0
    });
    if (isCFF) {
      descriptor.data.FontFile3 = fontFile;
    } else {
      descriptor.data.FontFile2 = fontFile;
    }
    descriptor.end();
    const descendantFontData = {
      Type: "Font",
      Subtype: "CIDFontType0",
      BaseFont: name,
      CIDSystemInfo: {
        Registry: new String("Adobe"),
        Ordering: new String("Identity"),
        Supplement: 0
      },
      FontDescriptor: descriptor,
      W: [0, this.widths]
    };
    if (!isCFF) {
      descendantFontData.Subtype = "CIDFontType2";
      descendantFontData.CIDToGIDMap = "Identity";
    }
    const descendantFont = this.document.ref(descendantFontData);
    descendantFont.end();
    this.dictionary.data = {
      Type: "Font",
      Subtype: "Type0",
      BaseFont: name,
      Encoding: "Identity-H",
      DescendantFonts: [descendantFont],
      ToUnicode: this.toUnicodeCmap()
    };
    return this.dictionary.end();
  }
  // Maps the glyph ids encoded in the PDF back to unicode strings
  // Because of ligature substitutions and the like, there may be one or more
  // unicode characters represented by each glyph.
  toUnicodeCmap() {
    const cmap = this.document.ref();
    let entries = [];
    let unicodeMap = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange";
    for (let [index2, codePoints] of this.unicode.entries()) {
      const encoded = [];
      if (entries.length >= 100) {
        unicodeMap += "\n" + entries.length + " beginbfchar\n" + entries.join("\n") + "\nendbfchar";
        entries = [];
      }
      for (let value2 of codePoints) {
        if (value2 > 65535) {
          value2 -= 65536;
          encoded.push(toHex$2(value2 >>> 10 & 1023 | 55296));
          value2 = 56320 | value2 & 1023;
        }
        encoded.push(toHex$2(value2));
      }
      entries.push("<" + toHex$2(index2) + "><" + encoded.join(" ") + ">");
    }
    if (entries.length) {
      unicodeMap += "\n" + entries.length + " beginbfchar\n" + entries.join("\n") + "\nendbfchar\n";
    }
    unicodeMap += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
    cmap.end(unicodeMap);
    return cmap;
  }
};
class PDFFont {
  static open(document2, src2, family, id) {
    let font;
    if (typeof src2 === "string") {
      if (StandardFont$1.isStandardFont(src2)) {
        return new StandardFont$1(document2, src2, id);
      }
      {
        throw new Error(`Can't open ${src2} in browser build`);
      }
    } else if (src2 instanceof Uint8Array) {
      font = $d636bc798e7178db$export$185802fd694ee1f5(src2, family);
    } else if (src2 instanceof ArrayBuffer) {
      font = $d636bc798e7178db$export$185802fd694ee1f5(new Uint8Array(src2), family);
    } else if (typeof src2 === "object") {
      font = src2;
    }
    if (font == null) {
      throw new Error("Not a supported font format or standard PDF font.");
    }
    return new EmbeddedFont(document2, font, id);
  }
  encode() {
    throw new Error("Must be implemented by subclasses");
  }
  widthOfString() {
    throw new Error("Must be implemented by subclasses");
  }
  ref() {
    return this.dictionary != null ? this.dictionary : this.dictionary = this.document.ref();
  }
  finalize() {
    if (this.embedded || this.dictionary == null) {
      return;
    }
    this.embed();
    return this.embedded = true;
  }
  embed() {
    throw new Error("Must be implemented by subclasses");
  }
  lineHeight(size, includeGap) {
    if (includeGap == null) {
      includeGap = false;
    }
    const gap = includeGap ? this.lineGap : 0;
    return (this.ascender + gap - this.descender) / 1e3 * size;
  }
}
const StandardFont$1 = createStandardFont(PDFFont);
const EmbeddedFont = createEmbeddedFont(PDFFont);
var FontsMixin = {
  initFonts() {
    this._fontFamilies = {};
    this._fontCount = 0;
    this._fontSize = 12;
    this._font = null;
    this._registeredFonts = {};
    return this.font("Helvetica");
  },
  font(src2, family, size) {
    let cacheKey;
    let font;
    if (typeof family === "number") {
      size = family;
      family = null;
    }
    if (typeof src2 === "string" && this._registeredFonts[src2]) {
      cacheKey = src2;
      ({
        src: src2,
        family
      } = this._registeredFonts[src2]);
    } else {
      cacheKey = family || src2;
      if (typeof cacheKey !== "string") {
        cacheKey = null;
      }
    }
    if (size != null) {
      this.fontSize(size);
    }
    if (font = this._fontFamilies[cacheKey]) {
      this._font = font;
      return this;
    }
    const id = `F${++this._fontCount}`;
    this._font = PDFFont.open(this, src2, family, id);
    if (font = this._fontFamilies[this._font.name]) {
      this._font = font;
      return this;
    }
    if (cacheKey) {
      this._fontFamilies[cacheKey] = this._font;
    }
    if (this._font.name) {
      this._fontFamilies[this._font.name] = this._font;
    }
    return this;
  },
  fontSize(_fontSize) {
    this._fontSize = _fontSize;
    return this;
  },
  currentLineHeight(includeGap) {
    if (includeGap == null) {
      includeGap = false;
    }
    return this._font.lineHeight(this._fontSize, includeGap);
  },
  registerFont(name, src2, family) {
    this._registeredFonts[name] = {
      src: src2,
      family
    };
    return this;
  }
};
function PDFNumber(n3) {
  return Math.fround(n3);
}
const SOFT_HYPHEN$1 = "";
const HYPHEN$1 = "-";
class LineWrapper extends EventEmitter {
  constructor(document2, options) {
    super();
    this.document = document2;
    this.horizontalScaling = options.horizontalScaling || 100;
    this.indent = (options.indent || 0) * this.horizontalScaling / 100;
    this.characterSpacing = (options.characterSpacing || 0) * this.horizontalScaling / 100;
    this.wordSpacing = (options.wordSpacing === 0) * this.horizontalScaling / 100;
    this.columns = options.columns || 1;
    this.columnGap = (options.columnGap != null ? options.columnGap : 18) * this.horizontalScaling / 100;
    this.lineWidth = (options.width * this.horizontalScaling / 100 - this.columnGap * (this.columns - 1)) / this.columns;
    this.spaceLeft = this.lineWidth;
    this.startX = this.document.x;
    this.startY = this.document.y;
    this.column = 1;
    this.ellipsis = options.ellipsis;
    this.continuedX = 0;
    this.features = options.features;
    if (options.height != null) {
      this.height = options.height;
      this.maxY = PDFNumber(this.startY + options.height);
    } else {
      this.maxY = PDFNumber(this.document.page.maxY());
    }
    this.on("firstLine", (options2) => {
      const indent = this.continuedX || this.indent;
      this.document.x += indent;
      this.lineWidth -= indent;
      if (options2.indentAllLines) {
        return;
      }
      return this.once("line", () => {
        this.document.x -= indent;
        this.lineWidth += indent;
        if (options2.continued && !this.continuedX) {
          this.continuedX = this.indent;
        }
        if (!options2.continued) {
          return this.continuedX = 0;
        }
      });
    });
    this.on("lastLine", (options2) => {
      const {
        align
      } = options2;
      if (align === "justify") {
        options2.align = "left";
      }
      this.lastLine = true;
      return this.once("line", () => {
        this.document.y += options2.paragraphGap || 0;
        options2.align = align;
        return this.lastLine = false;
      });
    });
  }
  wordWidth(word) {
    return this.document.widthOfString(word, this) + this.characterSpacing + this.wordSpacing;
  }
  canFit(word, w) {
    if (word[word.length - 1] != SOFT_HYPHEN$1) {
      return w <= this.spaceLeft;
    }
    return w + this.wordWidth(HYPHEN$1) <= this.spaceLeft;
  }
  eachWord(text, fn) {
    let bk;
    const breaker = new $557adaaeb0c7885f$exports(text);
    let last2 = null;
    const wordWidths = /* @__PURE__ */ Object.create(null);
    while (bk = breaker.nextBreak()) {
      var shouldContinue;
      let word = text.slice((last2 != null ? last2.position : void 0) || 0, bk.position);
      let w = wordWidths[word] != null ? wordWidths[word] : wordWidths[word] = this.wordWidth(word);
      if (w > this.lineWidth + this.continuedX) {
        let lbk = last2;
        const fbk = {};
        while (word.length) {
          var l2, mightGrow;
          if (w > this.spaceLeft) {
            l2 = Math.ceil(this.spaceLeft / (w / word.length));
            w = this.wordWidth(word.slice(0, l2));
            mightGrow = w <= this.spaceLeft && l2 < word.length;
          } else {
            l2 = word.length;
          }
          let mustShrink = w > this.spaceLeft && l2 > 0;
          while (mustShrink || mightGrow) {
            if (mustShrink) {
              w = this.wordWidth(word.slice(0, --l2));
              mustShrink = w > this.spaceLeft && l2 > 0;
            } else {
              w = this.wordWidth(word.slice(0, ++l2));
              mustShrink = w > this.spaceLeft && l2 > 0;
              mightGrow = w <= this.spaceLeft && l2 < word.length;
            }
          }
          if (l2 === 0 && this.spaceLeft === this.lineWidth) {
            l2 = 1;
          }
          fbk.required = bk.required || l2 < word.length;
          shouldContinue = fn(word.slice(0, l2), w, fbk, lbk);
          lbk = {
            required: false
          };
          word = word.slice(l2);
          w = this.wordWidth(word);
          if (shouldContinue === false) {
            break;
          }
        }
      } else {
        shouldContinue = fn(word, w, bk, last2);
      }
      if (shouldContinue === false) {
        break;
      }
      last2 = bk;
    }
  }
  wrap(text, options) {
    this.horizontalScaling = options.horizontalScaling || 100;
    if (options.indent != null) {
      this.indent = options.indent * this.horizontalScaling / 100;
    }
    if (options.characterSpacing != null) {
      this.characterSpacing = options.characterSpacing * this.horizontalScaling / 100;
    }
    if (options.wordSpacing != null) {
      this.wordSpacing = options.wordSpacing * this.horizontalScaling / 100;
    }
    if (options.ellipsis != null) {
      this.ellipsis = options.ellipsis;
    }
    const nextY = this.document.y + this.document.currentLineHeight(true);
    if (this.document.y > this.maxY || nextY > this.maxY) {
      this.nextSection();
    }
    let buffer = "";
    let textWidth = 0;
    let wc = 0;
    let lc = 0;
    let {
      y: y2
    } = this.document;
    const emitLine = () => {
      options.textWidth = textWidth + this.wordSpacing * (wc - 1);
      options.wordCount = wc;
      options.lineWidth = this.lineWidth;
      ({
        y: y2
      } = this.document);
      this.emit("line", buffer, options, this);
      return lc++;
    };
    this.emit("sectionStart", options, this);
    this.eachWord(text, (word, w, bk, last2) => {
      if (last2 == null || last2.required) {
        this.emit("firstLine", options, this);
        this.spaceLeft = this.lineWidth;
      }
      if (this.canFit(word, w)) {
        buffer += word;
        textWidth += w;
        wc++;
      }
      if (bk.required || !this.canFit(word, w)) {
        const lh = this.document.currentLineHeight(true);
        if (this.height != null && this.ellipsis && PDFNumber(this.document.y + lh * 2) > this.maxY && this.column >= this.columns) {
          if (this.ellipsis === true) {
            this.ellipsis = "";
          }
          buffer = buffer.replace(/\s+$/, "");
          textWidth = this.wordWidth(buffer + this.ellipsis);
          while (buffer && textWidth > this.lineWidth) {
            buffer = buffer.slice(0, -1).replace(/\s+$/, "");
            textWidth = this.wordWidth(buffer + this.ellipsis);
          }
          if (textWidth <= this.lineWidth) {
            buffer = buffer + this.ellipsis;
          }
          textWidth = this.wordWidth(buffer);
        }
        if (bk.required) {
          if (w > this.spaceLeft) {
            emitLine();
            buffer = word;
            textWidth = w;
            wc = 1;
          }
          this.emit("lastLine", options, this);
        }
        if (buffer[buffer.length - 1] == SOFT_HYPHEN$1) {
          buffer = buffer.slice(0, -1) + HYPHEN$1;
          this.spaceLeft -= this.wordWidth(HYPHEN$1);
        }
        emitLine();
        if (PDFNumber(this.document.y + lh) > this.maxY) {
          const shouldContinue = this.nextSection();
          if (!shouldContinue) {
            wc = 0;
            buffer = "";
            return false;
          }
        }
        if (bk.required) {
          this.spaceLeft = this.lineWidth;
          buffer = "";
          textWidth = 0;
          return wc = 0;
        } else {
          this.spaceLeft = this.lineWidth - w;
          buffer = word;
          textWidth = w;
          return wc = 1;
        }
      } else {
        return this.spaceLeft -= w;
      }
    });
    if (wc > 0) {
      this.emit("lastLine", options, this);
      emitLine();
    }
    this.emit("sectionEnd", options, this);
    if (options.continued === true) {
      if (lc > 1) {
        this.continuedX = 0;
      }
      this.continuedX += options.textWidth || 0;
      return this.document.y = y2;
    } else {
      return this.document.x = this.startX;
    }
  }
  nextSection(options) {
    this.emit("sectionEnd", options, this);
    if (++this.column > this.columns) {
      if (this.height != null) {
        return false;
      }
      this.document.continueOnNewPage();
      this.column = 1;
      this.startY = this.document.page.margins.top;
      this.maxY = this.document.page.maxY();
      this.document.x = this.startX;
      if (this.document._fillColor) {
        this.document.fillColor(...this.document._fillColor);
      }
      this.emit("pageBreak", options, this);
    } else {
      this.document.x += this.lineWidth + this.columnGap;
      this.document.y = this.startY;
      this.emit("columnBreak", options, this);
    }
    this.emit("sectionStart", options, this);
    return true;
  }
}
const {
  number: number$3
} = PDFObject;
var TextMixin = {
  initText() {
    this._line = this._line.bind(this);
    this.x = 0;
    this.y = 0;
    return this._lineGap = 0;
  },
  lineGap(_lineGap) {
    this._lineGap = _lineGap;
    return this;
  },
  moveDown(lines) {
    if (lines == null) {
      lines = 1;
    }
    this.y += this.currentLineHeight(true) * lines + this._lineGap;
    return this;
  },
  moveUp(lines) {
    if (lines == null) {
      lines = 1;
    }
    this.y -= this.currentLineHeight(true) * lines + this._lineGap;
    return this;
  },
  _text(text, x, y2, options, lineCallback) {
    options = this._initOptions(x, y2, options);
    text = text == null ? "" : `${text}`;
    if (options.wordSpacing) {
      text = text.replace(/\s{2,}/g, " ");
    }
    const addStructure = () => {
      if (options.structParent) {
        options.structParent.add(this.struct(options.structType || "P", [this.markStructureContent(options.structType || "P")]));
      }
    };
    if (options.rotation !== 0) {
      this.save();
      this.rotate(-options.rotation, {
        origin: [this.x, this.y]
      });
    }
    if (options.width) {
      let wrapper = this._wrapper;
      if (!wrapper) {
        wrapper = new LineWrapper(this, options);
        wrapper.on("line", lineCallback);
        wrapper.on("firstLine", addStructure);
      }
      this._wrapper = options.continued ? wrapper : null;
      this._textOptions = options.continued ? options : null;
      wrapper.wrap(text, options);
    } else {
      for (let line2 of text.split("\n")) {
        addStructure();
        lineCallback(line2, options);
      }
    }
    if (options.rotation !== 0) this.restore();
    return this;
  },
  text(text, x, y2, options) {
    return this._text(text, x, y2, options, this._line);
  },
  widthOfString(string, options) {
    if (options === void 0) {
      options = {};
    }
    const horizontalScaling = options.horizontalScaling || 100;
    return (this._font.widthOfString(string, this._fontSize, options.features) + (options.characterSpacing || 0) * (string.length - 1)) * horizontalScaling / 100;
  },
  /**
   * Compute the bounding box of a string
   * based on what will actually be rendered by `doc.text()`
   *
   * @param string - The string
   * @param x - X position of text (defaults to this.x)
   * @param y - Y position of text (defaults to this.y)
   * @param options - Any text options (The same you would apply to `doc.text()`)
   * @returns {{x: number, y: number, width: number, height: number}}
   */
  boundsOfString(string, x, y2, options) {
  },
  heightOfString(text, options) {
    const {
      x,
      y: y2
    } = this;
    options = this._initOptions(options);
    options.height = Infinity;
    const lineGap2 = options.lineGap || this._lineGap || 0;
    this._text(text, this.x, this.y, options, () => {
      return this.y += this.currentLineHeight(true) + lineGap2;
    });
    const height2 = this.y - y2;
    this.x = x;
    this.y = y2;
    return height2;
  },
  list(list, x, y2, options, wrapper) {
    options = this._initOptions(x, y2, options);
    const listType = options.listType || "bullet";
    const unit2 = Math.round(this._font.ascender / 1e3 * this._fontSize);
    const midLine = unit2 / 2;
    const r2 = options.bulletRadius || unit2 / 3;
    const indent = options.textIndent || (listType === "bullet" ? r2 * 5 : unit2 * 2);
    const itemIndent = options.bulletIndent || (listType === "bullet" ? r2 * 8 : unit2 * 2);
    let level = 1;
    const items = [];
    const levels = [];
    const numbers = [];
    var flatten2 = function(list2) {
      let n3 = 1;
      for (let i2 = 0; i2 < list2.length; i2++) {
        const item = list2[i2];
        if (Array.isArray(item)) {
          level++;
          flatten2(item);
          level--;
        } else {
          items.push(item);
          levels.push(level);
          if (listType !== "bullet") {
            numbers.push(n3++);
          }
        }
      }
    };
    flatten2(list);
    const label = function(n3) {
      switch (listType) {
        case "numbered":
          return `${n3}.`;
        case "lettered":
          var letter = String.fromCharCode((n3 - 1) % 26 + 65);
          var times = Math.floor((n3 - 1) / 26 + 1);
          var text = Array(times + 1).join(letter);
          return `${text}.`;
      }
    };
    const drawListItem = function(listItem, i2) {
      wrapper = new LineWrapper(this, options);
      wrapper.on("line", this._line);
      level = 1;
      wrapper.once("firstLine", () => {
        let item, itemType, labelType, bodyType;
        if (options.structParent) {
          if (options.structTypes) {
            [itemType, labelType, bodyType] = options.structTypes;
          } else {
            [itemType, labelType, bodyType] = ["LI", "Lbl", "LBody"];
          }
        }
        if (itemType) {
          item = this.struct(itemType);
          options.structParent.add(item);
        } else if (options.structParent) {
          item = options.structParent;
        }
        let l2;
        if ((l2 = levels[i2++]) !== level) {
          const diff = itemIndent * (l2 - level);
          this.x += diff;
          wrapper.lineWidth -= diff;
          level = l2;
        }
        if (item && (labelType || bodyType)) {
          item.add(this.struct(labelType || bodyType, [this.markStructureContent(labelType || bodyType)]));
        }
        switch (listType) {
          case "bullet":
            this.circle(this.x - indent + r2, this.y + midLine, r2);
            this.fill();
            break;
          case "numbered":
          case "lettered":
            var text = label(numbers[i2 - 1]);
            this._fragment(text, this.x - indent, this.y, options);
            break;
        }
        if (item && labelType && bodyType) {
          item.add(this.struct(bodyType, [this.markStructureContent(bodyType)]));
        }
        if (item && item !== options.structParent) {
          item.end();
        }
      });
      wrapper.on("sectionStart", () => {
        const pos = indent + itemIndent * (level - 1);
        this.x += pos;
        return wrapper.lineWidth -= pos;
      });
      wrapper.on("sectionEnd", () => {
        const pos = indent + itemIndent * (level - 1);
        this.x -= pos;
        return wrapper.lineWidth += pos;
      });
      wrapper.wrap(listItem, options);
    };
    for (let i2 = 0; i2 < items.length; i2++) {
      drawListItem.call(this, items[i2], i2);
    }
    return this;
  },
  _initOptions(x, y2, options) {
    var _options$rotation;
    if (x === void 0) {
      x = {};
    }
    if (options === void 0) {
      options = {};
    }
    if (typeof x === "object") {
      options = x;
      x = null;
    }
    const result = Object.assign({}, options);
    if (this._textOptions) {
      for (let key in this._textOptions) {
        const val = this._textOptions[key];
        if (key !== "continued") {
          if (result[key] === void 0) {
            result[key] = val;
          }
        }
      }
    }
    if (x != null) {
      this.x = x;
    }
    if (y2 != null) {
      this.y = y2;
    }
    if (result.lineBreak !== false) {
      if (result.width == null) {
        result.width = this.page.width - this.x - this.page.margins.right;
      }
      result.width = Math.max(result.width, 0);
    }
    if (!result.columns) {
      result.columns = 0;
    }
    if (result.columnGap == null) {
      result.columnGap = 18;
    }
    result.rotation = Number((_options$rotation = options.rotation) !== null && _options$rotation !== void 0 ? _options$rotation : 0) % 360;
    if (result.rotation < 0) result.rotation += 360;
    return result;
  },
  _line(text, options, wrapper) {
    if (options === void 0) {
      options = {};
    }
    this._fragment(text, this.x, this.y, options);
    const lineGap2 = options.lineGap || this._lineGap || 0;
    if (!wrapper) {
      return this.x += this.widthOfString(text, options);
    } else {
      return this.y += this.currentLineHeight(true) + lineGap2;
    }
  },
  _fragment(text, x, y2, options) {
    let dy, encoded, i2, positions, textWidth, words;
    text = `${text}`.replace(/\n/g, "");
    if (text.length === 0) {
      return;
    }
    const align = options.align || "left";
    let wordSpacing = options.wordSpacing || 0;
    const characterSpacing = options.characterSpacing || 0;
    const horizontalScaling = options.horizontalScaling || 100;
    if (options.width) {
      switch (align) {
        case "right":
          textWidth = this.widthOfString(text.replace(/\s+$/, ""), options);
          x += options.lineWidth - textWidth;
          break;
        case "center":
          x += options.lineWidth / 2 - options.textWidth / 2;
          break;
        case "justify":
          words = text.trim().split(/\s+/);
          textWidth = this.widthOfString(text.replace(/\s+/g, ""), options);
          var spaceWidth = this.widthOfString(" ") + characterSpacing;
          wordSpacing = Math.max(0, (options.lineWidth - textWidth) / Math.max(1, words.length - 1) - spaceWidth);
          break;
      }
    }
    if (typeof options.baseline === "number") {
      dy = -options.baseline;
    } else {
      switch (options.baseline) {
        case "svg-middle":
          dy = 0.5 * this._font.xHeight;
          break;
        case "middle":
        case "svg-central":
          dy = 0.5 * (this._font.descender + this._font.ascender);
          break;
        case "bottom":
        case "ideographic":
          dy = this._font.descender;
          break;
        case "alphabetic":
          dy = 0;
          break;
        case "mathematical":
          dy = 0.5 * this._font.ascender;
          break;
        case "hanging":
          dy = 0.8 * this._font.ascender;
          break;
        case "top":
          dy = this._font.ascender;
          break;
        default:
          dy = this._font.ascender;
      }
      dy = dy / 1e3 * this._fontSize;
    }
    const renderedWidth = options.textWidth + wordSpacing * (options.wordCount - 1) + characterSpacing * (text.length - 1);
    if (options.link != null) {
      this.link(x, y2, renderedWidth, this.currentLineHeight(), options.link);
    }
    if (options.goTo != null) {
      this.goTo(x, y2, renderedWidth, this.currentLineHeight(), options.goTo);
    }
    if (options.destination != null) {
      this.addNamedDestination(options.destination, "XYZ", x, y2, null);
    }
    if (options.underline) {
      this.save();
      if (!options.stroke) {
        this.strokeColor(...this._fillColor || []);
      }
      const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);
      this.lineWidth(lineWidth);
      let lineY = y2 + this.currentLineHeight() - lineWidth;
      this.moveTo(x, lineY);
      this.lineTo(x + renderedWidth, lineY);
      this.stroke();
      this.restore();
    }
    if (options.strike) {
      this.save();
      if (!options.stroke) {
        this.strokeColor(...this._fillColor || []);
      }
      const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);
      this.lineWidth(lineWidth);
      let lineY = y2 + this.currentLineHeight() / 2;
      this.moveTo(x, lineY);
      this.lineTo(x + renderedWidth, lineY);
      this.stroke();
      this.restore();
    }
    this.save();
    if (options.oblique) {
      let skew;
      if (typeof options.oblique === "number") {
        skew = -Math.tan(options.oblique * Math.PI / 180);
      } else {
        skew = -0.25;
      }
      this.transform(1, 0, 0, 1, x, y2);
      this.transform(1, 0, skew, 1, -skew * dy, 0);
      this.transform(1, 0, 0, 1, -x, -y2);
    }
    this.transform(1, 0, 0, -1, 0, this.page.height);
    y2 = this.page.height - y2 - dy;
    if (this.page.fonts[this._font.id] == null) {
      this.page.fonts[this._font.id] = this._font.ref();
    }
    this.addContent("BT");
    this.addContent(`1 0 0 1 ${number$3(x)} ${number$3(y2)} Tm`);
    this.addContent(`/${this._font.id} ${number$3(this._fontSize)} Tf`);
    const mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;
    if (mode) {
      this.addContent(`${mode} Tr`);
    }
    if (characterSpacing) {
      this.addContent(`${number$3(characterSpacing)} Tc`);
    }
    if (horizontalScaling !== 100) {
      this.addContent(`${horizontalScaling} Tz`);
    }
    if (wordSpacing) {
      words = text.trim().split(/\s+/);
      wordSpacing += this.widthOfString(" ") + characterSpacing;
      wordSpacing *= 1e3 / this._fontSize;
      encoded = [];
      positions = [];
      for (let word of words) {
        const [encodedWord, positionsWord] = this._font.encode(word, options.features);
        encoded = encoded.concat(encodedWord);
        positions = positions.concat(positionsWord);
        const space = {};
        const object = positions[positions.length - 1];
        for (let key in object) {
          const val = object[key];
          space[key] = val;
        }
        space.xAdvance += wordSpacing;
        positions[positions.length - 1] = space;
      }
    } else {
      [encoded, positions] = this._font.encode(text, options.features);
    }
    const scale2 = this._fontSize / 1e3;
    const commands = [];
    let last2 = 0;
    let hadOffset = false;
    const addSegment = (cur) => {
      if (last2 < cur) {
        const hex = encoded.slice(last2, cur).join("");
        const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;
        commands.push(`<${hex}> ${number$3(-advance)}`);
      }
      return last2 = cur;
    };
    const flush = (i3) => {
      addSegment(i3);
      if (commands.length > 0) {
        this.addContent(`[${commands.join(" ")}] TJ`);
        return commands.length = 0;
      }
    };
    for (i2 = 0; i2 < positions.length; i2++) {
      const pos = positions[i2];
      if (pos.xOffset || pos.yOffset) {
        flush(i2);
        this.addContent(`1 0 0 1 ${number$3(x + pos.xOffset * scale2)} ${number$3(y2 + pos.yOffset * scale2)} Tm`);
        flush(i2 + 1);
        hadOffset = true;
      } else {
        if (hadOffset) {
          this.addContent(`1 0 0 1 ${number$3(x)} ${number$3(y2)} Tm`);
          hadOffset = false;
        }
        if (pos.xAdvance - pos.advanceWidth !== 0) {
          addSegment(i2 + 1);
        }
      }
      x += pos.xAdvance * scale2;
    }
    flush(i2);
    this.addContent("ET");
    return this.restore();
  }
};
const COLOR_SPACE_MAP = {
  1: "DeviceGray",
  3: "DeviceRGB",
  4: "DeviceCMYK"
};
let JPEG$1 = class JPEG {
  constructor(data2, label) {
    this.data = data2;
    this.label = label;
    this.orientation = 1;
    if (this.data.readUInt16BE(0) !== 65496) {
      throw "SOI not found in JPEG";
    }
    const markers = _JPEG.decode(this.data);
    for (let i2 = 0; i2 < markers.length; i2 += 1) {
      const marker = markers[i2];
      if (marker.name === "EXIF" && marker.entries.orientation) {
        this.orientation = marker.entries.orientation;
      }
      if (marker.name === "SOF") {
        this.bits || (this.bits = marker.precision);
        this.width || (this.width = marker.width);
        this.height || (this.height = marker.height);
        this.colorSpace || (this.colorSpace = COLOR_SPACE_MAP[marker.numberOfComponents]);
      }
    }
    this.obj = null;
  }
  embed(document2) {
    if (this.obj) {
      return;
    }
    this.obj = document2.ref({
      Type: "XObject",
      Subtype: "Image",
      BitsPerComponent: this.bits,
      Width: this.width,
      Height: this.height,
      ColorSpace: this.colorSpace,
      Filter: "DCTDecode"
    });
    if (this.colorSpace === "DeviceCMYK") {
      this.obj.data["Decode"] = [1, 0, 1, 0, 1, 0, 1, 0];
    }
    this.obj.end(this.data);
    return this.data = null;
  }
};
class PNGImage {
  constructor(data2, label) {
    this.label = label;
    this.image = new PNG$1(data2);
    this.width = this.image.width;
    this.height = this.image.height;
    this.imgData = this.image.imgData;
    this.obj = null;
  }
  embed(document2) {
    let dataDecoded = false;
    this.document = document2;
    if (this.obj) {
      return;
    }
    const hasAlphaChannel = this.image.hasAlphaChannel;
    const isInterlaced = this.image.interlaceMethod === 1;
    this.obj = this.document.ref({
      Type: "XObject",
      Subtype: "Image",
      BitsPerComponent: hasAlphaChannel ? 8 : this.image.bits,
      Width: this.width,
      Height: this.height,
      Filter: "FlateDecode"
    });
    if (!hasAlphaChannel) {
      const params = this.document.ref({
        Predictor: isInterlaced ? 1 : 15,
        Colors: this.image.colors,
        BitsPerComponent: this.image.bits,
        Columns: this.width
      });
      this.obj.data.DecodeParms = params;
      params.end();
    }
    if (this.image.palette.length === 0) {
      this.obj.data.ColorSpace = this.image.colorSpace;
    } else {
      const palette = this.document.ref();
      palette.end(Buffer$2.from(this.image.palette));
      this.obj.data.ColorSpace = ["Indexed", "DeviceRGB", this.image.palette.length / 3 - 1, palette];
    }
    if (this.image.transparency.grayscale != null) {
      const val = this.image.transparency.grayscale;
      this.obj.data.Mask = [val, val];
    } else if (this.image.transparency.rgb) {
      const {
        rgb
      } = this.image.transparency;
      const mask = [];
      for (let x of rgb) {
        mask.push(x, x);
      }
      this.obj.data.Mask = mask;
    } else if (this.image.transparency.indexed) {
      dataDecoded = true;
      return this.loadIndexedAlphaChannel();
    } else if (hasAlphaChannel) {
      dataDecoded = true;
      return this.splitAlphaChannel();
    }
    if (isInterlaced && !dataDecoded) {
      return this.decodeData();
    }
    this.finalize();
  }
  finalize() {
    if (this.alphaChannel) {
      const sMask = this.document.ref({
        Type: "XObject",
        Subtype: "Image",
        Height: this.height,
        Width: this.width,
        BitsPerComponent: 8,
        Filter: "FlateDecode",
        ColorSpace: "DeviceGray",
        Decode: [0, 1]
      });
      sMask.end(this.alphaChannel);
      this.obj.data.SMask = sMask;
    }
    this.obj.end(this.imgData);
    this.image = null;
    return this.imgData = null;
  }
  splitAlphaChannel() {
    return this.image.decodePixels((pixels) => {
      let a2;
      let p2;
      const colorCount = this.image.colors;
      const pixelCount = this.width * this.height;
      const imgData = Buffer$2.alloc(pixelCount * colorCount);
      const alphaChannel = Buffer$2.alloc(pixelCount);
      let i2 = p2 = a2 = 0;
      const len = pixels.length;
      const skipByteCount = this.image.bits === 16 ? 1 : 0;
      while (i2 < len) {
        for (let colorIndex = 0; colorIndex < colorCount; colorIndex++) {
          imgData[p2++] = pixels[i2++];
          i2 += skipByteCount;
        }
        alphaChannel[a2++] = pixels[i2++];
        i2 += skipByteCount;
      }
      this.imgData = zlib.deflateSync(imgData);
      this.alphaChannel = zlib.deflateSync(alphaChannel);
      return this.finalize();
    });
  }
  loadIndexedAlphaChannel() {
    const transparency = this.image.transparency.indexed;
    return this.image.decodePixels((pixels) => {
      const alphaChannel = Buffer$2.alloc(this.width * this.height);
      let i2 = 0;
      for (let j = 0, end2 = pixels.length; j < end2; j++) {
        alphaChannel[i2++] = transparency[pixels[j]];
      }
      this.alphaChannel = zlib.deflateSync(alphaChannel);
      return this.finalize();
    });
  }
  decodeData() {
    this.image.decodePixels((pixels) => {
      this.imgData = zlib.deflateSync(pixels);
      this.finalize();
    });
  }
}
class PDFImage {
  static open(src2, label) {
    let data2;
    if (Buffer$2.isBuffer(src2)) {
      data2 = src2;
    } else if (src2 instanceof ArrayBuffer) {
      data2 = Buffer$2.from(new Uint8Array(src2));
    } else {
      let match;
      if (match = /^data:.+?;base64,(.*)$/.exec(src2)) {
        data2 = Buffer$2.from(match[1], "base64");
      } else {
        data2 = fs.readFileSync(src2);
        if (!data2) {
          return;
        }
      }
    }
    if (data2[0] === 255 && data2[1] === 216) {
      return new JPEG$1(data2, label);
    } else if (data2[0] === 137 && data2.toString("ascii", 1, 4) === "PNG") {
      return new PNGImage(data2, label);
    } else {
      throw new Error("Unknown image format.");
    }
  }
}
var ImagesMixin = {
  initImages() {
    this._imageRegistry = {};
    return this._imageCount = 0;
  },
  image(src2, x, y2, options) {
    if (options === void 0) {
      options = {};
    }
    let bh, bp, bw, image, ip, left, left1, rotateAngle, originX, originY;
    if (typeof x === "object") {
      options = x;
      x = null;
    }
    const ignoreOrientation = options.ignoreOrientation || options.ignoreOrientation !== false && this.options.ignoreOrientation;
    x = (left = x != null ? x : options.x) != null ? left : this.x;
    y2 = (left1 = y2 != null ? y2 : options.y) != null ? left1 : this.y;
    if (typeof src2 === "string") {
      image = this._imageRegistry[src2];
    }
    if (!image) {
      if (src2.width && src2.height) {
        image = src2;
      } else {
        image = this.openImage(src2);
      }
    }
    if (!image.obj) {
      image.embed(this);
    }
    if (this.page.xobjects[image.label] == null) {
      this.page.xobjects[image.label] = image.obj;
    }
    let {
      width,
      height: height2
    } = image;
    if (!ignoreOrientation && image.orientation > 4) {
      [width, height2] = [height2, width];
    }
    let w = options.width || width;
    let h = options.height || height2;
    if (options.width && !options.height) {
      const wp = w / width;
      w = width * wp;
      h = height2 * wp;
    } else if (options.height && !options.width) {
      const hp = h / height2;
      w = width * hp;
      h = height2 * hp;
    } else if (options.scale) {
      w = width * options.scale;
      h = height2 * options.scale;
    } else if (options.fit) {
      [bw, bh] = options.fit;
      bp = bw / bh;
      ip = width / height2;
      if (ip > bp) {
        w = bw;
        h = bw / ip;
      } else {
        h = bh;
        w = bh * ip;
      }
    } else if (options.cover) {
      [bw, bh] = options.cover;
      bp = bw / bh;
      ip = width / height2;
      if (ip > bp) {
        h = bh;
        w = bh * ip;
      } else {
        w = bw;
        h = bw / ip;
      }
    }
    if (options.fit || options.cover) {
      if (options.align === "center") {
        x = x + bw / 2 - w / 2;
      } else if (options.align === "right") {
        x = x + bw - w;
      }
      if (options.valign === "center") {
        y2 = y2 + bh / 2 - h / 2;
      } else if (options.valign === "bottom") {
        y2 = y2 + bh - h;
      }
    }
    if (!ignoreOrientation) {
      switch (image.orientation) {
        // No orientation (need to flip image, though, because of the default transform matrix on the document)
        default:
        case 1:
          h = -h;
          y2 -= h;
          rotateAngle = 0;
          break;
        // Flip Horizontal
        case 2:
          w = -w;
          h = -h;
          x -= w;
          y2 -= h;
          rotateAngle = 0;
          break;
        // Rotate 180 degrees
        case 3:
          originX = x;
          originY = y2;
          h = -h;
          x -= w;
          rotateAngle = 180;
          break;
        // Flip vertical
        case 4:
          break;
        // Flip horizontally and rotate 270 degrees CW
        case 5:
          originX = x;
          originY = y2;
          [w, h] = [h, w];
          y2 -= h;
          rotateAngle = 90;
          break;
        // Rotate 90 degrees CW
        case 6:
          originX = x;
          originY = y2;
          [w, h] = [h, w];
          h = -h;
          rotateAngle = 90;
          break;
        // Flip horizontally and rotate 90 degrees CW
        case 7:
          originX = x;
          originY = y2;
          [w, h] = [h, w];
          h = -h;
          w = -w;
          x -= w;
          rotateAngle = 90;
          break;
        // Rotate 270 degrees CW
        case 8:
          originX = x;
          originY = y2;
          [w, h] = [h, w];
          h = -h;
          x -= w;
          y2 -= h;
          rotateAngle = -90;
          break;
      }
    } else {
      h = -h;
      y2 -= h;
      rotateAngle = 0;
    }
    if (options.link != null) {
      this.link(x, y2, w, h, options.link);
    }
    if (options.goTo != null) {
      this.goTo(x, y2, w, h, options.goTo);
    }
    if (options.destination != null) {
      this.addNamedDestination(options.destination, "XYZ", x, y2, null);
    }
    if (this.y === y2) {
      this.y += h;
    }
    this.save();
    if (rotateAngle) {
      this.rotate(rotateAngle, {
        origin: [originX, originY]
      });
    }
    this.transform(w, 0, 0, h, x, y2);
    this.addContent(`/${image.label} Do`);
    this.restore();
    return this;
  },
  openImage(src2) {
    let image;
    if (typeof src2 === "string") {
      image = this._imageRegistry[src2];
    }
    if (!image) {
      image = PDFImage.open(src2, `I${++this._imageCount}`);
      if (typeof src2 === "string") {
        this._imageRegistry[src2] = image;
      }
    }
    return image;
  }
};
var AnnotationsMixin = {
  annotate(x, y2, w, h, options) {
    options.Type = "Annot";
    options.Rect = this._convertRect(x, y2, w, h);
    options.Border = [0, 0, 0];
    if (options.Subtype === "Link" && typeof options.F === "undefined") {
      options.F = 1 << 2;
    }
    if (options.Subtype !== "Link") {
      if (options.C == null) {
        options.C = this._normalizeColor(options.color || [0, 0, 0]);
      }
    }
    delete options.color;
    if (typeof options.Dest === "string") {
      options.Dest = new String(options.Dest);
    }
    for (let key in options) {
      const val = options[key];
      options[key[0].toUpperCase() + key.slice(1)] = val;
    }
    const ref = this.ref(options);
    this.page.annotations.push(ref);
    ref.end();
    return this;
  },
  note(x, y2, w, h, contents, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Text";
    options.Contents = new String(contents);
    if (options.Name == null) {
      options.Name = "Comment";
    }
    if (options.color == null) {
      options.color = [243, 223, 92];
    }
    return this.annotate(x, y2, w, h, options);
  },
  goTo(x, y2, w, h, name, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Link";
    options.A = this.ref({
      S: "GoTo",
      D: new String(name)
    });
    options.A.end();
    return this.annotate(x, y2, w, h, options);
  },
  link(x, y2, w, h, url, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Link";
    if (typeof url === "number") {
      const pages = this._root.data.Pages.data;
      if (url >= 0 && url < pages.Kids.length) {
        options.A = this.ref({
          S: "GoTo",
          D: [pages.Kids[url], "XYZ", null, null, null]
        });
        options.A.end();
      } else {
        throw new Error(`The document has no page ${url}`);
      }
    } else {
      options.A = this.ref({
        S: "URI",
        URI: new String(url)
      });
      options.A.end();
    }
    return this.annotate(x, y2, w, h, options);
  },
  _markup(x, y2, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    const [x1, y1, x2, y22] = this._convertRect(x, y2, w, h);
    options.QuadPoints = [x1, y22, x2, y22, x1, y1, x2, y1];
    options.Contents = new String();
    return this.annotate(x, y2, w, h, options);
  },
  highlight(x, y2, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Highlight";
    if (options.color == null) {
      options.color = [241, 238, 148];
    }
    return this._markup(x, y2, w, h, options);
  },
  underline(x, y2, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Underline";
    return this._markup(x, y2, w, h, options);
  },
  strike(x, y2, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "StrikeOut";
    return this._markup(x, y2, w, h, options);
  },
  lineAnnotation(x1, y1, x2, y2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Line";
    options.Contents = new String();
    options.L = [x1, this.page.height - y1, x2, this.page.height - y2];
    return this.annotate(x1, y1, x2, y2, options);
  },
  rectAnnotation(x, y2, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Square";
    options.Contents = new String();
    return this.annotate(x, y2, w, h, options);
  },
  ellipseAnnotation(x, y2, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Circle";
    options.Contents = new String();
    return this.annotate(x, y2, w, h, options);
  },
  textAnnotation(x, y2, w, h, text, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "FreeText";
    options.Contents = new String(text);
    options.DA = new String();
    return this.annotate(x, y2, w, h, options);
  },
  fileAnnotation(x, y2, w, h, file, options) {
    if (file === void 0) {
      file = {};
    }
    if (options === void 0) {
      options = {};
    }
    const filespec = this.file(file.src, Object.assign({
      hidden: true
    }, file));
    options.Subtype = "FileAttachment";
    options.FS = filespec;
    if (options.Contents) {
      options.Contents = new String(options.Contents);
    } else if (filespec.data.Desc) {
      options.Contents = filespec.data.Desc;
    }
    return this.annotate(x, y2, w, h, options);
  },
  _convertRect(x1, y1, w, h) {
    let y2 = y1;
    y1 += h;
    let x2 = x1 + w;
    const [m0, m1, m2, m3, m4, m5] = this._ctm;
    x1 = m0 * x1 + m2 * y1 + m4;
    y1 = m1 * x1 + m3 * y1 + m5;
    x2 = m0 * x2 + m2 * y2 + m4;
    y2 = m1 * x2 + m3 * y2 + m5;
    return [x1, y1, x2, y2];
  }
};
class PDFOutline {
  constructor(document2, parent, title2, dest, options) {
    if (options === void 0) {
      options = {
        expanded: false
      };
    }
    this.document = document2;
    this.options = options;
    this.outlineData = {};
    if (dest !== null) {
      this.outlineData["Dest"] = [dest.dictionary, "Fit"];
    }
    if (parent !== null) {
      this.outlineData["Parent"] = parent;
    }
    if (title2 !== null) {
      this.outlineData["Title"] = new String(title2);
    }
    this.dictionary = this.document.ref(this.outlineData);
    this.children = [];
  }
  addItem(title2, options) {
    if (options === void 0) {
      options = {
        expanded: false
      };
    }
    const result = new PDFOutline(this.document, this.dictionary, title2, this.document.page, options);
    this.children.push(result);
    return result;
  }
  endOutline() {
    if (this.children.length > 0) {
      if (this.options.expanded) {
        this.outlineData.Count = this.children.length;
      }
      const first = this.children[0], last2 = this.children[this.children.length - 1];
      this.outlineData.First = first.dictionary;
      this.outlineData.Last = last2.dictionary;
      for (let i2 = 0, len = this.children.length; i2 < len; i2++) {
        const child = this.children[i2];
        if (i2 > 0) {
          child.outlineData.Prev = this.children[i2 - 1].dictionary;
        }
        if (i2 < this.children.length - 1) {
          child.outlineData.Next = this.children[i2 + 1].dictionary;
        }
        child.endOutline();
      }
    }
    return this.dictionary.end();
  }
}
var OutlineMixin = {
  initOutline() {
    return this.outline = new PDFOutline(this, null, null, null);
  },
  endOutline() {
    this.outline.endOutline();
    if (this.outline.children.length > 0) {
      this._root.data.Outlines = this.outline.dictionary;
      return this._root.data.PageMode = "UseOutlines";
    }
  }
};
class PDFStructureContent {
  constructor(pageRef, mcid) {
    this.refs = [{
      pageRef,
      mcid
    }];
  }
  push(structContent) {
    structContent.refs.forEach((ref) => this.refs.push(ref));
  }
}
class PDFStructureElement {
  constructor(document2, type, options, children) {
    if (options === void 0) {
      options = {};
    }
    if (children === void 0) {
      children = null;
    }
    this.document = document2;
    this._attached = false;
    this._ended = false;
    this._flushed = false;
    this.dictionary = document2.ref({
      // Type: "StructElem",
      S: type
    });
    const data2 = this.dictionary.data;
    if (Array.isArray(options) || this._isValidChild(options)) {
      children = options;
      options = {};
    }
    if (typeof options.title !== "undefined") {
      data2.T = new String(options.title);
    }
    if (typeof options.lang !== "undefined") {
      data2.Lang = new String(options.lang);
    }
    if (typeof options.alt !== "undefined") {
      data2.Alt = new String(options.alt);
    }
    if (typeof options.expanded !== "undefined") {
      data2.E = new String(options.expanded);
    }
    if (typeof options.actual !== "undefined") {
      data2.ActualText = new String(options.actual);
    }
    this._children = [];
    if (children) {
      if (!Array.isArray(children)) {
        children = [children];
      }
      children.forEach((child) => this.add(child));
      this.end();
    }
  }
  add(child) {
    if (this._ended) {
      throw new Error(`Cannot add child to already-ended structure element`);
    }
    if (!this._isValidChild(child)) {
      throw new Error(`Invalid structure element child`);
    }
    if (child instanceof PDFStructureElement) {
      child.setParent(this.dictionary);
      if (this._attached) {
        child.setAttached();
      }
    }
    if (child instanceof PDFStructureContent) {
      this._addContentToParentTree(child);
    }
    if (typeof child === "function" && this._attached) {
      child = this._contentForClosure(child);
    }
    this._children.push(child);
    return this;
  }
  _addContentToParentTree(content) {
    content.refs.forEach((_ref) => {
      let {
        pageRef,
        mcid
      } = _ref;
      const pageStructParents = this.document.getStructParentTree().get(pageRef.data.StructParents);
      pageStructParents[mcid] = this.dictionary;
    });
  }
  setParent(parentRef) {
    if (this.dictionary.data.P) {
      throw new Error(`Structure element added to more than one parent`);
    }
    this.dictionary.data.P = parentRef;
    this._flush();
  }
  setAttached() {
    if (this._attached) {
      return;
    }
    this._children.forEach((child, index2) => {
      if (child instanceof PDFStructureElement) {
        child.setAttached();
      }
      if (typeof child === "function") {
        this._children[index2] = this._contentForClosure(child);
      }
    });
    this._attached = true;
    this._flush();
  }
  end() {
    if (this._ended) {
      return;
    }
    this._children.filter((child) => child instanceof PDFStructureElement).forEach((child) => child.end());
    this._ended = true;
    this._flush();
  }
  _isValidChild(child) {
    return child instanceof PDFStructureElement || child instanceof PDFStructureContent || typeof child === "function";
  }
  _contentForClosure(closure) {
    const content = this.document.markStructureContent(this.dictionary.data.S);
    closure();
    this.document.endMarkedContent();
    this._addContentToParentTree(content);
    return content;
  }
  _isFlushable() {
    if (!this.dictionary.data.P || !this._ended) {
      return false;
    }
    return this._children.every((child) => {
      if (typeof child === "function") {
        return false;
      }
      if (child instanceof PDFStructureElement) {
        return child._isFlushable();
      }
      return true;
    });
  }
  _flush() {
    if (this._flushed || !this._isFlushable()) {
      return;
    }
    this.dictionary.data.K = [];
    this._children.forEach((child) => this._flushChild(child));
    this.dictionary.end();
    this._children = [];
    this.dictionary.data.K = null;
    this._flushed = true;
  }
  _flushChild(child) {
    if (child instanceof PDFStructureElement) {
      this.dictionary.data.K.push(child.dictionary);
    }
    if (child instanceof PDFStructureContent) {
      child.refs.forEach((_ref2) => {
        let {
          pageRef,
          mcid
        } = _ref2;
        if (!this.dictionary.data.Pg) {
          this.dictionary.data.Pg = pageRef;
        }
        if (this.dictionary.data.Pg === pageRef) {
          this.dictionary.data.K.push(mcid);
        } else {
          this.dictionary.data.K.push({
            Type: "MCR",
            Pg: pageRef,
            MCID: mcid
          });
        }
      });
    }
  }
}
class PDFNumberTree extends PDFTree {
  _compareKeys(a2, b2) {
    return parseInt(a2) - parseInt(b2);
  }
  _keysName() {
    return "Nums";
  }
  _dataForKey(k2) {
    return parseInt(k2);
  }
}
var MarkingsMixin = {
  initMarkings(options) {
    this.structChildren = [];
    if (options.tagged) {
      this.getMarkInfoDictionary().data.Marked = true;
      this.getStructTreeRoot();
    }
  },
  markContent(tag, options) {
    if (options === void 0) {
      options = null;
    }
    if (tag === "Artifact" || options && options.mcid) {
      let toClose = 0;
      this.page.markings.forEach((marking) => {
        if (toClose || marking.structContent || marking.tag === "Artifact") {
          toClose++;
        }
      });
      while (toClose--) {
        this.endMarkedContent();
      }
    }
    if (!options) {
      this.page.markings.push({
        tag
      });
      this.addContent(`/${tag} BMC`);
      return this;
    }
    this.page.markings.push({
      tag,
      options
    });
    const dictionary2 = {};
    if (typeof options.mcid !== "undefined") {
      dictionary2.MCID = options.mcid;
    }
    if (tag === "Artifact") {
      if (typeof options.type === "string") {
        dictionary2.Type = options.type;
      }
      if (Array.isArray(options.bbox)) {
        dictionary2.BBox = [options.bbox[0], this.page.height - options.bbox[3], options.bbox[2], this.page.height - options.bbox[1]];
      }
      if (Array.isArray(options.attached) && options.attached.every((val) => typeof val === "string")) {
        dictionary2.Attached = options.attached;
      }
    }
    if (tag === "Span") {
      if (options.lang) {
        dictionary2.Lang = new String(options.lang);
      }
      if (options.alt) {
        dictionary2.Alt = new String(options.alt);
      }
      if (options.expanded) {
        dictionary2.E = new String(options.expanded);
      }
      if (options.actual) {
        dictionary2.ActualText = new String(options.actual);
      }
    }
    this.addContent(`/${tag} ${PDFObject.convert(dictionary2)} BDC`);
    return this;
  },
  markStructureContent(tag, options) {
    if (options === void 0) {
      options = {};
    }
    const pageStructParents = this.getStructParentTree().get(this.page.structParentTreeKey);
    const mcid = pageStructParents.length;
    pageStructParents.push(null);
    this.markContent(tag, {
      ...options,
      mcid
    });
    const structContent = new PDFStructureContent(this.page.dictionary, mcid);
    this.page.markings.slice(-1)[0].structContent = structContent;
    return structContent;
  },
  endMarkedContent() {
    this.page.markings.pop();
    this.addContent("EMC");
    return this;
  },
  struct(type, options, children) {
    if (options === void 0) {
      options = {};
    }
    if (children === void 0) {
      children = null;
    }
    return new PDFStructureElement(this, type, options, children);
  },
  addStructure(structElem) {
    const structTreeRoot = this.getStructTreeRoot();
    structElem.setParent(structTreeRoot);
    structElem.setAttached();
    this.structChildren.push(structElem);
    if (!structTreeRoot.data.K) {
      structTreeRoot.data.K = [];
    }
    structTreeRoot.data.K.push(structElem.dictionary);
    return this;
  },
  initPageMarkings(pageMarkings) {
    pageMarkings.forEach((marking) => {
      if (marking.structContent) {
        const structContent = marking.structContent;
        const newStructContent = this.markStructureContent(marking.tag, marking.options);
        structContent.push(newStructContent);
        this.page.markings.slice(-1)[0].structContent = structContent;
      } else {
        this.markContent(marking.tag, marking.options);
      }
    });
  },
  endPageMarkings(page) {
    const pageMarkings = page.markings;
    pageMarkings.forEach(() => page.write("EMC"));
    page.markings = [];
    return pageMarkings;
  },
  getMarkInfoDictionary() {
    if (!this._root.data.MarkInfo) {
      this._root.data.MarkInfo = this.ref({});
    }
    return this._root.data.MarkInfo;
  },
  hasMarkInfoDictionary() {
    return !!this._root.data.MarkInfo;
  },
  getStructTreeRoot() {
    if (!this._root.data.StructTreeRoot) {
      this._root.data.StructTreeRoot = this.ref({
        Type: "StructTreeRoot",
        ParentTree: new PDFNumberTree(),
        ParentTreeNextKey: 0
      });
    }
    return this._root.data.StructTreeRoot;
  },
  getStructParentTree() {
    return this.getStructTreeRoot().data.ParentTree;
  },
  createStructParentTreeNextKey() {
    this.getMarkInfoDictionary();
    const structTreeRoot = this.getStructTreeRoot();
    const key = structTreeRoot.data.ParentTreeNextKey++;
    structTreeRoot.data.ParentTree.add(key, []);
    return key;
  },
  endMarkings() {
    const structTreeRoot = this._root.data.StructTreeRoot;
    if (structTreeRoot) {
      structTreeRoot.end();
      this.structChildren.forEach((structElem) => structElem.end());
    }
    if (this._root.data.MarkInfo) {
      this._root.data.MarkInfo.end();
    }
  }
};
const FIELD_FLAGS = {
  readOnly: 1,
  required: 2,
  noExport: 4,
  multiline: 4096,
  password: 8192,
  toggleToOffButton: 16384,
  radioButton: 32768,
  pushButton: 65536,
  combo: 131072,
  edit: 262144,
  sort: 524288,
  multiSelect: 2097152,
  noSpell: 4194304
};
const FIELD_JUSTIFY = {
  left: 0,
  center: 1,
  right: 2
};
const VALUE_MAP = {
  value: "V",
  defaultValue: "DV"
};
const FORMAT_SPECIAL = {
  zip: "0",
  zipPlus4: "1",
  zip4: "1",
  phone: "2",
  ssn: "3"
};
const FORMAT_DEFAULT = {
  number: {
    nDec: 0,
    sepComma: false,
    negStyle: "MinusBlack",
    currency: "",
    currencyPrepend: true
  },
  percent: {
    nDec: 0,
    sepComma: false
  }
};
var AcroFormMixin = {
  /**
   * Must call if adding AcroForms to a document. Must also call font() before
   * this method to set the default font.
   */
  initForm() {
    if (!this._font) {
      throw new Error("Must set a font before calling initForm method");
    }
    this._acroform = {
      fonts: {},
      defaultFont: this._font.name
    };
    this._acroform.fonts[this._font.id] = this._font.ref();
    let data2 = {
      Fields: [],
      NeedAppearances: true,
      DA: new String(`/${this._font.id} 0 Tf 0 g`),
      DR: {
        Font: {}
      }
    };
    data2.DR.Font[this._font.id] = this._font.ref();
    const AcroForm = this.ref(data2);
    this._root.data.AcroForm = AcroForm;
    return this;
  },
  /**
   * Called automatically by document.js
   */
  endAcroForm() {
    if (this._root.data.AcroForm) {
      if (!Object.keys(this._acroform.fonts).length && !this._acroform.defaultFont) {
        throw new Error("No fonts specified for PDF form");
      }
      let fontDict = this._root.data.AcroForm.data.DR.Font;
      Object.keys(this._acroform.fonts).forEach((name) => {
        fontDict[name] = this._acroform.fonts[name];
      });
      this._root.data.AcroForm.data.Fields.forEach((fieldRef) => {
        this._endChild(fieldRef);
      });
      this._root.data.AcroForm.end();
    }
    return this;
  },
  _endChild(ref) {
    if (Array.isArray(ref.data.Kids)) {
      ref.data.Kids.forEach((childRef) => {
        this._endChild(childRef);
      });
      ref.end();
    }
    return this;
  },
  /**
   * Creates and adds a form field to the document. Form fields are intermediate
   * nodes in a PDF form that are used to specify form name heirarchy and form
   * value defaults.
   * @param {string} name - field name (T attribute in field dictionary)
   * @param {object} options  - other attributes to include in field dictionary
   */
  formField(name, options) {
    if (options === void 0) {
      options = {};
    }
    let fieldDict = this._fieldDict(name, null, options);
    let fieldRef = this.ref(fieldDict);
    this._addToParent(fieldRef);
    return fieldRef;
  },
  /**
   * Creates and adds a Form Annotation to the document. Form annotations are
   * called Widget annotations internally within a PDF file.
   * @param {string} name - form field name (T attribute of widget annotation
   * dictionary)
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @param {object} options
   */
  formAnnotation(name, type, x, y2, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    let fieldDict = this._fieldDict(name, type, options);
    fieldDict.Subtype = "Widget";
    if (fieldDict.F === void 0) {
      fieldDict.F = 4;
    }
    this.annotate(x, y2, w, h, fieldDict);
    let annotRef = this.page.annotations[this.page.annotations.length - 1];
    return this._addToParent(annotRef);
  },
  formText(name, x, y2, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "text", x, y2, w, h, options);
  },
  formPushButton(name, x, y2, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "pushButton", x, y2, w, h, options);
  },
  formCombo(name, x, y2, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "combo", x, y2, w, h, options);
  },
  formList(name, x, y2, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "list", x, y2, w, h, options);
  },
  formRadioButton(name, x, y2, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "radioButton", x, y2, w, h, options);
  },
  formCheckbox(name, x, y2, w, h, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "checkbox", x, y2, w, h, options);
  },
  _addToParent(fieldRef) {
    let parent = fieldRef.data.Parent;
    if (parent) {
      if (!parent.data.Kids) {
        parent.data.Kids = [];
      }
      parent.data.Kids.push(fieldRef);
    } else {
      this._root.data.AcroForm.data.Fields.push(fieldRef);
    }
    return this;
  },
  _fieldDict(name, type, options) {
    if (options === void 0) {
      options = {};
    }
    if (!this._acroform) {
      throw new Error("Call document.initForm() method before adding form elements to document");
    }
    let opts2 = Object.assign({}, options);
    if (type !== null) {
      opts2 = this._resolveType(type, options);
    }
    opts2 = this._resolveFlags(opts2);
    opts2 = this._resolveJustify(opts2);
    opts2 = this._resolveFont(opts2);
    opts2 = this._resolveStrings(opts2);
    opts2 = this._resolveColors(opts2);
    opts2 = this._resolveFormat(opts2);
    opts2.T = new String(name);
    if (opts2.parent) {
      opts2.Parent = opts2.parent;
      delete opts2.parent;
    }
    return opts2;
  },
  _resolveType(type, opts2) {
    if (type === "text") {
      opts2.FT = "Tx";
    } else if (type === "pushButton") {
      opts2.FT = "Btn";
      opts2.pushButton = true;
    } else if (type === "radioButton") {
      opts2.FT = "Btn";
      opts2.radioButton = true;
    } else if (type === "checkbox") {
      opts2.FT = "Btn";
    } else if (type === "combo") {
      opts2.FT = "Ch";
      opts2.combo = true;
    } else if (type === "list") {
      opts2.FT = "Ch";
    } else {
      throw new Error(`Invalid form annotation type '${type}'`);
    }
    return opts2;
  },
  _resolveFormat(opts2) {
    const f2 = opts2.format;
    if (f2 && f2.type) {
      let fnKeystroke;
      let fnFormat;
      let params = "";
      if (FORMAT_SPECIAL[f2.type] !== void 0) {
        fnKeystroke = `AFSpecial_Keystroke`;
        fnFormat = `AFSpecial_Format`;
        params = FORMAT_SPECIAL[f2.type];
      } else {
        let format2 = f2.type.charAt(0).toUpperCase() + f2.type.slice(1);
        fnKeystroke = `AF${format2}_Keystroke`;
        fnFormat = `AF${format2}_Format`;
        if (f2.type === "date") {
          fnKeystroke += "Ex";
          params = String(f2.param);
        } else if (f2.type === "time") {
          params = String(f2.param);
        } else if (f2.type === "number") {
          let p2 = Object.assign({}, FORMAT_DEFAULT.number, f2);
          params = String([String(p2.nDec), p2.sepComma ? "0" : "1", '"' + p2.negStyle + '"', "null", '"' + p2.currency + '"', String(p2.currencyPrepend)].join(","));
        } else if (f2.type === "percent") {
          let p2 = Object.assign({}, FORMAT_DEFAULT.percent, f2);
          params = String([String(p2.nDec), p2.sepComma ? "0" : "1"].join(","));
        }
      }
      opts2.AA = opts2.AA ? opts2.AA : {};
      opts2.AA.K = {
        S: "JavaScript",
        JS: new String(`${fnKeystroke}(${params});`)
      };
      opts2.AA.F = {
        S: "JavaScript",
        JS: new String(`${fnFormat}(${params});`)
      };
    }
    delete opts2.format;
    return opts2;
  },
  _resolveColors(opts2) {
    let color = this._normalizeColor(opts2.backgroundColor);
    if (color) {
      if (!opts2.MK) {
        opts2.MK = {};
      }
      opts2.MK.BG = color;
    }
    color = this._normalizeColor(opts2.borderColor);
    if (color) {
      if (!opts2.MK) {
        opts2.MK = {};
      }
      opts2.MK.BC = color;
    }
    delete opts2.backgroundColor;
    delete opts2.borderColor;
    return opts2;
  },
  _resolveFlags(options) {
    let result = 0;
    Object.keys(options).forEach((key) => {
      if (FIELD_FLAGS[key]) {
        if (options[key]) {
          result |= FIELD_FLAGS[key];
        }
        delete options[key];
      }
    });
    if (result !== 0) {
      options.Ff = options.Ff ? options.Ff : 0;
      options.Ff |= result;
    }
    return options;
  },
  _resolveJustify(options) {
    let result = 0;
    if (options.align !== void 0) {
      if (typeof FIELD_JUSTIFY[options.align] === "number") {
        result = FIELD_JUSTIFY[options.align];
      }
      delete options.align;
    }
    if (result !== 0) {
      options.Q = result;
    }
    return options;
  },
  _resolveFont(options) {
    if (this._acroform.fonts[this._font.id] == null) {
      this._acroform.fonts[this._font.id] = this._font.ref();
    }
    if (this._acroform.defaultFont !== this._font.name) {
      options.DR = {
        Font: {}
      };
      const fontSize = options.fontSize || 0;
      options.DR.Font[this._font.id] = this._font.ref();
      options.DA = new String(`/${this._font.id} ${fontSize} Tf 0 g`);
    }
    return options;
  },
  _resolveStrings(options) {
    let select = [];
    function appendChoices(a2) {
      if (Array.isArray(a2)) {
        for (let idx = 0; idx < a2.length; idx++) {
          if (typeof a2[idx] === "string") {
            select.push(new String(a2[idx]));
          } else {
            select.push(a2[idx]);
          }
        }
      }
    }
    appendChoices(options.Opt);
    if (options.select) {
      appendChoices(options.select);
      delete options.select;
    }
    if (select.length) {
      options.Opt = select;
    }
    Object.keys(VALUE_MAP).forEach((key) => {
      if (options[key] !== void 0) {
        options[VALUE_MAP[key]] = options[key];
        delete options[key];
      }
    });
    ["V", "DV"].forEach((key) => {
      if (typeof options[key] === "string") {
        options[key] = new String(options[key]);
      }
    });
    if (options.MK && options.MK.CA) {
      options.MK.CA = new String(options.MK.CA);
    }
    if (options.label) {
      options.MK = options.MK ? options.MK : {};
      options.MK.CA = new String(options.label);
      delete options.label;
    }
    return options;
  }
};
var AttachmentsMixin = {
  /**
   * Embed contents of `src` in PDF
   * @param {Buffer | ArrayBuffer | string} src input Buffer, ArrayBuffer, base64 encoded string or path to file
   * @param {object} options
   *  * options.name: filename to be shown in PDF, will use `src` if none set
   *  * options.type: filetype to be shown in PDF
   *  * options.description: description to be shown in PDF
   *  * options.hidden: if true, do not add attachment to EmbeddedFiles dictionary. Useful for file attachment annotations
   *  * options.creationDate: override creation date
   *  * options.modifiedDate: override modified date
   *  * options.relationship: Relationship between the PDF document and its attached file. Can be 'Alternative', 'Data', 'Source', 'Supplement' or 'Unspecified'.
   * @returns filespec reference
   */
  file(src2, options) {
    if (options === void 0) {
      options = {};
    }
    options.name = options.name || src2;
    options.relationship = options.relationship || "Unspecified";
    const refBody = {
      Type: "EmbeddedFile",
      Params: {}
    };
    let data2;
    if (!src2) {
      throw new Error("No src specified");
    }
    if (Buffer$2.isBuffer(src2)) {
      data2 = src2;
    } else if (src2 instanceof ArrayBuffer) {
      data2 = Buffer$2.from(new Uint8Array(src2));
    } else {
      let match;
      if (match = /^data:(.*?);base64,(.*)$/.exec(src2)) {
        if (match[1]) {
          refBody.Subtype = match[1].replace("/", "#2F");
        }
        data2 = Buffer$2.from(match[2], "base64");
      } else {
        data2 = fs.readFileSync(src2);
        if (!data2) {
          throw new Error(`Could not read contents of file at filepath ${src2}`);
        }
        const {
          birthtime,
          ctime
        } = fs.statSync(src2);
        refBody.Params.CreationDate = birthtime;
        refBody.Params.ModDate = ctime;
      }
    }
    if (options.creationDate instanceof Date) {
      refBody.Params.CreationDate = options.creationDate;
    }
    if (options.modifiedDate instanceof Date) {
      refBody.Params.ModDate = options.modifiedDate;
    }
    if (options.type) {
      refBody.Subtype = options.type.replace("/", "#2F");
    }
    const checksum = CryptoJS.MD5(CryptoJS.lib.WordArray.create(new Uint8Array(data2)));
    refBody.Params.CheckSum = new String(checksum);
    refBody.Params.Size = data2.byteLength;
    let ref;
    if (!this._fileRegistry) this._fileRegistry = {};
    let file = this._fileRegistry[options.name];
    if (file && isEqual(refBody, file)) {
      ref = file.ref;
    } else {
      ref = this.ref(refBody);
      ref.end(data2);
      this._fileRegistry[options.name] = {
        ...refBody,
        ref
      };
    }
    const fileSpecBody = {
      Type: "Filespec",
      AFRelationship: options.relationship,
      F: new String(options.name),
      EF: {
        F: ref
      },
      UF: new String(options.name)
    };
    if (options.description) {
      fileSpecBody.Desc = new String(options.description);
    }
    const filespec = this.ref(fileSpecBody);
    filespec.end();
    if (!options.hidden) {
      this.addNamedEmbeddedFile(options.name, filespec);
    }
    if (this._root.data.AF) {
      this._root.data.AF.push(filespec);
    } else {
      this._root.data.AF = [filespec];
    }
    return filespec;
  }
};
function isEqual(a2, b2) {
  return a2.Subtype === b2.Subtype && a2.Params.CheckSum.toString() === b2.Params.CheckSum.toString() && a2.Params.Size === b2.Params.Size && a2.Params.CreationDate.getTime() === b2.Params.CreationDate.getTime() && (a2.Params.ModDate === void 0 && b2.Params.ModDate === void 0 || a2.Params.ModDate.getTime() === b2.Params.ModDate.getTime());
}
var __dirname = "/home/runner/work/react-pdf/react-pdf/packages/pdfkit/src/mixins";
var PDFA = {
  initPDFA(pSubset) {
    if (pSubset.charAt(pSubset.length - 3) === "-") {
      this.subset_conformance = pSubset.charAt(pSubset.length - 1).toUpperCase();
      this.subset = parseInt(pSubset.charAt(pSubset.length - 2));
    } else {
      this.subset_conformance = "B";
      this.subset = parseInt(pSubset.charAt(pSubset.length - 1));
    }
  },
  endSubset() {
    this._addPdfaMetadata();
    this._addColorOutputIntent();
  },
  _addColorOutputIntent() {
    const iccProfile = fs.readFileSync(`${__dirname}/data/sRGB_IEC61966_2_1.icc`);
    const colorProfileRef = this.ref({
      Length: iccProfile.length,
      N: 3
    });
    colorProfileRef.write(iccProfile);
    colorProfileRef.end();
    const intentRef = this.ref({
      Type: "OutputIntent",
      S: "GTS_PDFA1",
      Info: new String("sRGB IEC61966-2.1"),
      OutputConditionIdentifier: new String("sRGB IEC61966-2.1"),
      DestOutputProfile: colorProfileRef
    });
    intentRef.end();
    this._root.data.OutputIntents = [intentRef];
  },
  _getPdfaid() {
    return `
        <rdf:Description xmlns:pdfaid="http://www.aiim.org/pdfa/ns/id/" rdf:about="">
            <pdfaid:part>${this.subset}</pdfaid:part>
            <pdfaid:conformance>${this.subset_conformance}</pdfaid:conformance>
        </rdf:Description>
        `;
  },
  _addPdfaMetadata() {
    this.appendXML(this._getPdfaid());
  }
};
var PDFUA = {
  initPDFUA() {
    this.subset = 1;
  },
  endSubset() {
    this._addPdfuaMetadata();
  },
  _addPdfuaMetadata() {
    this.appendXML(this._getPdfuaid());
  },
  _getPdfuaid() {
    return `
        <rdf:Description xmlns:pdfuaid="http://www.aiim.org/pdfua/ns/id/" rdf:about="">
            <pdfuaid:part>${this.subset}</pdfuaid:part>
        </rdf:Description>
        `;
  }
};
var SubsetMixin = {
  _importSubset(subset) {
    Object.assign(this, subset);
  },
  initSubset(options) {
    switch (options.subset) {
      case "PDF/A-1":
      case "PDF/A-1a":
      case "PDF/A-1b":
      case "PDF/A-2":
      case "PDF/A-2a":
      case "PDF/A-2b":
      case "PDF/A-3":
      case "PDF/A-3a":
      case "PDF/A-3b":
        this._importSubset(PDFA);
        this.initPDFA(options.subset);
        break;
      case "PDF/UA":
        this._importSubset(PDFUA);
        this.initPDFUA();
        break;
    }
  }
};
class PDFMetadata {
  constructor() {
    this._metadata = `
        <?xpacket begin="\uFEFF" id="W5M0MpCehiHzreSzNTczkc9d"?>
            <x:xmpmeta xmlns:x="adobe:ns:meta/">
                <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
        `;
  }
  _closeTags() {
    this._metadata = this._metadata.concat(`
                </rdf:RDF>
            </x:xmpmeta>
        <?xpacket end="w"?>
        `);
  }
  append(xml, newline) {
    if (newline === void 0) {
      newline = true;
    }
    this._metadata = this._metadata.concat(xml);
    if (newline) this._metadata = this._metadata.concat("\n");
  }
  getXML() {
    return this._metadata;
  }
  getLength() {
    return this._metadata.length;
  }
  end() {
    this._closeTags();
    this._metadata = this._metadata.trim();
  }
}
var MetadataMixin = {
  initMetadata() {
    this.metadata = new PDFMetadata();
  },
  appendXML(xml, newline) {
    if (newline === void 0) {
      newline = true;
    }
    this.metadata.append(xml, newline);
  },
  _addInfo() {
    this.appendXML(`
        <rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/">
            <xmp:CreateDate>${this.info.CreationDate.toISOString().split(".")[0] + "Z"}</xmp:CreateDate>
            <xmp:CreatorTool>${this.info.Creator}</xmp:CreatorTool>
        </rdf:Description>
        `);
    if (this.info.Title || this.info.Author || this.info.Subject) {
      this.appendXML(`
            <rdf:Description rdf:about="" xmlns:dc="http://purl.org/dc/elements/1.1/">
            `);
      if (this.info.Title) {
        this.appendXML(`
                <dc:title>
                    <rdf:Alt>
                        <rdf:li xml:lang="x-default">${this.info.Title}</rdf:li>
                    </rdf:Alt>
                </dc:title>
                `);
      }
      if (this.info.Author) {
        this.appendXML(`
                <dc:creator>
                    <rdf:Seq>
                        <rdf:li>${this.info.Author}</rdf:li>
                    </rdf:Seq>
                </dc:creator>
                `);
      }
      if (this.info.Subject) {
        this.appendXML(`
                <dc:description>
                    <rdf:Alt>
                        <rdf:li xml:lang="x-default">${this.info.Subject}</rdf:li>
                    </rdf:Alt>
                </dc:description>
                `);
      }
      this.appendXML(`
            </rdf:Description>
            `);
    }
    this.appendXML(`
        <rdf:Description rdf:about="" xmlns:pdf="http://ns.adobe.com/pdf/1.3/">
            <pdf:Producer>${this.info.Creator}</pdf:Producer>`, false);
    if (this.info.Keywords) {
      this.appendXML(`
            <pdf:Keywords>${this.info.Keywords}</pdf:Keywords>`, false);
    }
    this.appendXML(`
        </rdf:Description>
        `);
  },
  endMetadata() {
    this._addInfo();
    this.metadata.end();
    if (this.version != 1.3) {
      this.metadataRef = this.ref({
        length: this.metadata.getLength(),
        Type: "Metadata",
        Subtype: "XML"
      });
      this.metadataRef.compress = false;
      this.metadataRef.write(Buffer$2.from(this.metadata.getXML(), "utf-8"));
      this.metadataRef.end();
      this._root.data.Metadata = this.metadataRef;
    }
  }
};
class PDFDocument extends stream.Readable {
  constructor(options) {
    if (options === void 0) {
      options = {};
    }
    super(options);
    this.options = options;
    switch (options.pdfVersion) {
      case "1.4":
        this.version = 1.4;
        break;
      case "1.5":
        this.version = 1.5;
        break;
      case "1.6":
        this.version = 1.6;
        break;
      case "1.7":
      case "1.7ext3":
        this.version = 1.7;
        break;
      default:
        this.version = 1.3;
        break;
    }
    this.compress = this.options.compress != null ? this.options.compress : true;
    this._pageBuffer = [];
    this._pageBufferStart = 0;
    this._offsets = [];
    this._waiting = 0;
    this._ended = false;
    this._offset = 0;
    const Pages = this.ref({
      Type: "Pages",
      Count: 0,
      Kids: []
    });
    const Names = this.ref({
      Dests: new PDFNameTree()
    });
    this._root = this.ref({
      Type: "Catalog",
      Pages,
      Names
    });
    if (this.options.lang) {
      this._root.data.Lang = new String(this.options.lang);
    }
    this.page = null;
    this.initMetadata();
    this.initColor();
    this.initVector();
    this.initFonts(options.font);
    this.initText();
    this.initImages();
    this.initOutline();
    this.initMarkings(options);
    this.initSubset(options);
    this.info = {
      Producer: "PDFKit",
      Creator: "PDFKit",
      CreationDate: /* @__PURE__ */ new Date()
    };
    if (this.options.info) {
      for (let key in this.options.info) {
        const val = this.options.info[key];
        this.info[key] = val;
      }
    }
    if (this.options.displayTitle) {
      this._root.data.ViewerPreferences = this.ref({
        DisplayDocTitle: true
      });
    }
    this._id = PDFSecurity.generateFileID(this.info);
    this._write(`%PDF-${this.version}`);
    this._write("%");
    if (this.options.autoFirstPage !== false) {
      this.addPage();
    }
  }
  addPage(options) {
    if (options == null) {
      ({
        options
      } = this);
    }
    if (!this.options.bufferPages) {
      this.flushPages();
    }
    this.page = new PDFPage(this, options);
    this._pageBuffer.push(this.page);
    const pages = this._root.data.Pages.data;
    pages.Kids.push(this.page.dictionary);
    pages.Count++;
    this.x = this.page.margins.left;
    this.y = this.page.margins.top;
    this._ctm = [1, 0, 0, 1, 0, 0];
    this.transform(1, 0, 0, -1, 0, this.page.height);
    this.emit("pageAdded");
    return this;
  }
  continueOnNewPage(options) {
    const pageMarkings = this.endPageMarkings(this.page);
    this.addPage(options !== null && options !== void 0 ? options : this.page._options);
    this.initPageMarkings(pageMarkings);
    return this;
  }
  bufferedPageRange() {
    return {
      start: this._pageBufferStart,
      count: this._pageBuffer.length
    };
  }
  switchToPage(n3) {
    let page;
    if (!(page = this._pageBuffer[n3 - this._pageBufferStart])) {
      throw new Error(`switchToPage(${n3}) out of bounds, current buffer covers pages ${this._pageBufferStart} to ${this._pageBufferStart + this._pageBuffer.length - 1}`);
    }
    return this.page = page;
  }
  flushPages() {
    const pages = this._pageBuffer;
    this._pageBuffer = [];
    this._pageBufferStart += pages.length;
    for (let page of pages) {
      this.endPageMarkings(page);
      page.end();
    }
  }
  addNamedDestination(name) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (args.length === 0) {
      args = ["XYZ", null, null, null];
    }
    if (args[0] === "XYZ" && args[2] !== null) {
      args[2] = this.page.height - args[2];
    }
    args.unshift(this.page.dictionary);
    this._root.data.Names.data.Dests.add(name, args);
  }
  addNamedEmbeddedFile(name, ref) {
    if (!this._root.data.Names.data.EmbeddedFiles) {
      this._root.data.Names.data.EmbeddedFiles = new PDFNameTree({
        limits: false
      });
    }
    this._root.data.Names.data.EmbeddedFiles.add(name, ref);
  }
  addNamedJavaScript(name, js) {
    if (!this._root.data.Names.data.JavaScript) {
      this._root.data.Names.data.JavaScript = new PDFNameTree();
    }
    let data2 = {
      JS: new String(js),
      S: "JavaScript"
    };
    this._root.data.Names.data.JavaScript.add(name, data2);
  }
  ref(data2) {
    const ref = new PDFReference(this, this._offsets.length + 1, data2);
    this._offsets.push(null);
    this._waiting++;
    return ref;
  }
  _read() {
  }
  // do nothing, but this method is required by node
  _write(data2) {
    if (!Buffer$2.isBuffer(data2)) {
      data2 = Buffer$2.from(data2 + "\n", "binary");
    }
    this.push(data2);
    return this._offset += data2.length;
  }
  addContent(data2) {
    this.page.write(data2);
    return this;
  }
  _refEnd(ref) {
    this._offsets[ref.id - 1] = ref.offset;
    if (--this._waiting === 0 && this._ended) {
      this._finalize();
      return this._ended = false;
    }
  }
  end() {
    this.flushPages();
    this._info = this.ref();
    for (let key in this.info) {
      let val = this.info[key];
      if (typeof val === "string") {
        val = new String(val);
      }
      let entry = this.ref(val);
      entry.end();
      this._info.data[key] = entry;
    }
    this._info.end();
    for (let name in this._fontFamilies) {
      const font = this._fontFamilies[name];
      font.finalize();
    }
    this.endOutline();
    this.endMarkings();
    if (this.subset) {
      this.endSubset();
    }
    this.endMetadata();
    this._root.end();
    this._root.data.Pages.end();
    this._root.data.Names.end();
    this.endAcroForm();
    if (this._root.data.ViewerPreferences) {
      this._root.data.ViewerPreferences.end();
    }
    if (this._security) {
      this._security.end();
    }
    if (this._waiting === 0) {
      return this._finalize();
    } else {
      return this._ended = true;
    }
  }
  _finalize() {
    const xRefOffset = this._offset;
    this._write("xref");
    this._write(`0 ${this._offsets.length + 1}`);
    this._write("0000000000 65535 f ");
    for (let offset2 of this._offsets) {
      offset2 = `0000000000${offset2}`.slice(-10);
      this._write(offset2 + " 00000 n ");
    }
    const trailer = {
      Size: this._offsets.length + 1,
      Root: this._root,
      Info: this._info,
      ID: [this._id, this._id]
    };
    if (this._security) {
      trailer.Encrypt = this._security.dictionary;
    }
    this._write("trailer");
    this._write(PDFObject.convert(trailer));
    this._write("startxref");
    this._write(`${xRefOffset}`);
    this._write("%%EOF");
    return this.push(null);
  }
  toString() {
    return "[object PDFDocument]";
  }
}
const mixin = (methods) => {
  Object.assign(PDFDocument.prototype, methods);
};
mixin(MetadataMixin);
mixin(ColorMixin);
mixin(VectorMixin);
mixin(FontsMixin);
mixin(TextMixin);
mixin(ImagesMixin);
mixin(AnnotationsMixin);
mixin(OutlineMixin);
mixin(MarkingsMixin);
mixin(AcroFormMixin);
mixin(AttachmentsMixin);
mixin(SubsetMixin);
PDFDocument.LineWrapper = LineWrapper;
const STANDARD_FONTS = [
  "Courier",
  "Courier-Bold",
  "Courier-Oblique",
  "Courier-BoldOblique",
  "Helvetica",
  "Helvetica-Bold",
  "Helvetica-Oblique",
  "Helvetica-BoldOblique",
  "Times-Roman",
  "Times-Bold",
  "Times-Italic",
  "Times-BoldItalic"
];
class StandardFont {
  constructor(src2) {
    __publicField(this, "name");
    __publicField(this, "src");
    __publicField(this, "fullName");
    __publicField(this, "familyName");
    __publicField(this, "subfamilyName");
    __publicField(this, "postscriptName");
    __publicField(this, "copyright");
    __publicField(this, "version");
    __publicField(this, "underlinePosition");
    __publicField(this, "underlineThickness");
    __publicField(this, "italicAngle");
    __publicField(this, "bbox");
    __publicField(this, "OS/2");
    __publicField(this, "hhea");
    __publicField(this, "numGlyphs");
    __publicField(this, "characterSet");
    __publicField(this, "availableFeatures");
    __publicField(this, "type");
    this.name = src2;
    this.fullName = src2;
    this.familyName = src2;
    this.subfamilyName = src2;
    this.type = "STANDARD";
    this.postscriptName = src2;
    this.availableFeatures = [];
    this.copyright = "";
    this.version = 1;
    this.underlinePosition = -100;
    this.underlineThickness = 50;
    this.italicAngle = 0;
    this.bbox = {};
    this["OS/2"] = {};
    this.hhea = {};
    this.numGlyphs = 0;
    this.characterSet = [];
    this.src = PDFFont.open(null, src2);
  }
  encode(str) {
    return this.src.encode(str);
  }
  layout(str) {
    const [encoded, positions] = this.encode(str);
    const glyphs = encoded.map((g, i2) => {
      const glyph = this.getGlyph(parseInt(g, 16));
      glyph.advanceWidth = positions[i2].advanceWidth;
      return glyph;
    });
    const advanceWidth2 = positions.reduce((acc, p2) => acc + p2.advanceWidth, 0);
    return {
      positions,
      stringIndices: positions.map((_, i2) => i2),
      glyphs,
      script: "latin",
      language: "dflt",
      direction: "ltr",
      features: {},
      advanceWidth: advanceWidth2,
      advanceHeight: 0,
      bbox: void 0
    };
  }
  glyphForCodePoint(codePoint) {
    const glyph = this.getGlyph(codePoint);
    glyph.advanceWidth = 400;
    return glyph;
  }
  getGlyph(id) {
    return {
      id,
      codePoints: [id],
      isLigature: false,
      name: this.src.font.characterToGlyph(id),
      _font: this.src,
      // @ts-expect-error assign proper value
      advanceWidth: void 0
    };
  }
  hasGlyphForCodePoint(codePoint) {
    return this.src.font.characterToGlyph(codePoint) !== ".notdef";
  }
  // Based on empirical observation
  get ascent() {
    return 900;
  }
  // Based on empirical observation
  get capHeight() {
    switch (this.name) {
      case "Times-Roman":
      case "Times-Bold":
      case "Times-Italic":
      case "Times-BoldItalic":
        return 650;
      case "Courier":
      case "Courier-Bold":
      case "Courier-Oblique":
      case "Courier-BoldOblique":
        return 550;
      default:
        return 690;
    }
  }
  // Based on empirical observation
  get xHeight() {
    switch (this.name) {
      case "Times-Roman":
      case "Times-Bold":
      case "Times-Italic":
      case "Times-BoldItalic":
        return 440;
      case "Courier":
      case "Courier-Bold":
      case "Courier-Oblique":
      case "Courier-BoldOblique":
        return 390;
      default:
        return 490;
    }
  }
  // Based on empirical observation
  get descent() {
    switch (this.name) {
      case "Times-Roman":
      case "Times-Bold":
      case "Times-Italic":
      case "Times-BoldItalic":
        return -220;
      case "Courier":
      case "Courier-Bold":
      case "Courier-Oblique":
      case "Courier-BoldOblique":
        return -230;
      default:
        return -200;
    }
  }
  get lineGap() {
    return 0;
  }
  get unitsPerEm() {
    return 1e3;
  }
  stringsForGlyph() {
    throw new Error("Method not implemented.");
  }
  glyphsForString() {
    throw new Error("Method not implemented.");
  }
  widthOfGlyph() {
    throw new Error("Method not implemented.");
  }
  getAvailableFeatures() {
    throw new Error("Method not implemented.");
  }
  createSubset() {
    throw new Error("Method not implemented.");
  }
  getVariation() {
    throw new Error("Method not implemented.");
  }
  getFont() {
    throw new Error("Method not implemented.");
  }
  getName() {
    throw new Error("Method not implemented.");
  }
  setDefaultLanguage() {
    throw new Error("Method not implemented.");
  }
}
const fetchFont = async (src2, options) => {
  const response = await fetch(src2, options);
  const data2 = await response.arrayBuffer();
  return new Uint8Array(data2);
};
const isDataUrl = (dataUrl) => {
  const header = dataUrl.split(",")[0];
  const hasDataPrefix = header.substring(0, 5) === "data:";
  const hasBase64Prefix = header.split(";")[1] === "base64";
  return hasDataPrefix && hasBase64Prefix;
};
class FontSource {
  constructor(src2, fontFamily, fontStyle, fontWeight, options) {
    __publicField(this, "src");
    __publicField(this, "fontFamily");
    __publicField(this, "fontStyle");
    __publicField(this, "fontWeight");
    __publicField(this, "data");
    __publicField(this, "options");
    __publicField(this, "loadResultPromise");
    this.src = src2;
    this.fontFamily = fontFamily;
    this.fontStyle = fontStyle || "normal";
    this.fontWeight = fontWeight || 400;
    this.data = null;
    this.options = options || {};
    this.loadResultPromise = null;
  }
  async _load() {
    const { postscriptName } = this.options;
    let data2 = null;
    if (STANDARD_FONTS.includes(this.src)) {
      data2 = new StandardFont(this.src);
    } else if (isDataUrl(this.src)) {
      const raw = this.src.split(",")[1];
      const uint8Array = new Uint8Array(atob(raw).split("").map((c2) => c2.charCodeAt(0)));
      data2 = $d636bc798e7178db$export$185802fd694ee1f5(uint8Array, postscriptName);
    } else {
      const { headers, body, method = "GET" } = this.options;
      const buffer = await fetchFont(this.src, { method, body, headers });
      data2 = $d636bc798e7178db$export$185802fd694ee1f5(buffer, postscriptName);
    }
    if (data2 && "fonts" in data2) {
      throw new Error("Font collection is not supported");
    }
    this.data = data2;
  }
  async load() {
    if (this.loadResultPromise === null) {
      this.loadResultPromise = this._load();
    }
    return this.loadResultPromise;
  }
}
const FONT_WEIGHTS$1 = {
  thin: 100,
  hairline: 100,
  ultralight: 200,
  extralight: 200,
  light: 300,
  normal: 400,
  medium: 500,
  semibold: 600,
  demibold: 600,
  bold: 700,
  ultrabold: 800,
  extrabold: 800,
  heavy: 900,
  black: 900
};
const resolveFontWeight = (value2) => {
  return typeof value2 === "string" ? FONT_WEIGHTS$1[value2] : value2;
};
const sortByFontWeight = (a2, b2) => a2.fontWeight - b2.fontWeight;
class FontFamily {
  constructor(family) {
    __publicField(this, "family");
    __publicField(this, "sources");
    this.family = family;
    this.sources = [];
  }
  static create(family) {
    return new FontFamily(family);
  }
  register({ src: src2, fontWeight, fontStyle, ...options }) {
    const numericFontWeight = fontWeight ? resolveFontWeight(fontWeight) : void 0;
    this.sources.push(new FontSource(src2, this.family, fontStyle, numericFontWeight, options));
  }
  resolve(descriptor) {
    const { fontWeight = 400, fontStyle = "normal" } = descriptor;
    const styleSources = this.sources.filter((s2) => s2.fontStyle === fontStyle);
    const exactFit = styleSources.find((s2) => s2.fontWeight === fontWeight);
    if (exactFit)
      return exactFit;
    let font = null;
    const numericFontWeight = resolveFontWeight(fontWeight);
    if (numericFontWeight >= 400 && numericFontWeight <= 500) {
      const leftOffset = styleSources.filter((s2) => s2.fontWeight <= numericFontWeight);
      const rightOffset = styleSources.filter((s2) => s2.fontWeight > 500);
      const fit = styleSources.filter((s2) => s2.fontWeight >= numericFontWeight && s2.fontWeight < 500);
      font = fit[0] || leftOffset[leftOffset.length - 1] || rightOffset[0];
    }
    const lt = styleSources.filter((s2) => s2.fontWeight < numericFontWeight).sort(sortByFontWeight);
    const gt = styleSources.filter((s2) => s2.fontWeight > numericFontWeight).sort(sortByFontWeight);
    if (numericFontWeight < 400) {
      font = lt[lt.length - 1] || gt[0];
    }
    if (numericFontWeight > 500) {
      font = gt[0] || lt[lt.length - 1];
    }
    if (!font) {
      throw new Error(`Could not resolve font for ${this.family}, fontWeight ${fontWeight}, fontStyle ${fontStyle}`);
    }
    return font;
  }
}
class FontStore {
  constructor() {
    __publicField(this, "fontFamilies", {});
    __publicField(this, "emojiSource", null);
    __publicField(this, "hyphenationCallback", null);
    __publicField(this, "register", (data2) => {
      const { family } = data2;
      if (!this.fontFamilies[family]) {
        this.fontFamilies[family] = FontFamily.create(family);
      }
      if ("fonts" in data2) {
        for (let i2 = 0; i2 < data2.fonts.length; i2 += 1) {
          const { src: src2, fontStyle, fontWeight, ...options } = data2.fonts[i2];
          this.fontFamilies[family].register({
            src: src2,
            fontStyle,
            fontWeight,
            ...options
          });
        }
      } else {
        const { src: src2, fontStyle, fontWeight, ...options } = data2;
        this.fontFamilies[family].register({
          src: src2,
          fontStyle,
          fontWeight,
          ...options
        });
      }
    });
    __publicField(this, "registerEmojiSource", (emojiSource) => {
      this.emojiSource = emojiSource;
    });
    __publicField(this, "registerHyphenationCallback", (callback) => {
      this.hyphenationCallback = callback;
    });
    __publicField(this, "getFont", (descriptor) => {
      const { fontFamily } = descriptor;
      if (!this.fontFamilies[fontFamily]) {
        throw new Error(`Font family not registered: ${fontFamily}. Please register it calling Font.register() method.`);
      }
      return this.fontFamilies[fontFamily].resolve(descriptor);
    });
    __publicField(this, "load", async (descriptor) => {
      const font = this.getFont(descriptor);
      if (font)
        await font.load();
    });
    __publicField(this, "reset", () => {
      const keys = Object.keys(this.fontFamilies);
      for (let i2 = 0; i2 < keys.length; i2 += 1) {
        const key = keys[i2];
        for (let j = 0; j < this.fontFamilies[key].sources.length; j++) {
          const fontSource = this.fontFamilies[key].sources[j];
          fontSource.data = null;
        }
      }
    });
    __publicField(this, "clear", () => {
      this.fontFamilies = {};
    });
    __publicField(this, "getRegisteredFonts", () => this.fontFamilies);
    __publicField(this, "getEmojiSource", () => this.emojiSource);
    __publicField(this, "getHyphenationCallback", () => this.hyphenationCallback);
    __publicField(this, "getRegisteredFontFamilies", () => Object.keys(this.fontFamilies));
    this.register({
      family: "Helvetica",
      fonts: [
        { src: "Helvetica", fontStyle: "normal", fontWeight: 400 },
        { src: "Helvetica-Bold", fontStyle: "normal", fontWeight: 700 },
        { src: "Helvetica-Oblique", fontStyle: "italic", fontWeight: 400 },
        { src: "Helvetica-BoldOblique", fontStyle: "italic", fontWeight: 700 }
      ]
    });
    this.register({
      family: "Courier",
      fonts: [
        { src: "Courier", fontStyle: "normal", fontWeight: 400 },
        { src: "Courier-Bold", fontStyle: "normal", fontWeight: 700 },
        { src: "Courier-Oblique", fontStyle: "italic", fontWeight: 400 },
        { src: "Courier-BoldOblique", fontStyle: "italic", fontWeight: 700 }
      ]
    });
    this.register({
      family: "Times-Roman",
      fonts: [
        { src: "Times-Roman", fontStyle: "normal", fontWeight: 400 },
        { src: "Times-Bold", fontStyle: "normal", fontWeight: 700 },
        { src: "Times-Italic", fontStyle: "italic", fontWeight: 400 },
        { src: "Times-BoldItalic", fontStyle: "italic", fontWeight: 700 }
      ]
    });
    this.register({
      family: "Helvetica-Bold",
      src: "Helvetica-Bold"
    });
    this.register({
      family: "Helvetica-Oblique",
      src: "Helvetica-Oblique"
    });
    this.register({
      family: "Helvetica-BoldOblique",
      src: "Helvetica-BoldOblique"
    });
    this.register({
      family: "Courier-Bold",
      src: "Courier-Bold"
    });
    this.register({
      family: "Courier-Oblique",
      src: "Courier-Oblique"
    });
    this.register({
      family: "Courier-BoldOblique",
      src: "Courier-BoldOblique"
    });
    this.register({
      family: "Times-Bold",
      src: "Times-Bold"
    });
    this.register({
      family: "Times-Italic",
      src: "Times-Italic"
    });
    this.register({
      family: "Times-BoldItalic",
      src: "Times-BoldItalic"
    });
    this.load({
      fontFamily: "Helvetica",
      fontStyle: "normal",
      fontWeight: 400
    });
    this.load({
      fontFamily: "Helvetica",
      fontStyle: "normal",
      fontWeight: 700
    });
    this.load({
      fontFamily: "Helvetica",
      fontStyle: "italic",
      fontWeight: 400
    });
    this.load({
      fontFamily: "Helvetica",
      fontStyle: "italic",
      fontWeight: 700
    });
  }
}
const adjust = (index2, fn, collection) => {
  if (Math.abs(index2) > collection.length)
    return collection;
  const i2 = collection.length + index2;
  return Object.assign([], collection, { [i2]: fn(collection[i2]) });
};
const asyncCompose = (...fns) => async (value2, ...args) => {
  let result = value2;
  const reversedFns = fns.slice().reverse();
  for (let i2 = 0; i2 < reversedFns.length; i2 += 1) {
    const fn = reversedFns[i2];
    result = await fn(result, ...args);
  }
  return result;
};
const capitalize = (value2) => {
  if (!value2)
    return value2;
  return value2.replace(/(^|\s)\S/g, (l2) => l2.toUpperCase());
};
const castArray = (value2) => {
  return Array.isArray(value2) ? value2 : [value2];
};
const compose = (...fns) => (value2, ...args) => {
  let result = value2;
  const reversedFns = fns.slice().reverse();
  for (let i2 = 0; i2 < reversedFns.length; i2 += 1) {
    const fn = reversedFns[i2];
    result = fn(result, ...args);
  }
  return result;
};
const dropLast$2 = (array) => array.slice(0, array.length - 1);
function evolve(transformations, object) {
  const result = {};
  const keys = Object.keys(object);
  for (let i2 = 0; i2 < keys.length; i2 += 1) {
    const key = keys[i2];
    const transformation = transformations[key];
    if (typeof transformation === "function") {
      result[key] = transformation(object[key]);
    } else {
      result[key] = object[key];
    }
  }
  return result;
}
const isNil = (value2) => value2 === null || value2 === void 0;
function last(value2) {
  return value2 === "" ? "" : value2[value2.length - 1];
}
const mapValues = (object, fn) => {
  const entries = Object.entries(object);
  const acc = {};
  return entries.reduce((acc2, [key, value2], index2) => {
    acc2[key] = fn(value2, key, index2);
    return acc2;
  }, acc);
};
const isPercent = (value2) => /((-)?\d+\.?\d*)%/g.exec(`${value2}`);
const matchPercent = (value2) => {
  const match = isPercent(value2);
  if (match) {
    const f2 = parseFloat(match[1]);
    const percent = f2 / 100;
    return { percent, value: f2 };
  }
  return null;
};
const omit$1 = (keys, object) => {
  const _keys = castArray(keys);
  const copy5 = Object.assign({}, object);
  _keys.forEach((key) => {
    delete copy5[key];
  });
  return copy5;
};
const pick = (keys, obj) => {
  const result = {};
  for (let i2 = 0; i2 < keys.length; i2 += 1) {
    const key = keys[i2];
    if (key in obj)
      result[key] = obj[key];
  }
  return result;
};
const repeat = (element, length2 = 0) => {
  const result = new Array(length2);
  for (let i2 = 0; i2 < length2; i2 += 1) {
    result[i2] = element;
  }
  return result;
};
const reverse = (list) => Array.prototype.slice.call(list, 0).reverse();
const upperFirst = (value2) => {
  if (!value2)
    return value2;
  return value2.charAt(0).toUpperCase() + value2.slice(1);
};
const without = (keys, array) => {
  const result = [];
  for (let i2 = 0; i2 < array.length; i2 += 1) {
    const value2 = array[i2];
    if (!keys.includes(value2))
      result.push(value2);
  }
  return result;
};
const parseFloat$1 = (value2) => {
  return typeof value2 === "string" ? Number.parseFloat(value2) : value2;
};
var absSvgPath;
var hasRequiredAbsSvgPath;
function requireAbsSvgPath() {
  if (hasRequiredAbsSvgPath) return absSvgPath;
  hasRequiredAbsSvgPath = 1;
  absSvgPath = absolutize;
  function absolutize(path) {
    var startX = 0;
    var startY = 0;
    var x = 0;
    var y2 = 0;
    return path.map(function(seg) {
      seg = seg.slice();
      var type = seg[0];
      var command = type.toUpperCase();
      if (type != command) {
        seg[0] = command;
        switch (type) {
          case "a":
            seg[6] += x;
            seg[7] += y2;
            break;
          case "v":
            seg[1] += y2;
            break;
          case "h":
            seg[1] += x;
            break;
          default:
            for (var i2 = 1; i2 < seg.length; ) {
              seg[i2++] += x;
              seg[i2++] += y2;
            }
        }
      }
      switch (command) {
        case "Z":
          x = startX;
          y2 = startY;
          break;
        case "H":
          x = seg[1];
          break;
        case "V":
          y2 = seg[1];
          break;
        case "M":
          x = startX = seg[1];
          y2 = startY = seg[2];
          break;
        default:
          x = seg[seg.length - 2];
          y2 = seg[seg.length - 1];
      }
      return seg;
    });
  }
  return absSvgPath;
}
var absSvgPathExports = requireAbsSvgPath();
const absPath = /* @__PURE__ */ getDefaultExportFromCjs$2(absSvgPathExports);
var parseSvgPath;
var hasRequiredParseSvgPath;
function requireParseSvgPath() {
  if (hasRequiredParseSvgPath) return parseSvgPath;
  hasRequiredParseSvgPath = 1;
  parseSvgPath = parse2;
  var length2 = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
  var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
  function parse2(path) {
    var data2 = [];
    path.replace(segment, function(_, command, args) {
      var type = command.toLowerCase();
      args = parseValues(args);
      if (type == "m" && args.length > 2) {
        data2.push([command].concat(args.splice(0, 2)));
        type = "l";
        command = command == "m" ? "l" : "L";
      }
      while (true) {
        if (args.length == length2[type]) {
          args.unshift(command);
          return data2.push(args);
        }
        if (args.length < length2[type]) throw new Error("malformed path data");
        data2.push([command].concat(args.splice(0, length2[type])));
      }
    });
    return data2;
  }
  var number2 = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
  function parseValues(args) {
    var numbers = args.match(number2);
    return numbers ? numbers.map(Number) : [];
  }
  return parseSvgPath;
}
var parseSvgPathExports = requireParseSvgPath();
const parsePath = /* @__PURE__ */ getDefaultExportFromCjs$2(parseSvgPathExports);
var _slicedToArray = /* @__PURE__ */ function() {
  function sliceIterator(arr, i2) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2) break;
      }
    } catch (err2) {
      _d = true;
      _e = err2;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i2) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i2);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var TAU = Math.PI * 2;
var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x = _ref.x, y2 = _ref.y;
  x *= rx;
  y2 *= ry;
  var xp = cosphi * x - sinphi * y2;
  var yp = sinphi * x + cosphi * y2;
  return {
    x: xp + centerx,
    y: yp + centery
  };
};
var approxUnitArc = function approxUnitArc2(ang1, ang2) {
  var a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y2 = Math.sin(ang1 + ang2);
  return [{
    x: x1 - y1 * a2,
    y: y1 + x1 * a2
  }, {
    x: x2 + y2 * a2,
    y: y2 - x2 * a2
  }, {
    x: x2,
    y: y2
  }];
};
var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var dot = ux * vx + uy * vy;
  if (dot > 1) {
    dot = 1;
  }
  if (dot < -1) {
    dot = -1;
  }
  return sign * Math.acos(dot);
};
var getArcCenter = function getArcCenter2(px2, py2, cx2, cy2, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);
  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;
  var centerx = cosphi * centerxp - sinphi * centeryp + (px2 + cx2) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py2 + cy2) / 2;
  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;
  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  return [centerx, centery, ang1, ang2];
};
var arcToBezier = function arcToBezier2(_ref2) {
  var px2 = _ref2.px, py2 = _ref2.py, cx2 = _ref2.cx, cy2 = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
  var curves = [];
  if (rx === 0 || ry === 0) {
    return [];
  }
  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);
  var pxp = cosphi * (px2 - cx2) / 2 + sinphi * (py2 - cy2) / 2;
  var pyp = -sinphi * (px2 - cx2) / 2 + cosphi * (py2 - cy2) / 2;
  if (pxp === 0 && pyp === 0) {
    return [];
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var _getArcCenter = getArcCenter(px2, py2, cx2, cy2, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  var segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  for (var i2 = 0; i2 < segments; i2++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }
  return curves.map(function(curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y2 = _mapToEllipse2.y;
    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _mapToEllipse3.x, y3 = _mapToEllipse3.y;
    return { x1, y1, x2, y2, x, y: y3 };
  });
};
function normalize$2(path) {
  var prev;
  var result = [];
  var bezierX = 0;
  var bezierY = 0;
  var startX = 0;
  var startY = 0;
  var quadX = null;
  var quadY = null;
  var x = 0;
  var y2 = 0;
  for (var i2 = 0, len = path.length; i2 < len; i2++) {
    var seg = path[i2];
    var command = seg[0];
    switch (command) {
      case "M":
        startX = seg[1];
        startY = seg[2];
        break;
      case "A":
        var curves = arcToBezier({
          px: x,
          py: y2,
          cx: seg[6],
          cy: seg[7],
          rx: seg[1],
          ry: seg[2],
          xAxisRotation: seg[3],
          largeArcFlag: seg[4],
          sweepFlag: seg[5]
        });
        if (!curves.length) continue;
        for (var j = 0, c2; j < curves.length; j++) {
          c2 = curves[j];
          seg = ["C", c2.x1, c2.y1, c2.x2, c2.y2, c2.x, c2.y];
          if (j < curves.length - 1) result.push(seg);
        }
        break;
      case "S":
        var cx2 = x;
        var cy2 = y2;
        if (prev == "C" || prev == "S") {
          cx2 += cx2 - bezierX;
          cy2 += cy2 - bezierY;
        }
        seg = ["C", cx2, cy2, seg[1], seg[2], seg[3], seg[4]];
        break;
      case "T":
        if (prev == "Q" || prev == "T") {
          quadX = x * 2 - quadX;
          quadY = y2 * 2 - quadY;
        } else {
          quadX = x;
          quadY = y2;
        }
        seg = quadratic(x, y2, quadX, quadY, seg[1], seg[2]);
        break;
      case "Q":
        quadX = seg[1];
        quadY = seg[2];
        seg = quadratic(x, y2, seg[1], seg[2], seg[3], seg[4]);
        break;
      case "L":
        seg = line(x, y2, seg[1], seg[2]);
        break;
      case "H":
        seg = line(x, y2, seg[1], y2);
        break;
      case "V":
        seg = line(x, y2, x, seg[1]);
        break;
      case "Z":
        seg = line(x, y2, startX, startY);
        break;
    }
    prev = command;
    x = seg[seg.length - 2];
    y2 = seg[seg.length - 1];
    if (seg.length > 4) {
      bezierX = seg[seg.length - 4];
      bezierY = seg[seg.length - 3];
    } else {
      bezierX = x;
      bezierY = y2;
    }
    result.push(seg);
  }
  return result;
}
function line(x1, y1, x2, y2) {
  return ["C", x1, y1, x2, y2, x2, y2];
}
function quadratic(x1, y1, cx2, cy2, x2, y2) {
  return [
    "C",
    x1 / 3 + 2 / 3 * cx2,
    y1 / 3 + 2 / 3 * cy2,
    x2 / 3 + 2 / 3 * cx2,
    y2 / 3 + 2 / 3 * cy2,
    x2,
    y2
  ];
}
var colorString$1 = { exports: {} };
var colorName;
var hasRequiredColorName;
function requireColorName() {
  if (hasRequiredColorName) return colorName;
  hasRequiredColorName = 1;
  colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  return colorName;
}
var simpleSwizzle = { exports: {} };
var isArrayish;
var hasRequiredIsArrayish;
function requireIsArrayish() {
  if (hasRequiredIsArrayish) return isArrayish;
  hasRequiredIsArrayish = 1;
  isArrayish = function isArrayish2(obj) {
    if (!obj || typeof obj === "string") {
      return false;
    }
    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
  };
  return isArrayish;
}
var hasRequiredSimpleSwizzle;
function requireSimpleSwizzle() {
  if (hasRequiredSimpleSwizzle) return simpleSwizzle.exports;
  hasRequiredSimpleSwizzle = 1;
  var isArrayish2 = requireIsArrayish();
  var concat5 = Array.prototype.concat;
  var slice5 = Array.prototype.slice;
  var swizzle = simpleSwizzle.exports = function swizzle2(args) {
    var results = [];
    for (var i2 = 0, len = args.length; i2 < len; i2++) {
      var arg = args[i2];
      if (isArrayish2(arg)) {
        results = concat5.call(results, slice5.call(arg));
      } else {
        results.push(arg);
      }
    }
    return results;
  };
  swizzle.wrap = function(fn) {
    return function() {
      return fn(swizzle(arguments));
    };
  };
  return simpleSwizzle.exports;
}
var hasRequiredColorString;
function requireColorString() {
  if (hasRequiredColorString) return colorString$1.exports;
  hasRequiredColorString = 1;
  var colorNames = requireColorName();
  var swizzle = requireSimpleSwizzle();
  var hasOwnProperty2 = Object.hasOwnProperty;
  var reverseNames = /* @__PURE__ */ Object.create(null);
  for (var name in colorNames) {
    if (hasOwnProperty2.call(colorNames, name)) {
      reverseNames[colorNames[name]] = name;
    }
  }
  var cs = colorString$1.exports = {
    to: {},
    get: {}
  };
  cs.get = function(string) {
    var prefix2 = string.substring(0, 3).toLowerCase();
    var val;
    var model;
    switch (prefix2) {
      case "hsl":
        val = cs.get.hsl(string);
        model = "hsl";
        break;
      case "hwb":
        val = cs.get.hwb(string);
        model = "hwb";
        break;
      default:
        val = cs.get.rgb(string);
        model = "rgb";
        break;
    }
    if (!val) {
      return null;
    }
    return { model, value: val };
  };
  cs.get.rgb = function(string) {
    if (!string) {
      return null;
    }
    var abbr = /^#([a-f0-9]{3,4})$/i;
    var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
    var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var keyword = /^(\w+)$/;
    var rgb = [0, 0, 0, 1];
    var match;
    var i2;
    var hexAlpha;
    if (match = string.match(hex)) {
      hexAlpha = match[2];
      match = match[1];
      for (i2 = 0; i2 < 3; i2++) {
        var i22 = i2 * 2;
        rgb[i2] = parseInt(match.slice(i22, i22 + 2), 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha, 16) / 255;
      }
    } else if (match = string.match(abbr)) {
      match = match[1];
      hexAlpha = match[3];
      for (i2 = 0; i2 < 3; i2++) {
        rgb[i2] = parseInt(match[i2] + match[i2], 16);
      }
      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
      }
    } else if (match = string.match(rgba)) {
      for (i2 = 0; i2 < 3; i2++) {
        rgb[i2] = parseInt(match[i2 + 1], 0);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(per)) {
      for (i2 = 0; i2 < 3; i2++) {
        rgb[i2] = Math.round(parseFloat(match[i2 + 1]) * 2.55);
      }
      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(keyword)) {
      if (match[1] === "transparent") {
        return [0, 0, 0, 0];
      }
      if (!hasOwnProperty2.call(colorNames, match[1])) {
        return null;
      }
      rgb = colorNames[match[1]];
      rgb[3] = 1;
      return rgb;
    } else {
      return null;
    }
    for (i2 = 0; i2 < 3; i2++) {
      rgb[i2] = clamp(rgb[i2], 0, 255);
    }
    rgb[3] = clamp(rgb[3], 0, 1);
    return rgb;
  };
  cs.get.hsl = function(string) {
    if (!string) {
      return null;
    }
    var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hsl);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var s2 = clamp(parseFloat(match[2]), 0, 100);
      var l2 = clamp(parseFloat(match[3]), 0, 100);
      var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s2, l2, a2];
    }
    return null;
  };
  cs.get.hwb = function(string) {
    if (!string) {
      return null;
    }
    var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hwb);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var w = clamp(parseFloat(match[2]), 0, 100);
      var b2 = clamp(parseFloat(match[3]), 0, 100);
      var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b2, a2];
    }
    return null;
  };
  cs.to.hex = function() {
    var rgba = swizzle(arguments);
    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
  };
  cs.to.rgb = function() {
    var rgba = swizzle(arguments);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
  };
  cs.to.rgb.percent = function() {
    var rgba = swizzle(arguments);
    var r2 = Math.round(rgba[0] / 255 * 100);
    var g = Math.round(rgba[1] / 255 * 100);
    var b2 = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r2 + "%, " + g + "%, " + b2 + "%)" : "rgba(" + r2 + "%, " + g + "%, " + b2 + "%, " + rgba[3] + ")";
  };
  cs.to.hsl = function() {
    var hsla = swizzle(arguments);
    return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
  };
  cs.to.hwb = function() {
    var hwba = swizzle(arguments);
    var a2 = "";
    if (hwba.length >= 4 && hwba[3] !== 1) {
      a2 = ", " + hwba[3];
    }
    return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a2 + ")";
  };
  cs.to.keyword = function(rgb) {
    return reverseNames[rgb.slice(0, 3)];
  };
  function clamp(num, min2, max2) {
    return Math.min(Math.max(min2, num), max2);
  }
  function hexDouble(num) {
    var str = Math.round(num).toString(16).toUpperCase();
    return str.length < 2 ? "0" + str : str;
  }
  return colorString$1.exports;
}
var colorStringExports = requireColorString();
const colorString = /* @__PURE__ */ getDefaultExportFromCjs$2(colorStringExports);
const renderPath = (ctx, node) => {
  var _a;
  const d2 = (_a = node.props) == null ? void 0 : _a.d;
  if (d2)
    ctx.path(node.props.d);
};
const KAPPA$3 = 4 * ((Math.sqrt(2) - 1) / 3);
const renderRect = (ctx, node) => {
  var _a, _b, _c, _d, _e, _f;
  const x = ((_a = node.props) == null ? void 0 : _a.x) || 0;
  const y2 = ((_b = node.props) == null ? void 0 : _b.y) || 0;
  const rx = ((_c = node.props) == null ? void 0 : _c.rx) || 0;
  const ry = ((_d = node.props) == null ? void 0 : _d.ry) || 0;
  const width = ((_e = node.props) == null ? void 0 : _e.width) || 0;
  const height2 = ((_f = node.props) == null ? void 0 : _f.height) || 0;
  if (!width || !height2)
    return;
  if (rx && ry) {
    const krx = rx * KAPPA$3;
    const kry = ry * KAPPA$3;
    ctx.moveTo(x + rx, y2);
    ctx.lineTo(x - rx + width, y2);
    ctx.bezierCurveTo(x - rx + width + krx, y2, x + width, y2 + ry - kry, x + width, y2 + ry);
    ctx.lineTo(x + width, y2 + height2 - ry);
    ctx.bezierCurveTo(x + width, y2 + height2 - ry + kry, x - rx + width + krx, y2 + height2, x - rx + width, y2 + height2);
    ctx.lineTo(x + rx, y2 + height2);
    ctx.bezierCurveTo(x + rx - krx, y2 + height2, x, y2 + height2 - ry + kry, x, y2 + height2 - ry);
    ctx.lineTo(x, y2 + ry);
    ctx.bezierCurveTo(x, y2 + ry - kry, x + rx - krx, y2, x + rx, y2);
  } else {
    ctx.moveTo(x, y2);
    ctx.lineTo(x + width, y2);
    ctx.lineTo(x + width, y2 + height2);
    ctx.lineTo(x, y2 + height2);
  }
  ctx.closePath();
};
const renderLine$1 = (ctx, node) => {
  const { x1, x2, y1, y2 } = node.props || {};
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
};
const renderGroup = () => {
};
const KAPPA$2 = 4 * ((Math.sqrt(2) - 1) / 3);
const drawEllipse = (ctx, rx, ry, cx2 = 0, cy2 = 0) => {
  const x = cx2 - rx;
  const y2 = cy2 - ry;
  const ox = rx * KAPPA$2;
  const oy = ry * KAPPA$2;
  const xe = x + rx * 2;
  const ye = y2 + ry * 2;
  const xm = x + rx;
  const ym = y2 + ry;
  ctx.moveTo(x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y2, xm, y2);
  ctx.bezierCurveTo(xm + ox, y2, xe, ym - oy, xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  ctx.closePath();
};
const renderEllipse = (ctx, node) => {
  const { cx: cx2, cy: cy2, rx, ry } = node.props || {};
  drawEllipse(ctx, rx, ry, cx2, cy2);
};
const renderCircle = (ctx, node) => {
  var _a, _b, _c;
  const cx2 = (_a = node.props) == null ? void 0 : _a.cx;
  const cy2 = (_b = node.props) == null ? void 0 : _b.cy;
  const r2 = (_c = node.props) == null ? void 0 : _c.r;
  drawEllipse(ctx, r2, r2, cx2, cy2);
};
const number = (n3) => {
  if (n3 > -1e21 && n3 < 1e21) {
    return Math.round(n3 * 1e6) / 1e6;
  }
  throw new Error(`unsupported number: ${n3}`);
};
const _renderGlyphs = (ctx, encoded, positions, x, y2) => {
  const commands = [];
  const scale2 = ctx._fontSize / 1e3;
  let i2;
  let last2 = 0;
  let hadOffset = false;
  ctx.save();
  ctx.transform(1, 0, 0, -1, 0, ctx.page.height);
  y2 = ctx.page.height - y2;
  if (ctx.page.fonts[ctx._font.id] == null) {
    ctx.page.fonts[ctx._font.id] = ctx._font.ref();
  }
  ctx.addContent("BT");
  ctx.addContent(`1 0 0 1 ${number(x)} ${number(y2)} Tm`);
  ctx.addContent(`/${ctx._font.id} ${number(ctx._fontSize)} Tf`);
  const addSegment = (cur) => {
    if (last2 < cur) {
      const hex = encoded.slice(last2, cur).join("");
      const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;
      commands.push(`<${hex}> ${number(-advance)}`);
    }
    return last2 = cur;
  };
  const flush = (s2) => {
    addSegment(s2);
    if (commands.length > 0) {
      ctx.addContent(`[${commands.join(" ")}] TJ`);
      return commands.length = 0;
    }
  };
  for (i2 = 0; i2 < positions.length; i2 += 1) {
    const pos = positions[i2];
    if (pos.xOffset || pos.yOffset) {
      flush(i2);
      ctx.addContent(`1 0 0 1 ${number(x + pos.xOffset * scale2)} ${number(y2 + pos.yOffset * scale2)} Tm`);
      flush(i2 + 1);
      hadOffset = true;
    } else {
      if (hadOffset) {
        ctx.addContent(`1 0 0 1 ${number(x)} ${number(y2)} Tm`);
        hadOffset = false;
      }
      if (pos.xAdvance - pos.advanceWidth !== 0) {
        addSegment(i2 + 1);
      }
    }
    x += pos.xAdvance * scale2;
  }
  flush(i2);
  ctx.addContent("ET");
  return ctx.restore();
};
const renderGlyphs = (ctx, glyphs, positions, x, y2) => {
  const scale2 = 1e3 / ctx._fontSize;
  const unitsPerEm = ctx._font.font.unitsPerEm || 1e3;
  const advanceWidthScale = 1e3 / unitsPerEm;
  const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);
  const encodedPositions = positions.map((pos, i2) => ({
    xAdvance: pos.xAdvance * scale2,
    yAdvance: pos.yAdvance * scale2,
    xOffset: pos.xOffset,
    yOffset: pos.yOffset,
    advanceWidth: glyphs[i2].advanceWidth * advanceWidthScale
  }));
  return _renderGlyphs(ctx, encodedGlyphs, encodedPositions, x, y2);
};
const renderRun$1 = (ctx, run) => {
  var _a;
  if (!run.glyphs)
    return;
  if (!run.positions)
    return;
  const runAdvanceWidth = run.xAdvance;
  const font = (_a = run.attributes.font) == null ? void 0 : _a[0];
  const { fontSize, color, opacity } = run.attributes;
  if (color)
    ctx.fillColor(color);
  ctx.fillOpacity(opacity);
  if (font) {
    ctx.font(font.type === "STANDARD" ? font.fullName : font, fontSize);
  }
  try {
    renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);
  } catch (error) {
    console.log(error);
  }
  ctx.translate(runAdvanceWidth, 0);
};
const renderSpan = (ctx, line2, textAnchor, dominantBaseline) => {
  var _a, _b, _c, _d, _e, _f;
  ctx.save();
  const x = ((_a = line2.box) == null ? void 0 : _a.x) || 0;
  const y2 = ((_b = line2.box) == null ? void 0 : _b.y) || 0;
  const font = (_d = (_c = line2.runs[0]) == null ? void 0 : _c.attributes.font) == null ? void 0 : _d[0];
  const scale2 = ((_f = (_e = line2.runs[0]) == null ? void 0 : _e.attributes) == null ? void 0 : _f.scale) || 1;
  const width = line2.xAdvance;
  if (!font)
    return;
  const ascent2 = font.ascent * scale2;
  const xHeight = font.xHeight * scale2;
  const descent2 = font.descent * scale2;
  const capHeight = font.capHeight * scale2;
  let xTranslate = x;
  let yTranslate = y2;
  switch (textAnchor) {
    case "middle":
      xTranslate = x - width / 2;
      break;
    case "end":
      xTranslate = x - width;
      break;
    default:
      xTranslate = x;
      break;
  }
  switch (dominantBaseline) {
    case "middle":
    case "central":
      yTranslate = y2 + capHeight / 2;
      break;
    case "hanging":
      yTranslate = y2 + capHeight;
      break;
    case "mathematical":
      yTranslate = y2 + xHeight;
      break;
    case "text-after-edge":
      yTranslate = y2 + descent2;
      break;
    case "text-before-edge":
      yTranslate = y2 + ascent2;
      break;
    default:
      yTranslate = y2;
      break;
  }
  ctx.translate(xTranslate, yTranslate);
  line2.runs.forEach((run) => renderRun$1(ctx, run));
  ctx.restore();
};
const renderSvgText = (ctx, node) => {
  const children = node.children;
  children.forEach((span) => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));
};
const pairs = (values) => {
  const result = [];
  for (let i2 = 0; i2 < values.length; i2 += 2) {
    result.push([values[i2], values[i2 + 1]]);
  }
  return result;
};
const parsePoints = (points) => {
  let values = (points || "").trim().replace(/,/g, " ").replace(/(\d)-(\d)/g, "$1 -$2").split(/\s+/);
  if (values.length % 2 !== 0) {
    values = values.slice(0, -1);
  }
  const mappedValues = values.map(parseFloat);
  return pairs(mappedValues);
};
const drawPolyline = (ctx, points) => {
  if (points.length > 0) {
    ctx.moveTo(points[0][0], points[0][1]);
    points.slice(1).forEach((p2) => ctx.lineTo(p2[0], p2[1]));
  }
};
const renderPolyline = (ctx, node) => {
  const points = parsePoints(node.props.points || "");
  drawPolyline(ctx, points);
};
const renderPolygon = (ctx, node) => {
  const points = parsePoints(node.props.points || "");
  drawPolyline(ctx, points);
  ctx.closePath();
};
const renderImage$1 = (ctx, node) => {
  var _a;
  if (!node.box)
    return;
  if (!((_a = node.image) == null ? void 0 : _a.data))
    return;
  const { x = 0, y: y2 = 0 } = node.props;
  const { width, height: height2, opacity } = node.style;
  const paddingTop = node.box.paddingLeft || 0;
  const paddingLeft = node.box.paddingLeft || 0;
  if (width === 0 || height2 === 0) {
    console.warn(`Image with src '${node.props.href}' skipped due to invalid dimensions`);
    return;
  }
  if (typeof width === "string" || typeof height2 === "string") {
    console.warn(`Image with src '${node.props.href}' skipped due to percentage width or height`);
    return;
  }
  ctx.save();
  ctx.fillOpacity(opacity || 1).image(node.image.data, x + paddingLeft, y2 + paddingTop, {
    width,
    height: height2
  });
  ctx.restore();
};
const KAPPA$1 = 4 * ((Math.sqrt(2) - 1) / 3);
const clipNode = (ctx, node) => {
  if (!node.box)
    return;
  if (!node.style)
    return;
  const { top, left, width, height: height2 } = node.box;
  const { borderTopLeftRadius = 0, borderTopRightRadius = 0, borderBottomRightRadius = 0, borderBottomLeftRadius = 0 } = node.style;
  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height2);
  const ctr = rtr * (1 - KAPPA$1);
  ctx.moveTo(left + rtr, top);
  ctx.lineTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);
  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height2);
  const cbr = rbr * (1 - KAPPA$1);
  ctx.lineTo(left + width, top + height2 - rbr);
  ctx.bezierCurveTo(left + width, top + height2 - cbr, left + width - cbr, top + height2, left + width - rbr, top + height2);
  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height2);
  const cbl = rbl * (1 - KAPPA$1);
  ctx.lineTo(left + rbl, top + height2);
  ctx.bezierCurveTo(left + cbl, top + height2, left, top + height2 - cbl, left, top + height2 - rbl);
  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height2);
  const ctl = rtl * (1 - KAPPA$1);
  ctx.lineTo(left, top + rtl);
  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);
  ctx.closePath();
  ctx.clip();
};
const applySingleTransformation = (ctx, transform2, origin) => {
  const { operation, value: value2 } = transform2;
  switch (operation) {
    case "scale": {
      const [scaleX, scaleY] = value2;
      ctx.scale(scaleX, scaleY, { origin });
      break;
    }
    case "rotate": {
      const [angle] = value2;
      ctx.rotate(angle, { origin });
      break;
    }
    case "translate": {
      const [x, y2 = 0] = value2;
      ctx.translate(x, y2, { origin });
      break;
    }
    case "skew": {
      const [xAngle = 0, yAngle = 0] = value2;
      const radx = xAngle * Math.PI / 180;
      const rady = yAngle * Math.PI / 180;
      const tanx = Math.tan(radx);
      const tany = Math.tan(rady);
      let x = 0;
      let y2 = 0;
      if (origin != null) {
        [x, y2] = Array.from(origin);
        const x1 = x + tanx * y2;
        const y1 = y2 + tany * x;
        x -= x1;
        y2 -= y1;
      }
      ctx.transform(1, tany, tanx, 1, x, y2);
      break;
    }
    case "matrix": {
      ctx.transform(...value2);
      break;
    }
    default: {
      console.error(`Transform operation: '${operation}' doesn't supported`);
    }
  }
};
const applyTransformations = (ctx, node) => {
  if (!node.origin)
    return;
  const { props, style } = node;
  const origin = [node.origin.left, node.origin.top];
  const propsTransform = "transform" in props ? props.transform : void 0;
  const operations = (style == null ? void 0 : style.transform) || propsTransform || [];
  operations.forEach((operation) => {
    applySingleTransformation(ctx, operation, origin);
  });
};
const getPathBoundingBox = (node) => {
  var _a;
  const path = normalize$2(absPath(parsePath(((_a = node.props) == null ? void 0 : _a.d) || "")));
  if (!path.length)
    return [0, 0, 0, 0];
  const bounds = [Infinity, Infinity, -Infinity, -Infinity];
  for (let i2 = 0, l2 = path.length; i2 < l2; i2 += 1) {
    const points = path[i2].slice(1);
    for (let j = 0; j < points.length; j += 2) {
      if (points[j + 0] < bounds[0])
        bounds[0] = points[j + 0];
      if (points[j + 1] < bounds[1])
        bounds[1] = points[j + 1];
      if (points[j + 0] > bounds[2])
        bounds[2] = points[j + 0];
      if (points[j + 1] > bounds[3])
        bounds[3] = points[j + 1];
    }
  }
  return bounds;
};
const getCircleBoundingBox = (node) => {
  var _a, _b, _c;
  const r2 = ((_a = node.props) == null ? void 0 : _a.r) || 0;
  const cx2 = ((_b = node.props) == null ? void 0 : _b.cx) || 0;
  const cy2 = ((_c = node.props) == null ? void 0 : _c.cy) || 0;
  return [cx2 - r2, cy2 - r2, cx2 + r2, cy2 + r2];
};
const getEllipseBoundingBox = (node) => {
  var _a, _b, _c, _d;
  const cx2 = ((_a = node.props) == null ? void 0 : _a.cx) || 0;
  const cy2 = ((_b = node.props) == null ? void 0 : _b.cy) || 0;
  const rx = ((_c = node.props) == null ? void 0 : _c.rx) || 0;
  const ry = ((_d = node.props) == null ? void 0 : _d.ry) || 0;
  return [cx2 - rx, cy2 - ry, cx2 + rx, cy2 + ry];
};
const getLineBoundingBox = (node) => {
  var _a, _b, _c, _d;
  const x1 = ((_a = node.props) == null ? void 0 : _a.x1) || 0;
  const y1 = ((_b = node.props) == null ? void 0 : _b.y1) || 0;
  const x2 = ((_c = node.props) == null ? void 0 : _c.x2) || 0;
  const y2 = ((_d = node.props) == null ? void 0 : _d.y2) || 0;
  return [
    Math.min(x1, x2),
    Math.min(y1, y2),
    Math.max(x1, x2),
    Math.max(y1, y2)
  ];
};
const getRectBoundingBox = (node) => {
  var _a, _b, _c, _d;
  const x = ((_a = node.props) == null ? void 0 : _a.x) || 0;
  const y2 = ((_b = node.props) == null ? void 0 : _b.y) || 0;
  const width = ((_c = node.props) == null ? void 0 : _c.width) || 0;
  const height2 = ((_d = node.props) == null ? void 0 : _d.height) || 0;
  return [x, y2, x + width, y2 + height2];
};
const max = (values) => Math.max(-Infinity, ...values);
const min = (values) => Math.min(Infinity, ...values);
const getPolylineBoundingBox = (node) => {
  var _a;
  const points = parsePoints((_a = node.props) == null ? void 0 : _a.points);
  const xValues = points.map((p2) => p2[0]);
  const yValues = points.map((p2) => p2[1]);
  return [min(xValues), min(yValues), max(xValues), max(yValues)];
};
const boundingBoxFns = {
  [Rect]: getRectBoundingBox,
  [Line]: getLineBoundingBox,
  [Path]: getPathBoundingBox,
  [Circle]: getCircleBoundingBox,
  [Ellipse]: getEllipseBoundingBox,
  [Polygon]: getPolylineBoundingBox,
  [Polyline]: getPolylineBoundingBox
};
const getBoundingBox = (node) => {
  const boundingBoxFn = boundingBoxFns[node.type];
  return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];
};
const setStrokeWidth = (ctx, node) => {
  if (!node.props)
    return;
  if (!("strokeWidth" in node.props))
    return;
  const lineWidth = node.props.strokeWidth;
  if (lineWidth)
    ctx.lineWidth(lineWidth);
};
const setStrokeColor = (ctx, node) => {
  if (!node.props)
    return;
  if (!("stroke" in node.props))
    return;
  const strokeColor = node.props.stroke;
  if (strokeColor)
    ctx.strokeColor(strokeColor);
};
const setOpacity = (ctx, node) => {
  if (!node.props)
    return;
  if (!("opacity" in node.props))
    return;
  const opacity = node.props.opacity;
  if (!isNil(opacity))
    ctx.opacity(opacity);
};
const setFillOpacity = (ctx, node) => {
  if (!node.props)
    return;
  if (!("fillOpacity" in node.props))
    return;
  const fillOpacity = node.props.fillOpacity || null;
  if (!isNil(fillOpacity))
    ctx.fillOpacity(fillOpacity);
};
const setStrokeOpacity = (ctx, node) => {
  var _a;
  if (!node.props)
    return;
  if (!("strokeOpacity" in node.props))
    return;
  const strokeOpacity = (_a = node.props) == null ? void 0 : _a.strokeOpacity;
  if (!isNil(strokeOpacity))
    ctx.strokeOpacity(strokeOpacity);
};
const setLineJoin = (ctx, node) => {
  if (!node.props)
    return;
  if (!("strokeLinejoin" in node.props))
    return;
  const lineJoin = node.props.strokeLinejoin;
  if (lineJoin)
    ctx.lineJoin(lineJoin);
};
const setLineCap = (ctx, node) => {
  var _a;
  if (!node.props)
    return;
  if (!("strokeLinecap" in node.props))
    return;
  const lineCap = (_a = node.props) == null ? void 0 : _a.strokeLinecap;
  if (lineCap)
    ctx.lineCap(lineCap);
};
const setLineDash = (ctx, node) => {
  var _a;
  if (!node.props)
    return;
  if (!("strokeDasharray" in node.props))
    return;
  const value2 = ((_a = node.props) == null ? void 0 : _a.strokeDasharray) || null;
  if (value2)
    ctx.dash(value2.split(/[\s,]+/).map(Number));
};
const hasLinearGradientFill = (node) => {
  var _a;
  if (!node.props)
    return false;
  if (!("fill" in node.props))
    return false;
  if (typeof node.props.fill === "string")
    return false;
  return ((_a = node.props.fill) == null ? void 0 : _a.type) === LinearGradient;
};
const hasRadialGradientFill = (node) => {
  var _a;
  if (!node.props)
    return false;
  if (!("fill" in node.props))
    return false;
  if (typeof node.props.fill === "string")
    return false;
  return ((_a = node.props.fill) == null ? void 0 : _a.type) === RadialGradient;
};
function multiplyMatrices(m1, m2) {
  const a2 = m1[0] * m2[0] + m1[2] * m2[1];
  const b2 = m1[1] * m2[0] + m1[3] * m2[1];
  const c2 = m1[0] * m2[2] + m1[2] * m2[3];
  const d2 = m1[1] * m2[2] + m1[3] * m2[3];
  const e2 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
  const f2 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
  return [a2, b2, c2, d2, e2, f2];
}
const transformGradient = (grad, transforms, bbox, units) => {
  const matrices = transforms.map((transform2) => {
    switch (transform2.operation) {
      case "scale": {
        const value2 = transform2.value;
        return [value2[0], 0, 0, value2[1], 0, 0];
      }
      case "translate": {
        const value2 = transform2.value;
        let x = value2[0] || 0;
        let y2 = value2[1] || 0;
        if (units === "objectBoundingBox") {
          x = (bbox[2] - bbox[0]) * x;
          y2 = (bbox[3] - bbox[1]) * y2;
        }
        return [1, 0, 0, 1, x, y2];
      }
      case "rotate": {
        const value2 = transform2.value;
        const cos = Math.cos(value2[0]);
        const sin = Math.sin(value2[0]);
        return [cos, sin, -sin, cos, 0, 0];
      }
      case "skew": {
        const value2 = transform2.value;
        return [1, Math.tan(value2[0]), Math.tan(value2[1]), 1, 0, 0];
      }
      case "matrix": {
        const value2 = transform2.value;
        let x = value2[4] || 0;
        let y2 = value2[5] || 0;
        if (units === "objectBoundingBox") {
          x = (bbox[2] - bbox[0]) * x;
          y2 = (bbox[3] - bbox[1]) * y2;
        }
        return [value2[0], value2[1], value2[2], value2[3], x, y2];
      }
      default:
        return [1, 0, 0, 1, 0, 0];
    }
  });
  const matrix = matrices.reduce(multiplyMatrices, [1, 0, 0, 1, 0, 0]);
  grad.setTransform(...matrix);
};
const setLinearGradientFill = (ctx, node) => {
  var _a, _b;
  if (!node.props)
    return;
  if (!("fill" in node.props))
    return;
  const bbox = getBoundingBox(node);
  const gradient = (_a = node.props) == null ? void 0 : _a.fill;
  if (!gradient)
    return;
  const units = gradient.props.gradientUnits || "objectBoundingBox";
  const transforms = gradient.props.gradientTransform || [];
  let x1 = gradient.props.x1 || 0;
  let y1 = gradient.props.y1 || 0;
  let x2 = gradient.props.x2 || 1;
  let y2 = gradient.props.y2 || 0;
  if (units === "objectBoundingBox") {
    const m0 = bbox[2] - bbox[0];
    const m3 = bbox[3] - bbox[1];
    const m4 = bbox[0];
    const m5 = bbox[1];
    x1 = m0 * x1 + m4;
    y1 = m3 * y1 + m5;
    x2 = m0 * x2 + m4;
    y2 = m3 * y2 + m5;
  }
  const grad = ctx.linearGradient(x1, y1, x2, y2);
  transformGradient(grad, transforms, bbox, units);
  (_b = gradient.children) == null ? void 0 : _b.forEach((stop) => {
    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);
  });
  ctx.fill(grad);
};
const setRadialGradientFill = (ctx, node) => {
  var _a, _b;
  if (!node.props)
    return;
  if (!("fill" in node.props))
    return;
  const bbox = getBoundingBox(node);
  const gradient = (_a = node.props) == null ? void 0 : _a.fill;
  if (!gradient)
    return;
  const units = gradient.props.gradientUnits || "objectBoundingBox";
  const transforms = gradient.props.gradientTransform || [];
  let r2 = gradient.props.r || 0.5;
  let cx2 = gradient.props.cx || 0.5;
  let cy2 = gradient.props.cy || 0.5;
  let fx = gradient.props.fx || cx2;
  let fy = gradient.props.fy || cy2;
  if (units === "objectBoundingBox") {
    const m0 = bbox[2] - bbox[0];
    const m3 = bbox[3] - bbox[1];
    const m4 = bbox[0];
    const m5 = bbox[1];
    r2 = r2 * m0;
    cx2 = m0 * cx2 + m4;
    cy2 = m3 * cy2 + m5;
    fx = m0 * fx + m4;
    fy = m3 * fy + m5;
  }
  const grad = ctx.radialGradient(cx2, cy2, 0, fx, fy, r2);
  transformGradient(grad, transforms, bbox, units);
  (_b = gradient.children) == null ? void 0 : _b.forEach((stop) => {
    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);
  });
  ctx.fill(grad);
};
const setFillColor = (ctx, node) => {
  var _a;
  if (!node.props)
    return;
  if (!("fill" in node.props))
    return;
  const fillColor = (_a = node.props) == null ? void 0 : _a.fill;
  if (fillColor)
    ctx.fillColor(fillColor);
};
const setFill = (ctx, node) => {
  if (hasLinearGradientFill(node))
    return setLinearGradientFill(ctx, node);
  if (hasRadialGradientFill(node))
    return setRadialGradientFill(ctx, node);
  return setFillColor(ctx, node);
};
const draw = (ctx, node) => {
  const props = node.props || {};
  if ("fill" in props && "stroke" in props && props.fill && props.stroke) {
    ctx.fillAndStroke(props.fillRule);
  } else if ("fill" in props && props.fill) {
    ctx.fill(props.fillRule);
  } else if ("stroke" in props && props.stroke) {
    ctx.stroke();
  } else {
    ctx.save();
    ctx.opacity(0);
    ctx.fill(null);
    ctx.restore();
  }
};
const noop = () => {
};
const renderFns$1 = {
  [Tspan]: noop,
  [TextInstance]: noop,
  [Path]: renderPath,
  [Rect]: renderRect,
  [Line]: renderLine$1,
  [G]: renderGroup,
  [Text]: renderSvgText,
  [Circle]: renderCircle,
  [Image]: renderImage$1,
  [Ellipse]: renderEllipse,
  [Polygon]: renderPolygon,
  [Polyline]: renderPolyline
};
const renderNode$1 = (ctx, node) => {
  const renderFn = renderFns$1[node.type];
  if (renderFn) {
    renderFn(ctx, node);
  } else {
    console.warn(`SVG node of type ${node.type} is not currently supported`);
  }
};
const drawNode = (ctx, node) => {
  setLineCap(ctx, node);
  setLineDash(ctx, node);
  setLineJoin(ctx, node);
  setStrokeWidth(ctx, node);
  setStrokeColor(ctx, node);
  setFill(ctx, node);
  setStrokeOpacity(ctx, node);
  setFillOpacity(ctx, node);
  setOpacity(ctx, node);
  applyTransformations(ctx, node);
  renderNode$1(ctx, node);
  draw(ctx, node);
};
const clipPath = (ctx, node) => {
  if (!node.props)
    return;
  if (!("clipPath" in node.props))
    return;
  const value2 = node.props.clipPath;
  if (value2) {
    const children = value2.children || [];
    children.forEach((child) => renderNode$1(ctx, child));
    ctx.clip();
  }
};
const drawChildren = (ctx, node) => {
  const children = node.children || [];
  children.forEach((child) => {
    ctx.save();
    clipPath(ctx, child);
    drawNode(ctx, child);
    drawChildren(ctx, child);
    ctx.restore();
  });
};
const resolveAspectRatio = (ctx, node) => {
  if (!node.box)
    return;
  const { width, height: height2 } = node.box;
  const { viewBox, preserveAspectRatio } = node.props;
  const { meetOrSlice = "meet", align = "xMidYMid" } = preserveAspectRatio || {};
  if (viewBox == null || width == null || height2 == null)
    return;
  const x = (viewBox == null ? void 0 : viewBox.minX) || 0;
  const y2 = (viewBox == null ? void 0 : viewBox.minY) || 0;
  const logicalWidth = (viewBox == null ? void 0 : viewBox.maxX) || width;
  const logicalHeight = (viewBox == null ? void 0 : viewBox.maxY) || height2;
  const logicalRatio = logicalWidth / logicalHeight;
  const physicalRatio = width / height2;
  const scaleX = width / logicalWidth;
  const scaleY = height2 / logicalHeight;
  if (align === "none") {
    ctx.scale(scaleX, scaleY);
    ctx.translate(-x, -y2);
    return;
  }
  if (logicalRatio < physicalRatio && meetOrSlice === "meet" || logicalRatio >= physicalRatio && meetOrSlice === "slice") {
    ctx.scale(scaleY, scaleY);
    switch (align) {
      case "xMinYMin":
      case "xMinYMid":
      case "xMinYMax":
        ctx.translate(-x, -y2);
        break;
      case "xMidYMin":
      case "xMidYMid":
      case "xMidYMax":
        ctx.translate(-x - (logicalWidth - width * logicalHeight / height2) / 2, -y2);
        break;
      default:
        ctx.translate(-x - (logicalWidth - width * logicalHeight / height2), -y2);
    }
  } else {
    ctx.scale(scaleX, scaleX);
    switch (align) {
      case "xMinYMin":
      case "xMidYMin":
      case "xMaxYMin":
        ctx.translate(-x, -y2);
        break;
      case "xMinYMid":
      case "xMidYMid":
      case "xMaxYMid":
        ctx.translate(-x, -y2 - (logicalHeight - height2 * logicalWidth / width) / 2);
        break;
      default:
        ctx.translate(-x, -y2 - (logicalHeight - height2 * logicalWidth / width));
    }
  }
};
const moveToOrigin = (ctx, node) => {
  if (!node.box)
    return;
  const { top, left } = node.box;
  const paddingLeft = node.box.paddingLeft || 0;
  const paddingTop = node.box.paddingTop || 0;
  ctx.translate(left + paddingLeft, top + paddingTop);
};
const renderSvg = (ctx, node) => {
  ctx.save();
  clipNode(ctx, node);
  moveToOrigin(ctx, node);
  resolveAspectRatio(ctx, node);
  drawChildren(ctx, node);
  ctx.restore();
};
const black = { value: "#000", opacity: 1 };
const parseColor = (hex) => {
  if (!hex)
    return black;
  const parsed = colorString.get(hex);
  if (!parsed)
    return black;
  const value2 = colorString.to.hex(parsed.value.slice(0, 3));
  const opacity = parsed.value[3];
  return { value: value2, opacity };
};
const DEST_REGEXP = /^#.+/;
const isSrcId$1 = (src2) => src2.match(DEST_REGEXP);
const renderAttachment = (ctx, attachment) => {
  const { xOffset = 0, yOffset = 0, width, height: height2, image } = attachment;
  ctx.translate(-width + xOffset, -height2 + yOffset);
  ctx.image(image, 0, 0, {
    fit: [width, height2],
    align: "center",
    valign: "bottom"
  });
};
const renderAttachments = (ctx, run) => {
  var _a;
  if (!run.glyphs)
    return;
  if (!run.positions)
    return;
  const font = (_a = run.attributes.font) == null ? void 0 : _a[0];
  if (!font)
    return;
  ctx.save();
  const space = font.glyphForCodePoint(32);
  const objectReplacement = font.glyphForCodePoint(65532);
  let attachmentAdvance = 0;
  for (let i2 = 0; i2 < run.glyphs.length; i2 += 1) {
    const position = run.positions[i2];
    const glyph = run.glyphs[i2];
    attachmentAdvance += position.xAdvance || 0;
    if (glyph.id === objectReplacement.id && run.attributes.attachment) {
      ctx.translate(attachmentAdvance, position.yOffset || 0);
      renderAttachment(ctx, run.attributes.attachment);
      run.glyphs[i2] = space;
      attachmentAdvance = 0;
    }
  }
  ctx.restore();
};
const renderRun = (ctx, run) => {
  var _a;
  if (!run.glyphs)
    return;
  if (!run.positions)
    return;
  const font = (_a = run.attributes.font) == null ? void 0 : _a[0];
  if (!font)
    return;
  const { fontSize, link } = run.attributes;
  const color = parseColor(run.attributes.color);
  const opacity = isNil(run.attributes.opacity) ? color.opacity : run.attributes.opacity;
  const { height: height2 = 0, descent: descent2 = 0, xAdvance = 0 } = run;
  ctx.fillColor(color.value);
  ctx.fillOpacity(opacity);
  if (link) {
    if (isSrcId$1(link)) {
      ctx.goTo(0, -height2 - descent2, xAdvance, height2, link.slice(1));
    } else {
      ctx.link(0, -height2 - descent2, xAdvance, height2, link);
    }
  }
  renderAttachments(ctx, run);
  ctx.font(font.type === "STANDARD" ? font.fullName : font, fontSize);
  try {
    renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);
  } catch (error) {
    console.log(error);
  }
  ctx.translate(xAdvance, 0);
};
const renderBackground$1 = (ctx, rect, backgroundColor) => {
  const color = parseColor(backgroundColor);
  ctx.save();
  ctx.fillOpacity(color.opacity);
  ctx.rect(rect.x, rect.y, rect.width, rect.height);
  ctx.fill(color.value);
  ctx.restore();
};
const renderDecorationLine = (ctx, decorationLine) => {
  ctx.save();
  ctx.lineWidth(decorationLine.rect.height);
  ctx.strokeOpacity(decorationLine.opacity);
  if (/dashed/.test(decorationLine.style)) {
    ctx.dash(3 * decorationLine.rect.height, {});
  } else if (/dotted/.test(decorationLine.style)) {
    ctx.dash(decorationLine.rect.height, {});
  }
  if (/wavy/.test(decorationLine.style)) {
    const dist = Math.max(2, decorationLine.rect.height);
    let step = 1.1 * dist;
    const stepCount = Math.floor(decorationLine.rect.width / (2 * step));
    const remainingWidth = decorationLine.rect.width - stepCount * 2 * step;
    const adjustment = remainingWidth / stepCount / 2;
    step += adjustment;
    const cp1y = decorationLine.rect.y + dist;
    const cp2y = decorationLine.rect.y - dist;
    let { x } = decorationLine.rect;
    ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);
    for (let i2 = 0; i2 < stepCount; i2 += 1) {
      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, decorationLine.rect.y);
      x += 2 * step;
    }
  } else {
    ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y);
    ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y);
    if (/double/.test(decorationLine.style)) {
      ctx.moveTo(decorationLine.rect.x, decorationLine.rect.y + decorationLine.rect.height * 2);
      ctx.lineTo(decorationLine.rect.x + decorationLine.rect.width, decorationLine.rect.y + decorationLine.rect.height * 2);
    }
  }
  ctx.stroke(decorationLine.color);
  ctx.restore();
};
const renderLine = (ctx, line2) => {
  if (!line2.box)
    return;
  const lineAscent = line2.ascent || 0;
  ctx.save();
  ctx.translate(line2.box.x, line2.box.y + lineAscent);
  for (let i2 = 0; i2 < line2.runs.length; i2 += 1) {
    const run = line2.runs[i2];
    const isLastRun = i2 === line2.runs.length - 1;
    if (run.attributes.backgroundColor) {
      const xAdvance = run.xAdvance ?? 0;
      const overflowRight = isLastRun ? line2.overflowRight ?? 0 : 0;
      const backgroundRect = {
        x: 0,
        y: -lineAscent,
        height: line2.box.height,
        width: xAdvance - overflowRight
      };
      renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);
    }
    renderRun(ctx, run);
  }
  ctx.restore();
  ctx.save();
  ctx.translate(line2.box.x, line2.box.y);
  if (line2.decorationLines) {
    for (let i2 = 0; i2 < line2.decorationLines.length; i2 += 1) {
      const decorationLine = line2.decorationLines[i2];
      renderDecorationLine(ctx, decorationLine);
    }
  }
  ctx.restore();
};
const renderBlock = (ctx, block) => {
  block.forEach((line2) => {
    renderLine(ctx, line2);
  });
};
const renderText = (ctx, node) => {
  var _a, _b;
  if (!node.box)
    return;
  if (!node.lines)
    return;
  const { top, left } = node.box;
  const blocks = [node.lines];
  const paddingTop = ((_a = node.box) == null ? void 0 : _a.paddingTop) || 0;
  const paddingLeft = ((_b = node.box) == null ? void 0 : _b.paddingLeft) || 0;
  const initialY = node.lines[0] ? node.lines[0].box.y : 0;
  const offsetX = node.alignOffset || 0;
  ctx.save();
  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);
  blocks.forEach((block) => {
    renderBlock(ctx, block);
  });
  ctx.restore();
};
const renderPage = (ctx, node) => {
  var _a;
  if (!node.box)
    return;
  const { width, height: height2 } = node.box;
  const dpi = ((_a = node.props) == null ? void 0 : _a.dpi) || 72;
  const userUnit = dpi / 72;
  ctx.addPage({ size: [width, height2], margin: 0, userUnit });
};
const renderNote = (ctx, node) => {
  var _a, _b;
  if (!node.box)
    return;
  const { top, left } = node.box;
  const value2 = ((_a = node == null ? void 0 : node.children) == null ? void 0 : _a[0].value) || "";
  const color = (_b = node.style) == null ? void 0 : _b.backgroundColor;
  ctx.note(left, top, 0, 0, value2, { color });
};
const embedImage = (ctx, node) => {
  const src2 = node.image.data;
  let image;
  if (typeof src2 === "string") {
    image = ctx._imageRegistry[src2];
  }
  if (!image) {
    image = ctx.openImage(src2);
  }
  if (!image.obj) {
    image.embed(ctx);
  }
  return image;
};
const isNumeric = (n3) => {
  return !Number.isNaN(parseFloat(n3)) && Number.isFinite(n3);
};
const applyContainObjectFit = (cw, ch, iw, ih, px2, py2) => {
  const cr = cw / ch;
  const ir = iw / ih;
  const pxp = matchPercent(px2 ?? null);
  const pyp = matchPercent(py2 ?? null);
  const pxv = pxp ? pxp.percent : 0.5;
  const pyv = pyp ? pyp.percent : 0.5;
  if (cr > ir) {
    const height3 = ch;
    const width2 = height3 * ir;
    const yOffset2 = isNumeric(py2) ? py2 : 0;
    const xOffset2 = isNumeric(px2) ? px2 : (cw - width2) * pxv;
    return { width: width2, height: height3, xOffset: xOffset2, yOffset: yOffset2 };
  }
  const width = cw;
  const height2 = width / ir;
  const xOffset = isNumeric(px2) ? px2 : 0;
  const yOffset = isNumeric(py2) ? py2 : (ch - height2) * pyv;
  return { width, height: height2, yOffset, xOffset };
};
const applyNoneObjectFit = (cw, ch, iw, ih, px2, py2) => {
  const width = iw;
  const height2 = ih;
  const pxp = matchPercent(px2 ?? null);
  const pyp = matchPercent(py2 ?? null);
  const pxv = pxp ? pxp.percent : 0.5;
  const pyv = pyp ? pyp.percent : 0.5;
  const xOffset = isNumeric(px2) ? px2 : (cw - width) * pxv;
  const yOffset = isNumeric(py2) ? py2 : (ch - height2) * pyv;
  return { width, height: height2, xOffset, yOffset };
};
const applyCoverObjectFit = (cw, ch, iw, ih, px2, py2) => {
  const ir = iw / ih;
  const cr = cw / ch;
  const pxp = matchPercent(px2 ?? null);
  const pyp = matchPercent(py2 ?? null);
  const pxv = pxp ? pxp.percent : 0.5;
  const pyv = pyp ? pyp.percent : 0.5;
  if (cr > ir) {
    const width2 = cw;
    const height3 = width2 / ir;
    const xOffset2 = isNumeric(px2) ? px2 : 0;
    const yOffset2 = isNumeric(py2) ? py2 : (ch - height3) * pyv;
    return { width: width2, height: height3, yOffset: yOffset2, xOffset: xOffset2 };
  }
  const height2 = ch;
  const width = height2 * ir;
  const xOffset = isNumeric(px2) ? px2 : (cw - width) * pxv;
  const yOffset = isNumeric(py2) ? py2 : 0;
  return { width, height: height2, xOffset, yOffset };
};
const applyScaleDownObjectFit = (cw, ch, iw, ih, px2, py2) => {
  const containDimension = applyContainObjectFit(cw, ch, iw, ih, px2, py2);
  const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px2, py2);
  return containDimension.width < noneDimension.width ? containDimension : noneDimension;
};
const applyFillObjectFit = (cw, ch, px2, py2) => {
  return {
    width: cw,
    height: ch,
    xOffset: matchPercent(px2 ?? null) ? 0 : px2 || 0,
    yOffset: matchPercent(py2 ?? null) ? 0 : py2 || 0
  };
};
const resolveObjectFit = (type = "fill", cw, ch, iw, ih, px2, py2) => {
  switch (type) {
    case "contain":
      return applyContainObjectFit(cw, ch, iw, ih, px2, py2);
    case "cover":
      return applyCoverObjectFit(cw, ch, iw, ih, px2, py2);
    case "none":
      return applyNoneObjectFit(cw, ch, iw, ih, px2, py2);
    case "scale-down":
      return applyScaleDownObjectFit(cw, ch, iw, ih, px2, py2);
    default:
      return applyFillObjectFit(cw, ch, px2, py2);
  }
};
const drawImage = (ctx, node, options) => {
  var _a, _b, _c, _d;
  if (!node.box)
    return;
  if (!node.image)
    return;
  const { left, top } = node.box;
  const opacity = (_a = node.style) == null ? void 0 : _a.opacity;
  const objectFit = (_b = node.style) == null ? void 0 : _b.objectFit;
  const objectPositionX = (_c = node.style) == null ? void 0 : _c.objectPositionX;
  const objectPositionY = (_d = node.style) == null ? void 0 : _d.objectPositionY;
  const paddingTop = node.box.paddingTop || 0;
  const paddingRight = node.box.paddingRight || 0;
  const paddingBottom = node.box.paddingBottom || 0;
  const paddingLeft = node.box.paddingLeft || 0;
  const imageCache = options.imageCache || /* @__PURE__ */ new Map();
  const { width, height: height2, xOffset, yOffset } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);
  if (node.image.data) {
    if (width !== 0 && height2 !== 0) {
      const cacheKey = node.image.key;
      const image = imageCache.get(cacheKey) || embedImage(ctx, node);
      if (cacheKey)
        imageCache.set(cacheKey, image);
      const imageOpacity = isNil(opacity) ? 1 : opacity;
      ctx.fillOpacity(imageOpacity).image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {
        width,
        height: height2
      });
    } else {
      console.warn(`Image with src '${JSON.stringify(node.props.src || node.props.source)}' skipped due to invalid dimensions`);
    }
  }
};
const renderImage = (ctx, node, options) => {
  ctx.save();
  clipNode(ctx, node);
  drawImage(ctx, node, options);
  ctx.restore();
};
const CONTENT_COLOR = "#a1c6e7";
const PADDING_COLOR = "#c4deb9";
const MARGIN_COLOR = "#f8cca1";
const debugContent = (ctx, node) => {
  if (!node.box)
    return;
  const { left, top, width, height: height2, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0 } = node.box;
  ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height2 - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();
};
const debugPadding = (ctx, node) => {
  if (!node.box)
    return;
  const { left, top, width, height: height2, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0, borderLeftWidth = 0, borderTopWidth = 0, borderRightWidth = 0, borderBottomWidth = 0 } = node.box;
  ctx.fillColor(PADDING_COLOR).opacity(0.5);
  ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill();
  ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height2 - borderTopWidth - borderBottomWidth).fill();
  ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height2 - borderTopWidth - borderBottomWidth).fill();
  ctx.rect(left + paddingLeft + borderLeftWidth, top + height2 - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();
};
const debugMargin = (ctx, node) => {
  if (!node.box)
    return;
  const { left, top, width, height: height2 } = node.box;
  const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0 } = node.box;
  ctx.fillColor(MARGIN_COLOR).opacity(0.5);
  ctx.rect(left, top - marginTop, width, marginTop).fill();
  ctx.rect(left - marginLeft, top - marginTop, marginLeft, height2 + marginTop + marginBottom).fill();
  ctx.rect(left + width, top - marginTop, marginRight, height2 + marginTop + marginBottom).fill();
  ctx.rect(left, top + height2, width, marginBottom).fill();
};
const debugText = (ctx, node) => {
  if (!node.box)
    return;
  const { left, top, width, height: height2 } = node.box;
  const { marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0 } = node.box;
  const roundedWidth = Math.round(width + marginLeft + marginRight);
  const roundedHeight = Math.round(height2 + marginTop + marginBottom);
  ctx.fontSize(6).opacity(1).fillColor("black").text(`${roundedWidth} x ${roundedHeight}`, left - marginLeft, Math.max(top - marginTop - 4, 1), { width: Infinity });
};
const debugOrigin = (ctx, node) => {
  if (node.origin) {
    ctx.circle(node.origin.left, node.origin.top, 3).fill("red").circle(node.origin.left, node.origin.top, 5).stroke("red");
  }
};
const renderDebug = (ctx, node) => {
  if (!node.props)
    return;
  if (!("debug" in node.props) || !node.props.debug)
    return;
  ctx.save();
  debugContent(ctx, node);
  debugPadding(ctx, node);
  debugMargin(ctx, node);
  debugText(ctx, node);
  debugOrigin(ctx, node);
  ctx.restore();
};
const availableMethods = [
  "dash",
  "clip",
  "save",
  "path",
  "fill",
  "font",
  "text",
  "rect",
  "scale",
  "moveTo",
  "lineTo",
  "stroke",
  "rotate",
  "circle",
  "lineCap",
  "opacity",
  "ellipse",
  "polygon",
  "restore",
  "lineJoin",
  "fontSize",
  "fillColor",
  "lineWidth",
  "translate",
  "miterLimit",
  "strokeColor",
  "fillOpacity",
  "roundedRect",
  "fillAndStroke",
  "strokeOpacity",
  "bezierCurveTo",
  "quadraticCurveTo",
  "linearGradient",
  "radialGradient"
];
const painter = (ctx) => {
  const p2 = availableMethods.reduce((acc, prop) => ({
    ...acc,
    [prop]: (...args) => {
      ctx[prop](...args);
      return p2;
    }
  }), {});
  return p2;
};
const renderCanvas = (ctx, node) => {
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box;
  const paddingTop = node.box.paddingTop || 0;
  const paddingLeft = node.box.paddingLeft || 0;
  const paddingRight = node.box.paddingRight || 0;
  const paddingBottom = node.box.paddingBottom || 0;
  const availableWidth = width - paddingLeft - paddingRight;
  const availableHeight = height2 - paddingTop - paddingBottom;
  if (!availableWidth || !availableHeight) {
    console.warn("Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.");
  }
  ctx.save().translate(left + paddingLeft, top + paddingTop);
  if (node.props.paint) {
    node.props.paint(painter(ctx), availableWidth, availableHeight);
  }
  ctx.restore();
};
const KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
const clipBorderTop = (ctx, layout2, style, rtr, rtl) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderTopWidth, borderRightWidth, borderLeftWidth } = style;
  ctx.moveTo(left + rtl, top);
  ctx.lineTo(left + width - rtr, top);
  const c0 = rtr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);
  const topRightYCoord = top + Math.max(borderTopWidth, rtr);
  ctx.lineTo(left + width, topRightYCoord);
  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);
  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);
  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);
  const c1 = innerTopRightRadiusX * (1 - KAPPA);
  const c2 = innerTopRightRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);
  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);
  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);
  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);
  const c3 = innerTopLeftRadiusX * (1 - KAPPA);
  const c4 = innerTopLeftRadiusY * (1 - KAPPA);
  const topLeftYCoord = top + Math.max(borderTopWidth, rtl);
  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);
  ctx.lineTo(left, topLeftYCoord);
  ctx.lineTo(left, top + rtl);
  const c5 = rtl * (1 - KAPPA);
  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);
  ctx.closePath();
  ctx.clip();
  if (borderRightWidth) {
    const trSlope = -borderTopWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left, top);
    ctx.lineTo(left, top + height2);
    ctx.closePath();
    ctx.clip();
  }
  if (borderLeftWidth) {
    const trSlope = -borderTopWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left, top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left + width, top + height2);
    ctx.closePath();
    ctx.clip();
  }
};
const fillBorderTop = (ctx, layout2, style, rtr, rtl) => {
  const { top, left, width } = layout2;
  const { borderTopColor, borderTopWidth, borderTopStyle, borderRightWidth, borderLeftWidth } = style;
  const c0 = rtl * (1 - KAPPA);
  const c1 = rtr * (1 - KAPPA);
  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));
  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);
  ctx.lineTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);
  ctx.strokeColor(borderTopColor);
  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);
  if (borderTopStyle === "dashed") {
    ctx.dash(borderTopWidth * 2, { space: borderTopWidth * 1.2 });
  } else if (borderTopStyle === "dotted") {
    ctx.dash(borderTopWidth, { space: borderTopWidth * 1.2 });
  }
  ctx.stroke();
  ctx.undash();
};
const clipBorderRight = (ctx, layout2, style, rtr, rbr) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderTopWidth, borderRightWidth, borderBottomWidth } = style;
  ctx.moveTo(left + width, top + rtr);
  ctx.lineTo(left + width, top + height2 - rbr);
  const c0 = rbr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width, top + height2 - c0, left + width - c0, top + height2, left + width - rbr, top + height2);
  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);
  ctx.lineTo(topBottomXCoord, top + height2);
  ctx.lineTo(topBottomXCoord, top + height2 - borderBottomWidth);
  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);
  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);
  const c1 = innerBottomRightRadiusX * (1 - KAPPA);
  const c2 = innerBottomRightRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height2 - borderBottomWidth, left + width - borderRightWidth, top + height2 - borderBottomWidth - c2, left + width - borderRightWidth, top + height2 - Math.max(rbr, borderBottomWidth));
  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));
  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);
  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);
  const c3 = innerTopRightRadiusX * (1 - KAPPA);
  const c4 = innerTopRightRadiusY * (1 - KAPPA);
  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);
  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);
  ctx.lineTo(topRightXCoord, top);
  ctx.lineTo(left + width - rtr, top);
  const c5 = rtr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);
  ctx.closePath();
  ctx.clip();
  if (borderTopWidth) {
    const trSlope = -borderTopWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left, top + height2);
    ctx.closePath();
    ctx.clip();
  }
  if (borderBottomWidth) {
    const brSlope = borderBottomWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left, top);
    ctx.closePath();
    ctx.clip();
  }
};
const fillBorderRight = (ctx, layout2, style, rtr, rbr) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderRightColor, borderRightStyle, borderRightWidth, borderTopWidth, borderBottomWidth } = style;
  const c0 = rbr * (1 - KAPPA);
  const c1 = rtr * (1 - KAPPA);
  ctx.moveTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);
  ctx.lineTo(left + width, top + height2 - rbr);
  ctx.bezierCurveTo(left + width, top + height2 - c0, left + width - c0, top + height2, left + width - rbr, top + height2);
  ctx.strokeColor(borderRightColor);
  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);
  if (borderRightStyle === "dashed") {
    ctx.dash(borderRightWidth * 2, { space: borderRightWidth * 1.2 });
  } else if (borderRightStyle === "dotted") {
    ctx.dash(borderRightWidth, { space: borderRightWidth * 1.2 });
  }
  ctx.stroke();
  ctx.undash();
};
const clipBorderBottom = (ctx, layout2, style, rbl, rbr) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderBottomWidth, borderRightWidth, borderLeftWidth } = style;
  ctx.moveTo(left + width - rbr, top + height2);
  ctx.lineTo(left + rbl, top + height2);
  const c0 = rbl * (1 - KAPPA);
  ctx.bezierCurveTo(left + c0, top + height2, left, top + height2 - c0, left, top + height2 - rbl);
  const bottomLeftYCoord = top + height2 - Math.max(borderBottomWidth, rbl);
  ctx.lineTo(left, bottomLeftYCoord);
  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);
  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);
  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);
  const c1 = innerBottomLeftRadiusX * (1 - KAPPA);
  const c2 = innerBottomLeftRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + borderLeftWidth, top + height2 - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height2 - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height2 - borderBottomWidth);
  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height2 - borderBottomWidth);
  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);
  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);
  const c3 = innerBottomRightRadiusX * (1 - KAPPA);
  const c4 = innerBottomRightRadiusY * (1 - KAPPA);
  const bottomRightYCoord = top + height2 - Math.max(borderBottomWidth, rbr);
  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height2 - borderBottomWidth, left + width - borderRightWidth, top + height2 - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);
  ctx.lineTo(left + width, bottomRightYCoord);
  ctx.lineTo(left + width, top + height2 - rbr);
  const c5 = rbr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width, top + height2 - c5, left + width - c5, top + height2, left + width - rbr, top + height2);
  ctx.closePath();
  ctx.clip();
  if (borderRightWidth) {
    const brSlope = borderBottomWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left, top);
    ctx.closePath();
    ctx.clip();
  }
  if (borderLeftWidth) {
    const trSlope = -borderBottomWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height2);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.lineTo(left + width, top);
    ctx.closePath();
    ctx.clip();
  }
};
const fillBorderBottom = (ctx, layout2, style, rbl, rbr) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderBottomColor, borderBottomStyle, borderBottomWidth, borderRightWidth, borderLeftWidth } = style;
  const c0 = rbl * (1 - KAPPA);
  const c1 = rbr * (1 - KAPPA);
  ctx.moveTo(left + width, top + height2 - rbr);
  ctx.bezierCurveTo(left + width, top + height2 - c1, left + width - c1, top + height2, left + width - rbr, top + height2);
  ctx.lineTo(left + rbl, top + height2);
  ctx.bezierCurveTo(left + c0, top + height2, left, top + height2 - c0, left, top + height2 - rbl);
  ctx.strokeColor(borderBottomColor);
  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);
  if (borderBottomStyle === "dashed") {
    ctx.dash(borderBottomWidth * 2, { space: borderBottomWidth * 1.2 });
  } else if (borderBottomStyle === "dotted") {
    ctx.dash(borderBottomWidth, { space: borderBottomWidth * 1.2 });
  }
  ctx.stroke();
  ctx.undash();
};
const clipBorderLeft = (ctx, layout2, style, rbl, rtl) => {
  const { top, left, width, height: height2 } = layout2;
  const { borderTopWidth, borderLeftWidth, borderBottomWidth } = style;
  ctx.moveTo(left, top + height2 - rbl);
  ctx.lineTo(left, top + rtl);
  const c0 = rtl * (1 - KAPPA);
  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);
  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);
  ctx.lineTo(topLeftCoordX, top);
  ctx.lineTo(topLeftCoordX, top + borderTopWidth);
  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);
  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);
  const c1 = innerTopLeftRadiusX * (1 - KAPPA);
  const c2 = innerTopLeftRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));
  ctx.lineTo(left + borderLeftWidth, top + height2 - Math.max(rbl, borderBottomWidth));
  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);
  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);
  const c3 = innerBottomLeftRadiusX * (1 - KAPPA);
  const c4 = innerBottomLeftRadiusY * (1 - KAPPA);
  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);
  ctx.bezierCurveTo(left + borderLeftWidth, top + height2 - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height2 - borderBottomWidth, bottomLeftXCoord, top + height2 - borderBottomWidth);
  ctx.lineTo(bottomLeftXCoord, top + height2);
  ctx.lineTo(left + rbl, top + height2);
  const c5 = rbl * (1 - KAPPA);
  ctx.bezierCurveTo(left + c5, top + height2, left, top + height2 - c5, left, top + height2 - rbl);
  ctx.closePath();
  ctx.clip();
  if (borderBottomWidth) {
    const trSlope = -borderBottomWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height2);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left, top);
    ctx.lineTo(left + width, top);
    ctx.closePath();
    ctx.clip();
  }
  if (borderBottomWidth) {
    const trSlope = -borderTopWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left, top);
    ctx.lineTo(left, top + height2);
    ctx.lineTo(left + width, top + height2);
    ctx.closePath();
    ctx.clip();
  }
};
const fillBorderLeft = (ctx, layout2, style, rbl, rtl) => {
  const { top, left, height: height2 } = layout2;
  const { borderLeftColor, borderLeftStyle, borderLeftWidth, borderTopWidth, borderBottomWidth } = style;
  const c0 = rbl * (1 - KAPPA);
  const c1 = rtl * (1 - KAPPA);
  ctx.moveTo(left + rbl, top + height2);
  ctx.bezierCurveTo(left + c0, top + height2, left, top + height2 - c0, left, top + height2 - rbl);
  ctx.lineTo(left, top + rtl);
  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);
  ctx.strokeColor(borderLeftColor);
  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);
  if (borderLeftStyle === "dashed") {
    ctx.dash(borderLeftWidth * 2, { space: borderLeftWidth * 1.2 });
  } else if (borderLeftStyle === "dotted") {
    ctx.dash(borderLeftWidth, { space: borderLeftWidth * 1.2 });
  }
  ctx.stroke();
  ctx.undash();
};
const shouldRenderBorders = (node) => node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);
const renderBorders = (ctx, node) => {
  if (!node.box)
    return;
  if (!shouldRenderBorders(node))
    return;
  const { width, height: height2, borderTopWidth = 0, borderLeftWidth = 0, borderRightWidth = 0, borderBottomWidth = 0 } = node.box;
  const { opacity = 1, borderTopColor = "black", borderTopStyle = "solid", borderLeftColor = "black", borderLeftStyle = "solid", borderRightColor = "black", borderRightStyle = "solid", borderBottomColor = "black", borderBottomStyle = "solid" } = node.style;
  const borderTopLeftRadius = node.style.borderTopLeftRadius || 0;
  const borderTopRightRadius = node.style.borderTopRightRadius || 0;
  const borderBottomLeftRadius = node.style.borderBottomLeftRadius || 0;
  const borderBottomRightRadius = node.style.borderBottomRightRadius || 0;
  const style = {
    borderTopColor,
    borderTopWidth,
    borderTopStyle,
    borderLeftColor,
    borderLeftWidth,
    borderLeftStyle,
    borderRightColor,
    borderRightWidth,
    borderRightStyle,
    borderBottomColor,
    borderBottomWidth,
    borderBottomStyle
  };
  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height2);
  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height2);
  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height2);
  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height2);
  ctx.save();
  ctx.strokeOpacity(opacity);
  if (borderTopWidth) {
    ctx.save();
    clipBorderTop(ctx, node.box, style, rtr, rtl);
    fillBorderTop(ctx, node.box, style, rtr, rtl);
    ctx.restore();
  }
  if (borderRightWidth) {
    ctx.save();
    clipBorderRight(ctx, node.box, style, rtr, rbr);
    fillBorderRight(ctx, node.box, style, rtr, rbr);
    ctx.restore();
  }
  if (borderBottomWidth) {
    ctx.save();
    clipBorderBottom(ctx, node.box, style, rbl, rbr);
    fillBorderBottom(ctx, node.box, style, rbl, rbr);
    ctx.restore();
  }
  if (borderLeftWidth) {
    ctx.save();
    clipBorderLeft(ctx, node.box, style, rbl, rtl);
    fillBorderLeft(ctx, node.box, style, rbl, rtl);
    ctx.restore();
  }
  ctx.restore();
};
const drawBackground = (ctx, node) => {
  var _a;
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box;
  const color = parseColor(node.style.backgroundColor);
  const nodeOpacity = isNil((_a = node.style) == null ? void 0 : _a.opacity) ? 1 : node.style.opacity;
  const opacity = Math.min(color.opacity, nodeOpacity);
  ctx.fillOpacity(opacity).fillColor(color.value).rect(left, top, width, height2).fill();
};
const renderBackground = (ctx, node) => {
  var _a;
  const hasBackground = !!node.box && !!((_a = node.style) == null ? void 0 : _a.backgroundColor);
  if (hasBackground) {
    ctx.save();
    clipNode(ctx, node);
    drawBackground(ctx, node);
    ctx.restore();
  }
};
const isString$1 = (value2) => typeof value2 === "string";
const isSrcId = (value2) => /^#.+/.test(value2);
const renderLink = (ctx, node, src2) => {
  if (!src2 || !node.box)
    return;
  const isId = isSrcId(src2);
  const method = isId ? "goTo" : "link";
  const value2 = isId ? src2.slice(1) : src2;
  const { top, left, width, height: height2 } = node.box;
  ctx[method](left, top, width, height2, value2);
};
const setLink = (ctx, node) => {
  const props = node.props || {};
  if ("src" in props && isString$1(props.src))
    return renderLink(ctx, node, props.src);
  if ("href" in props && isString$1(props.href))
    return renderLink(ctx, node, props.href);
};
const setDestination = (ctx, node) => {
  if (!node.box)
    return;
  if (!node.props)
    return;
  if ("id" in node.props) {
    ctx.addNamedDestination(node.props.id, "XYZ", null, node.box.top, null);
  }
};
const clean = (options) => {
  const opt = { ...options };
  Object.entries(opt).forEach((pair) => {
    if (!pair[1]) {
      delete opt[pair[0]];
    }
  });
  return opt;
};
const parseCommonFormOptions = (node) => {
  var _a, _b, _c, _d, _e;
  return {
    required: ((_a = node.props) == null ? void 0 : _a.required) || false,
    noExport: ((_b = node.props) == null ? void 0 : _b.noExport) || false,
    readOnly: ((_c = node.props) == null ? void 0 : _c.readOnly) || false,
    value: ((_d = node.props) == null ? void 0 : _d.value) || void 0,
    defaultValue: ((_e = node.props) == null ? void 0 : _e.defaultValue) || void 0
  };
};
const parseTextInputOptions = (node, fieldSet) => {
  var _a, _b, _c, _d, _e, _f, _g;
  return clean({
    ...parseCommonFormOptions(node),
    parent: fieldSet || void 0,
    align: ((_a = node.props) == null ? void 0 : _a.align) || "left",
    multiline: ((_b = node.props) == null ? void 0 : _b.multiline) || void 0,
    password: ((_c = node.props) == null ? void 0 : _c.password) || false,
    noSpell: ((_d = node.props) == null ? void 0 : _d.noSpell) || false,
    format: ((_e = node.props) == null ? void 0 : _e.format) || void 0,
    fontSize: ((_f = node.props) == null ? void 0 : _f.fontSize) || void 0,
    MaxLen: ((_g = node.props) == null ? void 0 : _g.maxLength) || void 0
  });
};
const parseSelectAndListFieldOptions = (node) => {
  var _a, _b, _c, _d, _e;
  return clean({
    ...parseCommonFormOptions(node),
    sort: ((_a = node.props) == null ? void 0 : _a.sort) || false,
    edit: ((_b = node.props) == null ? void 0 : _b.edit) || false,
    multiSelect: ((_c = node.props) == null ? void 0 : _c.multiSelect) || false,
    noSpell: ((_d = node.props) == null ? void 0 : _d.noSpell) || false,
    select: ((_e = node.props) == null ? void 0 : _e.select) || [""]
  });
};
const getAppearance = (ctx, codepoint, width, height2) => {
  const appearance = ctx.ref({
    Type: "XObject",
    Subtype: "Form",
    BBox: [0, 0, width, height2],
    Resources: {
      ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
      Font: {
        ZaDi: ctx._acroform.fonts.ZaDi
      }
    }
  });
  appearance.initDeflate();
  appearance.write(`/Tx BMC
q
/ZaDi ${height2 * 0.8} Tf
BT
${width * 0.45} ${height2 / 4} Td (${codepoint}) Tj
ET
Q
EMC`);
  appearance.end(null);
  return appearance;
};
const parseCheckboxOptions = (ctx, node, fieldSet) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { width, height: height2 } = node.box || {};
  const onOption = ((_a = node.props) == null ? void 0 : _a.onState) || "Yes";
  const offOption = ((_b = node.props) == null ? void 0 : _b.offState) || "Off";
  const xMark = ((_c = node.props) == null ? void 0 : _c.xMark) || false;
  if (!Object.prototype.hasOwnProperty.call(ctx._acroform.fonts, "ZaDi")) {
    const ref = ctx.ref({
      Type: "Font",
      Subtype: "Type1",
      BaseFont: "ZapfDingbats"
    });
    ctx._acroform.fonts.ZaDi = ref;
    ref.end(null);
  }
  const normalAppearance = {
    [onOption]: getAppearance(ctx, xMark ? "8" : "4", width, height2),
    [offOption]: getAppearance(ctx, xMark ? " " : "8", width, height2)
  };
  return clean({
    ...parseCommonFormOptions(node),
    backgroundColor: ((_d = node.props) == null ? void 0 : _d.backgroundColor) || void 0,
    borderColor: ((_e = node.props) == null ? void 0 : _e.borderColor) || void 0,
    parent: fieldSet || void 0,
    value: `/${((_f = node.props) == null ? void 0 : _f.checked) === true ? onOption : offOption}`,
    defaultValue: `/${((_g = node.props) == null ? void 0 : _g.checked) === true ? onOption : offOption}`,
    AS: ((_h = node.props) == null ? void 0 : _h.checked) === true ? onOption : offOption,
    AP: { N: normalAppearance, D: normalAppearance }
  });
};
const renderTextInput = (ctx, node, options) => {
  var _a, _b;
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box;
  const name = ((_a = node.props) == null ? void 0 : _a.name) || "";
  const fieldSetOptions = (_b = options.fieldSets) == null ? void 0 : _b.at(0);
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formText(name, left, top, width, height2, parseTextInputOptions(node, fieldSetOptions));
};
const renderSelect = (ctx, node) => {
  var _a;
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box;
  const name = ((_a = node.props) == null ? void 0 : _a.name) || "";
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formCombo(name, left, top, width, height2, parseSelectAndListFieldOptions(node));
};
const renderFieldSet = (ctx, node, options) => {
  var _a;
  const name = ((_a = node.props) == null ? void 0 : _a.name) || "";
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  const formField = ctx.formField(name);
  const option = options;
  if (!option.fieldSets) {
    option.fieldSets = [formField];
  } else {
    option.fieldSets.push(formField);
  }
};
const cleanUpFieldSet = (_ctx, _node, options) => {
  options.fieldSets.pop();
};
const renderList = (ctx, node) => {
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box || {};
  const name = "name" in node.props ? node.props.name || "" : "";
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formList(name, left, top, width, height2, parseSelectAndListFieldOptions(node));
};
const renderCheckbox = (ctx, node, options) => {
  var _a, _b;
  if (!node.box)
    return;
  const { top, left, width, height: height2 } = node.box;
  const name = ((_a = node.props) == null ? void 0 : _a.name) || "";
  const fieldSetOptions = (_b = options.fieldSets) == null ? void 0 : _b.at(0);
  if (!ctx._root.data.AcroForm) {
    ctx.initForm();
  }
  ctx.formCheckbox(name, left, top, width, height2, parseCheckboxOptions(ctx, node, fieldSetOptions));
};
const isRecursiveNode = (node) => node.type !== Text && node.type !== Svg;
const renderChildren = (ctx, node, options) => {
  ctx.save();
  if (node.box) {
    ctx.translate(node.box.left, node.box.top);
  }
  const children = node.children || [];
  const renderChild = (child) => renderNode(ctx, child, options);
  children.forEach(renderChild);
  ctx.restore();
};
const renderFns = {
  [Text]: renderText,
  [Note]: renderNote,
  [Image]: renderImage,
  [FieldSet]: renderFieldSet,
  [TextInput]: renderTextInput,
  [Select]: renderSelect,
  [Checkbox]: renderCheckbox,
  [List]: renderList,
  [Canvas]: renderCanvas,
  [Svg]: renderSvg,
  [Link]: setLink
};
const cleanUpFns = {
  [FieldSet]: cleanUpFieldSet
};
const renderNode = (ctx, node, options) => {
  var _a;
  const overflowHidden = ((_a = node.style) == null ? void 0 : _a.overflow) === "hidden";
  const shouldRenderChildren = isRecursiveNode(node);
  if (node.type === Page)
    renderPage(ctx, node);
  ctx.save();
  if (overflowHidden)
    clipNode(ctx, node);
  applyTransformations(ctx, node);
  renderBackground(ctx, node);
  renderBorders(ctx, node);
  const renderFn = renderFns[node.type];
  if (renderFn)
    renderFn(ctx, node, options);
  if (shouldRenderChildren)
    renderChildren(ctx, node, options);
  const cleanUpFn = cleanUpFns[node.type];
  if (cleanUpFn)
    cleanUpFn(ctx, node, options);
  setDestination(ctx, node);
  renderDebug(ctx, node);
  ctx.restore();
};
const addNodeBookmark = (ctx, node, pageNumber, registry) => {
  if (!node.box)
    return;
  if (!node.props)
    return;
  if ("bookmark" in node.props && node.props.bookmark) {
    const bookmark = node.props.bookmark;
    const { title: title2, parent, expanded, zoom, fit } = bookmark;
    const outline = registry[parent] || ctx.outline;
    const top = bookmark.top || node.box.top;
    const left = bookmark.left || node.box.left;
    const instance = outline.addItem(title2, {
      pageNumber,
      expanded,
      top,
      left,
      zoom,
      fit
    });
    registry[bookmark.ref] = instance;
  }
  if (!node.children)
    return;
  node.children.forEach((child) => addNodeBookmark(ctx, child, pageNumber, registry));
};
const addBookmarks = (ctx, root) => {
  const registry = {};
  const pages = root.children || [];
  pages.forEach((page, i2) => {
    addNodeBookmark(ctx, page, i2, registry);
  });
};
const render = (ctx, doc) => {
  const pages = doc.children || [];
  const options = { imageCache: /* @__PURE__ */ new Map(), fieldSets: [] };
  pages.forEach((page) => renderNode(ctx, page, options));
  addBookmarks(ctx, doc);
  ctx.end();
  return ctx;
};
var queries;
var hasRequiredQueries;
function requireQueries() {
  if (hasRequiredQueries) return queries;
  hasRequiredQueries = 1;
  function MaxHeight(value2) {
    this.value = value2;
    this.match = function(options) {
      return this.value >= options.height;
    };
  }
  function MinHeight(value2) {
    this.value = value2;
    this.match = function(options) {
      return this.value < options.height;
    };
  }
  function MaxWidth(value2) {
    this.value = value2;
    this.match = function(options) {
      return this.value >= options.width;
    };
  }
  function MinWidth(value2) {
    this.value = value2;
    this.match = function(options) {
      return this.value < options.width;
    };
  }
  function Orientation(value2) {
    this.value = value2;
    this.match = function(options) {
      return this.value === options.orientation;
    };
  }
  queries = function Query(type, value2) {
    switch (type) {
      case "max-height":
        return new MaxHeight(value2);
      case "min-height":
        return new MinHeight(value2);
      case "max-width":
        return new MaxWidth(value2);
      case "min-width":
        return new MinWidth(value2);
      case "orientation":
        return new Orientation(value2);
      default:
        throw new Error(value2);
    }
  };
  return queries;
}
var operators;
var hasRequiredOperators;
function requireOperators() {
  if (hasRequiredOperators) return operators;
  hasRequiredOperators = 1;
  function And(left, right) {
    this.left = left;
    this.right = right;
    this.match = function(options) {
      return left.match(options) && right.match(options);
    };
  }
  function Or(left, right) {
    this.left = left;
    this.right = right;
    this.match = function(options) {
      return left.match(options) || right.match(options);
    };
  }
  operators = function Operator(type, left, right) {
    switch (type) {
      case "and":
        return new And(left, right);
      case ",":
        return new Or(left, right);
      default:
        throw new Error(value);
    }
  };
  return operators;
}
var parser_1;
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser_1;
  hasRequiredParser = 1;
  var Query = requireQueries();
  var Operator = requireOperators();
  var NUMBERS = /[0-9]/;
  var LETTERS = /[a-z|\-]/i;
  var WHITESPACE = /\s/;
  var COLON = /:/;
  var COMMA = /,/;
  var AND = /and$/;
  var AT = /@/;
  function tokenizer(input) {
    var current = 0;
    var tokens = [];
    while (current < input.length) {
      var char = input[current];
      if (AT.test(char)) {
        char = input[++current];
        while (LETTERS.test(char) && char !== void 0) {
          char = input[++current];
        }
      }
      if (WHITESPACE.test(char) || char === ")" || char === "(") {
        current++;
        continue;
      }
      if (COLON.test(char) || COMMA.test(char)) {
        current++;
        tokens.push({ type: "operator", value: char });
        continue;
      }
      if (NUMBERS.test(char)) {
        var value2 = "";
        while (NUMBERS.test(char)) {
          value2 += char;
          char = input[++current];
        }
        tokens.push({ type: "number", value: value2 });
        continue;
      }
      if (LETTERS.test(char)) {
        var value2 = "";
        while (LETTERS.test(char) && char !== void 0) {
          value2 += char;
          char = input[++current];
        }
        if (AND.test(value2)) {
          tokens.push({ type: "operator", value: value2 });
        } else {
          tokens.push({ type: "literal", value: value2 });
        }
        continue;
      }
      throw new TypeError(
        "Tokenizer: I dont know what this character is: " + char
      );
    }
    return tokens;
  }
  function parser(tokens) {
    var output = [];
    var stack = [];
    while (tokens.length > 0) {
      var token = tokens.shift();
      if (token.type === "number" || token.type === "literal") {
        output.push(token);
        continue;
      }
      if (token.type === "operator") {
        if (COLON.test(token.value)) {
          token = { type: "query", key: output.pop(), value: tokens.shift() };
          output.push(token);
          continue;
        }
        while (stack.length > 0) {
          output.unshift(stack.pop());
        }
        stack.push(token);
      }
    }
    while (stack.length > 0) {
      output.unshift(stack.pop());
    }
    function walk() {
      var head = output.shift();
      if (head.type === "number") {
        return parseInt(head.value);
      }
      if (head.type === "literal") {
        return head.value;
      }
      if (head.type === "operator") {
        var l2 = walk();
        var r2 = walk();
        return Operator(head.value, l2, r2);
      }
      if (head.type === "query") {
        var l2 = head.key.value;
        var r2 = head.value.value;
        return Query(l2, r2);
      }
    }
    return walk();
  }
  parser_1 = {
    parse: function(query) {
      var tokens = tokenizer(query);
      var ast = parser(tokens);
      return ast;
    }
  };
  return parser_1;
}
var src;
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src;
  hasRequiredSrc = 1;
  var Parser = requireParser();
  src = function(queries2, options) {
    var result = {};
    Object.keys(queries2).forEach(function(query) {
      if (Parser.parse(query).match(options)) {
        Object.assign(result, queries2[query]);
      }
    });
    return result;
  };
  return src;
}
var srcExports = requireSrc();
const matchMedia = /* @__PURE__ */ getDefaultExportFromCjs$2(srcExports);
var converter;
var hasRequiredConverter;
function requireConverter() {
  if (hasRequiredConverter) return converter;
  hasRequiredConverter = 1;
  var hslToRgb = function(hue, saturation, lightness) {
    if (hue == void 0) {
      return [0, 0, 0];
    }
    var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
    var huePrime = hue / 60;
    var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
    huePrime = Math.floor(huePrime);
    var red;
    var green;
    var blue;
    if (huePrime === 0) {
      red = chroma;
      green = secondComponent;
      blue = 0;
    } else if (huePrime === 1) {
      red = secondComponent;
      green = chroma;
      blue = 0;
    } else if (huePrime === 2) {
      red = 0;
      green = chroma;
      blue = secondComponent;
    } else if (huePrime === 3) {
      red = 0;
      green = secondComponent;
      blue = chroma;
    } else if (huePrime === 4) {
      red = secondComponent;
      green = 0;
      blue = chroma;
    } else if (huePrime === 5) {
      red = chroma;
      green = 0;
      blue = secondComponent;
    }
    var lightnessAdjustment = lightness - chroma / 2;
    red += lightnessAdjustment;
    green += lightnessAdjustment;
    blue += lightnessAdjustment;
    return [
      Math.abs(Math.round(red * 255)),
      Math.abs(Math.round(green * 255)),
      Math.abs(Math.round(blue * 255))
    ];
  };
  converter = hslToRgb;
  return converter;
}
var hslToHex;
var hasRequiredHslToHex;
function requireHslToHex() {
  if (hasRequiredHslToHex) return hslToHex;
  hasRequiredHslToHex = 1;
  var toRgb = requireConverter();
  function max2(val, n3) {
    return val > n3 ? n3 : val;
  }
  function min2(val, n3) {
    return val < n3 ? n3 : val;
  }
  function cycle(val) {
    val = max2(val, 1e7);
    val = min2(val, -1e7);
    while (val < 0) {
      val += 360;
    }
    while (val > 359) {
      val -= 360;
    }
    return val;
  }
  function hsl(hue, saturation, luminosity) {
    hue = cycle(hue);
    saturation = min2(max2(saturation, 100), 0);
    luminosity = min2(max2(luminosity, 100), 0);
    saturation /= 100;
    luminosity /= 100;
    var rgb = toRgb(hue, saturation, luminosity);
    return "#" + rgb.map(function(n3) {
      return (256 + n3).toString(16).substr(-2);
    }).join("");
  }
  hslToHex = hsl;
  return hslToHex;
}
var hslToHexExports = requireHslToHex();
const hlsToHex = /* @__PURE__ */ getDefaultExportFromCjs$2(hslToHexExports);
var parse$2;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse$2;
  hasRequiredParse = 1;
  var openParentheses = "(".charCodeAt(0);
  var closeParentheses = ")".charCodeAt(0);
  var singleQuote = "'".charCodeAt(0);
  var doubleQuote = '"'.charCodeAt(0);
  var backslash = "\\".charCodeAt(0);
  var slash = "/".charCodeAt(0);
  var comma = ",".charCodeAt(0);
  var colon = ":".charCodeAt(0);
  var star = "*".charCodeAt(0);
  var uLower = "u".charCodeAt(0);
  var uUpper = "U".charCodeAt(0);
  var plus = "+".charCodeAt(0);
  var isUnicodeRange = /^[a-f0-9?-]+$/i;
  parse$2 = function(input) {
    var tokens = [];
    var value2 = input;
    var next, quote, prev, token, escape2, escapePos, whitespacePos, parenthesesOpenPos;
    var pos = 0;
    var code = value2.charCodeAt(pos);
    var max2 = value2.length;
    var stack = [{ nodes: tokens }];
    var balanced = 0;
    var parent;
    var name = "";
    var before = "";
    var after = "";
    while (pos < max2) {
      if (code <= 32) {
        next = pos;
        do {
          next += 1;
          code = value2.charCodeAt(next);
        } while (code <= 32);
        token = value2.slice(pos, next);
        prev = tokens[tokens.length - 1];
        if (code === closeParentheses && balanced) {
          after = token;
        } else if (prev && prev.type === "div") {
          prev.after = token;
          prev.sourceEndIndex += token.length;
        } else if (code === comma || code === colon || code === slash && value2.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
          before = token;
        } else {
          tokens.push({
            type: "space",
            sourceIndex: pos,
            sourceEndIndex: next,
            value: token
          });
        }
        pos = next;
      } else if (code === singleQuote || code === doubleQuote) {
        next = pos;
        quote = code === singleQuote ? "'" : '"';
        token = {
          type: "string",
          sourceIndex: pos,
          quote
        };
        do {
          escape2 = false;
          next = value2.indexOf(quote, next + 1);
          if (~next) {
            escapePos = next;
            while (value2.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape2 = !escape2;
            }
          } else {
            value2 += quote;
            next = value2.length - 1;
            token.unclosed = true;
          }
        } while (escape2);
        token.value = value2.slice(pos + 1, next);
        token.sourceEndIndex = token.unclosed ? next : next + 1;
        tokens.push(token);
        pos = next + 1;
        code = value2.charCodeAt(pos);
      } else if (code === slash && value2.charCodeAt(pos + 1) === star) {
        next = value2.indexOf("*/", pos);
        token = {
          type: "comment",
          sourceIndex: pos,
          sourceEndIndex: next + 2
        };
        if (next === -1) {
          token.unclosed = true;
          next = value2.length;
          token.sourceEndIndex = next;
        }
        token.value = value2.slice(pos + 2, next);
        tokens.push(token);
        pos = next + 2;
        code = value2.charCodeAt(pos);
      } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
        token = value2[pos];
        tokens.push({
          type: "word",
          sourceIndex: pos - before.length,
          sourceEndIndex: pos + token.length,
          value: token
        });
        pos += 1;
        code = value2.charCodeAt(pos);
      } else if (code === slash || code === comma || code === colon) {
        token = value2[pos];
        tokens.push({
          type: "div",
          sourceIndex: pos - before.length,
          sourceEndIndex: pos + token.length,
          value: token,
          before,
          after: ""
        });
        before = "";
        pos += 1;
        code = value2.charCodeAt(pos);
      } else if (openParentheses === code) {
        next = pos;
        do {
          next += 1;
          code = value2.charCodeAt(next);
        } while (code <= 32);
        parenthesesOpenPos = pos;
        token = {
          type: "function",
          sourceIndex: pos - name.length,
          value: name,
          before: value2.slice(parenthesesOpenPos + 1, next)
        };
        pos = next;
        if (name === "url" && code !== singleQuote && code !== doubleQuote) {
          next -= 1;
          do {
            escape2 = false;
            next = value2.indexOf(")", next + 1);
            if (~next) {
              escapePos = next;
              while (value2.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape2 = !escape2;
              }
            } else {
              value2 += ")";
              next = value2.length - 1;
              token.unclosed = true;
            }
          } while (escape2);
          whitespacePos = next;
          do {
            whitespacePos -= 1;
            code = value2.charCodeAt(whitespacePos);
          } while (code <= 32);
          if (parenthesesOpenPos < whitespacePos) {
            if (pos !== whitespacePos + 1) {
              token.nodes = [
                {
                  type: "word",
                  sourceIndex: pos,
                  sourceEndIndex: whitespacePos + 1,
                  value: value2.slice(pos, whitespacePos + 1)
                }
              ];
            } else {
              token.nodes = [];
            }
            if (token.unclosed && whitespacePos + 1 !== next) {
              token.after = "";
              token.nodes.push({
                type: "space",
                sourceIndex: whitespacePos + 1,
                sourceEndIndex: next,
                value: value2.slice(whitespacePos + 1, next)
              });
            } else {
              token.after = value2.slice(whitespacePos + 1, next);
              token.sourceEndIndex = next;
            }
          } else {
            token.after = "";
            token.nodes = [];
          }
          pos = next + 1;
          token.sourceEndIndex = token.unclosed ? next : pos;
          code = value2.charCodeAt(pos);
          tokens.push(token);
        } else {
          balanced += 1;
          token.after = "";
          token.sourceEndIndex = pos + 1;
          tokens.push(token);
          stack.push(token);
          tokens = token.nodes = [];
          parent = token;
        }
        name = "";
      } else if (closeParentheses === code && balanced) {
        pos += 1;
        code = value2.charCodeAt(pos);
        parent.after = after;
        parent.sourceEndIndex += after.length;
        after = "";
        balanced -= 1;
        stack[stack.length - 1].sourceEndIndex = pos;
        stack.pop();
        parent = stack[balanced];
        tokens = parent.nodes;
      } else {
        next = pos;
        do {
          if (code === backslash) {
            next += 1;
          }
          next += 1;
          code = value2.charCodeAt(next);
        } while (next < max2 && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
        token = value2.slice(pos, next);
        if (openParentheses === code) {
          name = token;
        } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
          tokens.push({
            type: "unicode-range",
            sourceIndex: pos,
            sourceEndIndex: next,
            value: token
          });
        } else {
          tokens.push({
            type: "word",
            sourceIndex: pos,
            sourceEndIndex: next,
            value: token
          });
        }
        pos = next;
      }
    }
    for (pos = stack.length - 1; pos; pos -= 1) {
      stack[pos].unclosed = true;
      stack[pos].sourceEndIndex = value2.length;
    }
    return stack[0].nodes;
  };
  return parse$2;
}
var parseExports = requireParse();
const parse$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(parseExports);
var unit;
var hasRequiredUnit;
function requireUnit() {
  if (hasRequiredUnit) return unit;
  hasRequiredUnit = 1;
  var minus = "-".charCodeAt(0);
  var plus = "+".charCodeAt(0);
  var dot = ".".charCodeAt(0);
  var exp = "e".charCodeAt(0);
  var EXP = "E".charCodeAt(0);
  function likeNumber(value2) {
    var code = value2.charCodeAt(0);
    var nextCode;
    if (code === plus || code === minus) {
      nextCode = value2.charCodeAt(1);
      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }
      var nextNextCode = value2.charCodeAt(2);
      if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
        return true;
      }
      return false;
    }
    if (code === dot) {
      nextCode = value2.charCodeAt(1);
      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }
      return false;
    }
    if (code >= 48 && code <= 57) {
      return true;
    }
    return false;
  }
  unit = function(value2) {
    var pos = 0;
    var length2 = value2.length;
    var code;
    var nextCode;
    var nextNextCode;
    if (length2 === 0 || !likeNumber(value2)) {
      return false;
    }
    code = value2.charCodeAt(pos);
    if (code === plus || code === minus) {
      pos++;
    }
    while (pos < length2) {
      code = value2.charCodeAt(pos);
      if (code < 48 || code > 57) {
        break;
      }
      pos += 1;
    }
    code = value2.charCodeAt(pos);
    nextCode = value2.charCodeAt(pos + 1);
    if (code === dot && nextCode >= 48 && nextCode <= 57) {
      pos += 2;
      while (pos < length2) {
        code = value2.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
    }
    code = value2.charCodeAt(pos);
    nextCode = value2.charCodeAt(pos + 1);
    nextNextCode = value2.charCodeAt(pos + 2);
    if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
      pos += nextCode === plus || nextCode === minus ? 3 : 2;
      while (pos < length2) {
        code = value2.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
    }
    return {
      number: value2.slice(0, pos),
      unit: value2.slice(pos)
    };
  };
  return unit;
}
var unitExports = requireUnit();
const parseUnit = /* @__PURE__ */ getDefaultExportFromCjs$2(unitExports);
const compact = (array) => array.filter(Boolean);
const mergeStyles$2 = (styles) => styles.reduce((acc, style) => {
  const s2 = Array.isArray(style) ? flatten$1(style) : style;
  Object.keys(s2).forEach((key) => {
    if (s2[key] !== null && s2[key] !== void 0) {
      acc[key] = s2[key];
    }
  });
  return acc;
}, {});
const flatten$1 = compose(mergeStyles$2, compact, castArray);
const resolveMediaQueries = (container, style) => {
  return Object.keys(style).reduce((acc, key) => {
    if (/@media/.test(key)) {
      return {
        ...acc,
        ...matchMedia({ [key]: style[key] }, container)
      };
    }
    return { ...acc, [key]: style[key] };
  }, {});
};
const isRgb = (value2) => /rgba?/g.test(value2);
const isHsl = (value2) => /hsla?/g.test(value2);
const parseRgb = (value2) => {
  const rgb = colorString.get.rgb(value2);
  return colorString.to.hex(rgb);
};
const parseHsl = (value2) => {
  const hsl = colorString.get.hsl(value2).map(Math.round);
  const hex = hlsToHex(...hsl);
  return hex.toUpperCase();
};
const transformColor = (value2) => {
  if (isRgb(value2))
    return parseRgb(value2);
  if (isHsl(value2))
    return parseHsl(value2);
  return value2;
};
const parseValue$1 = (value2) => {
  if (typeof value2 === "number")
    return { value: value2, unit: void 0 };
  const match = /^(-?\d*\.?\d+)(in|mm|cm|pt|vh|vw|px|rem)?$/g.exec(value2);
  return match ? { value: parseFloat(match[1]), unit: match[2] || "pt" } : { value: value2, unit: void 0 };
};
const transformUnit$1 = (container, value2) => {
  const scalar = parseValue$1(value2);
  const outputDpi = 72;
  const inputDpi = container.dpi || 72;
  const mmFactor = 1 / 25.4 * outputDpi;
  const cmFactor = 1 / 2.54 * outputDpi;
  if (typeof scalar.value !== "number")
    return scalar.value;
  switch (scalar.unit) {
    case "rem":
      return scalar.value * (container.remBase || 18);
    case "in":
      return scalar.value * outputDpi;
    case "mm":
      return scalar.value * mmFactor;
    case "cm":
      return scalar.value * cmFactor;
    case "vh":
      return scalar.value * (container.height / 100);
    case "vw":
      return scalar.value * (container.width / 100);
    case "px":
      return Math.round(scalar.value * (outputDpi / inputDpi));
    default:
      return scalar.value;
  }
};
const processNumberValue = (key, value2) => ({
  [key]: parseFloat$1(value2)
});
const processUnitValue = (key, value2, container) => ({
  [key]: transformUnit$1(container, value2)
});
const processColorValue = (key, value2) => {
  const result = { [key]: transformColor(value2) };
  return result;
};
const processNoopValue = (key, value2) => ({
  [key]: value2
});
const BORDER_SHORTHAND_REGEX = /(-?\d+(\.\d+)?(in|mm|cm|pt|vw|vh|px|rem)?)\s(\S+)\s(.+)/;
const matchBorderShorthand = (value2) => value2.match(BORDER_SHORTHAND_REGEX) || [];
const resolveBorderShorthand = (key, value2, container) => {
  const match = matchBorderShorthand(`${value2}`);
  if (match) {
    const widthMatch = match[1] || value2;
    const styleMatch = match[4] || value2;
    const colorMatch = match[5] || value2;
    const style = styleMatch;
    const color = colorMatch ? transformColor(colorMatch) : void 0;
    const width = widthMatch ? transformUnit$1(container, widthMatch) : void 0;
    if (key.match(/(Top|Right|Bottom|Left)$/)) {
      return {
        [`${key}Color`]: color,
        [`${key}Style`]: style,
        [`${key}Width`]: width
      };
    }
    if (key.match(/Color$/)) {
      return {
        borderTopColor: color,
        borderRightColor: color,
        borderBottomColor: color,
        borderLeftColor: color
      };
    }
    if (key.match(/Style$/)) {
      if (typeof style === "number")
        throw new Error(`Invalid border style: ${style}`);
      return {
        borderTopStyle: style,
        borderRightStyle: style,
        borderBottomStyle: style,
        borderLeftStyle: style
      };
    }
    if (key.match(/Width$/)) {
      if (typeof width !== "number")
        throw new Error(`Invalid border width: ${width}`);
      return {
        borderTopWidth: width,
        borderRightWidth: width,
        borderBottomWidth: width,
        borderLeftWidth: width
      };
    }
    if (key.match(/Radius$/)) {
      const radius = value2 ? transformUnit$1(container, value2) : void 0;
      if (typeof radius !== "number")
        throw new Error(`Invalid border radius: ${radius}`);
      return {
        borderTopLeftRadius: radius,
        borderTopRightRadius: radius,
        borderBottomRightRadius: radius,
        borderBottomLeftRadius: radius
      };
    }
    if (typeof width !== "number")
      throw new Error(`Invalid border width: ${width}`);
    if (typeof style === "number")
      throw new Error(`Invalid border style: ${style}`);
    return {
      borderTopColor: color,
      borderTopStyle: style,
      borderTopWidth: width,
      borderRightColor: color,
      borderRightStyle: style,
      borderRightWidth: width,
      borderBottomColor: color,
      borderBottomStyle: style,
      borderBottomWidth: width,
      borderLeftColor: color,
      borderLeftStyle: style,
      borderLeftWidth: width
    };
  }
  return { [key]: value2 };
};
const handlers$b = {
  border: resolveBorderShorthand,
  borderBottom: resolveBorderShorthand,
  borderBottomColor: processColorValue,
  borderBottomLeftRadius: processUnitValue,
  borderBottomRightRadius: processUnitValue,
  borderBottomStyle: processNoopValue,
  borderBottomWidth: processUnitValue,
  borderColor: resolveBorderShorthand,
  borderLeft: resolveBorderShorthand,
  borderLeftColor: processColorValue,
  borderLeftStyle: processNoopValue,
  borderLeftWidth: processUnitValue,
  borderRadius: resolveBorderShorthand,
  borderRight: resolveBorderShorthand,
  borderRightColor: processColorValue,
  borderRightStyle: processNoopValue,
  borderRightWidth: processUnitValue,
  borderStyle: resolveBorderShorthand,
  borderTop: resolveBorderShorthand,
  borderTopColor: processColorValue,
  borderTopLeftRadius: processUnitValue,
  borderTopRightRadius: processUnitValue,
  borderTopStyle: processNoopValue,
  borderTopWidth: processUnitValue,
  borderWidth: resolveBorderShorthand
};
const handlers$a = {
  backgroundColor: processColorValue,
  color: processColorValue,
  opacity: processNumberValue
};
const handlers$9 = {
  height: processUnitValue,
  maxHeight: processUnitValue,
  maxWidth: processUnitValue,
  minHeight: processUnitValue,
  minWidth: processUnitValue,
  width: processUnitValue
};
const flexDefaults = [1, 1, 0];
const flexAuto = [1, 1, "auto"];
const processFlexShorthand = (key, value2, container) => {
  let defaults = flexDefaults;
  let matches = [];
  if (value2 === "auto") {
    defaults = flexAuto;
  } else {
    matches = `${value2}`.split(" ");
  }
  const flexGrow = parseFloat$1(matches[0] || defaults[0]);
  const flexShrink = parseFloat$1(matches[1] || defaults[1]);
  const flexBasis = transformUnit$1(container, matches[2] || defaults[2]);
  return { flexGrow, flexShrink, flexBasis };
};
const handlers$8 = {
  alignContent: processNoopValue,
  alignItems: processNoopValue,
  alignSelf: processNoopValue,
  flex: processFlexShorthand,
  flexBasis: processUnitValue,
  flexDirection: processNoopValue,
  flexFlow: processNoopValue,
  flexGrow: processNumberValue,
  flexShrink: processNumberValue,
  flexWrap: processNoopValue,
  justifyContent: processNoopValue,
  justifySelf: processNoopValue
};
const processGapShorthand = (key, value2, container) => {
  const match = `${value2}`.split(" ");
  const rowGap = transformUnit$1(container, (match == null ? void 0 : match[0]) || value2);
  const columnGap = transformUnit$1(container, (match == null ? void 0 : match[1]) || value2);
  return { rowGap, columnGap };
};
const handlers$7 = {
  gap: processGapShorthand,
  columnGap: processUnitValue,
  rowGap: processUnitValue
};
const handlers$6 = {
  aspectRatio: processNumberValue,
  bottom: processUnitValue,
  display: processNoopValue,
  left: processUnitValue,
  position: processNoopValue,
  right: processUnitValue,
  top: processUnitValue,
  overflow: processNoopValue,
  zIndex: processNumberValue
};
const BOX_MODEL_UNITS = "px,in,mm,cm,pt,%,vw,vh";
const logError = (style, value2) => {
  const name = style.toString();
  console.error(`
    @react-pdf/stylesheet parsing error:
    ${name}: ${value2},
    ${" ".repeat(name.length + 2)}^
    Unsupported ${name} value format
  `);
};
const expandBoxModel = ({ expandsTo, maxValues = 1, autoSupported = false } = {}) => (model, value2, container) => {
  const nodes = parse$1(`${value2}`);
  const parts = [];
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    if (node.type === "function" || node.type === "string" || node.type === "div") {
      logError(model, value2);
      return {};
    }
    if (node.type === "word") {
      if (node.value === "auto" && autoSupported) {
        parts.push(node.value);
      } else {
        const result = parseUnit(node.value);
        if (result && BOX_MODEL_UNITS.includes(result.unit)) {
          parts.push(node.value);
        } else {
          logError(model, value2);
          return {};
        }
      }
    }
  }
  if (parts.length > maxValues) {
    logError(model, value2);
    return {};
  }
  const first = transformUnit$1(container, parts[0]);
  if (expandsTo) {
    const second = transformUnit$1(container, parts[1] || parts[0]);
    const third = transformUnit$1(container, parts[2] || parts[0]);
    const fourth = transformUnit$1(container, parts[3] || parts[1] || parts[0]);
    return expandsTo({ first, second, third, fourth });
  }
  return {
    [model]: first
  };
};
const processMargin = expandBoxModel({
  expandsTo: ({ first, second, third, fourth }) => ({
    marginTop: first,
    marginRight: second,
    marginBottom: third,
    marginLeft: fourth
  }),
  maxValues: 4,
  autoSupported: true
});
const processMarginVertical = expandBoxModel({
  expandsTo: ({ first, second }) => ({
    marginTop: first,
    marginBottom: second
  }),
  maxValues: 2,
  autoSupported: true
});
const processMarginHorizontal = expandBoxModel({
  expandsTo: ({ first, second }) => ({
    marginRight: first,
    marginLeft: second
  }),
  maxValues: 2,
  autoSupported: true
});
const processMarginSingle = expandBoxModel({
  autoSupported: true
});
const handlers$5 = {
  margin: processMargin,
  marginBottom: processMarginSingle,
  marginHorizontal: processMarginHorizontal,
  marginLeft: processMarginSingle,
  marginRight: processMarginSingle,
  marginTop: processMarginSingle,
  marginVertical: processMarginVertical
};
const processPadding = expandBoxModel({
  expandsTo: ({ first, second, third, fourth }) => ({
    paddingTop: first,
    paddingRight: second,
    paddingBottom: third,
    paddingLeft: fourth
  }),
  maxValues: 4
});
const processPaddingVertical = expandBoxModel({
  expandsTo: ({ first, second }) => ({
    paddingTop: first,
    paddingBottom: second
  }),
  maxValues: 2
});
const processPaddingHorizontal = expandBoxModel({
  expandsTo: ({ first, second }) => ({
    paddingRight: first,
    paddingLeft: second
  }),
  maxValues: 2
});
const processPaddingSingle = expandBoxModel();
const handlers$4 = {
  padding: processPadding,
  paddingBottom: processPaddingSingle,
  paddingHorizontal: processPaddingHorizontal,
  paddingLeft: processPaddingSingle,
  paddingRight: processPaddingSingle,
  paddingTop: processPaddingSingle,
  paddingVertical: processPaddingVertical
};
const offsetKeyword = (value2) => {
  switch (value2) {
    case "top":
    case "left":
      return "0%";
    case "right":
    case "bottom":
      return "100%";
    case "center":
      return "50%";
    default:
      return value2;
  }
};
const processObjectPosition = (key, value2, container) => {
  const match = `${value2}`.split(" ");
  const objectPositionX = offsetKeyword(transformUnit$1(container, (match == null ? void 0 : match[0]) || value2));
  const objectPositionY = offsetKeyword(transformUnit$1(container, (match == null ? void 0 : match[1]) || value2));
  return { objectPositionX, objectPositionY };
};
const processObjectPositionValue = (key, value2, container) => ({
  [key]: offsetKeyword(transformUnit$1(container, value2))
});
const handlers$3 = {
  objectPosition: processObjectPosition,
  objectPositionX: processObjectPositionValue,
  objectPositionY: processObjectPositionValue,
  objectFit: processNoopValue
};
const castInt = (value2) => {
  if (typeof value2 === "number")
    return value2;
  return parseInt(value2, 10);
};
const FONT_WEIGHTS = {
  thin: 100,
  hairline: 100,
  ultralight: 200,
  extralight: 200,
  light: 300,
  normal: 400,
  medium: 500,
  semibold: 600,
  demibold: 600,
  bold: 700,
  ultrabold: 800,
  extrabold: 800,
  heavy: 900,
  black: 900
};
const transformFontWeight = (value2) => {
  if (!value2)
    return FONT_WEIGHTS.normal;
  if (typeof value2 === "number")
    return value2;
  const lv = value2.toLowerCase();
  if (FONT_WEIGHTS[lv])
    return FONT_WEIGHTS[lv];
  return castInt(value2);
};
const processFontWeight = (key, value2) => {
  return { [key]: transformFontWeight(value2) };
};
const transformLineHeight = (value2, styles, container) => {
  if (value2 === "")
    return value2;
  const fontSize = transformUnit$1(container, styles.fontSize || 18);
  const lineHeight = transformUnit$1(container, value2);
  const { percent } = matchPercent(lineHeight) || {};
  if (percent)
    return percent * fontSize;
  return isNaN(value2) ? lineHeight : lineHeight * fontSize;
};
const processLineHeight = (key, value2, container, styles) => {
  return {
    [key]: transformLineHeight(value2, styles, container)
  };
};
const handlers$2 = {
  direction: processNoopValue,
  fontFamily: processNoopValue,
  fontSize: processUnitValue,
  fontStyle: processNoopValue,
  fontWeight: processFontWeight,
  letterSpacing: processUnitValue,
  lineHeight: processLineHeight,
  maxLines: processNumberValue,
  textAlign: processNoopValue,
  textDecoration: processNoopValue,
  textDecorationColor: processColorValue,
  textDecorationStyle: processNoopValue,
  textIndent: processNoopValue,
  textOverflow: processNoopValue,
  textTransform: processNoopValue,
  verticalAlign: processNoopValue
};
const matchNumber = (value2) => typeof value2 === "string" && /^-?\d*\.?\d*$/.test(value2);
const castFloat = (value2) => {
  if (typeof value2 !== "string")
    return value2;
  if (matchNumber(value2))
    return parseFloat(value2);
  return value2;
};
const parse = (transformString) => {
  const transforms = transformString.trim().split(/\)[ ,]|\)/);
  if (transforms.length === 1) {
    return [[transforms[0], true]];
  }
  const parsed = [];
  for (let i2 = 0; i2 < transforms.length; i2 += 1) {
    const transform2 = transforms[i2];
    if (transform2) {
      const [name, rawValue] = transform2.split("(");
      const splitChar = rawValue.indexOf(",") >= 0 ? "," : " ";
      const value2 = rawValue.split(splitChar).map((val) => val.trim());
      parsed.push({ operation: name.trim(), value: value2 });
    }
  }
  return parsed;
};
const parseAngle = (value2) => {
  const unitsRegexp = /(-?\d*\.?\d*)(\w*)?/i;
  const [, angle, unit2] = unitsRegexp.exec(value2);
  const number2 = Number.parseFloat(angle);
  return unit2 === "rad" ? number2 * 180 / Math.PI : number2;
};
const normalizeTransformOperation = ({ operation, value: value2 }) => {
  switch (operation) {
    case "scale": {
      const [scaleX, scaleY = scaleX] = value2.map((num) => Number.parseFloat(num));
      return { operation: "scale", value: [scaleX, scaleY] };
    }
    case "scaleX": {
      return { operation: "scale", value: [Number.parseFloat(value2), 1] };
    }
    case "scaleY": {
      return { operation: "scale", value: [1, Number.parseFloat(value2)] };
    }
    case "rotate": {
      return { operation: "rotate", value: [parseAngle(value2)] };
    }
    case "translate": {
      return {
        operation: "translate",
        value: value2.map((num) => Number.parseFloat(num))
      };
    }
    case "translateX": {
      return {
        operation: "translate",
        value: [Number.parseFloat(value2), 0]
      };
    }
    case "translateY": {
      return { operation: "translate", value: [0, Number.parseFloat(value2)] };
    }
    case "skew": {
      return { operation: "skew", value: value2.map(parseAngle) };
    }
    case "skewX": {
      return { operation: "skew", value: [parseAngle(value2), 0] };
    }
    case "skewY": {
      return { operation: "skew", value: [0, parseAngle(value2)] };
    }
    default: {
      return { operation, value: value2.map((num) => Number.parseFloat(num)) };
    }
  }
};
const normalize$1 = (operations) => {
  return operations.map((operation) => normalizeTransformOperation(operation));
};
const processTransform = (key, value2) => {
  if (typeof value2 !== "string")
    return { [key]: value2 };
  return { [key]: normalize$1(parse(value2)) };
};
const Y_AXIS_SHORTHANDS = { top: true, bottom: true };
const sortTransformOriginPair = (a2, b2) => {
  if (Y_AXIS_SHORTHANDS[a2])
    return 1;
  if (Y_AXIS_SHORTHANDS[b2])
    return -1;
  return 0;
};
const getTransformOriginPair = (values) => {
  if (!values || values.length === 0)
    return ["center", "center"];
  const pair = values.length === 1 ? [values[0], "center"] : values;
  return pair.sort(sortTransformOriginPair);
};
const processTransformOriginShorthand = (key, value2, container) => {
  const match = `${value2}`.split(" ");
  const pair = getTransformOriginPair(match);
  const transformOriginX = transformUnit$1(container, pair[0]);
  const transformOriginY = transformUnit$1(container, pair[1]);
  return {
    transformOriginX: offsetKeyword(transformOriginX) || castFloat(transformOriginX),
    transformOriginY: offsetKeyword(transformOriginY) || castFloat(transformOriginY)
  };
};
const processTransformOriginValue = (key, value2, container) => {
  const v2 = transformUnit$1(container, value2);
  return { [key]: offsetKeyword(v2) || castFloat(v2) };
};
const handlers$1 = {
  transform: processTransform,
  gradientTransform: processTransform,
  transformOrigin: processTransformOriginShorthand,
  transformOriginX: processTransformOriginValue,
  transformOriginY: processTransformOriginValue
};
const handlers = {
  fill: processColorValue,
  stroke: processColorValue,
  strokeDasharray: processNoopValue,
  strokeWidth: processUnitValue,
  fillOpacity: processNumberValue,
  strokeOpacity: processNumberValue,
  fillRule: processNoopValue,
  textAnchor: processNoopValue,
  strokeLinecap: processNoopValue,
  strokeLinejoin: processNoopValue,
  visibility: processNoopValue,
  clipPath: processNoopValue,
  dominantBaseline: processNoopValue
};
const shorthands = {
  ...handlers$b,
  ...handlers$a,
  ...handlers$9,
  ...handlers$8,
  ...handlers$7,
  ...handlers$6,
  ...handlers$5,
  ...handlers$4,
  ...handlers$3,
  ...handlers$2,
  ...handlers$1,
  ...handlers
};
const resolve$1 = (container) => (style) => {
  const propsArray = Object.keys(style);
  const resolvedStyle = {};
  for (let i2 = 0; i2 < propsArray.length; i2 += 1) {
    const key = propsArray[i2];
    const value2 = style[key];
    if (!shorthands[key]) {
      resolvedStyle[key] = value2;
      continue;
    }
    const resolved = shorthands[key](key, value2, container, style);
    const keys = Object.keys(resolved);
    for (let j = 0; j < keys.length; j += 1) {
      const propName = keys[j];
      const propValue = resolved[propName];
      resolvedStyle[propName] = propValue;
    }
  }
  return resolvedStyle;
};
const resolveStyles$1 = (container, style) => {
  const computeMediaQueries = (value2) => resolveMediaQueries(container, value2);
  return compose(resolve$1(container), computeMediaQueries, flatten$1)(style);
};
function bidiFactory() {
  var bidi2 = function(exports) {
    var DATA = {
      "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      "B": "a,3,f+2,2v,690",
      "S": "9,2,k",
      "WS": "c,k,4f4,1vk+a,u,1j,335",
      "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      "LRO": "6ct",
      "RLO": "6cu",
      "LRE": "6cq",
      "RLE": "6cr",
      "PDF": "6cs",
      "LRI": "6ee",
      "RLI": "6ef",
      "FSI": "6eg",
      "PDI": "6eh"
    };
    var TYPES = {};
    var TYPES_TO_NAMES = {};
    TYPES.L = 1;
    TYPES_TO_NAMES[1] = "L";
    Object.keys(DATA).forEach(function(type, i2) {
      TYPES[type] = 1 << i2 + 1;
      TYPES_TO_NAMES[TYPES[type]] = type;
    });
    Object.freeze(TYPES);
    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;
    var map = null;
    function parseData() {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        var loop = function(type2) {
          if (DATA.hasOwnProperty(type2)) {
            var lastCode = 0;
            DATA[type2].split(",").forEach(function(range2) {
              var ref = range2.split("+");
              var skip = ref[0];
              var step = ref[1];
              skip = parseInt(skip, 36);
              step = step ? parseInt(step, 36) : 0;
              map.set(lastCode += skip, TYPES[type2]);
              for (var i2 = 0; i2 < step; i2++) {
                map.set(++lastCode, TYPES[type2]);
              }
            });
          }
        };
        for (var type in DATA) loop(type);
      }
    }
    function getBidiCharType(char) {
      parseData();
      return map.get(char.codePointAt(0)) || TYPES.L;
    }
    function getBidiCharTypeName(char) {
      return TYPES_TO_NAMES[getBidiCharType(char)];
    }
    var data$1 = {
      "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function parseCharacterMap(encodedString, includeReverse) {
      var radix = 36;
      var lastCode = 0;
      var map2 = /* @__PURE__ */ new Map();
      var reverseMap = includeReverse && /* @__PURE__ */ new Map();
      var prevPair;
      encodedString.split(",").forEach(function visit(entry) {
        if (entry.indexOf("+") !== -1) {
          for (var i2 = +entry; i2--; ) {
            visit(prevPair);
          }
        } else {
          prevPair = entry;
          var ref = entry.split(">");
          var a2 = ref[0];
          var b2 = ref[1];
          a2 = String.fromCodePoint(lastCode += parseInt(a2, radix));
          b2 = String.fromCodePoint(lastCode += parseInt(b2, radix));
          map2.set(a2, b2);
          includeReverse && reverseMap.set(b2, a2);
        }
      });
      return { map: map2, reverseMap };
    }
    var openToClose, closeToOpen, canonical;
    function parse$12() {
      if (!openToClose) {
        var ref = parseCharacterMap(data$1.pairs, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        openToClose = map2;
        closeToOpen = reverseMap;
        canonical = parseCharacterMap(data$1.canonical, false).map;
      }
    }
    function openingToClosingBracket(char) {
      parse$12();
      return openToClose.get(char) || null;
    }
    function closingToOpeningBracket(char) {
      parse$12();
      return closeToOpen.get(char) || null;
    }
    function getCanonicalBracket(char) {
      parse$12();
      return canonical.get(char) || null;
    }
    var TYPE_L = TYPES.L;
    var TYPE_R = TYPES.R;
    var TYPE_EN = TYPES.EN;
    var TYPE_ES = TYPES.ES;
    var TYPE_ET = TYPES.ET;
    var TYPE_AN = TYPES.AN;
    var TYPE_CS = TYPES.CS;
    var TYPE_B = TYPES.B;
    var TYPE_S = TYPES.S;
    var TYPE_ON = TYPES.ON;
    var TYPE_BN = TYPES.BN;
    var TYPE_NSM = TYPES.NSM;
    var TYPE_AL = TYPES.AL;
    var TYPE_LRO = TYPES.LRO;
    var TYPE_RLO = TYPES.RLO;
    var TYPE_LRE = TYPES.LRE;
    var TYPE_RLE = TYPES.RLE;
    var TYPE_PDF = TYPES.PDF;
    var TYPE_LRI = TYPES.LRI;
    var TYPE_RLI = TYPES.RLI;
    var TYPE_FSI = TYPES.FSI;
    var TYPE_PDI = TYPES.PDI;
    function getEmbeddingLevels(string, baseDirection) {
      var MAX_DEPTH = 125;
      var charTypes = new Uint32Array(string.length);
      for (var i2 = 0; i2 < string.length; i2++) {
        charTypes[i2] = getBidiCharType(string[i2]);
      }
      var charTypeCounts = /* @__PURE__ */ new Map();
      function changeCharType(i3, type2) {
        var oldType = charTypes[i3];
        charTypes[i3] = type2;
        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
        if (oldType & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
        }
        charTypeCounts.set(type2, (charTypeCounts.get(type2) || 0) + 1);
        if (type2 & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
        }
      }
      var embedLevels = new Uint8Array(string.length);
      var isolationPairs = /* @__PURE__ */ new Map();
      var paragraphs = [];
      var paragraph = null;
      for (var i$1 = 0; i$1 < string.length; i$1++) {
        if (!paragraph) {
          paragraphs.push(paragraph = {
            start: i$1,
            end: string.length - 1,
            // 3.3.1 P2-P3: Determine the paragraph level
            level: baseDirection === "rtl" ? 1 : baseDirection === "ltr" ? 0 : determineAutoEmbedLevel(i$1, false)
          });
        }
        if (charTypes[i$1] & TYPE_B) {
          paragraph.end = i$1;
          paragraph = null;
        }
      }
      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
      var nextEven = function(n3) {
        return n3 + (n3 & 1 ? 1 : 2);
      };
      var nextOdd = function(n3) {
        return n3 + (n3 & 1 ? 2 : 1);
      };
      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
        paragraph = paragraphs[paraIdx];
        var statusStack = [{
          _level: paragraph.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }];
        var stackTop = void 0;
        var overflowIsolateCount = 0;
        var overflowEmbeddingCount = 0;
        var validIsolateCount = 0;
        charTypeCounts.clear();
        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
          var charType = charTypes[i$2];
          stackTop = statusStack[statusStack.length - 1];
          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
          if (charType & NEUTRAL_ISOLATE_TYPES) {
            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
          }
          if (charType & FORMATTING_TYPES) {
            if (charType & (TYPE_RLE | TYPE_LRE)) {
              embedLevels[i$2] = stackTop._level;
              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level,
                  _override: 0,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & (TYPE_RLO | TYPE_LRO)) {
              embedLevels[i$2] = stackTop._level;
              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level$1,
                  _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & ISOLATE_INIT_TYPES) {
              if (charType & TYPE_FSI) {
                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
              }
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
                validIsolateCount++;
                statusStack.push({
                  _level: level$2,
                  _override: 0,
                  _isolate: 1,
                  _isolInitIndex: i$2
                });
              } else {
                overflowIsolateCount++;
              }
            } else if (charType & TYPE_PDI) {
              if (overflowIsolateCount > 0) {
                overflowIsolateCount--;
              } else if (validIsolateCount > 0) {
                overflowEmbeddingCount = 0;
                while (!statusStack[statusStack.length - 1]._isolate) {
                  statusStack.pop();
                }
                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
                if (isolInitIndex != null) {
                  isolationPairs.set(isolInitIndex, i$2);
                  isolationPairs.set(i$2, isolInitIndex);
                }
                statusStack.pop();
                validIsolateCount--;
              }
              stackTop = statusStack[statusStack.length - 1];
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
            } else if (charType & TYPE_PDF) {
              if (overflowIsolateCount === 0) {
                if (overflowEmbeddingCount > 0) {
                  overflowEmbeddingCount--;
                } else if (!stackTop._isolate && statusStack.length > 1) {
                  statusStack.pop();
                  stackTop = statusStack[statusStack.length - 1];
                }
              }
              embedLevels[i$2] = stackTop._level;
            } else if (charType & TYPE_B) {
              embedLevels[i$2] = paragraph.level;
            }
          } else {
            embedLevels[i$2] = stackTop._level;
            if (stackTop._override && charType !== TYPE_BN) {
              changeCharType(i$2, stackTop._override);
            }
          }
        }
        var levelRuns = [];
        var currentRun = null;
        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
          var charType$1 = charTypes[i$3];
          if (!(charType$1 & BN_LIKE_TYPES)) {
            var lvl = embedLevels[i$3];
            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
            var isPDI = charType$1 === TYPE_PDI;
            if (currentRun && lvl === currentRun._level) {
              currentRun._end = i$3;
              currentRun._endsWithIsolInit = isIsolInit;
            } else {
              levelRuns.push(currentRun = {
                _start: i$3,
                _end: i$3,
                _level: lvl,
                _startsWithPDI: isPDI,
                _endsWithIsolInit: isIsolInit
              });
            }
          }
        }
        var isolatingRunSeqs = [];
        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
          var run = levelRuns[runIdx];
          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {
            var seqRuns = [currentRun = run];
            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null; ) {
              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
                if (levelRuns[i$4]._start === pdiIndex) {
                  seqRuns.push(currentRun = levelRuns[i$4]);
                  break;
                }
              }
            }
            var seqIndices = [];
            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
              var run$1 = seqRuns[i$5];
              for (var j = run$1._start; j <= run$1._end; j++) {
                seqIndices.push(j);
              }
            }
            var firstLevel = embedLevels[seqIndices[0]];
            var prevLevel = paragraph.level;
            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {
                prevLevel = embedLevels[i$6];
                break;
              }
            }
            var lastIndex = seqIndices[seqIndices.length - 1];
            var lastLevel = embedLevels[lastIndex];
            var nextLevel = paragraph.level;
            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {
                  nextLevel = embedLevels[i$7];
                  break;
                }
              }
            }
            isolatingRunSeqs.push({
              _seqIndices: seqIndices,
              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
            });
          }
        }
        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
          var ref = isolatingRunSeqs[seqIdx];
          var seqIndices$1 = ref._seqIndices;
          var sosType = ref._sosType;
          var eosType = ref._eosType;
          var embedDirection = embedLevels[seqIndices$1[0]] & 1 ? TYPE_R : TYPE_L;
          if (charTypeCounts.get(TYPE_NSM)) {
            for (var si = 0; si < seqIndices$1.length; si++) {
              var i$8 = seqIndices$1[si];
              if (charTypes[i$8] & TYPE_NSM) {
                var prevType = sosType;
                for (var sj = si - 1; sj >= 0; sj--) {
                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {
                    prevType = charTypes[seqIndices$1[sj]];
                    break;
                  }
                }
                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
              var i$9 = seqIndices$1[si$1];
              if (charTypes[i$9] & TYPE_EN) {
                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
                  if (prevCharType & STRONG_TYPES) {
                    if (prevCharType === TYPE_AL) {
                      changeCharType(i$9, TYPE_AN);
                    }
                    break;
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_AL)) {
            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
              var i$10 = seqIndices$1[si$2];
              if (charTypes[i$10] & TYPE_AL) {
                changeCharType(i$10, TYPE_R);
              }
            }
          }
          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
              var i$11 = seqIndices$1[si$3];
              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
                var prevType$1 = 0, nextType = 0;
                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
                  prevType$1 = charTypes[seqIndices$1[sj$2]];
                  if (!(prevType$1 & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
                  nextType = charTypes[seqIndices$1[sj$3]];
                  if (!(nextType & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {
                  changeCharType(i$11, prevType$1);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
              var i$12 = seqIndices$1[si$4];
              if (charTypes[i$12] & TYPE_EN) {
                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {
                  changeCharType(seqIndices$1[sj$4], TYPE_EN);
                }
                for (si$4++; si$4 < seqIndices$1.length && charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN); si$4++) {
                  if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {
                    changeCharType(seqIndices$1[si$4], TYPE_EN);
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
              var i$13 = seqIndices$1[si$5];
              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
                changeCharType(i$13, TYPE_ON);
                for (var sj$5 = si$5 - 1; sj$5 >= 0 && charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES; sj$5--) {
                  changeCharType(seqIndices$1[sj$5], TYPE_ON);
                }
                for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6++) {
                  changeCharType(seqIndices$1[sj$6], TYPE_ON);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
              var i$14 = seqIndices$1[si$6];
              var type = charTypes[i$14];
              if (type & TYPE_EN) {
                if (prevStrongType === TYPE_L) {
                  changeCharType(i$14, TYPE_L);
                }
              } else if (type & STRONG_TYPES) {
                prevStrongType = type;
              }
            }
          }
          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;
            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;
            var bracketPairs = [];
            {
              var openerStack = [];
              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
                  var char = string[seqIndices$1[si$7]];
                  var oppositeBracket = void 0;
                  if (openingToClosingBracket(char) !== null) {
                    if (openerStack.length < 63) {
                      openerStack.push({ char, seqIndex: si$7 });
                    } else {
                      break;
                    }
                  } else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
                      var stackChar = openerStack[stackIdx].char;
                      if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(char)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === char) {
                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
                        openerStack.length = stackIdx;
                        break;
                      }
                    }
                  }
                }
              }
              bracketPairs.sort(function(a2, b2) {
                return a2[0] - b2[0];
              });
            }
            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
              var ref$1 = bracketPairs[pairIdx];
              var openSeqIdx = ref$1[0];
              var closeSeqIdx = ref$1[1];
              var foundStrongType = false;
              var useStrongType = 0;
              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
                var i$15 = seqIndices$1[si$8];
                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
                  foundStrongType = true;
                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                  if (lr === embedDirection) {
                    useStrongType = lr;
                    break;
                  }
                }
              }
              if (foundStrongType && !useStrongType) {
                useStrongType = sosType;
                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
                  var i$16 = seqIndices$1[si$9];
                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    if (lr$1 !== embedDirection) {
                      useStrongType = lr$1;
                    } else {
                      useStrongType = embedDirection;
                    }
                    break;
                  }
                }
              }
              if (useStrongType) {
                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
                if (useStrongType !== embedDirection) {
                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$10]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
                if (useStrongType !== embedDirection) {
                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$11]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
              }
            }
            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
                var niRunStart = si$12, niRunEnd = si$12;
                var prevType$2 = sosType;
                for (var si2 = si$12 - 1; si2 >= 0; si2--) {
                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
                    niRunStart = si2;
                  } else {
                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                var nextType$1 = eosType;
                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
                    niRunEnd = si2$1;
                  } else {
                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {
                  charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;
                }
                si$12 = niRunEnd;
              }
            }
          }
        }
        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
          var level$3 = embedLevels[i$17];
          var type$1 = charTypes[i$17];
          if (level$3 & 1) {
            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
              embedLevels[i$17]++;
            }
          } else {
            if (type$1 & TYPE_R) {
              embedLevels[i$17]++;
            } else if (type$1 & (TYPE_AN | TYPE_EN)) {
              embedLevels[i$17] += 2;
            }
          }
          if (type$1 & BN_LIKE_TYPES) {
            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
          }
          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {
              embedLevels[j$1] = paragraph.level;
            }
          }
        }
      }
      return {
        levels: embedLevels,
        paragraphs
      };
      function determineAutoEmbedLevel(start2, isFSI) {
        for (var i3 = start2; i3 < string.length; i3++) {
          var charType2 = charTypes[i3];
          if (charType2 & (TYPE_R | TYPE_AL)) {
            return 1;
          }
          if (charType2 & (TYPE_B | TYPE_L) || isFSI && charType2 === TYPE_PDI) {
            return 0;
          }
          if (charType2 & ISOLATE_INIT_TYPES) {
            var pdi = indexOfMatchingPDI(i3);
            i3 = pdi === -1 ? string.length : pdi;
          }
        }
        return 0;
      }
      function indexOfMatchingPDI(isolateStart) {
        var isolationLevel = 1;
        for (var i3 = isolateStart + 1; i3 < string.length; i3++) {
          var charType2 = charTypes[i3];
          if (charType2 & TYPE_B) {
            break;
          }
          if (charType2 & TYPE_PDI) {
            if (--isolationLevel === 0) {
              return i3;
            }
          } else if (charType2 & ISOLATE_INIT_TYPES) {
            isolationLevel++;
          }
        }
        return -1;
      }
    }
    var data2 = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";
    var mirrorMap;
    function parse2() {
      if (!mirrorMap) {
        var ref = parseCharacterMap(data2, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        reverseMap.forEach(function(value2, key) {
          map2.set(key, value2);
        });
        mirrorMap = map2;
      }
    }
    function getMirroredCharacter(char) {
      parse2();
      return mirrorMap.get(char) || null;
    }
    function getMirroredCharactersMap(string, embeddingLevels, start2, end2) {
      var strLen = string.length;
      start2 = Math.max(0, start2 == null ? 0 : +start2);
      end2 = Math.min(strLen - 1, end2 == null ? strLen - 1 : +end2);
      var map2 = /* @__PURE__ */ new Map();
      for (var i2 = start2; i2 <= end2; i2++) {
        if (embeddingLevels[i2] & 1) {
          var mirror = getMirroredCharacter(string[i2]);
          if (mirror !== null) {
            map2.set(i2, mirror);
          }
        }
      }
      return map2;
    }
    function getReorderSegments(string, embeddingLevelsResult, start2, end2) {
      var strLen = string.length;
      start2 = Math.max(0, start2 == null ? 0 : +start2);
      end2 = Math.min(strLen - 1, end2 == null ? strLen - 1 : +end2);
      var segments = [];
      embeddingLevelsResult.paragraphs.forEach(function(paragraph) {
        var lineStart = Math.max(start2, paragraph.start);
        var lineEnd = Math.min(end2, paragraph.end);
        if (lineStart < lineEnd) {
          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);
          for (var i2 = lineEnd; i2 >= lineStart && getBidiCharType(string[i2]) & TRAILING_TYPES; i2--) {
            lineLevels[i2] = paragraph.level;
          }
          var maxLevel = paragraph.level;
          var minOddLevel = Infinity;
          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
            var level = lineLevels[i$1];
            if (level > maxLevel) {
              maxLevel = level;
            }
            if (level < minOddLevel) {
              minOddLevel = level | 1;
            }
          }
          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
              if (lineLevels[i$2] >= lvl) {
                var segStart = i$2;
                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
                  i$2++;
                }
                if (i$2 > segStart) {
                  segments.push([segStart + lineStart, i$2 + lineStart]);
                }
              }
            }
          }
        }
      });
      return segments;
    }
    function getReorderedString(string, embedLevelsResult, start2, end2) {
      var indices = getReorderedIndices2(string, embedLevelsResult, start2, end2);
      var chars = [].concat(string);
      indices.forEach(function(charIndex, i2) {
        chars[i2] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];
      });
      return chars.join("");
    }
    function getReorderedIndices2(string, embedLevelsResult, start2, end2) {
      var segments = getReorderSegments(string, embedLevelsResult, start2, end2);
      var indices = [];
      for (var i2 = 0; i2 < string.length; i2++) {
        indices[i2] = i2;
      }
      segments.forEach(function(ref) {
        var start3 = ref[0];
        var end3 = ref[1];
        var slice5 = indices.slice(start3, end3 + 1);
        for (var i3 = slice5.length; i3--; ) {
          indices[end3 - i3] = slice5[i3];
        }
      });
      return indices;
    }
    exports.closingToOpeningBracket = closingToOpeningBracket;
    exports.getBidiCharType = getBidiCharType;
    exports.getBidiCharTypeName = getBidiCharTypeName;
    exports.getCanonicalBracket = getCanonicalBracket;
    exports.getEmbeddingLevels = getEmbeddingLevels;
    exports.getMirroredCharacter = getMirroredCharacter;
    exports.getMirroredCharactersMap = getMirroredCharactersMap;
    exports.getReorderSegments = getReorderSegments;
    exports.getReorderedIndices = getReorderedIndices2;
    exports.getReorderedString = getReorderedString;
    exports.openingToClosingBracket = openingToClosingBracket;
    Object.defineProperty(exports, "__esModule", { value: true });
    return exports;
  }({});
  return bidi2;
}
var hyphen$2 = { exports: {} };
var hyphen$1 = hyphen$2.exports;
var hasRequiredHyphen;
function requireHyphen() {
  if (hasRequiredHyphen) return hyphen$2.exports;
  hasRequiredHyphen = 1;
  (function(module) {
    (function(root, factory) {
      if (module.exports) {
        module.exports = factory();
      } else {
        root.createHyphenator = factory();
      }
    })(hyphen$1, function() {
      function createTextReader(setup) {
        var char1 = "";
        var char2 = "";
        var i2 = 0;
        var verifier = setup();
        return function(text) {
          while (i2 < text.length) {
            char1 = text.charAt(i2++);
            char2 = text.charAt(i2);
            var verified = verifier(char1, char2);
            if (verified !== void 0) {
              return verified;
            }
          }
        };
      }
      var isNotLetter = RegExp.prototype.test.bind(
        /\s|(?![\'])[\!-\@\[-\`\{-\~\u2013-\u203C]/
      );
      function createHTMLVerifier() {
        var skip = false;
        return function(accumulate, chars) {
          if (skip) {
            if (chars[0] === ">") {
              accumulate();
              skip = false;
            }
          } else if (chars[0] === "<" && (!isNotLetter(chars[1]) || chars[1] === "/")) {
            skip = true;
          }
          return skip;
        };
      }
      function createHyphenCharVerifier(hyphenChar) {
        var skip = false;
        return function(accumulate, chars) {
          if (skip) {
            if (!isNotLetter(chars[0]) && isNotLetter(chars[1])) {
              accumulate();
              skip = false;
            }
          } else if (!isNotLetter(chars[0]) && chars[1] === hyphenChar) {
            skip = true;
          }
          return skip;
        };
      }
      function createHyphenationVerifier(verifiers, minWordLength) {
        return function() {
          var accum0 = "";
          var accum = "";
          function accumulate() {
            accum0 += accum;
            accum = "";
          }
          function resolveWith(value2) {
            accum0 = "";
            accum = "";
            return value2;
          }
          return function(char1, char2) {
            accum += char1;
            var skip = verifiers.reduce(function(skip2, verify) {
              return skip2 || verify(accumulate, [char1, char2]);
            }, false);
            if (!skip) {
              if (isNotLetter(char1) && !isNotLetter(char2)) {
                accumulate();
              }
              if (!isNotLetter(char1) && isNotLetter(char2)) {
                if (accum.length >= minWordLength) {
                  return resolveWith([accum0, accum]);
                } else {
                  accumulate();
                }
              }
            }
            if (char2 === "") {
              if (accum.length < minWordLength || skip) {
                accumulate();
              }
              return resolveWith([accum0, accum]);
            }
          };
        };
      }
      function createCharIterator(str) {
        var i2 = 0;
        function nextChar() {
          return str[i2++];
        }
        return nextChar;
      }
      function createStringSlicer(str) {
        var i2 = 0, slice5 = str;
        function next() {
          slice5 = str.slice(i2++);
          if (slice5.length < 3) {
            return;
          }
          return slice5;
        }
        function isFirstCharacter() {
          return i2 === 2;
        }
        return [next, isFirstCharacter];
      }
      function hyphenateWord(text, levelsTable, patternTrie, debug2, hyphenChar) {
        var levels = new Array(text.length + 1), loweredText = ("." + text.toLocaleLowerCase() + ".").split(""), wordSlice, letter, triePtr, trieNode, patternLevelsIndex, patternLevels, patternEntityIndex = -1, slicer, nextSlice, isFirstCharacter, nextLetter;
        for (var i2 = levels.length; i2--; ) levels[i2] = 0;
        slicer = createStringSlicer(loweredText);
        nextSlice = slicer[0];
        isFirstCharacter = slicer[1];
        while (wordSlice = nextSlice()) {
          patternEntityIndex++;
          if (isFirstCharacter()) {
            patternEntityIndex--;
          }
          triePtr = patternTrie;
          nextLetter = createCharIterator(wordSlice);
          while (letter = nextLetter()) {
            if ((trieNode = triePtr[letter]) === void 0) {
              break;
            }
            triePtr = {};
            patternLevelsIndex = -1;
            switch (Object.prototype.toString.call(trieNode)) {
              case "[object Array]":
                triePtr = trieNode[0];
                patternLevelsIndex = trieNode[1];
                break;
              case "[object Object]":
                triePtr = trieNode;
                break;
              case "[object Number]":
                patternLevelsIndex = trieNode;
                break;
            }
            if (patternLevelsIndex < 0) {
              continue;
            }
            if (!levelsTable[patternLevelsIndex].splice) {
              levelsTable[patternLevelsIndex] = levelsTable[patternLevelsIndex].slice("");
            }
            patternLevels = levelsTable[patternLevelsIndex];
            for (var k2 = 0; k2 < patternLevels.length; k2++)
              levels[patternEntityIndex + k2] = Math.max(
                patternLevels[k2],
                levels[patternEntityIndex + k2]
              );
          }
        }
        levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;
        var hyphenatedText = "";
        for (var i2 = 0; i2 < levels.length; i2++) {
          hyphenatedText += (levels[i2] % 2 === 1 ? hyphenChar : "") + text.charAt(i2);
        }
        return hyphenatedText;
      }
      function start2(text, levelsTable, patterns, cache2, debug2, hyphenChar, skipHTML, minWordLength, isAsync) {
        function done2() {
          resolveNewText(newText);
        }
        var newText = "", fragments, readText = createTextReader(
          createHyphenationVerifier(
            (skipHTML ? [createHTMLVerifier()] : []).concat(
              createHyphenCharVerifier(hyphenChar)
            ),
            minWordLength
          )
        ), resolveNewText = function() {
        };
        function nextTick2() {
          var loopStart = /* @__PURE__ */ new Date();
          while ((!isAsync || /* @__PURE__ */ new Date() - loopStart < 10) && (fragments = readText(text))) {
            if (fragments[1]) {
              var cacheKey = fragments[1].length ? "~" + fragments[1] : "";
              if (cache2[cacheKey] === void 0) {
                cache2[cacheKey] = hyphenateWord(
                  fragments[1],
                  levelsTable,
                  patterns,
                  debug2,
                  hyphenChar
                );
              }
              fragments[1] = cache2[cacheKey];
            }
            newText += fragments[0] + fragments[1];
          }
          if (!fragments) {
            done2();
          } else {
            setTimeout(nextTick2);
          }
        }
        if (isAsync) {
          setTimeout(nextTick2);
          return new Promise(function(resolve2) {
            resolveNewText = resolve2;
          });
        } else {
          nextTick2();
          return newText;
        }
      }
      var SETTING_DEFAULT_ASYNC = false;
      var SETTING_DEFAULT_DEBUG = false;
      var SETTING_DEFAULT_EXCEPTIONS = [];
      var SETTING_DEFAULT_HTML = true;
      var SETTING_DEFAULT_HYPH_CHAR = "";
      var SETTING_DEFAULT_MIN_WORD_LENGTH = 5;
      var SETTING_NAME_ASYNC = "async";
      var SETTING_NAME_DEBUG = "debug";
      var SETTING_NAME_EXCEPTIONS = "exceptions";
      var SETTING_NAME_HTML = "html";
      var SETTING_NAME_HYPH_CHAR = "hyphenChar";
      var SETTING_NAME_MIN_WORD_LENGTH = "minWordLength";
      var _global = typeof commonjsGlobal$1 === "object" ? commonjsGlobal$1 : typeof window === "object" ? window : typeof self === "object" ? self : {};
      function extend(target, source) {
        target = target || {};
        for (var key in source) {
          target[key] = source[key];
        }
        return target;
      }
      function validateArray(value2) {
        return value2 instanceof Array;
      }
      function keyOrDefault(object, key, defaultValue, test) {
        if (key in object && (test ? test(object[key]) : true)) {
          return object[key];
        }
        return defaultValue;
      }
      function exceptionsFromDefinition(excetionsList, hyphenChar) {
        return excetionsList.reduce(function(exceptions, exception) {
          exceptions["~" + exception.replace(/\-/g, "")] = exception.replace(
            /\-/g,
            hyphenChar
          );
          return exceptions;
        }, {});
      }
      function createHyphenator(patternsDefinition, options) {
        options = options || {};
        var asyncMode = keyOrDefault(
          options,
          SETTING_NAME_ASYNC,
          SETTING_DEFAULT_ASYNC
        ), caches = {}, debug2 = keyOrDefault(options, SETTING_NAME_DEBUG, SETTING_DEFAULT_DEBUG), exceptions = {}, hyphenChar = keyOrDefault(
          options,
          SETTING_NAME_HYPH_CHAR,
          SETTING_DEFAULT_HYPH_CHAR
        ), levelsTable = patternsDefinition[0].split(","), patterns = JSON.parse(patternsDefinition[1]), minWordLength = keyOrDefault(
          options,
          SETTING_NAME_MIN_WORD_LENGTH,
          SETTING_DEFAULT_MIN_WORD_LENGTH
        ) >> 0, skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML), userExceptions = keyOrDefault(
          options,
          SETTING_NAME_EXCEPTIONS,
          SETTING_DEFAULT_EXCEPTIONS,
          validateArray
        );
        var cacheKey = hyphenChar + minWordLength;
        exceptions[cacheKey] = {};
        if (patternsDefinition[2]) {
          exceptions[cacheKey] = exceptionsFromDefinition(
            patternsDefinition[2],
            hyphenChar
          );
        }
        if (userExceptions && userExceptions.length) {
          exceptions[cacheKey] = extend(
            exceptions[cacheKey],
            exceptionsFromDefinition(userExceptions, hyphenChar)
          );
        }
        caches[cacheKey] = extend({}, exceptions[cacheKey]);
        if (asyncMode && !("Promise" in _global)) {
          throw new Error(
            "Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode"
          );
        }
        return function(text, options2) {
          options2 = options2 || {};
          var localDebug = keyOrDefault(options2, SETTING_NAME_DEBUG, debug2), localHyphenChar = keyOrDefault(
            options2,
            SETTING_NAME_HYPH_CHAR,
            hyphenChar
          ), localMinWordLength = keyOrDefault(options2, SETTING_NAME_MIN_WORD_LENGTH, minWordLength) >> 0, localUserExceptions = keyOrDefault(
            options2,
            SETTING_NAME_EXCEPTIONS,
            SETTING_DEFAULT_EXCEPTIONS,
            validateArray
          ), cacheKey2 = localHyphenChar + localMinWordLength;
          if (!exceptions[cacheKey2] && patternsDefinition[2]) {
            exceptions[cacheKey2] = exceptionsFromDefinition(
              patternsDefinition[2],
              localHyphenChar
            );
            caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);
          }
          if (localUserExceptions && localUserExceptions.length) {
            exceptions[cacheKey2] = extend(
              exceptions[cacheKey2],
              exceptionsFromDefinition(localUserExceptions, localHyphenChar)
            );
            caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);
          }
          return start2(
            text,
            levelsTable,
            patterns,
            caches[cacheKey2],
            localDebug,
            localHyphenChar,
            skipHTML,
            localMinWordLength,
            asyncMode
          );
        };
      }
      return createHyphenator;
    });
  })(hyphen$2);
  return hyphen$2.exports;
}
var hyphenExports = requireHyphen();
const hyphen = /* @__PURE__ */ getDefaultExportFromCjs$2(hyphenExports);
var enUs$1 = { exports: {} };
var enUs = enUs$1.exports;
var hasRequiredEnUs;
function requireEnUs() {
  if (hasRequiredEnUs) return enUs$1.exports;
  hasRequiredEnUs = 1;
  (function(module) {
    (function(root, factory) {
      if (module.exports) {
        module.exports = factory();
      } else {
        root.hyphenationPatternsEnUs = factory();
      }
    })(enUs, function() {
      return [
        "0004,004,001,003,005,0005,00005,000005,0002,002,0000005,0003,00003,00505,00034,0001,00055,00004,4,05,0055,04,42,03,02,2,404,3,044,01,0505,55,5,045,041,0033,000004,22,00504,5504,0042,1,21,41,402,405,4004,43,23,000054,303,3005,022,5004,000003,252,45,25,2004,000505,054,403,401,3002,0025,144,432,00054,34,12,234,0022,014,0304,012,143,503,0403,101,052,414,212,011,043,00002,0041,0024,05005,03003,00102,0404,04303,01004,0034,025,0044,00404,00025,0103,042,0205,412,104,54,344,433,5005,253,055,0402,3004,0043,204,505,454,0000004,00303,04004,552,201,4005,0255,52,444,14,44,02004,033,05004,00045,00013,0021,0405,00044,0054,50055,000303,00001,304,0204,11,301,232,122,00305,504,000043,0104,00052,000045,50004,0023,00033,00032,00202,5003,202,0401,0000505,214,102,032,000161,004101,00501,00301,0036,0052,00023,006101,006,00401,000521,0014,0063,00012,000501,000006,000604,000601,005001,005005,0010305,00006,003012,003005,0003011,0061,013,000021,000022,000105,00211,00062,00051,000112,006013,000011,0200306,1021,0050001,003003,2102,305,000015,01030005,000035,001011,00021,16330001,0234,030006,5020001,000001,00016,0031,021,21431,002305,0350014,0000012,000063,00101,106,105,00435,00063,0300061,00041,100306,003602,023,0503,0010011,10003,1005,30011,00031,0001001,0000061,0030003,30305,001201,0301,5000101,500101,00015,000401,000065,000016,0000402,0500002,000205,030201,500301,00014,5001,000002,00030011,01034,0300006,030213,00400304,050001,05003,000311,0634,00061,0006,00000604,00050013,00213,0030001,100003,000033,30002,00003632,0003004,050003,0000021,006303,0000006,00005005,30451,03001,00231,00056,00011,6,001001,00500001,03005,503005,0000010001,1002,003001,001065,300001,32011,32,0000003,0213001,0500053,021005,10001,0000011,0001041,0020016,100032,50011,0606,5002,3001,03002,0015001,0102,00003001,000000033,0000001,300101,300015,0101003,00000101,0100501,0101,0010033,00000362,000014,0005001,031",
        '{".":{"a":{"c":{"h":0},"d":{"d":{"e":{"r":1}}},"f":{"t":2},"l":{"t":3},"m":{"a":{"t":4}},"n":{"c":4,"g":0,"i":{"m":5},"t":[{"e":3,"i":{"s":6}},0]},"r":{"s":4,"t":{"i":{"e":1},"y":1}},"s":{"c":3,"p":2,"s":2,"t":{"e":{"r":7}}},"t":{"o":{"m":6}},"u":{"d":2},"v":{"i":1},"w":{"n":0}},"b":{"a":{"g":1,"n":{"a":4},"s":{"e":0}},"e":{"r":[{"a":4},0],"s":{"m":3,"t":{"o":4}}},"r":{"i":8},"u":{"t":{"t":{"i":0}}}},"c":{"a":{"m":{"p":{"e":0}},"n":{"c":5},"p":{"a":{"b":6}},"r":{"o":{"l":5}},"t":1},"e":{"l":{"a":1}},"h":[{"i":{"l":{"l":{"i":7}}}},1],"i":[{"t":{"r":5}},9],"o":{"e":3,"r":[{"n":{"e":{"r":5}}},1],"n":{"g":{"r":5}}}},"d":{"e":{"m":{"o":{"i":1}},"o":3,"r":{"a":3,"i":[{"v":{"a":4}},3]},"s":{"c":0}},"i":{"c":{"t":{"i":{"o":10}}}},"o":{"t":1},"u":{"c":1,"m":{"b":6}},"r":{"i":{"v":67}}},"e":{"a":{"r":{"t":{"h":7}},"s":{"i":11}},"b":1,"e":{"r":0},"g":9,"l":{"d":4,"e":{"m":3}},"n":{"a":{"m":12},"g":3,"s":3},"q":{"u":{"i":{"t":13}}},"r":{"r":{"i":1}},"s":3,"u":[{"l":{"e":{"r":1}}},3],"y":{"e":5},"t":{"h":{"y":{"l":162}}},"v":[{"e":{"r":{"s":{"i":{"b":158}}}}},9]},"f":{"e":{"s":11},"o":{"r":{"m":{"e":{"r":5}}}}},"g":{"a":[{"s":{"o":{"m":163}}},9],"e":[{"n":{"t":14},"o":{"g":4,"m":{"e":1},"t":164}},9],"i":{"a":4,"b":1},"o":{"r":1}},"h":{"a":{"n":{"d":{"i":6},"k":5}},"e":[{"r":{"o":{"i":6,"e":3}},"s":11,"t":11,"m":{"o":165},"p":{"a":166}},9],"i":{"b":3,"e":{"r":3}},"o":{"n":{"e":{"y":5},"o":11},"v":5}},"i":{"d":{"l":1,"o":{"l":12}},"m":{"m":3,"p":{"i":{"n":4}}},"n":[{"c":{"i":3},"e":8,"k":9,"s":3,"u":{"t":167}},2],"r":{"r":4},"s":{"i":1}},"j":{"u":{"r":3}},"l":{"a":{"c":{"y":1},"m":1,"t":{"e":{"r":5},"h":6}},"e":[{"g":{"e":5},"n":0,"p":5,"v":15,"i":{"c":{"e":{"s":170}}}},9],"i":{"g":[{"a":5},1],"n":9,"o":3,"t":1}},"m":{"a":{"g":{"a":16},"l":{"o":5},"n":{"a":5},"r":{"t":{"i":5}}},"e":[{"r":{"c":11},"t":{"e":{"r":4},"a":{"l":{"a":0}}},"g":{"a":{"l":171}}},9],"i":{"s":[{"t":{"i":6},"e":{"r":{"s":173}}},15],"m":{"i":{"c":172}}},"o":{"n":{"e":11},"r":{"o":3}},"u":{"t":{"a":[{"b":6},4]}}},"n":{"i":{"c":1},"e":{"o":{"f":174}},"o":{"e":{"t":{"h":15}},"n":{"e":{"m":175}}}},"o":{"d":[{"d":5},9],"f":{"t":{"e":4}},"r":{"a":{"t":{"o":4}},"c":3,"d":2,"t":3},"s":[{"t":{"l":1}},3],"t":{"h":11},"u":{"t":11}},"p":{"e":{"d":{"a":{"l":5}},"t":{"e":4,"i":{"t":4}}},"i":{"e":1,"o":{"n":5},"t":9},"r":{"e":{"m":11,"a":{"m":15}}},"o":{"l":{"y":{"s":137}},"s":{"t":{"a":{"m":137}}}}},"r":{"a":{"c":1,"n":{"t":0},"t":{"i":{"o":{"n":{"a":7}}}},"v":{"e":{"n":{"o":176}}}},"e":{"e":[{"c":173},8],"m":{"i":{"t":4}},"s":[{"t":{"a":{"t":4}}},8]},"i":{"g":1,"t":{"u":5}},"o":{"q":1,"s":{"t":5},"w":{"d":5}},"u":{"d":1}},"s":{"c":{"i":{"e":11}},"e":{"l":{"f":6,"l":6},"n":9,"r":{"i":{"e":4}},"m":{"i":[{"c":0,"d":177,"p":36,"r":36,"s":178,"v":36},6]}},"h":9,"i":[{"n":{"g":17}},9],"t":[{"a":{"b":{"l":5}}},1],"y":9,"p":{"h":{"i":{"n":179}},"i":{"n":{"o":137}}}},"t":{"a":[{"p":{"e":{"s":{"t":{"r":180}}}}},1],"e":[{"n":{"a":{"n":5}},"l":{"e":{"g":{"r":3}}}},1],"h":9,"i":[{"l":0,"m":{"o":16},"n":{"g":17,"k":5}},9],"o":{"n":{"a":0},"p":[{"i":5,"o":{"g":170}},1],"u":{"s":5},"q":9},"r":{"i":{"b":{"u":{"t":6}}}}},"u":{"n":{"a":[{"t":{"t":144}},2],"c":{"e":3},"d":{"e":{"r":7}},"e":[{"r":{"r":181}},2],"k":4,"o":4,"u":3},"p":3,"r":{"e":11},"s":{"a":4}},"v":{"e":{"n":{"d":{"e":0}},"r":{"a":4}},"i":{"c":{"a":{"r":151}}}},"w":{"i":{"l":{"i":5}},"e":{"b":{"l":131}}},"y":{"e":1},"k":{"i":{"l":{"n":{"i":168}}},"o":{"r":{"t":{"e":169}}}}},"a":{"b":{".":18,"a":{"l":19,"n":19},"e":[{"r":{"d":4}},8],"i":{"a":5,"t":{"a":{"b":13}}},"l":{"a":{"t":4}},"o":{"l":{"i":{"z":20,"c":19}}},"r":[{"o":{"g":4}},18],"u":{"l":3}},"c":{"a":{"r":[{"d":4,"o":4},21],"b":{"l":24}},"e":{"o":{"u":19},"r":2},"h":{"e":{"t":19}},"i":[{"e":23,"n":2,"o":23},22],"r":{"o":{"b":4}},"t":{"i":{"f":5}},"u":{"l":3,"m":1}},"d":[{"d":{"i":{"n":1}},"e":{"r":{".":4}},"i":[{"a":23,"c":{"a":3},"e":{"r":0},"o":23,"t":23,"u":19},25],"l":{"e":1},"o":{"w":3},"r":{"a":{"n":4}},"s":{"u":1},"u":[{"c":23,"m":4},18]},24],"e":{"r":[{"i":{"e":17}},1]},"f":[{"f":[{"i":{"s":{"h":170}}},0]},24],"g":{"a":{"b":21,"n":0},"e":{"l":{"l":4},"o":0,"u":18},"i":2,"l":26,"n":2,"o":[{"g":27,"n":{"i":3}},24],"u":{"e":{"r":19},"l":4},"y":21},"h":{"a":23,"e":23,"l":1,"o":23},"i":[{"a":19,"c":{".":23},"l":{"y":4},"n":[{"i":{"n":5},"o":5},28],"t":{"e":{"n":5}}},9],"j":29,"k":{"e":{"n":2}},"l":{"a":{"b":4,"d":3,"r":21},"d":{"i":18},"e":[{"n":{"d":3,"t":{"i":21}},"o":30},25],"i":[{"a":{".":1},"e":0},2],"l":{"e":{"v":4},"i":{"c":18}},"m":18,"o":{"g":{".":19}},"y":{".":21,"s":[{"t":31},18],"t":32,"z":27}},"m":{"a":[{"b":4,"g":3,"r":{"a":5},"s":{"c":4},"t":{"i":{"s":21},"o":33}},18],"e":{"r":{"a":4},"n":{"t":{"a":{"b":182}}}},"i":{"c":3,"f":4,"l":{"y":4},"n":[{"o":0},2]},"o":[{"n":19,"r":{"i":6}},24],"p":{"e":{"n":5}}},"n":[{"a":{"g":{"e":3},"l":{"y":[{"s":183},27]},"r":[{"c":3,"i":17},23],"t":{"i":23}},"d":[{"e":{"s":17},"i":{"s":3},"l":2,"o":{"w":1}},18],"e":{"e":19,"n":23,"s":{"t":{".":4}},"u":23},"g":[{"i":{"e":5},"l":2},25],"i":{"c":34,"e":{"s":23},"f":35,"m":{"e":1,"i":19},"n":{"e":19},"o":3,"p":23,"s":{"h":3},"t":3,"u":23},"k":{"l":{"i":1}},"n":{"i":{"z":32}},"o":[{"t":[{"h":7},4],"a":{"c":148}},0],"s":{"a":9,"c":{"o":1},"n":1,"p":[{"o":11},9],"t":1,"u":{"r":1},"g":{"r":5},"v":11},"t":{"a":{"l":36},"i":{"e":1,"d":137,"n":184,"r":{"e":137}},"o":18,"r":9,"w":1},"u":{"a":3,"l":3,"r":19}},24],"o":18,"p":{"a":{"r":17,"t":4},"e":{"r":{"o":4},"a":{"b":{"l":{"e":132}}}},"h":{"e":{"r":23},"i":18},"i":{"l":{"l":{"a":[{"r":4},21]}},"n":3,"t":{"a":3,"u":23}},"l":24,"o":{"c":6,"l":{"a":4},"r":{"i":6},"s":{"t":12}},"s":{"e":{"s":5}},"u":23},"q":{"u":{"e":6}},"r":[{"a":{"c":{"t":3},"d":{"e":19,"i":{"s":4}},"l":3,"m":{"e":{"t":{"e":19}}},"n":{"g":17},"p":11,"t":[{"i":{"o":19,"v":4}},1],"u":19,"v":38,"w":17},"b":{"a":{"l":36}},"c":{"h":{"a":{"n":1},"e":{"t":185}}},"d":{"i":{"n":{"e":4}},"r":1},"e":{"a":{"s":4},"e":23,"n":{"t":3},"s":{"s":19}},"f":{"i":1,"l":1},"i":[{"a":{"l":4,"n":3},"e":{"t":23},"m":1,"n":{"a":{"t":4}},"o":3,"z":9},2],"m":{"i":9},"o":{"d":20,"n":{"i":19},"o":23},"p":9,"q":3,"r":{"e":17,"a":{"n":{"g":{"e":9}}}},"s":{"a":1,"h":9}},37],"s":{".":18,"a":{"b":1,"n":{"t":3}},"h":{"i":17},"i":{"a":{".":19},"b":23,"c":23,"t":39},"k":{"i":11},"l":1,"o":{"c":21},"p":{"h":4},"s":{"h":1},"t":{"e":{"n":3},"r":2},"u":{"r":{"a":6}},"y":{"m":{"p":{"t":{"o":{"t":4}}}}}},"t":{"a":[{"b":{"l":3},"c":4,"l":{"o":3},"p":4},24],"e":{"c":[{"h":4},5],"g":{"o":3},"n":{".":3},"r":{"a":3,"n":[{"a":19},6]},"s":{"t":3},"v":4},"h":[{"e":{"m":5,"n":19,"r":{"o":{"s":186}}},"o":[{"m":5},1]},18],"i":{".":18,"a":19,"b":20,"c":2,"f":3,"o":{"n":{"a":{"r":7}}},"t":{"u":3}},"o":{"g":21,"m":[{"i":{"z":4}},24],"p":21,"s":21},"r":[{"o":{"p":4}},29],"s":{"k":1},"t":{"a":{"g":1},"e":[{"s":{".":170}},4],"h":1},"u":[{"a":4,"e":4,"l":3,"r":{"a":3}},24],"y":24},"u":{"b":1,"g":{"h":[{"t":{"l":17}},12],"u":3},"l":[{"i":{"f":13}},40],"n":{"d":5},"r":3,"s":{"i":{"b":4}},"t":{"e":{"n":5},"h":2}},"v":{"a":[{"g":3,"n":19},24],"e":{"n":{"o":0},"r":{"a":3,"n":4,"y":4}},"i":[{"e":{"r":0},"g":3,"o":{"u":3}},2],"o":{"c":4,"r":29}},"w":{"a":{"y":27},"i":3,"l":{"y":1},"s":0},"x":{"i":{"c":1,"d":1}},"y":{"a":{"l":4},"e":0,"s":0},"z":{"i":{"e":{"r":0}},"z":{"i":5}}},"b":{"a":{".":32,"d":{"g":{"e":{"r":5}}},"g":{"e":1},"l":{"a":15},"n":{"d":{"a":{"g":5}},"e":0,"i":11},"r":{"b":{"i":7},"i":{"a":17},"o":{"n":{"i":{"e":187}}}},"s":{"s":{"i":0}},"t":[{"h":{"y":2}},41],"z":1,"c":{"k":{"e":{"r":{".":84}}}}},"b":[{"e":[{"r":23},24],"i":{"n":{"a":0},"t":0}},42],"d":43,"e":{".":18,"a":{"k":17,"t":12},"d":[{"a":3,"e":3,"i":3},44],"g":{"i":3,"u":4},"l":[{"i":2,"o":3},41],"m":45,"n":{"i":{"g":4},"u":4},"s":[{"p":3,"t":{"r":4}},46],"t":[{"i":{"z":5},"r":4,"w":3},27],"w":3,"y":{"o":4},"v":{"i":{"e":9}}},"f":25,"h":47,"i":{"b":9,"d":[{"i":{"f":167}},1],"e":[{"n":4,"r":1},27],"f":48,"l":[{"i":{"z":3},"l":{"a":{"b":8}}},41],"n":{"a":{"r":49},"d":0,"e":{"t":4}},"o":{"g":{"r":3},"u":4,"m":5,"r":{"b":2,"h":15}},"t":[{"i":{"o":50,"v":{"e":188}},"r":3,"u":{"a":51},"z":19},9]},"j":29,"k":1,"l":[{"a":{"t":{"h":7},"n":{"d":189}},"e":{".":21,"n":17,"s":{"p":32}},"i":{"s":23,"n":{"d":189}},"o":[{"n":{"d":190}},21],"u":{"n":{"t":17}}},52],"m":43,"n":[{"e":{"g":5}},47],"o":{"d":[{"i":11},27],"e":1,"l":{"i":{"c":11}},"m":{"b":{"i":0}},"n":{"a":[{"t":5},0]},"o":27,"r":{".":32,"a":43,"d":5,"e":32,"i":32,"n":{"o":191}},"s":53,"t":{"a":19,"h":6,"o":1,"u":{"l":192}},"u":{"n":{"d":54}}},"p":18,"r":{"i":{"t":18},"o":{"t":{"h":54}},"u":{"s":{"q":17}}},"s":[{"o":{"r":17}},55],"t":[{"l":1,"o":21,"r":23},25],"u":{"f":{"f":{"e":{"r":0}}},"g":{"a":1},"l":{"i":3},"m":{"i":17},"n":[{"t":{"i":17}},1],"r":{"e":3},"s":{"i":{"e":[{"r":193,"s":193},5]},"s":{"e":17,"i":{"n":{"g":17}}},"t":32},"t":{"a":18,"i":{"o":27},"o":19,"e":{"d":{".":8}},"t":{"e":{"d":0}}}},"v":29,"w":56,"y":{".":32,"s":0}},"c":{"a":[{"b":{"i":{"n":11},"l":2},"c":{"h":17},"d":{"e":{"n":4,"m":194}},"g":46,"h":57,"l":{"a":{"t":3},"l":{"a":0,"i":{"n":6}},"o":18},"n":{"d":5,"e":0,"i":{"c":0,"s":5,"z":11},"t":{"y":0},"y":17},"p":{"e":{"r":4}},"r":{"o":{"m":5}},"s":{"t":{"e":{"r":6},"i":{"g":5}},"y":18},"t":{"h":1,"i":{"v":18},"a":{"s":195}},"v":{"a":{"l":5}}},41],"c":[{"h":{"a":6},"i":{"a":0},"o":{"m":{"p":{"a":10}},"n":17,"u":{"t":12}}},23],"e":{".":25,"d":{".":18,"e":{"n":18}},"i":27,"l":{".":32,"l":27},"n":[{"c":27,"e":58,"i":18,"t":27},41],"p":27,"r":{"a":{"m":4}},"s":{"a":18,"s":{"i":[{"b":59},27]},"t":5},"t":[{"a":60},0],"w":0},"h":[{".":18,"a":{"b":61,"n":{"i":{"c":32,"s":20}}},"e":[{"a":{"p":54},"d":18,"l":{"o":5},"m":{"i":27},"n":{"e":4},"r":{".":3,"s":3}},8],"i":{"n":[{"e":{".":32,"s":{"s":4}},"i":32},62],"o":32,"t":27,"z":8,"e":{"v":{"o":6}}},"o":63,"t":{"i":1},"s":{".":18,"h":{"u":11}}},25],"i":[{"a":[{"b":64,"r":5},27],"c":4,"e":{"r":18},"f":{"i":{"c":{".":32}}},"i":18,"l":{"a":1,"i":27},"m":25,"n":[{"a":[{"t":27},21],"e":{"m":11},"g":[{".":19},29],"o":32,"q":8},25],"o":{"n":17},"p":{"e":18,"h":3,"i":{"c":18}},"s":{"t":{"a":18,"i":18}},"t":[{"i":{"z":11}},42],"z":32,"g":{"a":{"r":152}}},41],"k":[{"i":3},2],"l":[{"a":{"r":[{"a":{"t":{"i":{"o":19}}},"e":32},18]},"e":{"m":0,"a":{"r":0}},"i":{"c":18,"m":17},"y":0},65],"n":19,"o":[{"a":{"g":4},"e":8,"g":[{"r":1},25],"i":[{"n":{"c":3}},0],"l":{"i":5,"o":[{"r":11},32]},"m":{"e":{"r":5}},"n":{"a":0,"e":21,"g":11,"t":5},"p":{"a":3,"i":{"c":11},"l":1,"h":{"o":{"n":196}}},"r":{"b":18,"o":{"n":12}},"s":{"e":0},"v":[{"e":17},15],"w":{"a":5},"z":{"e":5,"i":4},"u":{"s":{"t":{"i":84}}}},41],"q":29,"r":{"a":{"s":{"t":6},"t":{".":32,"i":{"c":32}}},"e":{"a":{"t":11},"d":32,"t":{"a":47},"v":0},"i":[{"f":5,"n":21,"s":17,"t":{"i":[{"e":11},32]}},8],"o":{"p":{"l":0,"o":6},"s":{"e":17},"c":{"o":{"d":197}},"e":{"c":{"o":148}}},"u":{"d":0}},"s":66,"t":[{"a":{"b":0,"n":{"g":4,"t":19}},"e":[{"r":23},24],"i":{"c":{"u":21},"m":{"i":12}},"u":{"r":0},"w":21,"r":{"o":{"m":{"e":{"c":198}}}}},42],"u":{"d":5,"f":21,"i":[{"t":{"y":4}},21],"l":{"i":32,"t":{"i":{"s":0},"u":27}},"m":{"a":9,"e":23,"i":1},"n":27,"p":{"i":3,"y":4},"r":{"a":{"b":67,"n":{"c":{"e":199}}},"i":{"a":4}},"s":[{"s":{"i":17}},41],"t":[{"i":{"e":1,"v":56},"r":18},68]},"y":41,"z":{"e":0}},"d":{"a":[{".":32,"b":70,"c":{"h":17},"f":18,"g":25,"m":71,"n":{"g":11},"r":{"d":6,"k":6,"y":18},"t":[{"i":{"v":18},"o":18,"a":{"b":137}},27],"v":[{"e":5},53],"y":32,"l":{"o":{"n":{"e":48}}}},69],"b":29,"c":19,"d":[{"a":{"b":20},"i":{"b":94}},72],"e":{".":25,"a":{"f":6,"l":{"s":{".":1}}},"b":{"i":{"t":5},"o":{"n":1}},"c":{"a":{"n":36},"i":{"l":1},"o":{"m":4},"l":{"a":{"r":200},"i":{"n":{"a":64}}}},"d":42,"e":{".":18},"i":{"f":4},"l":{"i":{"e":17,"q":16},"o":4},"m":[{".":32,"i":{"c":[{".":5},27],"l":4},"o":{"n":{"s":1},"r":7,"s":9}},21],"n":[{"a":{"r":1},"o":3,"t":{"i":{"f":7}},"u":3},41],"p":[{"a":3,"i":17,"u":9},2],"q":23,"r":{"h":21,"m":32,"n":{"i":{"z":6}},"s":5},"s":[{".":24,"c":2,"o":64,"t":{"i":11,"r":3},"u":1,"i":{"c":11}},8],"t":[{"o":9,"i":{"c":9}},2],"v":[{"i":{"l":11}},2],"y":18,"f":{"i":{"n":{"i":{"t":{"i":201}}}}}},"f":43,"g":{"a":21,"e":{"t":73},"i":2,"y":24},"h":74,"i":{".":32,"a":[{"b":5},75],"c":{"a":{"m":1,"i":{"d":15}},"e":21,"t":27},"d":27,"e":{"n":76},"f":[{"f":{"r":{"a":5}}},29],"g":{"e":3},"l":{"a":{"t":{"o":1}}},"n":[{"a":41,"e":{".":27},"i":[{"z":4},32]},29],"o":[{"g":5},41],"p":{"l":1},"r":[{"e":[{"n":9,"r":9},2],"t":{"i":6}},8],"s":[{"i":32,"t":77},15],"t":{"i":24},"v":78,"m":{"e":{"t":{"h":{"y":141}}}}},"j":29,"k":79,"l":{"a":56,"e":{".":27,"d":27,"s":{".":27,"s":18},"a":{"d":42}},"o":48,"u":56,"y":25,"i":{"e":202}},"m":29,"n":80,"o":[{".":27,"d":{"e":4},"e":32,"f":57,"g":21,"l":{"a":1,"i":17,"o":{"r":4}},"m":{"i":{"z":5}},"n":{"a":{"t":3},"i":17},"o":{"d":11},"p":{"p":0},"r":21,"s":27,"u":{"t":56},"v":1,"x":27,"w":{"o":{"r":{"d":203}}}},41],"p":29,"r":[{"a":{"g":{"o":{"n":6}},"i":18},"e":[{"a":{"r":6},"n":[{"a":{"l":204}},32]},0],"i":{"b":0,"l":17,"f":{"t":{"a":189}},"p":{"l":{"e":{"g":205}}}},"o":{"p":0,"w":18,"m":{"e":{"d":206}}},"u":{"p":{"l":{"i":32}}},"y":18},41],"s":[{"p":1,"w":21,"y":21},81],"t":{"h":24,"a":{"b":23}},"u":[{"a":[{"l":{".":9}},82],"c":[{"a":29,"e":{"r":5},"t":{".":18,"s":18}},9],"e":{"l":4},"g":1,"l":{"e":23},"m":{"b":{"e":0}},"n":1,"p":[{"e":1},18],"o":{"p":{"o":{"l":207}}}},41],"v":29,"w":29,"y":[{"n":32,"s":{"e":1,"p":5}},24]},"e":{"a":{"b":72,"c":{"t":23},"d":[{"i":{"e":5}},15],"g":{"e":[{"r":4},1]},"l":[{"e":{"r":5},"o":{"u":11}},1],"m":{"e":{"r":11}},"n":{"d":19,"i":{"e":{"s":111}}},"r":{"a":11,"c":0,"e":{"s":5},"i":{"c":0,"l":0},"k":5,"t":[{"e":12},8]},"s":{"p":4,"s":23,"t":12},"t":[{"e":{"n":5},"h":{"i":12},"i":{"f":19},"u":83},9],"v":[{"e":{"n":11},"i":5,"o":5},9]},"b":[{"e":{"l":{".":21,"s":21},"n":21},"i":{"t":21},"r":23},42],"c":{"a":{"d":21,"n":{"c":6}},"c":{"a":6},"e":[{"s":{"s":{"a":4}}},29],"i":[{"b":21,"f":{"i":{"c":{"a":{"t":4}},"e":4},"y":4},"m":3,"t":[{"e":19},0]},9],"l":{"a":{"m":21},"u":{"s":21}},"o":{"l":24,"m":{"m":21,"p":{"e":21}},"n":{"c":21},"r":[{"a":3,"o":5},24]},"r":[{"e":{"m":21}},29],"t":{"a":{"n":1},"e":1},"u":[{"l":[{"a":3},21]},29],"h":{"a":{"s":23}}},"d":{"a":37,"d":61,"e":{"r":34,"s":0},"i":[{"a":23,"b":3,"c":{"a":3},"m":3,"t":2,"z":5},18],"o":[{"l":21,"n":84},18],"r":{"i":21},"u":{"l":[{"o":4,"i":{"n":{"g":2}}},21]},"g":{"l":15}},"e":{"c":9,"d":{"i":11},"f":9,"l":{"i":11,"y":1},"m":9,"n":{"a":1},"p":85,"s":[{"t":17},86],"t":{"y":1},"x":19},"f":[{"e":{"r":{"e":83}},"f":41,"i":{"c":[{"i":32},21],"l":17,"n":{"e":23,"i":{"t":{"e":20}}},"t":27},"o":{"r":{"e":{"s":6}}},"u":{"s":{"e":{".":21}}}},29],"g":{"a":{"l":18},"e":{"r":17},"i":{"b":4,"c":1,"n":{"g":4},"t":87},"n":4,"o":{".":21,"s":21},"u":{"l":2,"r":19},"y":32},"h":[{"e":{"r":17}},72],"i":[{"c":19,"d":4,"g":[{"l":4},8],"m":{"b":23},"n":{"f":23,"g":29,"s":{"t":19}},"r":{"d":0},"t":{"e":11,"h":3,"y":19}},9],"j":[{"u":{"d":[{"i":4},21]}},29],"k":{"i":{"n":0},"l":{"a":1}},"l":{"a":[{".":21,"c":21,"n":{"d":17},"t":{"i":{"v":4}},"w":21,"x":{"a":36}},29],"e":{"a":23,"b":{"r":{"a":4}},"c":32,"d":21,"g":{"a":3},"n":19,"r":34,"s":29},"f":9,"i":[{"b":{"e":23},"c":{".":33,"a":3},"e":{"r":23},"g":{"i":{"b":4}},"m":19,"n":{"g":83},"o":23,"s":[{"h":4},24],"v":88,"t":{"i":{"s":208}}},9],"l":{"a":[{"b":1},18],"o":17},"o":{"c":19,"g":4,"p":{".":3},"a":29},"s":{"h":9},"t":{"a":1},"u":{"d":19,"g":4}},"m":{"a":{"c":21,"g":21,"n":[{"a":4},19]},"b":4,"e":[{"l":24,"t":21},29],"i":{"c":{"a":3},"e":0,"g":{"r":{"a":4}},"n":[{"e":4,"i":35},89],"s":[{"h":4,"s":19},21],"z":3},"n":{"i":{"z":32}},"o":{"g":0,"n":{"i":{"o":7}}},"p":{"i":3},"u":{"l":[{"a":4},21],"n":11},"y":23},"n":{"a":{"m":{"o":4},"n":{"t":21}},"c":{"h":{"e":{"r":17}}},"d":{"i":{"c":3,"x":2}},"e":{"a":19,"e":19,"m":3,"r":{"o":4},"s":{"i":4,"t":4},"t":{"r":3},"w":23},"i":{"c":{"s":4},"e":19,"l":19,"o":23,"s":{"h":3},"t":3,"u":19,"z":32},"n":18,"o":[{"g":0,"s":21,"v":3},18],"s":{"w":1},"t":{"a":{"g":{"e":5}},"h":{"e":{"s":18}}},"u":{"a":3,"f":4},"y":{".":23},"z":61},"o":{"f":19,"g":[{"r":{"a":{"p":3}}},9],"i":90,"l":23,"p":{"a":{"r":11}},"r":[{"e":3,"o":{"l":4}},29],"s":0,"t":[{"o":1},21],"u":{"t":19},"w":19},"p":{"a":[{"i":23,"n":{"c":4}},24],"e":{"l":19,"n":{"t":23},"t":{"i":{"t":{"i":{"o":4}}}}},"h":{"e":17},"l":{"i":21},"o":29,"r":{"e":{"c":[{"a":4},21],"d":21,"h":3},"o":[{"b":21},23]},"s":{"h":1},"t":{"i":{"b":13}},"u":{"t":[{"a":4},21]},"i":{"n":{"e":{"p":{"h":209}}}}},"q":[{"u":{"i":{"l":12,"s":91}}},29],"r":{"a":[{"b":0,"n":{"d":18},"r":3,"t":{"i":{".":18}}},2],"b":[{"l":1},25],"c":{"h":[{"e":1},3]},"e":{".":25,"a":{"l":23},"c":{"o":5},"i":{"n":11},"l":{".":4},"m":{"o":3},"n":{"a":4,"c":{"e":4},"e":18,"t":3},"q":0,"s":{"s":4,"t":3},"t":17},"h":2,"i":[{"a":[{"n":{".":210}},92],"c":{"k":32},"e":{"n":23,"r":0},"n":{"e":3},"o":29,"t":18,"u":1,"v":[{"a":21},0]},2],"m":93,"n":{"i":{"s":1,"t":18,"z":32},"o":3},"o":[{"b":4,"c":19,"r":0,"u":2},25],"s":[{"e":{"t":3}},2],"t":{"e":{"r":11},"l":18,"w":3},"u":[{"t":0},18],"w":{"a":{"u":32}}},"s":{"a":[{"g":{"e":{".":21,"s":21}}},72],"c":[{"a":[{"n":4},24],"r":23,"u":4},9],"e":[{"c":[{"r":4},24],"n":{"c":4},"r":{"t":{".":21,"s":21},"v":{"a":21}}},74],"h":[{"a":23,"e":{"n":5}},18],"i":[{"c":24,"d":[{"e":{"n":4}},24],"g":{"n":{"a":4}},"m":94,"n":95,"s":{"t":{"e":17}},"u":0},29],"k":{"i":{"n":19}},"m":{"i":1},"o":{"l":[{"u":3},24],"n":[{"a":4},24]},"p":[{"e":{"r":3},"i":{"r":{"a":4}},"r":{"e":1},"a":{"c":{"i":211}}},29],"s":[{"i":{"b":96}},25],"t":{"a":{"n":36},"i":{"g":3,"m":4},"o":[{"n":23},44],"r":[{"o":19,"u":{"c":10}},25]},"u":{"r":[{"r":4},24]},"w":1},"t":{"a":{"b":0},"e":{"n":{"d":17},"o":23},"h":{"o":{"d":54},"y":{"l":{"e":{"n":{"e":162}}}}},"i":{"c":2,"d":{"e":19},"n":[{"o":0},17],"r":19,"t":{"i":{"o":19,"v":4}}},"n":18,"o":{"n":{"a":4}},"r":{"a":23,"e":23,"i":{"c":3,"f":4},"o":{"g":3,"s":4}},"u":{"a":3},"y":{"m":4},"z":4},"u":[{"n":19,"p":23,"r":{"o":3},"s":0,"t":{"e":17,"i":{"l":6},"r":4},"c":{"l":{"i":{"d":212}}}},18],"v":{"a":{"p":97,"s":[{"t":4},24]},"e":{"a":19,"l":{"l":3,"o":12},"n":{"g":19,"i":17},"r":[{"b":19},2]},"i":[{"d":3,"l":0,"n":21,"v":0},29],"o":{"c":19},"u":19},"w":{"a":[{"g":21},29],"e":{"e":19},"h":23,"i":{"l":6,"n":{"g":3},"t":23}},"x":{"p":41},"y":{"c":32,"e":{".":32},"s":0}},"f":{"a":[{"b":{"l":3,"r":11},"c":{"e":1},"g":18,"i":{"n":17},"l":{"l":{"e":6}},"m":{"a":26,"i":{"s":5}},"r":[{"t":{"h":5}},32],"t":{"a":3,"h":{"e":3},"o":18},"u":{"l":{"t":7}}},41],"b":56,"d":18,"e":{".":18,"a":{"s":17,"t":{"h":54}},"b":[{"r":{"u":{"a":15}}},1],"c":{"a":18,"t":32},"d":25,"l":{"i":3},"m":{"o":1},"n":{"d":[{"e":6},8]},"r":[{"r":32,"m":{"i":{"o":213}}},15],"v":0},"f":[{"e":{"s":21},"i":{"e":21,"n":{".":19},"s":94},"l":{"y":21},"y":24},43],"h":18,"i":[{"a":3,"c":{".":48,"a":{"l":47,"n":23,"t":{"e":18}},"e":{"n":23,"r":3},"i":[{"a":32,"e":32},0],"s":18,"u":3,"h":27},"d":{"e":{"l":4}},"g":{"h":{"t":7}},"l":{"i":5,"l":{"i":{"n":6}},"y":18},"n":[{"a":32,"d":97,"e":9,"g":98,"n":0},25],"s":{"t":{"i":0}},"t":{"t":{"e":{"d":{".":5}}}}},41],"l":[{"e":{"s":{"s":19}},"i":{"n":17},"o":{"r":{"e":11},"w":{"e":{"r":{".":84}}}},"y":100,"a":{"g":{"e":{"l":214}}},"u":{"o":{"r":27}}},99],"m":18,"n":18,"o":[{"n":[{"d":{"e":0},"t":0},32],"r":[{"a":{"t":4,"y":5},"e":{"t":6},"i":0,"t":{"a":6}},9],"s":5},41],"p":56,"r":{"a":{"t":0},"e":{"a":19,"s":{"c":6}},"i":[{"l":17},8],"o":{"l":6}},"s":48,"t":[{"o":21,"y":24},25],"u":[{"e":{"l":4},"g":18,"m":{"i":{"n":1}},"n":{"e":4},"r":{"i":3},"s":{"i":17,"s":0},"t":{"a":18}},27],"y":41},"g":{"a":[{"f":0,"l":{".":32,"i":27,"o":3},"m":[{"e":{"t":4},"o":19},25],"n":{"i":{"s":5,"z":[{"a":6},3]},"o":18},"r":{"n":67},"s":{"s":17},"t":{"h":12,"i":{"v":18}},"z":18},41],"b":23,"d":1,"e":{".":25,"d":25,"e":{"z":17},"l":{"i":{"n":0,"s":4,"z":4},"y":18},"n":[{"a":{"t":1},"i":{"z":4},"o":18,"y":18,"c":{"y":{".":8}}},41],"o":[{"m":3,"d":215},41],"r":{"y":21},"s":{"i":32},"t":{"h":6,"o":18,"y":1,"i":{"c":{".":8}}},"v":1},"g":[{"e":[{"r":23},24],"l":{"u":6},"o":0},101],"h":{"i":{"n":3},"o":{"u":{"t":4}},"t":{"o":1,"w":{"e":15}}},"i":{".":32,"a":[{"r":5},102],"c":[{"i":{"a":32},"o":21},29],"e":{"n":6,"s":{".":32}},"l":0,"m":{"e":{"n":23}},"n":{".":68,"g":{"e":5},"s":103},"o":32,"r":[{"l":0},27],"s":{"l":23},"u":1,"v":32,"z":27},"l":[{"a":[{"d":{"i":6},"s":32},0],"e":[{"a":{"d":29}},41],"i":{"b":0,"g":23,"s":{"h":43}},"o":[{"r":11,"b":{"i":{"n":106}}},27]},9],"m":[{"y":21},29],"n":{"a":[{".":21,"c":69},1],"e":{"t":{"t":17,"i":{"s":{"m":137}}}},"i":[{"n":24,"o":21},29],"o":[{"n":21,"m":{"o":5},"r":{".":216,"e":{"s":{"p":24}}}},29]},"o":[{".":27,"b":5,"e":32,"g":104,"i":{"s":3},"n":[{"a":105,"d":{"o":7},"i":[{"z":{"a":217}},3]},8],"o":32,"r":{"i":{"z":4},"o":{"u":5}},"s":{".":32},"v":15},41],"p":23,"r":[{"a":{"d":{"a":18},"i":21,"n":84,"p":{"h":{".":32,"e":{"r":[{".":7},19]},"i":{"c":32},"y":18}},"y":18},"e":{"n":0,"s":{"s":{".":18}}},"i":{"t":18,"e":{"v":213}},"o":21,"u":{"f":17}},41],"s":[{"t":{"e":19}},9],"t":{"h":11},"u":{"a":[{"r":{"d":27}},1],"e":25,"i":{"t":106},"n":27,"s":27,"t":[{"a":{"n":29}},26]},"w":23,"y":[{"n":107,"r":{"a":4}},41]},"h":{"a":{"b":{"l":73},"c":{"h":17},"e":{"m":0,"t":0},"g":{"u":19},"l":{"a":[{"m":12},3]},"m":1,"n":{"c":{"i":0,"y":0},"d":{".":32},"g":[{"e":{"r":6},"o":6},0],"i":{"z":108},"k":0,"t":{"e":0}},"p":{"l":11,"t":5,"a":{"r":{"r":218}}},"r":{"a":{"n":3,"s":4},"d":[{"e":12},8],"l":{"e":0},"p":{"e":{"n":6}},"t":{"e":{"r":5}}},"s":{"s":5},"u":{"n":17},"z":[{"a":11},32],"i":{"r":{"s":137}},"t":{"c":{"h":213}}},"b":29,"e":{"a":{"d":41,"r":27},"c":{"a":{"n":1,"t":19}},"d":[{"o":13},21],"l":{"i":93,"l":{"i":{"s":0},"y":0},"o":19},"m":{"p":0},"n":[{"a":[{"t":5},17]},9],"o":{"r":5},"p":5,"r":{"a":[{"p":12},21],"b":{"a":0},"e":{"a":6},"n":23,"o":{"u":19},"y":23},"s":[{"p":64},29],"t":[{"e":{"d":0}},1],"u":0,"x":{"a":168}},"f":29,"h":29,"i":{"a":{"n":4},"c":{"o":1},"g":{"h":6},"l":109,"m":{"e":{"r":36}},"n":{"a":21},"o":{"n":{"e":17}},"p":[{"e":{"l":{"a":219}}},1],"r":{"l":0,"o":3,"p":0,"r":0},"s":{"e":{"l":11},"s":0},"t":{"h":{"e":{"r":6}},"e":{"s":{"i":{"d":12}}}},"v":9},"k":18,"l":[{"a":{"n":17},"o":[{"r":{"i":11}},24]},80],"m":[{"e":{"t":17}},43],"n":[{"a":{"u":{"z":12}}},42],"o":{"d":{"i":{"z":19},"s":19},"g":[{"e":17},1],"l":{"a":{"r":5},"e":110},"m":{"a":1,"e":12},"n":{"a":0,"y":4},"o":{"d":27,"n":17},"r":{"a":{"t":5},"i":{"s":4,"c":{".":187}},"t":{"e":12},"u":4},"s":{"e":[{"n":4},0],"p":15},"u":{"s":[{"e":54},41]},"v":{"e":{"l":5}}},"p":56,"r":[{"e":{"e":6},"o":{"n":{"i":{"z":5}},"p":{"o":11}}},26],"s":[{"h":21},101],"t":{"a":{"r":21},"e":{"n":2,"s":4,"o":{"u":216}},"y":21},"u":{"g":1,"m":{"i":{"n":1}},"n":{"k":{"e":5},"t":0},"s":{"t":14},"t":1},"w":[{"a":{"r":{"t":21}}},29],"y":{"p":{"e":3,"h":3,"o":{"t":{"h":{"a":137}}}},"s":9}},"i":{"a":[{"l":24,"m":[{"e":{"t":{"e":5}}},0],"n":[{"c":18,"i":11,"t":46},24],"p":{"e":4},"s":{"s":17},"t":{"i":{"v":21},"r":{"i":{"c":1}},"u":21}},42],"b":{"e":[{"r":{"a":3,"t":4}},0],"i":{"a":4,"n":3,"t":{".":4,"e":4}},"l":[{"i":3},29],"o":19,"r":[{"i":94},29],"u":{"n":19}},"c":{"a":{"m":18,"p":32,"r":[{".":21,"a":21},18],"s":6,"y":21},"c":{"u":17},"e":{"o":18},"h":18,"i":[{"d":19,"n":{"a":4},"p":[{"a":3},24]},25],"l":{"y":21},"o":{"c":94},"r":[{"a":32,"y":21},43],"t":{"e":1,"u":[{"a":111},84]},"u":{"l":{"a":3},"m":1,"o":4,"r":23}},"d":[{"a":{"i":21,"n":{"c":4}},"d":4,"e":{"a":{"l":11},"s":0},"i":[{"a":{"n":4,"r":0},"e":19,"o":[{"u":5,"s":1},3],"t":2,"u":4},24],"l":{"e":23},"o":{"m":21,"w":3},"r":21,"u":[{"o":4},24]},25],"e":[{"d":{"e":0},"g":{"a":113},"l":{"d":12},"n":{"a":67,"e":0,"n":19,"t":{"i":23}},"r":{".":29},"s":{"c":23,"t":29},"t":23},112],"f":{".":18,"e":{"r":{"o":4}},"f":{"e":{"n":5},"r":1},"i":{"c":{".":18},"e":23},"l":23,"t":18,"a":{"c":{"e":{"t":137}}}},"g":[{"a":{"b":5},"e":{"r":{"a":3}},"h":{"t":{"i":12}},"i":[{"b":23,"l":3,"n":3,"t":3},18],"l":28,"o":[{"r":3,"t":4},24],"r":{"e":19},"u":{"i":5,"r":2},"n":{"i":{"t":[{"e":{"r":213}},0]}}},25],"h":23,"i":114,"j":[{"k":21},23],"k":18,"l":{"a":[{"b":93,"d":{"e":21},"m":94,"r":{"a":5}},29],"e":{"g":23,"r":2,"v":17},"f":4,"i":[{"a":3,"b":9,"o":3,"s":{"t":1},"t":25,"z":9},2],"l":{"a":{"b":5}},"n":18,"o":{"q":3},"t":{"y":1},"u":{"r":4},"v":3},"m":{"a":{"g":[{"e":3},21],"r":{"y":5}},"e":{"n":{"t":{"a":{"r":10}}},"t":18},"i":[{"d":{"a":4},"l":{"e":5},"n":{"i":19},"t":18},2],"n":{"i":1},"o":{"n":23},"u":[{"l":{"a":3}},24],"p":{"e":{"d":{"a":201}}}},"n":{".":25,"a":{"u":83,"v":18},"c":{"e":{"l":36,"r":3}},"d":[{"l":{"i":{"n":{"g":4}}}},18],"e":[{"e":23,"r":{"a":{"r":17}},"s":{"s":19}},25],"g":{"a":18,"e":[{"n":4},18],"i":18,"l":{"i":{"n":{"g":4}}},"o":18,"u":18},"i":[{".":19,"a":21,"o":3,"s":2,"t":{"e":{".":19,"l":{"y":{".":19}}},"i":{"o":32},"y":3}},25],"k":18,"l":18,"n":25,"o":[{"c":90,"s":0,"t":21},42],"s":[{"e":3,"u":{"r":{"a":7}}},25],"t":{".":25,"h":112},"u":[{"s":19},2],"y":18,"f":{"r":{"a":{"s":220}}}},"o":[{".":18,"g":{"e":17,"r":9},"l":29,"m":1,"n":{"a":{"t":11},"e":{"r":{"y":0}},"i":11},"p":{"h":4},"r":{"i":11},"s":21,"t":{"h":4,"i":19,"o":1},"u":{"r":21}},25],"p":[{"e":0,"h":{"r":{"a":{"s":115}}},"i":[{"c":1},3],"r":{"e":96},"u":{"l":3}},25],"q":{"u":{"a":23,"e":{"f":4},"i":{"d":3,"t":116}}},"r":[{"a":[{"b":0,"c":21},29],"d":{"e":5},"e":{"d":{"e":0},"f":21,"l":117,"s":21},"g":{"i":4},"i":[{"d":{"e":5},"s":1,"t":{"u":11},"z":118},2],"m":{"i":{"n":1}},"o":{"g":0,"n":{".":32}},"u":{"l":4},"r":{"e":{"v":{"o":{"c":221}}}}},18],"s":{".":25,"a":{"g":4,"r":3,"s":6},"c":[{"h":3},119],"e":[{"r":3},18],"f":27,"h":{"a":{"n":4},"o":{"n":3,"p":5}},"i":{"b":3,"d":0,"s":19,"t":{"i":{"v":4}}},"k":26,"l":{"a":{"n":36}},"m":{"s":18},"o":[{"m":{"e":{"r":5}}},24],"p":[{"i":9,"y":1},2],"s":[{"a":{"l":1},"e":{"n":36,"s":1}},62],"t":{"a":{".":1},"e":2,"i":2,"l":{"y":0},"r":{"a":{"l":18}}},"u":[{"s":4},24]},"t":{"a":{".":18,"b":{"i":0},"g":21,"m":120,"n":23,"t":23},"e":[{"r":{"a":3,"i":19},"s":[{"i":{"m":{"a":29}}},1]},25],"h":[{"i":{"l":148}},25],"i":[{"a":18,"c":[{"a":3,"k":31},22],"g":3,"l":{"l":4},"m":24,"o":25,"s":[{"m":21},18],"n":{"e":{"r":{"a":{"r":158}}}}},29],"o":{"m":121,"n":18},"r":{"a":{"m":21},"y":4},"t":18,"u":{"a":{"t":3},"d":19,"l":3},"z":{".":18}},"u":29,"v":[{"e":{"l":{"l":3},"n":{".":3},"r":{".":83,"s":{".":21}}},"i":{"l":{".":4},"o":4,"t":2},"o":{"r":{"e":19,"o":35},"t":83}},25],"w":56,"x":{"o":1},"y":18,"z":{"a":{"r":18},"i":0,"o":{"n":{"t":32}}}},"j":{"a":[{"c":{"q":0},"p":[{"a":{"n":{"e":{"s":220}}}},1],"n":{"u":{"a":12}}},32],"e":[{"r":{"s":5,"e":{"m":222}},"s":{"t":{"i":{"e":18},"y":18}},"w":11},41],"o":{"p":1},"u":{"d":{"g":32}}},"k":{"a":{".":27,"b":23,"g":19,"i":{"s":17},"l":0},"b":29,"e":{"d":24,"e":41,"g":1,"l":{"i":[{"n":{"g":223}},4]},"n":{"d":73},"r":29,"s":[{"t":{".":23}},0],"t":{"y":1}},"f":23,"h":1,"i":[{".":32,"c":122,"l":{"l":21,"o":6},"m":21,"n":{".":21,"d":{"e":0},"e":{"s":{"s":19},"t":{"i":{"c":224}}},"g":0},"p":1,"s":[{"h":19},0]},29],"k":1,"l":[{"e":{"y":18},"y":18},29],"m":29,"n":{"e":{"s":19},"o":69},"o":{"r":4,"s":{"h":17},"u":23,"v":{"i":{"a":{"n":41}}}},"r":{"o":{"n":5}},"s":[{"c":21,"l":1,"y":21,"h":{"a":23}},101],"t":19,"w":29},"l":{"a":{"b":{"i":{"c":11},"o":21},"c":{"i":[{"e":225},17]},"d":{"e":21,"y":3},"g":{"n":0},"m":{"o":11},"n":{"d":[{"l":0},27],"e":{"t":5},"t":{"e":0}},"r":{"g":0,"i":11,"c":{"e":{"n":176}}},"s":{"e":0},"t":{"a":{"n":4},"e":{"l":{"i":18}},"i":{"v":18}},"v":[{"a":95},18],"i":{"n":{"e":{"s":{"s":226}}}}},"b":[{"i":{"n":17}},42],"c":[{"e":0,"i":23,"h":{"a":{"i":23},"i":{"l":{"d":227}}}},101],"d":[{"e":[{"r":{"e":1,"i":1}},24],"i":[{"s":4},0],"r":[{"i":21},23]},25],"e":{"a":[{"d":{"e":{"r":{".":183}}},"s":{"a":228}},9],"b":{"i":1},"f":{"t":6},"g":{".":32,"g":32,"e":{"n":{"d":{"r":{"e":230}}}}},"m":{"a":{"t":[{"i":{"c":5}},1]}},"n":{".":18,"c":27,"e":{".":32},"t":41,"o":{"i":{"d":78}}},"p":{"h":3,"r":1},"r":{"a":{"b":6},"e":0,"g":27,"i":68,"o":21},"s":[{"c":{"o":4},"q":32,"s":[{".":32},27]},8],"v":{"a":23,"e":{"r":{".":0,"a":0,"s":0}}},"y":[{"e":18},27],"c":{"t":{"a":{"b":229}}}},"f":[{"r":19},25],"g":[{"a":[{"r":12},19],"e":{"s":21},"o":11},80],"h":48,"i":{"a":{"g":1,"m":9,"r":{"i":{"z":6}},"s":1,"t":{"o":1}},"b":{"i":4},"c":{"i":{"o":32},"o":{"r":1},"s":18,"t":{".":18},"u":21,"y":23},"d":{"a":23,"e":{"r":5},"i":27},"f":{"e":{"r":11},"f":21,"l":1},"g":{"a":{"t":{"e":32}},"h":27,"r":{"a":1}},"k":27,"l":123,"m":{"b":{"l":0},"i":11,"o":1,"p":90},"n":{"a":21,"e":[{"a":11},124],"i":11,"k":{"e":{"r":6}}},"o":{"g":4},"q":125,"s":{"p":0},"t":[{".":24,"i":{"c":{"a":32,"s":108}},"h":{"o":{"g":204}}},29],"v":{"e":{"r":11}},"z":29},"j":18,"k":{"a":[{"l":23,"t":0},11]},"l":[{"a":{"w":21},"e":[{"a":19,"c":23,"g":23,"l":23,"n":73,"t":73},24],"i":[{"n":[{"a":19},126],"s":{"h":231}},9],"o":[{"q":{"u":{"i":10}},"u":{"t":4},"w":19},1],"f":{"l":2}},29],"m":[{"e":{"t":19},"i":{"n":{"g":3}},"o":{"d":21,"n":[{"e":{"l":{"l":232}}},17]}},25],"n":81,"o":{".":27,"b":{"a":{"l":5},"o":{"t":{"o":233}}},"c":{"i":1},"f":18,"g":{"i":{"c":27},"o":19,"u":27,"e":{"s":{".":9}}},"m":{"e":{"r":11}},"n":{"g":32,"i":[{"z":127},0]},"o":{"d":6},"p":{"e":{".":32},"i":11,"m":23},"r":{"a":[{"t":{"o":1}},17],"i":{"e":4},"o":{"u":5}},"s":{".":32,"e":{"t":5},"o":{"p":{"h":{"i":{"z":32},"y":32}}},"t":0},"t":{"a":1},"u":{"n":{"d":6},"t":25},"v":18,"a":{"d":{"e":{"d":{".":17},"r":{".":183}}}}},"p":[{"a":{"b":5},"h":{"a":23,"i":19},"i":{"n":{"g":4},"t":23},"l":21,"r":19},25],"r":43,"s":[{"c":21,"e":24,"i":{"e":21}},81],"t":[{"a":{"g":4,"n":{"e":7}},"e":[{"n":17,"r":{"a":36},"a":23},29],"h":{"i":[{"l":{"y":148}},11]},"i":{"e":{"s":{".":19}},"s":17},"r":29,"u":[{"r":{"a":12}},8]},18],"u":{"a":4,"b":{"r":3},"c":{"h":17,"i":3},"e":{"n":3,"p":15},"f":0,"i":{"d":4},"m":{"a":1,"i":32,"n":{".":19,"i":{"a":32}},"b":{"i":{"a":{".":235}}}},"o":[{"r":11},3],"p":18,"s":{"s":17,"t":{"e":11}},"t":41,"n":{"k":{"e":{"r":234}}}},"v":{"e":{"n":19,"t":128}},"w":42,"y":[{"a":18,"b":18,"m":{"e":4},"n":{"o":3},"s":[{"e":19,"t":{"y":{"r":4}}},58],"g":{"a":{"m":{"i":236}}}},41]},"m":{"a":[{"b":25,"c":{"a":9,"h":{"i":{"n":{"e":4}}},"l":1},"g":{"i":{"n":5},"n":32},"h":25,"i":{"d":6},"l":{"d":18,"i":{"g":3,"n":4},"l":{"i":0},"t":{"y":0},"a":{"p":222}},"n":{"i":{"a":32,"s":5,"z":11},".":24,"u":{"s":{"c":237}}},"p":[{"h":{"r":{"o":244}}},18],"r":{"i":{"n":{"e":{".":4}},"z":4},"l":{"y":0},"v":11,"g":{"i":{"n":238}}},"s":{"c":{"e":4},"e":0,"t":15},"t":{"e":32,"h":12,"i":{"s":3,"z":{"a":18}}}},41],"b":[{"a":{"t":129},"i":{"l":19,"n":{"g":83},"v":0}},43],"c":56,"e":{".":18,"d":[{".":18,"i":{"a":32,"e":3,"c":[{"i":{"n":152}},84],"o":{"c":239}},"y":108},25],"g":[{"r":{"a":{"n":240}}},9],"l":{"o":{"n":5},"t":0},"m":[{"o":130},9],"n":[{"a":[{"c":5},0],"d":{"e":0},"e":18,"i":0,"s":[{"u":7},17],"t":[{"e":0},27],".":24},41],"o":{"n":4},"r":{"s":{"a":19}},"s":[{"t":{"i":27}},25],"t":{"a":[{"l":11},1],"e":2,"h":{"i":4},"r":[{"i":{"c":32,"e":4},"y":3},21]},"v":1},"f":43,"h":25,"i":{".":32,"a":3,"d":{"a":[{"b":241},0],"g":0},"g":0,"l":{"i":{"a":27,"e":108,"t":{"a":27}},"l":[{"a":{"g":208},"i":{"l":{"i":59}}},21]},"n":{"a":0,"d":27,"e":{"e":19},"g":{"l":[{"i":5,"y":19},21]},"t":0,"u":[{"t":{"e":{"r":242,"s":{"t":242}}}},21],"i":{"s":{".":174}}},"o":{"t":17},"s":[{"e":{"r":{".":0}},"l":5,"t":{"i":0,"r":{"y":19}}},24],"t":{"h":18},"z":24},"k":18,"l":43,"m":[{"a":{"r":{"y":5},"b":243}},29],"n":[{"a":1,"i":{"n":21},"o":1},43],"o":[{"c":{"r":[{"a":{"t":[{"i":{"z":32}},245]}},18]},"d":131,"g":{"o":1},"i":{"s":[{"e":5},84]},"k":18,"l":{"e":{"s":{"t":4},"c":246}},"m":{"e":3},"n":{"e":{"t":5,"y":{"l":247}},"g":{"e":5},"i":{"a":12,"s":{"m":0,"t":0},"z":3},"o":{"l":36,"c":{"h":12},"e":{"n":171},"s":249},"y":{".":3}},"r":[{"a":{".":18},"o":{"n":{"i":{"s":248}}}},9],"s":[{"e":{"y":4},"p":3},8],"t":{"h":[{"e":{"t":250}},12]},"u":{"f":19,"s":[{"i":{"n":98}},27]},"v":9,"e":{"l":{"a":{"s":167}}}},41],"p":[{"a":{"r":{"a":[{"b":5},7],"i":6}},"e":{"t":23},"h":{"a":{"s":36}},"i":[{"a":0,"e":{"s":4},"n":34,"r":19,"s":4},24],"o":{"r":{"i":11},"s":{"i":{"t":{"e":6}}},"u":{"s":21},"v":6},"t":{"r":1},"y":24},43],"r":47,"s":[{"h":[{"a":{"c":{"k":251}}},21],"i":19},101],"t":18,"u":[{"l":{"a":{"r":49},"t":[{"i":[{"u":252},54]},32]},"m":27,"n":8,"p":18,"u":1,"d":{"r":{"o":9}}},41],"w":18},"n":{"a":[{"b":[{"u":21},81],"c":{".":18,"a":1,"t":19},"g":{"e":{"r":{".":5}}},"k":0,"l":{"i":[{"a":4},1],"t":18},"m":{"i":{"t":4}},"n":[{"c":{"i":36},"i":{"t":0},"k":17},24],"r":{"c":[{"h":{"s":{".":73}}},11],"e":18,"i":11,"l":0,"m":19},"s":[{"c":0,"t":{"i":5}},21],"t":[{"a":{"l":3},"o":{"m":{"i":{"z":6}}}},24],"u":[{"s":{"e":11},"t":27},24],"v":{"e":0}},41],"b":80,"c":{"a":{"r":6},"e":{"s":{".":21}},"h":{"a":23,"e":{"o":19,"s":{"t":253}},"i":{"l":19,"s":23}},"i":{"n":2,"t":1},"o":{"u":{"r":{"a":7}}},"r":29,"u":29},"d":{"a":{"i":21,"n":19},"e":[{"s":{"t":{".":4}}},29],"i":{"b":0,"f":79,"t":29,"z":23,"e":{"c":{"k":29}}},"u":{"c":19,"r":0},"w":{"e":9},"t":{"h":{"r":3}}},"e":{".":25,"a":{"r":23},"b":[{"u":11,"a":{"c":{"k":3}}},9],"c":[{"k":32},9],"d":25,"g":{"a":{"t":[{"i":{"v":5}},1]},"e":32},"l":{"a":1,"i":{"z":5}},"m":{"i":4,"o":1},"n":[{"e":18},41],"o":27,"p":{"o":1},"q":9,"r":[{"a":{"b":6,"r":21},"e":24,"i":132,"r":0},29],"s":[{".":25,"p":18,"t":25,"w":18,"k":{"i":119}},41],"t":{"i":{"c":27}},"v":[{"e":19},1],"w":1},"f":[{"i":{"n":{"i":{"t":{"e":{"s":226}}}}}},23],"g":{"a":{"b":21},"e":{"l":23,"n":{"e":[{"s":5},133]},"r":{"e":19,"i":23}},"h":{"a":4,"o":2},"i":{"b":23,"n":2,"t":19},"l":{"a":21},"o":{"v":17},"s":{"h":4,"p":{"r":2}},"u":[{"m":21},29],"y":24},"h":[{"a":[{"b":12},0],"e":0},80],"i":{"a":[{"n":[{".":114},3],"p":1},68],"b":{"a":3,"l":1},"d":[{"i":4},1],"e":{"r":1},"f":{"i":[{"c":{"a":{"t":4}}},9]},"g":{"r":19},"k":0,"m":[{"i":{"z":3}},29],"n":[{"e":{".":32},"g":0},29],"o":1,"s":{".":32,"t":{"a":0}},"t":[{"h":21,"i":{"o":27},"o":{"r":23},"r":3},24]},"j":29,"k":[{"e":{"r":{"o":19},"t":23},"i":{"n":3},"l":29,"r":{"u":{"p":3}}},44],"l":[{"e":{"s":{"s":19}}},43],"m":[{"e":[{"t":17},0]},19],"n":[{"e":0,"i":{"a":{"l":11},"v":0}},101],"o":{"b":{"l":[{"e":3},0]},"c":{"l":19,"e":{"r":{"o":{"s":254}}}},"d":66,"e":27,"g":[{"e":17},18],"i":{"s":{"i":6}},"l":{"i":134,"o":{"g":{"i":{"s":32}}}},"m":{"i":{"c":27,"z":108,"s":{"t":82}},"o":1,"y":3,"a":{"l":214},"e":{"n":{"o":194}}},"n":[{"a":{"g":0},"i":[{"z":19,"s":{"o":255}},5],"e":{"q":15}},1],"p":[{"o":{"l":{"i":135,"y":{".":256}}}},18],"r":{"a":{"b":5,"r":{"y":1}}},"s":{"c":18,"e":0,"t":5},"t":{"a":4},"u":[{"n":27},41],"v":{"e":{"l":136,"m":{"b":2}}},"w":{"l":12}},"p":[{"i":0,"r":{"e":{"c":17}}},72],"q":29,"r":[{"u":0},29],"s":[{"a":{"b":4,"t":{"i":36}},"c":[{"e":{"i":{"v":4}}},1],"e":[{"s":83},24],"i":{"d":137,"g":17},"l":24,"m":[{"o":{"o":1}},3],"o":{"c":21},"p":{"e":1,"i":19},"t":{"a":{"b":{"l":6}}}},81],"t":[{"a":{"b":0},"e":{"r":{"s":12}},"i":[{"b":19,"e":{"r":0},"f":8,"n":{"e":23,"g":83},"p":0},9],"r":{"o":{"l":{"l":{"i":7}}},"e":{"p":137}},"s":1,"u":{"m":{"e":11}}},29],"u":{"a":2,"d":1,"e":{"n":4},"f":{"f":{"e":0}},"i":{"n":23,"t":50},"m":[{"e":2,"i":19},21],"n":138,"o":23,"t":{"r":3}},"v":74,"w":72,"y":{"m":0,"p":0},"z":[{"a":23},18]},"o":{"a":[{"d":11,"l":{"e":{"s":108}},"r":{"d":12},"s":{"e":0,"t":{"e":6}},"t":{"i":5}},18],"b":{"a":{"b":35,"r":19},"e":{"l":0},"i":[{"n":[{"g":4},24]},29],"r":23,"u":{"l":3},"l":{"i":{"g":189}}},"c":{"e":29,"h":[{"e":{"t":23},"a":{"s":23}},0],"i":{"f":12,"l":21},"l":{"a":{"m":21}},"o":{"d":21},"r":{"a":{"c":3,"t":{"i":{"z":4}}},"e":12,"i":{"t":32}},"t":{"o":{"r":{"a":7}}},"u":{"l":{"a":3},"r":{"e":19}}},"d":{"d":{"e":{"d":4}},"i":{"c":3,"o":11,"t":{"i":{"c":137}}},"o":[{"r":12},139],"u":{"c":{"t":{".":4,"s":4}}},"e":{"l":{"l":{"i":12}}}},"e":{"l":21,"n":{"g":19},"r":[{"s":{"t":257}},23],"t":{"a":1},"v":23},"f":{"i":[{"t":{"e":4,"t":17}},24]},"g":{"a":{"r":121,"t":{"i":{"v":4},"o":21}},"e":[{"n":{"e":19},"o":19,"r":21},29],"i":{"e":23,"s":140,"t":3},"l":[{"y":79},21],"n":{"i":{"z":27}},"r":{"o":21},"u":{"i":5},"y":[{"n":25},41]},"h":[{"a":{"b":6}},74],"i":[{"c":{"e":{"s":11}},"d":{"e":{"r":3}},"f":{"f":17},"g":0,"l":{"e":{"t":4}},"n":{"g":23,"t":{"e":{"r":6}}},"s":{"m":19,"o":{"n":4},"t":{"e":{"n":6}}},"t":{"e":{"r":3}}},9],"j":19,"k":[{"e":{"n":23,"s":{"t":15}},"i":{"e":4}},25],"l":{"a":[{"n":21,"s":{"s":36}},29],"d":[{"e":15},9],"e":{"r":3,"s":{"c":23,"t":{"e":{"r":88}}},"t":23},"f":{"i":1},"i":[{"a":23,"c":{"e":23},"d":{".":4},"f":73,"l":19,"n":{"g":3},"o":19,"s":{".":19,"h":3},"t":{"e":19,"i":{"o":19}},"v":19,"g":{"o":{"p":{"o":258}}}},9],"l":{"i":{"e":17}},"o":{"g":{"i":{"z":4}},"r":0,"n":{"o":{"m":259}}},"p":{"l":4},"t":9,"u":{"b":3,"m":{"e":3},"n":3,"s":19},"v":9,"y":24},"m":{"a":{"h":4,"l":5,"t":{"i":{"z":4}}},"b":{"e":9,"l":1},"e":[{"n":{"a":3},"r":{"s":{"e":4}},"t":[{"r":{"y":4}},21],"c":{"h":{"a":260}}},24],"i":{"a":23,"c":{".":3,"a":3},"d":19,"n":[{"i":19},2]},"m":{"e":{"n":{"d":32}}},"o":{"g":{"e":0},"n":21},"p":{"i":3,"r":{"o":7}}},"n":[{"a":[{"c":1,"n":23},2],"c":[{"i":{"l":27}},2],"d":[{"o":4},25],"e":{"n":23,"s":{"t":4}},"g":{"u":1},"i":{"c":2,"o":23,"s":2,"u":19},"k":{"e":{"y":3}},"o":{"d":{"i":1},"m":{"y":3,"i":{"c":137}},"r":{"m":{"a":23}},"t":{"o":{"n":261}},"u":23},"s":[{"p":{"i":[{"r":{"a":10}},36]},"u":17},3],"t":{"e":{"n":36},"i":[{"f":7},93]},"u":{"m":4},"v":{"a":6}},24],"o":[{"d":{"e":5,"i":5},"k":1,"p":{"i":11},"r":{"d":23},"s":{"t":6}},9],"p":{"a":24,"e":{"d":5,"r":[{"a":[{"g":18},27]},2]},"h":[{"a":{"n":19},"e":{"r":19}},25],"i":{"n":{"g":3},"t":23,"s":{"m":{".":2}}},"o":{"n":19,"s":{"i":21}},"r":29,"u":2,"y":5},"q":29,"r":{"a":[{".":19,"g":83,"l":{"i":{"z":4}},"n":{"g":{"e":4}}},29],"e":{"a":[{"l":19},5],"i":3,"s":{"h":5,"t":{".":4}},"w":17},"g":{"u":1},"i":{"a":56,"c":{"a":3},"l":19,"n":2,"o":29,"t":{"y":3},"u":23},"m":{"i":9},"n":{"e":8},"o":{"f":19,"u":{"g":3}},"p":{"e":4},"r":{"h":27},"s":{"e":[{"n":5},1],"t":17},"t":{"h":{"i":3,"y":3,"o":{"n":{"i":{"t":262}}},"r":{"i":137}},"y":1,"i":{"v":{"e":{"l":{"y":4}}}}},"u":{"m":19},"y":29},"s":{"a":{"l":3},"c":[{"e":1,"o":{"p":[{"i":18},23]},"r":19},9],"i":{"e":95,"t":{"i":{"v":4},"o":3,"y":3},"u":0},"l":1,"o":24,"p":{"a":1,"o":1,"h":{"e":{"r":83}}},"t":{"a":[{"t":{"i":19}},9],"i":{"l":4,"t":4}}},"t":{"a":{"n":21},"e":{"l":{"e":{"g":36}},"r":{".":3,"s":4},"s":[{"t":{"e":{"r":263},"o":{"r":264}}},21]},"h":[{"e":{"s":{"i":5},"o":{"s":265}},"i":14},18],"i":{"c":{".":3,"a":4,"e":23},"f":23,"s":23},"o":{"s":5}},"u":[{"b":{"l":3,"a":{"d":{"o":116}}},"c":{"h":{"i":6}},"e":{"t":4},"l":1,"n":{"c":{"e":{"r":6}},"d":8},"v":4},9],"v":{"e":{"n":1,"r":{"n":{"e":17},"s":12,"t":1}},"i":{"s":23,"t":{"i":36},"a":{"n":{".":266}}},"o":{"l":60}},"w":{"d":{"e":{"r":3}},"e":{"l":3,"s":{"t":4}},"i":2,"n":{"i":5},"o":21},"y":{"a":2},"x":{"i":{"d":{"i":{"c":267}}}}},"p":{"a":[{"c":{"a":1,"e":1,"t":0},"d":21,"g":{"a":{"n":32,"t":23}},"i":[{"n":17},21],"l":[{"m":{"a":{"t":268}}},21],"n":{"a":0,"e":{"l":11},"t":{"y":0},"y":3},"p":[{"u":1},2],"r":{"a":{"b":{"l":6},"g":{"e":5,"r":{"a":269}},"l":{"e":228},"m":[{"e":12},36]},"d":{"i":5},"e":[{"l":5},27],"i":[{"s":0},28]},"t":{"e":[{"r":4},9],"h":{"i":{"c":32},"y":4},"r":{"i":{"c":1}}},"v":0,"y":27},41],"b":43,"d":1,"e":{".":18,"a":[{"r":{"l":17}},138],"c":9,"d":[{"e":27,"i":[{"a":36,"c":0},27]},37],"e":[{"d":0,"v":208},21],"k":0,"l":{"a":1,"i":{"e":17}},"n":{"a":{"n":1},"c":21,"t":{"h":0}},"o":{"n":4},"r":{"a":{".":21,"b":{"l":6},"g":21},"i":[{"s":{"t":6}},21],"m":{"a":{"l":0},"e":7},"n":21,"o":11,"t":{"i":11},"u":4,"v":15},"t":[{"e":{"n":4},"i":{"z":4}},9]},"f":18,"g":18,"h":{".":18,"a":{"r":{"i":6}},"e":{"n":{"o":11},"r":1,"s":{".":1}},"i":{"c":2,"e":32,"n":{"g":4},"s":{"t":{"i":32}},"z":27,"l":{"a":{"n":{"t":168},"t":{"e":{"l":270}}}}},"l":9,"o":{"b":27,"n":{"e":27,"i":32},"r":0},"s":18,"t":3,"u":32,"y":41},"i":{"a":[{"n":17},3],"c":{"i":{"e":1},"y":1,"a":{"d":271}},"d":[{"a":19,"e":3,"i":32},21],"e":{"c":27,"n":3},"g":{"r":{"a":{"p":1}}},"l":{"o":3},"n":[{".":21,"d":17,"o":21},9],"o":[{"n":17},141],"t":{"h":[{"a":4},23],"u":9}},"k":142,"l":[{"a":{"n":27,"s":{"t":6}},"i":{"a":11,"e":{"r":5},"g":18,"n":[{"a":{"r":5}},0],"c":{"a":{"b":208}}},"o":{"i":17},"u":{"m":[{"b":17},0]}},143],"m":43,"n":48,"o":{"c":1,"d":{".":32},"e":{"m":4,"t":144},"g":145,"i":{"n":[{"t":32,"c":{"a":12}},84]},"l":{"y":{"t":6,"e":137,"p":{"h":{"o":{"n":{"o":272}}}}},"e":{".":41}},"n":{"i":1},"p":1,"r":[{"y":1},124],"s":[{"s":15},41],"t":[{"a":1},21],"u":{"n":32}},"p":[{"a":{"r":{"a":5}},"e":[{"d":21,"l":19,"n":23,"r":23,"t":23},24],"o":{"s":{"i":{"t":{"e":5}}}}},43],"r":[{"a":{"y":{"e":17}},"e":{"c":{"i":32,"o":5},"e":{"m":11},"f":{"a":{"c":6}},"l":{"a":0},"r":11,"s":{"e":23,"s":27,"p":{"l":{"i":84}}},"t":{"e":{"n":5}},"v":11,"m":{"a":{"c":273}},"n":{"e":{"u":15}}},"i":{"e":53,"n":{"t":146},"s":[{"o":12},0]},"o":{"c":{"a":23,"e":{"s":{"s":8}},"i":{"t":{"y":{".":274}}}},"f":{"i":{"t":6}},"l":11,"s":{"e":12},"t":15,"g":{"e":208}}},9],"s":[{"e":[{"u":{"d":[{"o":{"d":276,"f":276}},275]}},24],"h":1,"i":{"b":21}},81],"t":[{"a":{"b":134},"e":24,"h":24,"i":{"m":11},"u":{"r":0},"w":21,"o":{"m":{"a":{"t":277}}},"r":{"o":{"l":278}}},42],"u":{"b":[{"e":{"s":{"c":181}}},11],"e":0,"f":0,"l":{"c":11},"m":1,"n":9,"r":{"r":0},"s":32,"t":[{"e":[{"r":11},32],"r":3,"t":{"e":{"d":0},"i":{"n":0}}},9]},"w":23},"q":{"u":[{"a":{"v":5,"i":{"n":{"t":{"e":279}}},"s":{"i":[{"r":281,"s":281},280]}},"e":{".":25,"r":27,"t":27},"i":{"n":{"t":{"e":{"s":{"s":282}}}},"v":{"a":{"r":14}}}},9]},"r":{"a":{"b":[{"i":3,"o":{"l":{"i":{"c":29},"o":{"i":236}}}},25],"c":{"h":{"e":17,"u":3},"l":19},"f":{"f":{"i":5},"t":0},"i":24,"l":{"o":1},"m":{"e":{"t":[{"r":{"i":{"z":283}}},11],"n":24},"i":24,"o":{"u":3}},"n":{"e":{"o":6},"g":{"e":0},"i":21,"o":4,"h":{"a":{"s":167}}},"p":{"e":{"r":11},"h":{"y":27}},"r":{"c":5,"e":[{"f":5},17],"i":{"l":18}},"s":24,"t":{"i":{"o":{"n":115}}},"u":{"t":0},"v":{"a":{"i":4},"e":{"l":11}},"z":{"i":{"e":4}},"d":{"i":{"g":127,"o":{"g":249}}},"o":{"r":2}},"b":[{"a":{"b":21,"g":21},"i":[{"f":0,"n":[{"e":19,"g":{".":4,"e":284}},24]},8],"o":1},29],"c":[{"e":[{"n":17},24],"h":{"a":23,"e":{"r":0}},"i":{"b":90,"t":1},"u":{"m":12}},29],"d":{"a":{"l":21},"i":[{"a":0,"e":{"r":0},"n":[{"g":3},17]},9]},"e":{".":25,"a":{"l":2,"n":3,"r":{"r":4},"v":32,"w":1},"b":{"r":{"a":{"t":19}}},"c":{"o":{"l":{"l":5},"m":{"p":{"e":5}}},"r":{"e":1},"i":{"p":{"r":285}},"t":{"a":{"n":{"g":286}}}},"d":[{"e":2,"i":{"s":3,"t":5}},37],"f":{"a":{"c":1},"e":[{"r":{".":4}},9],"i":3,"y":1},"g":{"i":{"s":11}},"i":{"t":4},"l":{"i":2,"u":4},"n":{"t":{"a":90,"e":0}},"o":2,"p":{"i":{"n":4},"o":{"s":{"i":1}},"u":2},"r":[{"i":21,"o":17,"u":4},147],"s":{".":21,"p":{"i":1},"s":{"i":{"b":6}},"t":[{"a":{"l":4},"r":3},8]},"t":{"e":{"r":1},"i":{"z":96},"r":{"i":[{"b":{"u":85}},3]}},"u":[{"t":{"i":4}},8],"v":[{"a":{"l":1},"e":{"l":11,"r":{".":30,"s":4,"t":4}},"i":{"l":4},"o":{"l":{"u":5}}},8],"w":{"h":1}},"f":[{"u":0,"y":21},29],"g":[{"e":{"r":3,"t":23},"i":{"c":23,"n":[{"g":3},0],"s":19,"t":19},"l":29,"o":{"n":0},"u":23},9],"h":[{".":18,"a":{"l":18}},1],"i":{"a":[{"b":0,"g":1,"l":{".":23}},3],"b":[{"a":11},21],"c":{"a":{"s":5},"e":21,"i":[{"d":32,"e":1},18],"o":21},"d":{"e":{"r":5}},"e":{"n":{"c":3,"t":3},"r":2,"t":4},"g":{"a":{"n":5},"i":32},"l":{"i":{"z":11}},"m":{"a":{"n":32},"i":5,"o":27,"p":{"e":0}},"n":{"a":[{".":32},24],"d":0,"e":0,"g":0},"o":2,"p":{"h":[{"e":6},32],"l":[{"i":{"c":5}},9]},"q":21,"s":[{".":21,"c":0,"h":23,"p":0},24],"t":{"a":{"b":116},"e":{"d":{".":19},"r":{".":5,"s":5}},"i":{"c":11},"u":[{"r":5},9]},"v":{"e":{"l":5,"t":11},"i":11,"o":{"l":287}}},"j":23,"k":{"e":{"t":23},"l":{"e":1,"i":{"n":1}},".":288,"h":{"o":2},"r":{"a":{"u":29}},"s":{".":288}},"l":[{"e":[{"d":24,"q":{"u":30}},0],"i":{"g":21,"s":[{"h":4},21]},"o":73},29],"m":[{"a":{"c":5},"e":[{"n":23,"r":{"s":4}},24],"i":{"n":{"g":[{".":21},3]},"o":21,"t":23},"y":21},29],"n":{"a":{"r":21},"e":{"l":23,"r":21,"t":19,"y":23},"i":{"c":19,"s":92,"t":23,"v":23},"o":[{"u":21},0],"u":23},"o":{"b":{"l":11,"o":{"t":289}},"c":[{"r":3},24],"e":[{"l":{"a":{"s":167}},"p":{"i":{"d":{"e":290}}}},1],"f":{"e":2,"i":{"l":4}},"k":[{"e":{"r":4}},8],"l":{"e":{".":32}},"m":{"e":{"t":{"e":5},"s":{"h":3}},"i":0,"p":0},"n":{"a":{"l":0},"e":0,"i":{"s":134},"t":{"a":0}},"o":{"m":41,"t":32},"p":{"e":{"l":3},"i":{"c":11}},"r":{"i":11,"o":4},"s":{"p":{"e":{"r":5}},"s":0},"t":{"h":{"e":1},"y":1,"r":{"o":{"n":2}}},"v":{"a":1,"e":{"l":5}},"x":5},"p":[{"e":{"a":21,"n":{"t":19},"r":{".":4},"t":23},"h":95,"i":{"n":{"g":3}},"o":23,"a":{"u":{"l":{"i":291}}}},29],"r":[{"e":{"c":0,"f":0,"o":21,"s":{"t":0}},"i":{"o":0,"v":0},"o":{"n":17,"s":17},"y":{"s":17}},72],"s":[{"a":[{"t":{"i":5}},29],"c":1,"e":[{"c":[{"r":0},23],"r":{".":4,"a":{"d":{"i":238}}},"s":3,"v":148},24],"h":[{"a":19},29],"i":[{"b":90},29],"o":{"n":12},"p":29,"w":19},44],"t":{"a":{"c":{"h":36},"g":21},"e":{"b":23,"n":{"d":17},"o":5},"i":[{"b":4,"d":0,"e":{"r":21},"g":23,"l":{"i":12,"l":17,"y":21},"s":{"t":21},"v":21},29],"r":{"i":23,"o":{"p":{"h":115}},"e":{"u":29}},"s":{"h":1},"h":{"o":{"u":29}}},"u":{"a":3,"e":{"l":93,"n":3},"g":{"l":1},"i":{"n":3},"m":{"p":{"l":11}},"n":[{"k":6,"t":{"y":0}},9],"s":{"c":19},"t":{"i":{"n":6}}},"v":{"e":[{"l":{"i":17},"n":23,"r":{".":4},"s":{"t":19},"y":23,"i":{"l":29}},1],"i":{"c":23,"v":0},"o":23},"w":29,"y":{"c":1,"n":{"g":{"e":32}},"t":3},"z":{"s":{"c":2}}},"s":{"a":[{"b":42,"c":{"k":32,"r":{"i":11},"t":23},"i":32,"l":{"a":{"r":36},"m":0,"o":4,"t":0,"e":{"s":{"c":54,"w":7}}},"n":{"c":27,"d":{"e":0}},"p":[{"a":{"r":{"i":{"l":292}}}},29],"t":{"a":4,"i":{"o":76},"u":11},"u":0,"v":{"o":{"r":4}},"w":32},9],"b":56,"c":{"a":{"n":{"t":149},"p":[{"e":{"r":267}},0],"v":6,"t":{"o":{"l":208}}},"e":{"d":21,"i":18,"s":21},"h":[{"o":21,"i":{"t":{"z":21}},"r":{"o":{"d":{"i":{"n":{"g":293}}}}}},8],"i":{"e":68,"n":{"d":150},"u":{"t":{"t":294}}},"l":{"e":6,"i":21},"o":{"f":17,"p":{"y":18},"u":{"r":{"a":7}}},"u":29,"r":{"a":{"p":{"e":{"r":{".":36}}}}},"y":{"t":{"h":247}}},"d":56,"e":{".":18,"a":[{"s":17,"w":5},1],"c":{"o":151,"t":27},"d":[{"e":95,"l":19},125],"g":[{"r":11},9],"i":32,"l":{"e":2,"f":32,"v":32},"m":{"e":[{"s":{"t":295}},18],"o":{"l":1},"a":{"p":{"h":287}},"i":{"t":{"i":{"c":296}}}},"n":{"a":{"t":5},"c":18,"d":0,"e":{"d":19},"g":5,"i":{"n":19},"t":{"d":18,"l":18}},"p":{"a":152,"t":{"e":{"m":{"b":11}}}},"r":{".":43,"l":21,"o":0,"v":{"o":18}},"s":[{"h":4,"t":5},72],"u":{"m":113},"v":[{"e":{"n":11}},32],"w":{"i":0},"x":32},"f":47,"g":48,"h":[{".":25,"e":{"r":2,"v":32},"i":{"n":2,"o":3,"p":27,"v":6},"o":[{"l":{"d":4},"n":12,"r":[{"t":7},17],"e":{"s":{"t":137}}},0],"w":18},24],"i":{"b":2,"c":{"c":19},"d":{"e":{".":27,"s":[{"t":6,"w":6},32],"d":{".":8}},"i":[{"z":4},32]},"g":{"n":{"a":18}},"l":{"e":0,"y":18},"n":[{"a":24,"e":{".":32},"g":23},42],"o":[{"n":[{"a":6},32]},41],"r":[{"a":5,"e":{"s":{"i":{"d":4}}}},9],"s":41,"t":{"i":{"o":27}},"u":32,"v":41,"z":32},"k":[{"e":[{"t":23},18],"i":{"n":{"e":4,"g":4}},"y":{"s":{"c":15}}},9],"l":[{"a":{"t":23},"e":24,"i":{"t":{"h":7}},"o":{"v":{"a":{"k":{"i":{"a":297}}}}}},74],"m":[{"a":[{"l":{"l":54},"n":12},23],"e":{"l":17,"n":19},"i":{"t":{"h":32}},"o":{"l":{"d":49}}},42],"n":72,"o":[{"c":{"e":1},"f":{"t":12},"l":{"a":{"b":1},"d":153,"i":{"c":3},"v":32,"u":{"t":{"e":9}}},"m":27,"n":{".":68,"a":17,"g":0},"p":[{"h":{"i":{"c":32,"z":19},"y":19}},21],"r":{"c":5,"d":5},"v":[{"i":4},18],"g":{"a":{"m":{"y":298}}}},41],"p":{"a":[{"i":32,"n":0,"c":{"e":299,"i":{"n":69}}},25],"e":{"n":{"d":17},"o":57,"r":25,"c":{"i":{"o":11}}},"h":{"e":[{"r":[{"o":213},27]},24],"o":6},"i":{"l":17,"n":{"g":4},"o":18,"c":{"i":{"l":208}}},"l":{"y":21},"o":{"n":21,"r":[{"t":{"s":{"c":300,"w":300}}},17],"t":18,"k":{"e":{"s":{"w":10}}}}},"q":{"u":{"a":{"l":{"l":36}},"i":{"t":{"o":88}}}},"r":29,"s":[{"a":[{"s":12,"c":{"h":{"u":301}}},29],"c":94,"e":{"l":23,"n":{"g":19},"s":{".":21},"t":19},"i":[{"e":[{"r":0},21],"l":{"y":4},"a":{"n":{".":210}},"g":{"n":{"a":{"b":302}}}},29],"l":[{"i":1},21],"n":21,"p":{"e":{"n":{"d":115}}},"t":9,"u":{"r":{"a":6}},"w":4,"h":{"a":{"t":3}}},25],"t":{".":25,"a":{"g":24,"l":24,"m":{"i":17,"p":69},"n":{"d":32,"t":{"s":{"h":{"i":303}}}},"p":90,"t":{".":32,"i":15},"r":{"t":{"l":{"i":12}}}},"e":{"d":21,"r":{"n":{"i":7},"o":19},"w":[{"a":6},8]},"h":{"e":23},"i":[{".":21,"a":19,"c":[{"k":32},29],"e":21,"f":23,"n":{"g":3},"r":32},9],"l":{"e":29},"o":{"c":{"k":32},"m":{"a":12},"n":{"e":32},"p":21,"r":{"e":27,"a":{"b":304}}},"r":[{"a":{"d":21,"t":{"u":32,"a":{"g":305}},"y":21},"i":{"d":21,"b":{"u":{"t":7}}},"y":18},1],"w":61,"y":[{"l":{"i":{"s":137}}},24],"b":4,"s":{"c":{"r":4}},"u":{"p":{"i":{"d":306}}}},"u":[{"a":{"l":2},"b":111,"g":151,"i":{"s":4,"t":12},"l":21,"m":[{"i":11},9],"n":9,"r":9,"p":{"e":{"r":{"e":307}}}},41],"v":18,"w":[{"o":18,"i":{"m":{"m":177}}},9],"y":[{"c":18,"l":27,"n":{"o":5,"c":41},"r":{"i":{"n":4}},"t":{"h":{"i":308}}},21]},"t":{"a":[{".":27,"b":[{"l":{"e":{"s":4}},"o":{"l":{"i":{"z":32,"s":{"m":309}}}}},25],"c":{"i":18},"d":{"o":4},"f":46,"i":{"l":{"o":5}},"l":[{"a":4,"e":{"n":5},"i":11,"k":[{"a":204},18],"l":{"i":{"s":0}},"o":{"g":4}},9],"m":{"o":4,"i":{"n":82}},"n":{"d":{"e":0},"t":{"a":54}},"p":{"e":{"r":4},"l":4,"a":{"t":{"h":310}}},"r":{"a":0,"c":18,"e":18,"i":{"z":3},"r":{"h":311}},"s":{"e":0,"y":4},"t":{"i":{"c":18},"u":{"r":1}},"u":{"n":17},"v":0,"w":25,"x":{"i":{"s":0}},"g":{"o":{"n":{".":3}}}},41],"b":42,"c":[{"h":[{"e":{"t":5},"c":15,"i":{"e":{"r":237}}},21],"r":29},18],"d":43,"e":{".":18,"a":{"d":{"i":17},"t":18,"c":{"h":{"e":{"r":{".":36}}}}},"c":{"e":17,"t":32},"d":[{"i":4},42],"e":41,"g":[{"e":{"r":4},"i":4},0],"l":{".":27,"i":17,"s":32,"e":{"g":84,"r":{"o":249}}},"m":{"a":[{"t":11},154]},"n":{"a":{"n":27},"c":27,"d":27,"e":{"s":18},"t":[{"a":{"g":0}},41]},"o":41,"p":[{"e":4},1],"r":{"c":11,"d":155,"i":[{"e":{"s":5},"s":11,"z":{"a":6},"c":{".":8}},41],"n":{"i":{"t":32}},"v":5,"g":{"e":{"i":312}}},"s":{".":18,"s":[{".":23,"e":{"s":313}},18]},"t":{"h":{"e":6}},"u":27,"x":27,"y":18},"f":42,"g":43,"h":{".":25,"a":{"n":17,"l":{"a":{"m":228}}},"e":[{"a":[{"s":3,"t":5},18],"i":{"s":11},"t":27},9],"i":{"c":{".":4,"a":4},"l":18,"n":{"k":32}},"l":18,"o":{"d":{"e":4,"i":{"c":32},"o":{"n":11}},"o":18,"r":{"i":{"t":6,"z":5}},"g":{"e":{"n":{"i":314}}},"k":{"e":{"r":175}}},"s":25,"y":{"l":{"a":{"n":228}},"s":{"c":11}}},"i":{"a":[{"b":1,"t":{"o":1},"n":{".":70}},41],"b":156,"c":{"k":18,"o":21,"u":157},"d":{"i":32},"e":{"n":27},"f":[{"y":4},8],"g":[{"u":32},25],"l":{"l":{"i":{"n":6}}},"m":[{"p":18,"u":{"l":5}},41],"n":[{"a":24,"e":{".":27},"i":27,"o":{"m":285}},42],"o":[{"c":4,"n":{"e":{"e":6}}},41],"q":32,"s":{"a":3,"e":27,"m":0,"o":4,"p":0,"t":{"i":{"c":{"a":32}}}},"t":{"l":3},"u":1,"v":[{"a":0},41],"z":[{"a":3,"e":{"n":3}},41]},"l":[{"a":[{"n":17},19],"e":{".":27,"d":27,"s":{".":27},"t":{".":19}},"o":19,"i":{"e":{"r":315}}},25],"m":[{"e":0},43],"n":81,"o":[{"b":3,"c":{"r":{"a":{"t":4}}},"d":{"o":18},"f":25,"g":{"r":9},"i":{"c":4},"m":{"a":9,"b":0,"y":3},"n":{"a":{"l":{"i":0},"t":3},"o":18,"y":18},"r":{"a":9,"i":{"e":3,"z":5}},"s":8,"u":{"r":32,"t":18},"w":{"a":{"r":3}},"l":{"o":{"g":{"y":84}}},"t":{"i":{"c":11}}},41],"p":43,"r":{"a":[{"b":11,"c":{"h":5,"i":[{"t":17},36],"t":{"e":17}},"s":17,"v":{"e":{"n":5,"s":158,"r":{"s":[{"a":{"b":317}},15]}}},"i":{"t":{"o":{"r":316}}}},41],"e":{"f":5,"m":[{"i":6},0],"a":{"c":{"h":{"e":318}}}},"i":{"a":[{"l":{".":1}},32],"c":{"e":{"s":5},"i":{"a":32},"s":18},"m":25,"v":0},"o":{"m":{"i":5},"n":{"i":6,"y":18},"p":{"h":{"e":5},"i":{"s":175},"o":{"l":{"e":{"s":320},"i":{"s":320,"t":321}}}},"s":{"p":11},"v":11,"l":{"e":{"u":{"m":319}}},"f":{"i":{"c":{".":17},"t":11}}},"u":{"i":5,"s":17}},"s":[{"c":[{"h":{"i":{"e":12}}},21],"h":0,"w":21},101],"t":[{"e":{"s":21},"o":19,"u":0,"r":{"i":{"b":{"u":{"t":322}}}}},66],"u":[{"a":[{"r":3},2],"b":{"i":1},"d":8,"e":18,"f":46,"i":76,"m":27,"n":{"i":{"s":1}},"p":{".":48},"r":{"e":27,"i":[{"s":11},32],"o":5,"y":4,"n":{"a":{"r":12}}},"s":27},41],"v":18,"w":[{"a":43,"i":{"s":17},"o":18,"h":29},1],"y":[{"a":18,"l":25,"p":{"e":12,"h":4,"a":{"l":64}}},41],"z":[{"e":1},18]},"u":{"a":{"b":18,"c":0,"n":{"a":4,"i":0},"r":{"a":{"n":{"t":5}},"d":8,"i":11,"t":11},"t":29,"v":0,"d":{"r":{"a":{"t":{"i":3,"u":15}}}}},"b":{"e":[{"l":21,"r":[{"o":21},23]},1],"i":[{"n":{"g":33}},72],"l":{"e":{".":23}}},"c":{"a":23,"i":{"b":0,"t":1},"l":{"e":12},"r":23,"u":23,"y":21},"d":{"d":4,"e":{"r":3,"s":{"t":4},"v":17},"i":{"c":29,"e":{"d":3,"s":3},"s":4,"t":19},"o":{"n":[{"y":232},21]},"s":{"i":1},"u":21},"e":{"n":{"e":21,"s":17,"t":{"e":0}},"r":{"i":{"l":0}},"a":{"m":15}},"f":{"a":27,"l":23},"g":{"h":{"e":{"n":11}},"i":{"n":4}},"i":[{"l":{"i":{"z":5}},"n":[{"g":29},1],"r":{"m":0},"t":{"a":17},"v":[{"e":{"r":{".":0}}},11]},156],"j":19,"k":18,"l":{"a":[{"b":5,"t":{"i":19}},29],"c":{"h":[{"e":32},17]},"d":{"e":{"r":3}},"e":[{"n":29},1],"g":{"i":1},"i":[{"a":19,"n":{"g":3},"s":{"h":4}},9],"l":{"a":{"r":1},"i":{"b":96,"s":1}},"m":61,"o":72,"s":[{"e":{"s":5}},18],"t":{"i":2,"r":{"a":54},"u":18},"u":[{"l":4},23],"v":4},"m":{"a":{"b":4},"b":{"i":1,"l":{"y":1}},"i":[{"n":{"g":83}},29],"o":{"r":{"o":6}},"p":9},"n":{"a":{"t":17},"e":[{"r":1},24],"i":[{"m":1,"n":24,"s":{"h":4},"v":11},29],"s":[{"w":1},93],"t":{"a":{"b":11},"e":{"r":{".":1},"s":1}},"u":0,"y":4,"z":4},"o":{"r":{"s":21},"s":19,"u":29},"p":{"e":[{"r":{"s":6}},29],"i":{"a":19,"n":{"g":3}},"l":23,"p":[{"o":{"r":{"t":10}}},3],"t":{"i":{"b":5},"u":17}},"r":{"a":[{".":18,"g":21,"s":21,"l":{".":216}},29],"b":{"e":1},"c":0,"d":2,"e":{"a":{"t":5}},"f":{"e":{"r":1},"r":1},"i":{"f":[{"i":{"c":0}},23],"n":2,"o":23,"t":29,"z":3,"a":{"l":{".":0}}},"l":[{"i":{"n":{"g":{".":5}}}},9],"n":{"o":1},"o":{"s":17},"p":{"e":1,"i":1},"s":{"e":{"r":5}},"t":{"e":{"s":4},"h":{"e":3},"i":[{"e":1},17]},"u":23},"s":[{"a":{"d":19,"n":19,"p":1},"c":[{"i":3},8],"e":{"a":5,"r":{".":9}},"i":{"a":19,"c":23},"l":{"i":{"n":1}},"p":2,"s":{"l":4},"t":{"e":{"r":{"e":4}},"r":2},"u":[{"r":17},24]},25],"t":{"a":{"b":0,"t":23},"e":{".":18,"l":18,"n":[{"i":17},18]},"i":[{"l":{"i":{"z":5}},"n":{"e":23,"g":3},"o":{"n":{"a":7}},"s":21,"z":31},101],"l":34,"o":{"f":4,"g":5,"m":{"a":{"t":{"i":{"c":5}}}},"n":19,"u":21},"s":0},"u":[{"m":1},23],"v":74,"x":{"u":11},"z":{"e":1}},"v":{"a":[{".":32,"b":159,"c":{"i":{"l":5},"u":11},"g":[{"e":1,"u":{"e":{"r":170}}},0],"l":{"i":{"e":4},"o":5,"u":15},"m":{"o":4},"n":{"i":{"z":4}},"p":{"i":4},"r":{"i":{"e":{"d":5}}},"t":[{"i":{"v":29}},27],"u":{"d":{"e":{"v":54}}}},41],"e":{".":18,"d":18,"g":11,"l":{".":23,"l":{"i":11},"o":1,"y":21},"n":{"o":{"m":11},"u":{"e":19}},"r":{"d":21,"e":{".":32,"l":[{"y":{".":41}},21],"n":[{"c":5},23],"s":21,"i":{"g":324}},"i":{"e":11},"m":{"i":{"n":36}},"s":{"e":27},"t":{"h":11}},"s":[{".":18,"t":{"e":0,"i":{"t":{"e":15}}}},99],"t":{"e":[{"r":11},1],"y":1}},"i":{"a":{"l":{"i":4},"n":32},"d":{"e":{".":32,"d":32,"n":47,"s":32},"i":32},"f":23,"g":{"n":4},"k":0,"l":[{"i":{"t":32,"z":127}},25],"n":[{"a":26,"c":24,"d":5,"g":18},29],"o":{"l":11,"r":73,"u":2},"p":1,"r":{"o":4},"s":{"i":{"t":11},"o":3,"u":3},"t":{"i":18,"r":11,"y":18},"v":[{"i":{"p":{"a":{"r":325}}}},27]},"o":{".":32,"i":[{"r":{"d":{"u":323}},"c":{"e":{"p":213}}},0],"k":27,"l":{"a":1,"e":19,"t":32,"v":27},"m":{"i":5},"r":{"a":{"b":5},"i":17,"y":1},"t":{"a":1,"e":{"e":18}}},"v":26,"y":21},"w":{"a":{"b":{"l":19},"c":25,"g":{"e":{"r":4},"o":5},"i":{"t":6},"l":{".":19},"m":0,"r":{"t":0},"s":{"t":[{"e":{"w":{"a":326}}},0]},"t":{"e":2},"v":{"e":{"r":4,"g":327}}},"b":29,"e":{"a":{"r":{"i":{"e":5}},"t":{"h":54}},"d":{"n":0},"e":{"t":12,"v":5,"k":{"n":137}},"l":{"l":0},"r":29,"s":{"t":12},"v":23},"h":{"i":0},"i":[{"l":[{"l":{"i":{"n":6}}},8],"n":{"d":{"e":0},"g":0},"r":0,"s":{"e":27},"t":{"h":12},"z":5,"d":{"e":{"s":{"p":6}}}},9],"k":21,"l":{"e":{"s":1},"i":{"n":3}},"n":{"o":21},"o":[{"m":15,"v":{"e":{"n":4}},"k":{"e":{"n":85}}},160],"p":19,"r":{"a":[{"p":{"a":{"r":{"o":12}}}},0],"i":[{"t":{"a":36,"e":{"r":{".":183}}}},0]},"s":{"h":23,"l":1,"p":{"e":1},"t":60},"t":18,"y":1,"c":23},"x":{"a":[{"c":{"e":5},"g":{"o":21},"m":11,"p":21,"s":5},29],"c":161,"e":[{"c":{"u":{"t":{"o":1}}},"d":24,"r":{"i":0,"o":4}},29],"h":[{"i":[{"l":6},8],"u":0},29],"i":[{"a":4,"c":4,"d":{"i":4},"m":{"e":21,"i":{"z":4}}},23],"o":[{"b":21},23],"p":[{"a":{"n":{"d":17}},"e":{"c":{"t":{"o":10}},"d":11}},23],"t":[{"i":23},74],"u":[{"a":3},29],"x":1,"q":[{"u":{"i":{"s":54}}},29]},"y":{"a":{"c":19,"r":110,"t":19},"b":29,"c":[{"e":[{"r":4},24],"h":[{"e":[{"d":264},0]},23],"o":{"m":17,"t":17}},29],"d":29,"e":{"e":19,"r":[{"f":21},29],"s":[{"t":{"e":{"r":{"y":328}}}},0],"t":1},"g":{"i":19},"h":47,"i":29,"l":{"a":23,"l":{"a":{"b":{"l":6}}},"o":23,"u":19},"m":{"b":{"o":{"l":7}},"e":[{"t":{"r":{"y":20}}},0],"p":{"a":12}},"n":{"c":{"h":{"r":3}},"d":4,"g":4,"i":{"c":4},"x":32},"o":[{"d":4,"g":33,"m":0,"n":{"e":{"t":4},"s":21},"s":21},72],"p":{"e":{"d":21,"r":6},"i":3,"o":[{"c":21},23],"t":{"a":9},"u":19},"r":{"a":{"m":5},"i":{"a":4},"o":23,"r":1},"s":{"c":1,"e":161,"i":{"c":{"a":3},"o":3,"s":27},"o":21,"s":0,"t":[{"a":3,"r":{"o":29}},2],"u":{"r":17}},"t":{"h":{"i":{"n":23}},"i":{"c":3}},"w":29},"z":{"a":[{"b":79,"r":8},2],"b":18,"e":[{"n":1,"p":1,"r":[{"o":3},29],"t":0},25],"i":[{"l":21,"s":21,"a":{"n":{".":23}}},42],"l":32,"m":18,"o":[{"m":1,"o":{"l":4},"p":{"h":{"r":329}}},41],"t":{"e":0},"z":[{"y":21,"w":231},101]}}',
        [
          "as-so-ciate",
          "as-so-ciates",
          "dec-li-na-tion",
          "oblig-a-tory",
          "phil-an-thropic",
          "present",
          "presents",
          "project",
          "projects",
          "reci-procity",
          "re-cog-ni-zance",
          "ref-or-ma-tion",
          "ret-ri-bu-tion",
          "ta-ble"
        ]
      ];
    });
  })(enUs$1);
  return enUs$1.exports;
}
var enUsExports = requireEnUs();
const pattern = /* @__PURE__ */ getDefaultExportFromCjs$2(enUsExports);
const fromFragments = (fragments) => {
  let offset2 = 0;
  let string = "";
  const runs = [];
  fragments.forEach((fragment) => {
    string += fragment.string;
    runs.push({
      ...fragment,
      start: offset2,
      end: offset2 + fragment.string.length,
      attributes: fragment.attributes || {}
    });
    offset2 += fragment.string.length;
  });
  return { string, runs };
};
const defaultHyphenationEngine = (word) => [word];
const wrapWords = (engines2 = {}, options = {}) => {
  return (attributedString) => {
    var _a;
    const syllables = [];
    const fragments = [];
    const hyphenateWord = options.hyphenationCallback || ((_a = engines2.wordHyphenation) == null ? void 0 : _a.call(engines2)) || defaultHyphenationEngine;
    for (let i2 = 0; i2 < attributedString.runs.length; i2 += 1) {
      let string = "";
      const run = attributedString.runs[i2];
      const words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);
      for (let j = 0; j < words.length; j += 1) {
        const word = words[j];
        const parts = hyphenateWord(word);
        syllables.push(...parts);
        string += parts.join("");
      }
      fragments.push({ ...run, string });
    }
    const result = { ...fromFragments(fragments), syllables };
    return result;
  };
};
const copy3 = (rect) => {
  return Object.assign({}, rect);
};
const partition = (rect, height2) => {
  const a2 = Object.assign({}, rect, { height: height2 });
  const b2 = Object.assign({}, rect, {
    y: rect.y + height2,
    height: rect.height - height2
  });
  return [a2, b2];
};
const crop = (height2, rect) => {
  const [, result] = partition(rect, height2);
  return result;
};
const height$2 = (paragraph) => {
  return paragraph.reduce((acc, block) => acc + block.box.height, 0);
};
const calculateScale = (run) => {
  var _a;
  const attributes2 = run.attributes || {};
  const fontSize = attributes2.fontSize || 12;
  const font = attributes2.font;
  const unitsPerEm = typeof font === "string" ? null : (_a = font == null ? void 0 : font[0]) == null ? void 0 : _a.unitsPerEm;
  return unitsPerEm ? fontSize / unitsPerEm : 0;
};
const scale = (run) => {
  var _a;
  return ((_a = run.attributes) == null ? void 0 : _a.scale) || calculateScale(run);
};
const offset = (index2, run) => {
  if (!run)
    return 0;
  const glyphIndices = run.glyphIndices || [];
  const value2 = glyphIndices[index2];
  return glyphIndices.slice(0, index2).filter((i2) => i2 === value2).length;
};
const getFont = (run) => {
  var _a, _b;
  return ((_b = (_a = run.attributes) == null ? void 0 : _a.font) == null ? void 0 : _b[0]) || null;
};
const slice$2 = (start2, end2, font, glyph) => {
  if (!glyph)
    return [];
  if (start2 === end2)
    return [];
  if (start2 === 0 && end2 === glyph.codePoints.length)
    return [glyph];
  const codePoints = glyph.codePoints.slice(start2, end2);
  const string = String.fromCodePoint(...codePoints);
  return font ? font.layout(string, void 0, void 0, void 0, "ltr").glyphs : [glyph];
};
const glyphIndexAt = (index2, run) => {
  var _a;
  const result = (_a = run == null ? void 0 : run.glyphIndices) == null ? void 0 : _a[index2];
  return isNil(result) ? index2 : result;
};
const normalize = (array) => {
  const head = array[0];
  return array.map((value2) => value2 - head);
};
const slice$1 = (start2, end2, run) => {
  var _a, _b;
  const runScale = scale(run);
  const font = getFont(run);
  const startIndex = glyphIndexAt(start2, run);
  const endIndex = glyphIndexAt(end2, run);
  const startGlyph = (_a = run.glyphs) == null ? void 0 : _a[startIndex];
  const endGlyph = (_b = run.glyphs) == null ? void 0 : _b[endIndex];
  const startOffset = offset(start2, run);
  const startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : [];
  const endOffset = offset(end2, run);
  const endGlyphs = slice$2(0, endOffset, font, endGlyph);
  const sliceStart = startIndex + Math.min(1, startOffset);
  const glyphs = (run.glyphs || []).slice(sliceStart, endIndex);
  const glyphPosition = (g) => ({
    xAdvance: g.advanceWidth * runScale,
    yAdvance: 0,
    xOffset: 0,
    yOffset: 0
  });
  const startPositions = startGlyphs.map(glyphPosition);
  const positions = (run.positions || []).slice(sliceStart, endIndex);
  const endPositions = endGlyphs.map(glyphPosition);
  return Object.assign({}, run, {
    start: run.start + start2,
    end: Math.min(run.end, run.start + end2),
    glyphIndices: normalize((run.glyphIndices || []).slice(start2, end2)),
    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),
    positions: [startPositions, positions, endPositions].flat()
  });
};
const runIndexAt$1 = (index2, runs) => {
  if (!runs)
    return -1;
  return runs.findIndex((run) => run.start <= index2 && index2 < run.end);
};
const filter = (start2, end2, runs) => {
  const startIndex = runIndexAt$1(start2, runs);
  const endIndex = Math.max(runIndexAt$1(end2 - 1, runs), startIndex);
  return runs.slice(startIndex, endIndex + 1);
};
const subtract = (index2, run) => {
  const start2 = run.start - index2;
  const end2 = run.end - index2;
  return Object.assign({}, run, { start: start2, end: end2 });
};
const sliceRuns = (start2, end2, runs) => {
  const sliceFirstRun = (a2) => slice$1(start2 - a2.start, end2 - a2.start, a2);
  const sliceLastRun = (a2) => slice$1(0, end2 - a2.start, a2);
  return runs.map((run, i2) => {
    let result = run;
    const isFirst = i2 === 0;
    const isLast = !isFirst && i2 === runs.length - 1;
    if (isFirst)
      result = sliceFirstRun(run);
    if (isLast)
      result = sliceLastRun(run);
    return subtract(start2, result);
  });
};
const slice3 = (start2, end2, attributedString) => {
  if (attributedString.string.length === 0)
    return attributedString;
  const string = attributedString.string.slice(start2, end2);
  const filteredRuns = filter(start2, end2, attributedString.runs);
  const slicedRuns = sliceRuns(start2, end2, filteredRuns);
  return Object.assign({}, attributedString, { string, runs: slicedRuns });
};
const findCharIndex = (string) => {
  return string.search(/\S/g);
};
const findLastCharIndex = (string) => {
  const match = string.match(/\S/g);
  return match ? string.lastIndexOf(match[match.length - 1]) : -1;
};
const trim = (attributedString) => {
  const start2 = findCharIndex(attributedString.string);
  const end2 = findLastCharIndex(attributedString.string);
  return slice3(start2, end2 + 1, attributedString);
};
const empty$1 = () => {
  return {
    start: 0,
    end: 0,
    glyphIndices: [],
    glyphs: [],
    positions: [],
    attributes: {}
  };
};
const isNumber$1 = (value2) => {
  return typeof value2 === "number";
};
const appendIndices = (length2, indices) => {
  const lastIndex = last(indices);
  const value2 = isNil(lastIndex) ? 0 : lastIndex + 1;
  const newIndices = Array(length2).fill(value2);
  return indices.concat(newIndices);
};
const fromCodePoint = (value2, font) => {
  if (typeof font === "string")
    return null;
  return font && value2 ? font.glyphForCodePoint(value2) : null;
};
const appendGlyph = (glyph, run) => {
  var _a;
  const glyphLength = ((_a = glyph.codePoints) == null ? void 0 : _a.length) || 0;
  const end2 = run.end + glyphLength;
  const glyphs = run.glyphs.concat(glyph);
  const glyphIndices = appendIndices(glyphLength, run.glyphIndices);
  if (!run.positions)
    return Object.assign({}, run, { end: end2, glyphs, glyphIndices });
  const positions = run.positions.concat({
    xAdvance: glyph.advanceWidth * scale(run),
    yAdvance: 0,
    xOffset: 0,
    yOffset: 0
  });
  return Object.assign({}, run, { end: end2, glyphs, glyphIndices, positions });
};
const append$1 = (value2, run) => {
  if (!value2)
    return run;
  const font = getFont(run);
  const glyph = isNumber$1(value2) ? fromCodePoint(value2, font) : value2;
  return appendGlyph(glyph, run);
};
const stringFromCodePoints = (codePoints) => {
  return String.fromCodePoint(...codePoints || []);
};
const append = (glyph, attributedString) => {
  const codePoints = typeof glyph === "number" ? [glyph] : glyph == null ? void 0 : glyph.codePoints;
  const codePointsString = stringFromCodePoints(codePoints || []);
  const string = attributedString.string + codePointsString;
  const firstRuns = attributedString.runs.slice(0, -1);
  const lastRun = last(attributedString.runs) || empty$1();
  const runs = firstRuns.concat(append$1(glyph, lastRun));
  return Object.assign({}, attributedString, { string, runs });
};
const ELLIPSIS_UNICODE = 8230;
const ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);
const getEllipsisCodePoint = (font) => {
  if (!font.encode)
    return ELLIPSIS_UNICODE;
  const [codePoints] = font.encode(ELLIPSIS_STRING);
  return parseInt(codePoints[0], 16);
};
const truncate = (paragraph) => {
  var _a, _b, _c;
  const runs = ((_a = last(paragraph)) == null ? void 0 : _a.runs) || [];
  const font = (_c = (_b = last(runs)) == null ? void 0 : _b.attributes) == null ? void 0 : _c.font[0];
  if (font) {
    const index2 = paragraph.length - 1;
    const codePoint = getEllipsisCodePoint(font);
    const glyph = font.glyphForCodePoint(codePoint);
    const lastBlock = append(glyph, trim(paragraph[index2]));
    return Object.assign([], paragraph, { [index2]: lastBlock });
  }
  return paragraph;
};
const omit = (value2, run) => {
  const attributes2 = Object.assign({}, run.attributes);
  delete attributes2[value2];
  return Object.assign({}, run, { attributes: attributes2 });
};
const ascent$1 = (run) => {
  var _a;
  const { font, attachment } = run.attributes;
  const attachmentHeight = (attachment == null ? void 0 : attachment.height) || 0;
  const fontAscent = typeof font === "string" ? 0 : ((_a = font == null ? void 0 : font[0]) == null ? void 0 : _a.ascent) || 0;
  return Math.max(attachmentHeight, fontAscent * scale(run));
};
const descent = (run) => {
  var _a, _b;
  const font = (_a = run.attributes) == null ? void 0 : _a.font;
  const fontDescent = typeof font === "string" ? 0 : ((_b = font == null ? void 0 : font[0]) == null ? void 0 : _b.descent) || 0;
  return scale(run) * fontDescent;
};
const lineGap = (run) => {
  var _a, _b;
  const font = (_a = run.attributes) == null ? void 0 : _a.font;
  const lineGap2 = typeof font === "string" ? 0 : ((_b = font == null ? void 0 : font[0]) == null ? void 0 : _b.lineGap) || 0;
  return lineGap2 * scale(run);
};
const height$1 = (run) => {
  var _a;
  const lineHeight = (_a = run.attributes) == null ? void 0 : _a.lineHeight;
  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);
};
const height = (attributedString) => {
  const reducer = (acc, run) => Math.max(acc, height$1(run));
  return attributedString.runs.reduce(reducer, 0);
};
const intersects = (a2, b2) => {
  const x = Math.max(a2.x, b2.x);
  const num1 = Math.min(a2.x + a2.width, b2.x + b2.width);
  const y2 = Math.max(a2.y, b2.y);
  const num2 = Math.min(a2.y + a2.height, b2.y + b2.height);
  return num1 >= x && num2 >= y2;
};
const getLineFragment = (lineRect, excludeRect) => {
  if (!intersects(excludeRect, lineRect))
    return [lineRect];
  const eStart = excludeRect.x;
  const eEnd = excludeRect.x + excludeRect.width;
  const lStart = lineRect.x;
  const lEnd = lineRect.x + lineRect.width;
  const a2 = Object.assign({}, lineRect, { width: eStart - lStart });
  const b2 = Object.assign({}, lineRect, { x: eEnd, width: lEnd - eEnd });
  return [a2, b2].filter((r2) => r2.width > 0);
};
const getLineFragments = (rect, excludeRects) => {
  let fragments = [rect];
  for (let i2 = 0; i2 < excludeRects.length; i2 += 1) {
    const excludeRect = excludeRects[i2];
    fragments = fragments.reduce((acc, fragment) => {
      const pieces = getLineFragment(fragment, excludeRect);
      return acc.concat(pieces);
    }, []);
  }
  return fragments;
};
const generateLineRects = (container, height2) => {
  const { excludeRects, ...rect } = container;
  if (!excludeRects)
    return [rect];
  const lineRects = [];
  const maxY = Math.max(...excludeRects.map((r2) => r2.y + r2.height));
  let currentRect = rect;
  while (currentRect.y < maxY) {
    const [lineRect, rest] = partition(currentRect, height2);
    const lineRectFragments = getLineFragments(lineRect, excludeRects);
    currentRect = rest;
    lineRects.push(...lineRectFragments);
  }
  return [...lineRects, currentRect];
};
const ATTACHMENT_CODE$1 = "";
const purgeAttachments = (line2) => {
  const shouldPurge = !line2.string.includes(ATTACHMENT_CODE$1);
  if (!shouldPurge)
    return line2;
  const runs = line2.runs.map((run) => omit("attachment", run));
  return Object.assign({}, line2, { runs });
};
const layoutLines = (rects, lines, indent) => {
  let rect = rects.shift();
  let currentY = rect.y;
  return lines.map((line2, i2) => {
    var _a, _b;
    const lineIndent = i2 === 0 ? indent : 0;
    const style = ((_b = (_a = line2.runs) == null ? void 0 : _a[0]) == null ? void 0 : _b.attributes) || {};
    const height$12 = Math.max(height(line2), style.lineHeight);
    if (currentY + height$12 > rect.y + rect.height && rects.length > 0) {
      rect = rects.shift();
      currentY = rect.y;
    }
    const newLine = {
      string: line2.string,
      runs: line2.runs,
      box: {
        x: rect.x + lineIndent,
        y: currentY,
        width: rect.width - lineIndent,
        height: height$12
      }
    };
    currentY += height$12;
    return purgeAttachments(newLine);
  });
};
const layoutParagraph = (engines2, options = {}) => {
  return (container, paragraph) => {
    var _a, _b, _c;
    const height$12 = height(paragraph);
    const indent = ((_c = (_b = (_a = paragraph.runs) == null ? void 0 : _a[0]) == null ? void 0 : _b.attributes) == null ? void 0 : _c.indent) || 0;
    const rects = generateLineRects(container, height$12);
    const availableWidths = rects.map((r2) => r2.width);
    availableWidths.unshift(availableWidths[0] - indent);
    const lines = engines2.linebreaker(options)(paragraph, availableWidths);
    return layoutLines(rects, lines, indent);
  };
};
const sliceAtHeight = (height2, paragraph) => {
  const newBlock = [];
  let counter = 0;
  for (let i2 = 0; i2 < paragraph.length; i2 += 1) {
    const line2 = paragraph[i2];
    counter += line2.box.height;
    if (counter < height2) {
      newBlock.push(line2);
    } else {
      break;
    }
  }
  return newBlock;
};
const typesetter = (engines2, options, container) => {
  return (attributedStrings) => {
    const result = [];
    const paragraphs = [...attributedStrings];
    const layout2 = layoutParagraph(engines2, options);
    const maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;
    const truncateEllipsis = container.truncateMode === "ellipsis";
    let linesCount = maxLines;
    let paragraphRect = copy3(container);
    let nextParagraph = paragraphs.shift();
    while (linesCount > 0 && nextParagraph) {
      const paragraph = layout2(paragraphRect, nextParagraph);
      const slicedBlock = paragraph.slice(0, linesCount);
      const linesHeight2 = height$2(slicedBlock);
      const shouldTruncate = truncateEllipsis && paragraph.length !== slicedBlock.length;
      linesCount -= slicedBlock.length;
      if (paragraphRect.height >= linesHeight2) {
        result.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);
        paragraphRect = crop(linesHeight2, paragraphRect);
        nextParagraph = paragraphs.shift();
      } else {
        result.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));
        break;
      }
    }
    return result;
  };
};
const start = (attributedString) => {
  const { runs } = attributedString;
  return runs.length === 0 ? 0 : runs[0].start;
};
const end = (attributedString) => {
  const { runs } = attributedString;
  return runs.length === 0 ? 0 : last(runs).end;
};
const length$1 = (attributedString) => {
  return end(attributedString) - start(attributedString);
};
const bidi$2 = bidiFactory();
const getBidiLevels$1 = (runs) => {
  return runs.reduce((acc, run) => {
    const length2 = run.end - run.start;
    const levels = repeat(run.attributes.bidiLevel, length2);
    return acc.concat(levels);
  }, []);
};
const getReorderedIndices = (string, segments) => {
  const indices = [];
  for (let i2 = 0; i2 < string.length; i2 += 1) {
    indices[i2] = i2;
  }
  segments.forEach(([start2, end2]) => {
    const slice5 = indices.slice(start2, end2 + 1);
    for (let i2 = slice5.length - 1; i2 >= 0; i2 -= 1) {
      indices[end2 - i2] = slice5[i2];
    }
  });
  return indices;
};
const getItemAtIndex = (runs, objectName, index2) => {
  for (let i2 = 0; i2 < runs.length; i2 += 1) {
    const run = runs[i2];
    const updatedIndex = run.glyphIndices[index2 - run.start];
    if (index2 >= run.start && index2 < run.end) {
      return run[objectName][updatedIndex];
    }
  }
  throw new Error(`index ${index2} out of range`);
};
const reorderLine = (line2) => {
  var _a;
  const levels = getBidiLevels$1(line2.runs);
  const direction = (_a = line2.runs[0]) == null ? void 0 : _a.attributes.direction;
  const level = direction === "rtl" ? 1 : 0;
  const end2 = length$1(line2) - 1;
  const paragraphs = [{ start: 0, end: end2, level }];
  const embeddingLevels = { paragraphs, levels };
  const segments = bidi$2.getReorderSegments(line2.string, embeddingLevels);
  if (segments.length === 0)
    return line2;
  const indices = getReorderedIndices(line2.string, segments);
  const updatedString = bidi$2.getReorderedString(line2.string, embeddingLevels);
  const updatedRuns = line2.runs.map((run) => {
    const selectedIndices = indices.slice(run.start, run.end);
    const updatedGlyphs = [];
    const updatedPositions = [];
    const addedGlyphs = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < selectedIndices.length; i2 += 1) {
      const index2 = selectedIndices[i2];
      const glyph = getItemAtIndex(line2.runs, "glyphs", index2);
      if (addedGlyphs.has(glyph.id))
        continue;
      updatedGlyphs.push(glyph);
      updatedPositions.push(getItemAtIndex(line2.runs, "positions", index2));
      if (glyph.isLigature) {
        addedGlyphs.add(glyph.id);
      }
    }
    return {
      ...run,
      glyphs: updatedGlyphs,
      positions: updatedPositions
    };
  });
  return {
    box: line2.box,
    runs: updatedRuns,
    string: updatedString
  };
};
const reorderParagraph = (paragraph) => paragraph.map(reorderLine);
const bidiReordering = () => {
  return (paragraphs) => paragraphs.map(reorderParagraph);
};
const DUMMY_CODEPOINT = 123;
const resolve = (glyphs = []) => {
  return glyphs.reduce((acc, glyph) => {
    const codePoints = (glyph == null ? void 0 : glyph.codePoints) || [DUMMY_CODEPOINT];
    if (acc.length === 0)
      return codePoints.map(() => 0);
    const last2 = acc[acc.length - 1];
    const next = codePoints.map(() => last2 + 1);
    return [...acc, ...next];
  }, []);
};
const getCharacterSpacing = (run) => {
  var _a;
  return ((_a = run.attributes) == null ? void 0 : _a.characterSpacing) || 0;
};
const scalePositions = (run, positions) => {
  const runScale = scale(run);
  const characterSpacing = getCharacterSpacing(run);
  return positions.map((position, i2) => {
    const isLast = i2 === positions.length;
    const xSpacing = isLast ? 0 : characterSpacing;
    return Object.assign({}, position, {
      xAdvance: position.xAdvance * runScale + xSpacing,
      yAdvance: position.yAdvance * runScale,
      xOffset: position.xOffset * runScale,
      yOffset: position.yOffset * runScale
    });
  });
};
const layoutRun = (string) => {
  return (run) => {
    const { start: start2, end: end2, attributes: attributes2 = {} } = run;
    const { font } = attributes2;
    if (!font)
      return { ...run, glyphs: [], glyphIndices: [], positions: [] };
    const runString = string.slice(start2, end2);
    if (typeof font === "string")
      throw new Error("Invalid font");
    const glyphRun = font[0].layout(runString, void 0, void 0, void 0, "ltr");
    const positions = scalePositions(run, glyphRun.positions);
    const glyphIndices = resolve(glyphRun.glyphs);
    const result = {
      ...run,
      positions,
      glyphIndices,
      glyphs: glyphRun.glyphs
    };
    return result;
  };
};
const generateGlyphs = () => {
  return (attributedString) => {
    const runs = attributedString.runs.map(layoutRun(attributedString.string));
    const res = Object.assign({}, attributedString, { runs });
    return res;
  };
};
const resolveRunYOffset = (run) => {
  var _a, _b, _c, _d;
  if (!run.positions)
    return run;
  const unitsPerEm = ((_c = (_b = (_a = run.attributes) == null ? void 0 : _a.font) == null ? void 0 : _b[0]) == null ? void 0 : _c.unitsPerEm) || 0;
  const yOffset = (((_d = run.attributes) == null ? void 0 : _d.yOffset) || 0) * unitsPerEm;
  const positions = run.positions.map((p2) => Object.assign({}, p2, { yOffset }));
  return Object.assign({}, run, { positions });
};
const resolveYOffset = () => {
  return (attributedString) => {
    const runs = attributedString.runs.map(resolveRunYOffset);
    const res = Object.assign({}, attributedString, { runs });
    return res;
  };
};
const sort = (runs) => {
  return runs.sort((a2, b2) => a2.start - b2.start || a2.end - b2.end);
};
const isEmpty = (run) => {
  return run.start === run.end;
};
const sortPoints = (a2, b2) => {
  return a2[1] - b2[1] || a2[3] - b2[3];
};
const generatePoints = (runs) => {
  const result = runs.reduce((acc, run, i2) => {
    return acc.concat([
      ["start", run.start, run.attributes, i2],
      ["end", run.end, run.attributes, i2]
    ]);
  }, []);
  return result.sort(sortPoints);
};
const mergeRuns = (runs) => {
  return runs.reduce((acc, run) => {
    const attributes2 = Object.assign({}, acc.attributes, run.attributes);
    return Object.assign({}, run, { attributes: attributes2 });
  }, {});
};
const groupEmptyRuns = (runs) => {
  const groups = runs.reduce((acc, run) => {
    if (!acc[run.start])
      acc[run.start] = [];
    acc[run.start].push(run);
    return acc;
  }, []);
  return Object.values(groups);
};
const flattenEmptyRuns = (runs) => {
  return groupEmptyRuns(runs).map(mergeRuns);
};
const flattenRegularRuns = (runs) => {
  const res = [];
  const points = generatePoints(runs);
  let start2 = -1;
  let attrs = {};
  const stack = [];
  for (let i2 = 0; i2 < points.length; i2 += 1) {
    const [type, offset2, attributes2] = points[i2];
    if (start2 !== -1 && start2 < offset2) {
      res.push({
        start: start2,
        end: offset2,
        attributes: attrs,
        glyphIndices: [],
        glyphs: [],
        positions: []
      });
    }
    if (type === "start") {
      stack.push(attributes2);
      attrs = Object.assign({}, attrs, attributes2);
    } else {
      attrs = {};
      for (let j = 0; j < stack.length; j += 1) {
        if (stack[j] === attributes2) {
          stack.splice(j--, 1);
        } else {
          attrs = Object.assign({}, attrs, stack[j]);
        }
      }
    }
    start2 = offset2;
  }
  return res;
};
const flatten = (runs = []) => {
  const emptyRuns = flattenEmptyRuns(runs.filter((run) => isEmpty(run)));
  const regularRuns = flattenRegularRuns(runs.filter((run) => !isEmpty(run)));
  return sort(emptyRuns.concat(regularRuns));
};
const empty = () => ({ string: "", runs: [] });
const omitFont = (attributedString) => {
  const runs = attributedString.runs.map((run) => omit("font", run));
  return Object.assign({}, attributedString, { runs });
};
const preprocessRuns = (engines2) => {
  return (attributedString) => {
    if (isNil(attributedString))
      return empty();
    const { string } = attributedString;
    const { fontSubstitution: fontSubstitution2, scriptItemizer: scriptItemizer2, bidi: bidi2 } = engines2;
    const { runs: omittedFontRuns } = omitFont(attributedString);
    const { runs: itemizationRuns } = scriptItemizer2()(attributedString);
    const { runs: substitutedRuns } = fontSubstitution2()(attributedString);
    const { runs: bidiRuns } = bidi2()(attributedString);
    const runs = bidiRuns.concat(substitutedRuns).concat(itemizationRuns).concat(omittedFontRuns);
    return { string, runs: flatten(runs) };
  };
};
const splitParagraphs = () => {
  return (attributedString) => {
    const paragraphs = [];
    let start2 = 0;
    let breakPoint = attributedString.string.indexOf("\n") + 1;
    while (breakPoint > 0) {
      paragraphs.push(slice3(start2, breakPoint, attributedString));
      start2 = breakPoint;
      breakPoint = attributedString.string.indexOf("\n", breakPoint) + 1;
    }
    if (start2 === 0) {
      paragraphs.push(attributedString);
    } else if (start2 < attributedString.string.length) {
      paragraphs.push(slice3(start2, length$1(attributedString), attributedString));
    }
    return paragraphs;
  };
};
const advanceWidth$2 = (positions) => {
  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);
};
const advanceWidth$1 = (run) => {
  return advanceWidth$2(run.positions || []);
};
const advanceWidth = (attributedString) => {
  const reducer = (acc, run) => acc + advanceWidth$1(run);
  return attributedString.runs.reduce(reducer, 0);
};
const WHITE_SPACES_CODE = 32;
const isWhiteSpace = (glyph) => {
  const codePoints = (glyph == null ? void 0 : glyph.codePoints) || [];
  return codePoints.includes(WHITE_SPACES_CODE);
};
const leadingPositions = (run) => {
  const glyphs = run.glyphs || [];
  const positions = run.positions || [];
  const leadingWhitespaces = glyphs.findIndex((g) => !isWhiteSpace(g));
  return positions.slice(0, leadingWhitespaces);
};
const leadingOffset$1 = (run) => {
  const positions = leadingPositions(run);
  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);
};
const leadingOffset = (attributedString) => {
  const runs = attributedString.runs || [];
  return leadingOffset$1(runs[0]);
};
const trailingPositions = (run) => {
  const glyphs = reverse(run.glyphs || []);
  const positions = reverse(run.positions || []);
  const leadingWhitespaces = glyphs.findIndex((g) => !isWhiteSpace(g));
  return positions.slice(0, leadingWhitespaces);
};
const trailingOffset$1 = (run) => {
  const positions = trailingPositions(run);
  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);
};
const trailingOffset = (attributedString) => {
  const runs = attributedString.runs || [];
  return trailingOffset$1(last(runs));
};
const dropLast$1 = (run) => {
  return slice$1(0, run.end - run.start - 1, run);
};
const dropLast = (attributedString) => {
  const string = dropLast$2(attributedString.string);
  const runs = adjust(-1, dropLast$1, attributedString.runs);
  return Object.assign({}, attributedString, { string, runs });
};
const ALIGNMENT_FACTORS$1 = { center: 0.5, right: 1 };
const removeNewLine = (line2) => {
  return last(line2.string) === "\n" ? dropLast(line2) : line2;
};
const getOverflowLeft = (line2) => {
  return leadingOffset(line2) + (line2.overflowLeft || 0);
};
const getOverflowRight = (line2) => {
  return trailingOffset(line2) + (line2.overflowRight || 0);
};
const adjustOverflow = (line2) => {
  const overflowLeft = getOverflowLeft(line2);
  const overflowRight = getOverflowRight(line2);
  const x = line2.box.x - overflowLeft;
  const width = line2.box.width + overflowLeft + overflowRight;
  const box = Object.assign({}, line2.box, { x, width });
  return Object.assign({}, line2, { box, overflowLeft, overflowRight });
};
const justifyLine$1 = (engines2, options, align) => {
  return (line2) => {
    const lineWidth = advanceWidth(line2);
    const alignFactor = ALIGNMENT_FACTORS$1[align] || 0;
    const remainingWidth = Math.max(0, line2.box.width - lineWidth);
    const shouldJustify = align === "justify" || lineWidth > line2.box.width;
    const x = line2.box.x + remainingWidth * alignFactor;
    const box = Object.assign({}, line2.box, { x });
    const newLine = Object.assign({}, line2, { box });
    return shouldJustify ? engines2.justification(options)(newLine) : newLine;
  };
};
const finalizeLine = (line2) => {
  let lineAscent = 0;
  let lineDescent = 0;
  let lineHeight = 0;
  let lineXAdvance = 0;
  const runs = line2.runs.map((run) => {
    const height2 = height$1(run);
    const ascent2 = ascent$1(run);
    const descent$1 = descent(run);
    const xAdvance = advanceWidth$1(run);
    lineHeight = Math.max(lineHeight, height2);
    lineAscent = Math.max(lineAscent, ascent2);
    lineDescent = Math.max(lineDescent, descent$1);
    lineXAdvance += xAdvance;
    return Object.assign({}, run, { height: height2, ascent: ascent2, descent: descent$1, xAdvance });
  });
  return Object.assign({}, line2, {
    runs,
    height: lineHeight,
    ascent: lineAscent,
    descent: lineDescent,
    xAdvance: lineXAdvance
  });
};
const finalizeBlock = (engines2, options) => {
  return (line2, index2, lines) => {
    var _a, _b;
    const isLastFragment = index2 === lines.length - 1;
    const style = ((_b = (_a = line2.runs) == null ? void 0 : _a[0]) == null ? void 0 : _b.attributes) || {};
    const align = isLastFragment ? style.alignLastLine : style.align;
    return compose(finalizeLine, engines2.textDecoration(), justifyLine$1(engines2, options, align), adjustOverflow, removeNewLine)(line2);
  };
};
const finalizeFragments = (engines2, options) => {
  return (paragraphs) => {
    const blockFinalizer = finalizeBlock(engines2, options);
    return paragraphs.map((paragraph) => paragraph.map(blockFinalizer));
  };
};
const ATTACHMENT_CODE = 65532;
const isReplaceGlyph = (glyph) => glyph.codePoints.includes(ATTACHMENT_CODE);
const resolveRunAttachments = (run) => {
  var _a;
  if (!run.positions)
    return run;
  const glyphs = run.glyphs || [];
  const attachment = (_a = run.attributes) == null ? void 0 : _a.attachment;
  if (!attachment)
    return run;
  const positions = run.positions.map((position, i2) => {
    const glyph = glyphs[i2];
    if (attachment.width && isReplaceGlyph(glyph)) {
      return Object.assign({}, position, { xAdvance: attachment.width });
    }
    return Object.assign({}, position);
  });
  return Object.assign({}, run, { positions });
};
const resolveAttachments = () => {
  return (attributedString) => {
    const runs = attributedString.runs.map(resolveRunAttachments);
    const res = Object.assign({}, attributedString, { runs });
    return res;
  };
};
const applyAttributes = (a2) => {
  return {
    align: a2.align || (a2.direction === "rtl" ? "right" : "left"),
    alignLastLine: a2.alignLastLine || (a2.align === "justify" ? "left" : a2.align || "left"),
    attachment: a2.attachment || null,
    backgroundColor: a2.backgroundColor || null,
    bullet: a2.bullet || null,
    characterSpacing: a2.characterSpacing || 0,
    color: a2.color || "black",
    direction: a2.direction || "ltr",
    features: a2.features || [],
    fill: a2.fill !== false,
    font: a2.font || [],
    fontSize: a2.fontSize || 12,
    hangingPunctuation: a2.hangingPunctuation || false,
    hyphenationFactor: a2.hyphenationFactor || 0,
    indent: a2.indent || 0,
    justificationFactor: a2.justificationFactor || 1,
    lineHeight: a2.lineHeight || null,
    lineSpacing: a2.lineSpacing || 0,
    link: a2.link || null,
    marginLeft: a2.marginLeft || a2.margin || 0,
    marginRight: a2.marginRight || a2.margin || 0,
    opacity: a2.opacity,
    paddingTop: a2.paddingTop || a2.padding || 0,
    paragraphSpacing: a2.paragraphSpacing || 0,
    script: a2.script || null,
    shrinkFactor: a2.shrinkFactor || 0,
    strike: a2.strike || false,
    strikeColor: a2.strikeColor || a2.color || "black",
    strikeStyle: a2.strikeStyle || "solid",
    stroke: a2.stroke || false,
    underline: a2.underline || false,
    underlineColor: a2.underlineColor || a2.color || "black",
    underlineStyle: a2.underlineStyle || "solid",
    verticalAlign: a2.verticalAlign || null,
    wordSpacing: a2.wordSpacing || 0,
    yOffset: a2.yOffset || 0
  };
};
const applyRunStyles = (run) => {
  const attributes2 = applyAttributes(run.attributes);
  return Object.assign({}, run, { attributes: attributes2 });
};
const applyDefaultStyles = () => {
  return (attributedString) => {
    const string = attributedString.string || "";
    const runs = (attributedString.runs || []).map(applyRunStyles);
    return { string, runs };
  };
};
const verticalAlignment = () => {
  return (attributedString) => {
    attributedString.runs.forEach((run) => {
      const { attributes: attributes2 } = run;
      const { verticalAlign } = attributes2;
      if (verticalAlign === "sub") {
        attributes2.yOffset = -0.2;
      } else if (verticalAlign === "super") {
        attributes2.yOffset = 0.4;
      }
    });
    return attributedString;
  };
};
const bidi$1 = bidiFactory();
const getBidiLevels = (runs) => {
  return runs.reduce((acc, run) => {
    const length2 = run.end - run.start;
    const levels = repeat(run.attributes.bidiLevel, length2);
    return acc.concat(levels);
  }, []);
};
const mirrorString = () => {
  return (attributedString) => {
    const levels = getBidiLevels(attributedString.runs);
    let updatedString = "";
    attributedString.string.split("").forEach((char, index2) => {
      const isRTL = levels[index2] % 2 === 1;
      const mirroredChar = isRTL ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index2)) : null;
      updatedString += mirroredChar || char;
    });
    const result = {
      ...attributedString,
      string: updatedString
    };
    return result;
  };
};
const layoutEngine = (engines2) => {
  return (attributedString, container, options = {}) => {
    const processParagraph = compose(resolveYOffset(), resolveAttachments(), verticalAlignment(), wrapWords(engines2, options), generateGlyphs(), mirrorString(), preprocessRuns(engines2));
    const processParagraphs = (paragraphs) => paragraphs.map(processParagraph);
    return compose(finalizeFragments(engines2, options), bidiReordering(), typesetter(engines2, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);
  };
};
const bidi = bidiFactory();
const bidiEngine = () => {
  return (attributedString) => {
    var _a;
    const { string } = attributedString;
    const direction = (_a = attributedString.runs[0]) == null ? void 0 : _a.attributes.direction;
    const { levels } = bidi.getEmbeddingLevels(string, direction);
    let lastLevel = null;
    let lastIndex = 0;
    let index2 = 0;
    const runs = [];
    for (let i2 = 0; i2 < levels.length; i2 += 1) {
      const level = levels[i2];
      if (level !== lastLevel) {
        if (lastLevel !== null) {
          runs.push({
            start: lastIndex,
            end: index2,
            attributes: { bidiLevel: lastLevel }
          });
        }
        lastIndex = index2;
        lastLevel = level;
      }
      index2 += 1;
    }
    if (lastIndex < string.length) {
      runs.push({
        start: lastIndex,
        end: string.length,
        attributes: { bidiLevel: lastLevel }
      });
    }
    const result = { string, runs };
    return result;
  };
};
const INFINITY = 1e4;
const getNextBreakpoint = (subnodes, widths, lineNumber) => {
  let position = null;
  let minimumBadness = Infinity;
  const sum = { width: 0, stretch: 0, shrink: 0 };
  const lineLength = widths[Math.min(lineNumber, widths.length - 1)];
  const calculateRatio = (node) => {
    const stretch = "stretch" in node ? node.stretch : null;
    if (sum.width < lineLength) {
      if (!stretch)
        return INFINITY;
      return sum.stretch - stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;
    }
    const shrink = "shrink" in node ? node.shrink : null;
    if (sum.width > lineLength) {
      if (!shrink)
        return INFINITY;
      return sum.shrink - shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;
    }
    return 0;
  };
  for (let i2 = 0; i2 < subnodes.length; i2 += 1) {
    const node = subnodes[i2];
    if (node.type === "box") {
      sum.width += node.width;
    }
    if (node.type === "glue") {
      sum.width += node.width;
      sum.stretch += node.stretch;
      sum.shrink += node.shrink;
    }
    if (sum.width - sum.shrink > lineLength) {
      if (position === null) {
        let j = i2 === 0 ? i2 + 1 : i2;
        while (j < subnodes.length && (subnodes[j].type === "glue" || subnodes[j].type === "penalty")) {
          j++;
        }
        position = j - 1;
      }
      break;
    }
    if (node.type === "penalty" || node.type === "glue") {
      const ratio = calculateRatio(node);
      const penalty = node.type === "penalty" ? node.penalty : 0;
      const badness = 100 * Math.abs(ratio) ** 3 + penalty;
      if (minimumBadness >= badness) {
        position = i2;
        minimumBadness = badness;
      }
    }
  }
  return sum.width - sum.shrink > lineLength ? position : null;
};
const applyBestFit = (nodes, widths) => {
  let count = 0;
  let lineNumber = 0;
  let subnodes = nodes;
  const breakpoints = [0];
  while (subnodes.length > 0) {
    const breakpoint2 = getNextBreakpoint(subnodes, widths, lineNumber);
    if (breakpoint2 !== null) {
      count += breakpoint2;
      breakpoints.push(count);
      subnodes = subnodes.slice(breakpoint2 + 1, subnodes.length);
      count++;
      lineNumber++;
    } else {
      subnodes = [];
    }
  }
  return breakpoints;
};
class LinkedListNode {
  constructor(data2) {
    __publicField(this, "data");
    __publicField(this, "prev");
    __publicField(this, "next");
    this.data = data2;
    this.prev = null;
    this.next = null;
  }
}
class LinkedList {
  constructor() {
    __publicField(this, "head");
    __publicField(this, "tail");
    __publicField(this, "listSize");
    __publicField(this, "listLength");
    this.head = null;
    this.tail = null;
    this.listSize = 0;
    this.listLength = 0;
  }
  isLinked(node) {
    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());
  }
  size() {
    return this.listSize;
  }
  isEmpty() {
    return this.listSize === 0;
  }
  first() {
    return this.head;
  }
  last() {
    return this.last;
  }
  forEach(callback) {
    let node = this.head;
    while (node !== null) {
      callback(node);
      node = node.next;
    }
  }
  at(i2) {
    let node = this.head;
    let index2 = 0;
    if (i2 >= this.listLength || i2 < 0) {
      return null;
    }
    while (node !== null) {
      if (i2 === index2) {
        return node;
      }
      node = node.next;
      index2 += 1;
    }
    return null;
  }
  insertAfter(node, newNode) {
    if (!this.isLinked(node))
      return this;
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next === null) {
      this.tail = newNode;
    } else {
      node.next.prev = newNode;
    }
    node.next = newNode;
    this.listSize += 1;
    return this;
  }
  insertBefore(node, newNode) {
    if (!this.isLinked(node))
      return this;
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev === null) {
      this.head = newNode;
    } else {
      node.prev.next = newNode;
    }
    node.prev = newNode;
    this.listSize += 1;
    return this;
  }
  push(node) {
    if (this.head === null) {
      this.unshift(node);
    } else {
      this.insertAfter(this.tail, node);
    }
    return this;
  }
  unshift(node) {
    if (this.head === null) {
      this.head = node;
      this.tail = node;
      node.prev = null;
      node.next = null;
      this.listSize += 1;
    } else {
      this.insertBefore(this.head, node);
    }
    return this;
  }
  remove(node) {
    if (!this.isLinked(node))
      return this;
    if (node.prev === null) {
      this.head = node.next;
    } else {
      node.prev.next = node.next;
    }
    if (node.next === null) {
      this.tail = node.prev;
    } else {
      node.next.prev = node.prev;
    }
    this.listSize -= 1;
    return this;
  }
}
__publicField(LinkedList, "Node", LinkedListNode);
function breakpoint(position, demerits, line2, fitnessClass, totals, previous) {
  return {
    position,
    demerits,
    line: line2,
    fitnessClass,
    totals: totals || {
      width: 0,
      stretch: 0,
      shrink: 0
    },
    previous
  };
}
function computeCost(nodes, lineLengths, sum, end2, active, currentLine) {
  let width = sum.width - active.totals.width;
  let stretch = 0;
  let shrink = 0;
  const lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];
  if (nodes[end2].type === "penalty") {
    width += nodes[end2].width;
  }
  if (width < lineLength) {
    stretch = sum.stretch - active.totals.stretch;
    if (stretch > 0) {
      return (lineLength - width) / stretch;
    }
    return linebreak.infinity;
  }
  if (width > lineLength) {
    shrink = sum.shrink - active.totals.shrink;
    if (shrink > 0) {
      return (lineLength - width) / shrink;
    }
    return linebreak.infinity;
  }
  return 0;
}
function computeSum(nodes, sum, breakPointIndex) {
  const result = {
    width: sum.width,
    stretch: sum.stretch,
    shrink: sum.shrink
  };
  for (let i2 = breakPointIndex; i2 < nodes.length; i2 += 1) {
    const node = nodes[i2];
    if (node.type === "glue") {
      result.width += node.width;
      result.stretch += node.stretch;
      result.shrink += node.shrink;
    } else if (node.type === "box" || node.type === "penalty" && node.penalty === -linebreak.infinity && i2 > breakPointIndex) {
      break;
    }
  }
  return result;
}
function findBestBreakpoints(activeNodes) {
  const breakpoints = [];
  if (activeNodes.size() === 0)
    return [];
  let tmp = { data: { demerits: Infinity } };
  activeNodes.forEach((node) => {
    if (node.data.demerits < tmp.data.demerits) {
      tmp = node;
    }
  });
  while (tmp !== null) {
    breakpoints.push(tmp.data.position);
    tmp = tmp.data.previous;
  }
  return breakpoints.reverse();
}
/**
 * @param nodes
 * @param availableWidths
 * @param tolerance
 * @preserve Knuth and Plass line breaking algorithm in JavaScript
 */
const linebreak = (nodes, availableWidths, tolerance) => {
  const options = {
    demerits: { line: 10, flagged: 100, fitness: 3e3 },
    tolerance: tolerance || 3
  };
  const activeNodes = new LinkedList();
  const sum = { width: 0, stretch: 0, shrink: 0 };
  const lineLengths = availableWidths;
  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, void 0, null)));
  function mainLoop(node, index2, nodes2) {
    let active = activeNodes.first();
    while (active !== null) {
      let currentLine = 0;
      const candidates = [
        { active: void 0, demerits: Infinity },
        { active: void 0, demerits: Infinity },
        { active: void 0, demerits: Infinity },
        { active: void 0, demerits: Infinity }
      ];
      while (active !== null) {
        currentLine = active.data.line + 1;
        const ratio = computeCost(nodes2, lineLengths, sum, index2, active.data, currentLine);
        if (ratio < -1 || node.type === "penalty" && node.penalty === -linebreak.infinity) {
          activeNodes.remove(active);
        }
        if (ratio >= -1 && ratio <= options.tolerance) {
          const badness = 100 * Math.pow(Math.abs(ratio), 3);
          let demerits = 0;
          if (node.type === "penalty" && node.penalty >= 0) {
            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2);
          } else if (node.type === "penalty" && node.penalty !== -linebreak.infinity) {
            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2);
          } else {
            demerits = Math.pow(options.demerits.line + badness, 2);
          }
          if (node.type === "penalty" && nodes2[active.data.position].type === "penalty") {
            demerits += options.demerits.flagged * node.flagged * // @ts-expect-error node is penalty here
            nodes2[active.data.position].flagged;
          }
          let currentClass;
          if (ratio < -0.5) {
            currentClass = 0;
          } else if (ratio <= 0.5) {
            currentClass = 1;
          } else if (ratio <= 1) {
            currentClass = 2;
          } else {
            currentClass = 3;
          }
          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {
            demerits += options.demerits.fitness;
          }
          demerits += active.data.demerits;
          if (demerits < candidates[currentClass].demerits) {
            candidates[currentClass] = { active, demerits };
          }
        }
        active = active.next;
        if (active !== null && active.data.line >= currentLine) {
          break;
        }
      }
      const tmpSum = computeSum(nodes2, sum, index2);
      for (let fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {
        const candidate = candidates[fitnessClass];
        if (candidate.demerits === Infinity)
          continue;
        const newNode = new LinkedList.Node(breakpoint(index2, candidate.demerits, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));
        if (active !== null) {
          activeNodes.insertBefore(active, newNode);
        } else {
          activeNodes.push(newNode);
        }
      }
    }
  }
  nodes.forEach((node, index2, nodes2) => {
    if (node.type === "box") {
      sum.width += node.width;
      return;
    }
    if (node.type === "glue") {
      const precedesBox = index2 > 0 && nodes2[index2 - 1].type === "box";
      if (precedesBox)
        mainLoop(node, index2, nodes2);
      sum.width += node.width;
      sum.stretch += node.stretch;
      sum.shrink += node.shrink;
      return;
    }
    if (node.type === "penalty" && node.penalty !== linebreak.infinity) {
      mainLoop(node, index2, nodes2);
    }
  });
  return findBestBreakpoints(activeNodes);
};
linebreak.infinity = 1e4;
linebreak.glue = (width, start2, end2, stretch, shrink) => ({
  type: "glue",
  start: start2,
  end: end2,
  width,
  stretch,
  shrink
});
linebreak.box = (width, start2, end2, hyphenated = false) => ({
  type: "box",
  width,
  start: start2,
  end: end2,
  hyphenated
});
linebreak.penalty = (width, penalty, flagged) => ({
  type: "penalty",
  width,
  penalty,
  flagged
});
const add = (index2, run) => {
  const start2 = run.start + index2;
  const end2 = run.end + index2;
  return Object.assign({}, run, { start: start2, end: end2 });
};
const length = (run) => {
  return run.end - run.start;
};
const concat3 = (runA, runB) => {
  const end2 = runA.end + length(runB);
  const glyphs = (runA.glyphs || []).concat(runB.glyphs || []);
  const positions = (runA.positions || []).concat(runB.positions || []);
  const attributes2 = Object.assign({}, runA.attributes, runB.attributes);
  const runAIndices = runA.glyphIndices || [];
  const runALastIndex = last(runAIndices) || 0;
  const runBIndices = (runB.glyphIndices || []).map((i2) => i2 + runALastIndex + 1);
  const glyphIndices = normalize(runAIndices.concat(runBIndices));
  return Object.assign({}, runA, {
    end: end2,
    glyphs,
    positions,
    attributes: attributes2,
    glyphIndices
  });
};
const insertGlyph$1 = (index2, glyph, run) => {
  if (!glyph)
    return run;
  const leadingRun = slice$1(0, index2, run);
  const trailingRun = slice$1(index2, Infinity, run);
  return concat3(append$1(glyph, leadingRun), trailingRun);
};
const insert = (index2, value2, run) => {
  const font = getFont(run);
  const glyph = isNumber$1(value2) ? fromCodePoint(value2, font) : value2;
  return insertGlyph$1(index2, glyph, run);
};
const runIndexAt = (index2, attributedString) => {
  return runIndexAt$1(index2, attributedString.runs);
};
const insertGlyph = (index2, glyph, attributedString) => {
  const runIndex = runIndexAt(index2, attributedString);
  if (runIndex === -1)
    return append(glyph, attributedString);
  const codePoints = [glyph];
  const string = attributedString.string.slice(0, index2) + stringFromCodePoints(codePoints) + attributedString.string.slice(index2);
  const runs = attributedString.runs.map((run, i2) => {
    if (i2 === runIndex)
      return insert(index2 - run.start, glyph, run);
    if (i2 > runIndex)
      return add(codePoints.length, run);
    return run;
  });
  return Object.assign({}, attributedString, { string, runs });
};
const advanceWidthBetween$1 = (start2, end2, run) => {
  const runStart = run.start || 0;
  const glyphStartIndex = Math.max(0, glyphIndexAt(start2 - runStart, run));
  const glyphEndIndex = Math.max(0, glyphIndexAt(end2 - runStart, run));
  const positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);
  return advanceWidth$2(positions);
};
const advanceWidthBetween = (start2, end2, attributedString) => {
  const runs = filter(start2, end2, attributedString.runs);
  return runs.reduce((acc, run) => acc + advanceWidthBetween$1(start2, end2, run), 0);
};
const HYPHEN = 45;
const TOLERANCE_STEPS = 5;
const TOLERANCE_LIMIT = 50;
const opts = {
  width: 3,
  stretch: 6,
  shrink: 9
};
const breakLines = (attributedString, nodes, breaks) => {
  let start2 = 0;
  let end2 = null;
  const lines = breaks.reduce((acc, breakPoint) => {
    const node = nodes[breakPoint];
    const prevNode = nodes[breakPoint - 1];
    if (breakPoint === nodes.length - 1)
      return acc;
    let line2;
    if (node.type === "penalty") {
      end2 = prevNode.end;
      line2 = slice3(start2, end2, attributedString);
      line2 = insertGlyph(line2.string.length, HYPHEN, line2);
    } else {
      end2 = node.end;
      line2 = slice3(start2, end2, attributedString);
    }
    start2 = end2;
    return [...acc, line2];
  }, []);
  lines.push(slice3(start2, attributedString.string.length, attributedString));
  return lines;
};
const getNodes = (attributedString, { align }, options) => {
  let start2 = 0;
  const hyphenWidth = 5;
  const { syllables } = attributedString;
  const hyphenPenalty = options.hyphenationPenalty || (align === "justify" ? 100 : 600);
  const result = syllables.reduce((acc, s2, index2) => {
    const width = advanceWidthBetween(start2, start2 + s2.length, attributedString);
    if (s2.trim() === "") {
      const stretch = width * opts.width / opts.stretch;
      const shrink = width * opts.width / opts.shrink;
      const end2 = start2 + s2.length;
      acc.push(linebreak.glue(width, start2, end2, stretch, shrink));
    } else {
      const hyphenated = syllables[index2 + 1] !== " ";
      const end2 = start2 + s2.length;
      acc.push(linebreak.box(width, start2, end2, hyphenated));
      if (syllables[index2 + 1] && hyphenated) {
        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));
      }
    }
    start2 += s2.length;
    return acc;
  }, []);
  result.push(linebreak.glue(0, start2, start2, linebreak.infinity, 0));
  result.push(linebreak.penalty(0, -linebreak.infinity, 1));
  return result;
};
const getAttributes = (attributedString) => {
  var _a, _b;
  return ((_b = (_a = attributedString.runs) == null ? void 0 : _a[0]) == null ? void 0 : _b.attributes) || {};
};
const linebreaker = (options) => {
  return (attributedString, availableWidths) => {
    let tolerance = options.tolerance || 4;
    const attributes2 = getAttributes(attributedString);
    const nodes = getNodes(attributedString, attributes2, options);
    let breaks = linebreak(nodes, availableWidths, tolerance);
    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {
      tolerance += TOLERANCE_STEPS;
      breaks = linebreak(nodes, availableWidths, tolerance);
    }
    if (breaks.length === 0 || breaks.length === 1 && breaks[0] === 0) {
      breaks = applyBestFit(nodes, availableWidths);
    }
    return breakLines(attributedString, nodes, breaks.slice(1));
  };
};
var Direction$1;
(function(Direction2) {
  Direction2[Direction2["GROW"] = 0] = "GROW";
  Direction2[Direction2["SHRINK"] = 1] = "SHRINK";
})(Direction$1 || (Direction$1 = {}));
const WHITESPACE_PRIORITY = 1;
const LETTER_PRIORITY = 2;
const EXPAND_WHITESPACE_FACTOR = {
  before: 0.5,
  after: 0.5,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};
const EXPAND_CHAR_FACTOR = {
  before: 0.14453125,
  // 37/256
  after: 0.14453125,
  priority: LETTER_PRIORITY,
  unconstrained: false
};
const SHRINK_WHITESPACE_FACTOR = {
  before: -0.04296875,
  // -11/256
  after: -0.04296875,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};
const SHRINK_CHAR_FACTOR = {
  before: -0.04296875,
  after: -0.04296875,
  priority: LETTER_PRIORITY,
  unconstrained: false
};
const getCharFactor = (direction, options) => {
  const expandCharFactor = options.expandCharFactor || {};
  const shrinkCharFactor = options.shrinkCharFactor || {};
  return direction === Direction$1.GROW ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);
};
const getWhitespaceFactor = (direction, options) => {
  const expandWhitespaceFactor = options.expandWhitespaceFactor || {};
  const shrinkWhitespaceFactor2 = options.shrinkWhitespaceFactor || {};
  return direction === Direction$1.GROW ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor2);
};
const factor = (direction, options) => (glyphs) => {
  const charFactor = getCharFactor(direction, options);
  const whitespaceFactor = getWhitespaceFactor(direction, options);
  const factors = [];
  for (let index2 = 0; index2 < glyphs.length; index2 += 1) {
    let f2;
    const glyph = glyphs[index2];
    if (isWhiteSpace(glyph)) {
      f2 = Object.assign({}, whitespaceFactor);
      if (index2 === glyphs.length - 1) {
        f2.before = 0;
        if (index2 > 0) {
          factors[index2 - 1].after = 0;
        }
      }
    } else if (glyph.isMark && index2 > 0) {
      f2 = Object.assign({}, factors[index2 - 1]);
      f2.before = 0;
      factors[index2 - 1].after = 0;
    } else {
      f2 = Object.assign({}, charFactor);
    }
    factors.push(f2);
  }
  return factors;
};
const getFactors = (gap, line2, options) => {
  const direction = gap > 0 ? Direction$1.GROW : Direction$1.SHRINK;
  const getFactor = factor(direction, options);
  const factors = line2.runs.reduce((acc, run) => {
    return acc.concat(getFactor(run.glyphs));
  }, []);
  factors[0].before = 0;
  factors[factors.length - 1].after = 0;
  return factors;
};
const KASHIDA_PRIORITY = 0;
const NULL_PRIORITY = 3;
const getDistances = (gap, factors) => {
  let total = 0;
  const priorities = [];
  const unconstrained = [];
  for (let priority2 = KASHIDA_PRIORITY; priority2 <= NULL_PRIORITY; priority2 += 1) {
    priorities[priority2] = unconstrained[priority2] = 0;
  }
  for (let j = 0; j < factors.length; j += 1) {
    const f2 = factors[j];
    const sum = f2.before + f2.after;
    total += sum;
    priorities[f2.priority] += sum;
    if (f2.unconstrained) {
      unconstrained[f2.priority] += sum;
    }
  }
  let highestPriority = -1;
  let highestPrioritySum = 0;
  let remainingGap = gap;
  let priority;
  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {
    const prioritySum = priorities[priority];
    if (prioritySum !== 0) {
      if (highestPriority === -1) {
        highestPriority = priority;
        highestPrioritySum = prioritySum;
      }
      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {
        priorities[priority] = remainingGap / prioritySum;
        unconstrained[priority] = 0;
        remainingGap = 0;
        break;
      }
      priorities[priority] = 1;
      remainingGap -= prioritySum;
      if (unconstrained[priority] !== 0) {
        unconstrained[priority] = remainingGap / unconstrained[priority];
        remainingGap = 0;
        break;
      }
    }
  }
  for (let p2 = priority + 1; p2 <= NULL_PRIORITY; p2 += 1) {
    priorities[p2] = 0;
    unconstrained[p2] = 0;
  }
  if (remainingGap > 0 && highestPriority > -1) {
    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;
  }
  const distances = [];
  for (let index2 = 0; index2 < factors.length; index2 += 1) {
    const f2 = factors[index2];
    const next = factors[index2 + 1];
    let dist = f2.after * priorities[f2.priority];
    if (next) {
      dist += next.before * priorities[next.priority];
    }
    if (f2.unconstrained) {
      dist += f2.after * unconstrained[f2.priority];
      if (next) {
        dist += next.before * unconstrained[next.priority];
      }
    }
    distances.push(dist);
  }
  return distances;
};
const justifyLine = (distances, line2) => {
  let index2 = 0;
  for (const run of line2.runs) {
    for (const position of run.positions) {
      position.xAdvance += distances[index2++];
    }
  }
  return line2;
};
const justification = (options) => {
  return (line2) => {
    const gap = line2.box.width - advanceWidth(line2);
    if (gap === 0)
      return line2;
    const factors = getFactors(gap, line2, options);
    const distances = getDistances(gap, factors);
    return justifyLine(distances, line2);
  };
};
const ascent = (attributedString) => {
  const reducer = (acc, run) => Math.max(acc, ascent$1(run));
  return attributedString.runs.reduce(reducer, 0);
};
const BASE_FONT_SIZE = 12;
const textDecoration = () => (line2) => {
  let x = line2.overflowLeft || 0;
  const overflowRight = line2.overflowRight || 0;
  const maxX = advanceWidth(line2) - overflowRight;
  line2.decorationLines = [];
  for (let i2 = 0; i2 < line2.runs.length; i2 += 1) {
    const run = line2.runs[i2];
    const width = Math.min(maxX - x, advanceWidth$1(run));
    const thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));
    if (run.attributes.underline) {
      const rect = {
        x,
        y: ascent(line2) + thickness * 2,
        width,
        height: thickness
      };
      const decorationLine = {
        rect,
        opacity: run.attributes.opacity,
        color: run.attributes.underlineColor || "black",
        style: run.attributes.underlineStyle || "solid"
      };
      line2.decorationLines.push(decorationLine);
    }
    if (run.attributes.strike) {
      const y2 = ascent(line2) - ascent$1(run) / 3;
      const rect = { x, y: y2, width, height: thickness };
      const decorationLine = {
        rect,
        opacity: run.attributes.opacity,
        color: run.attributes.strikeColor || "black",
        style: run.attributes.strikeStyle || "solid"
      };
      line2.decorationLines.push(decorationLine);
    }
    x += width;
  }
  return line2;
};
const ignoredScripts = ["Common", "Inherited", "Unknown"];
const scriptItemizer = () => {
  return (attributedString) => {
    const { string } = attributedString;
    let lastScript = "Unknown";
    let lastIndex = 0;
    let index2 = 0;
    const runs = [];
    if (!string)
      return empty();
    for (let i2 = 0; i2 < string.length; i2 += 1) {
      const char = string[i2];
      const codePoint = char.codePointAt(0);
      const script = $747425b437e121da$export$2e2bcd8739ae039.getScript(codePoint);
      if (script !== lastScript && !ignoredScripts.includes(script)) {
        if (lastScript !== "Unknown") {
          runs.push({
            start: lastIndex,
            end: index2,
            attributes: { script: lastScript }
          });
        }
        lastIndex = index2;
        lastScript = script;
      }
      index2 += char.length;
    }
    if (lastIndex < string.length) {
      runs.push({
        start: lastIndex,
        end: string.length,
        attributes: { script: lastScript }
      });
    }
    const result = { string, runs };
    return result;
  };
};
const SOFT_HYPHEN = "";
const hyphenator = hyphen(pattern);
const splitHyphen = (word) => {
  return word.split(SOFT_HYPHEN);
};
const cache = {};
const getParts = (word) => {
  const base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);
  return splitHyphen(base);
};
const wordHyphenation = () => {
  return (word) => {
    const cacheKey = `_${word}`;
    if (isNil(word))
      return [];
    if (cache[cacheKey])
      return cache[cacheKey];
    cache[cacheKey] = getParts(word);
    return cache[cacheKey];
  };
};
const IGNORED_CODE_POINTS = [173];
const getFontSize = (run) => run.attributes.fontSize || 12;
const pickFontFromFontStack = (codePoint, fontStack, lastFont) => {
  const fontStackWithFallback = [...fontStack, lastFont];
  for (let i2 = 0; i2 < fontStackWithFallback.length; i2 += 1) {
    const font = fontStackWithFallback[i2];
    if (!IGNORED_CODE_POINTS.includes(codePoint) && font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {
      return font;
    }
  }
  return fontStack.at(-1);
};
const fontSubstitution = () => ({ string, runs }) => {
  let lastFont = null;
  let lastFontSize = null;
  let lastIndex = 0;
  let index2 = 0;
  const res = [];
  for (let i2 = 0; i2 < runs.length; i2 += 1) {
    const run = runs[i2];
    if (string.length === 0) {
      res.push({
        start: 0,
        end: 0,
        attributes: { font: run.attributes.font }
      });
      break;
    }
    const chars = string.slice(run.start, run.end);
    for (let j = 0; j < chars.length; j += 1) {
      const char = chars[j];
      const codePoint = char.codePointAt(0);
      const font = pickFontFromFontStack(codePoint, run.attributes.font, lastFont);
      const fontSize = getFontSize(run);
      if (font !== lastFont || fontSize !== lastFontSize || font.unitsPerEm !== lastFont.unitsPerEm) {
        if (lastFont) {
          res.push({
            start: lastIndex,
            end: index2,
            attributes: {
              font: [lastFont],
              scale: lastFontSize / lastFont.unitsPerEm
            }
          });
        }
        lastFont = font;
        lastFontSize = fontSize;
        lastIndex = index2;
      }
      index2 += char.length;
    }
  }
  if (lastIndex < string.length) {
    const fontSize = getFontSize(last(runs));
    res.push({
      start: lastIndex,
      end: string.length,
      attributes: {
        font: [lastFont],
        scale: fontSize / lastFont.unitsPerEm
      }
    });
  }
  return { string, runs: res };
};
var loadYoga$2 = (() => {
  var _scriptDir = import.meta.url;
  return function(loadYoga2) {
    loadYoga2 = loadYoga2 || {};
    var h;
    h || (h = typeof loadYoga2 !== "undefined" ? loadYoga2 : {});
    var aa, ca;
    h.ready = new Promise(function(a2, b2) {
      aa = a2;
      ca = b2;
    });
    var da = Object.assign({}, h), q = "";
    "undefined" != typeof document && document.currentScript && (q = document.currentScript.src);
    _scriptDir && (q = _scriptDir);
    0 !== q.indexOf("blob:") ? q = q.substr(0, q.replace(/[?#].*/, "").lastIndexOf("/") + 1) : q = "";
    var ea = h.print || console.log.bind(console), v2 = h.printErr || console.warn.bind(console);
    Object.assign(h, da);
    da = null;
    var w;
    h.wasmBinary && (w = h.wasmBinary);
    h.noExitRuntime || true;
    "object" != typeof WebAssembly && x("no native wasm support detected");
    var fa, ha = false;
    function z(a2, b2, c2) {
      c2 = b2 + c2;
      for (var d2 = ""; !(b2 >= c2); ) {
        var e2 = a2[b2++];
        if (!e2) break;
        if (e2 & 128) {
          var f2 = a2[b2++] & 63;
          if (192 == (e2 & 224)) d2 += String.fromCharCode((e2 & 31) << 6 | f2);
          else {
            var g = a2[b2++] & 63;
            e2 = 224 == (e2 & 240) ? (e2 & 15) << 12 | f2 << 6 | g : (e2 & 7) << 18 | f2 << 12 | g << 6 | a2[b2++] & 63;
            65536 > e2 ? d2 += String.fromCharCode(e2) : (e2 -= 65536, d2 += String.fromCharCode(55296 | e2 >> 10, 56320 | e2 & 1023));
          }
        } else d2 += String.fromCharCode(e2);
      }
      return d2;
    }
    var ia, ja, A, C, ka, D, E, la, ma;
    function na() {
      var a2 = fa.buffer;
      ia = a2;
      h.HEAP8 = ja = new Int8Array(a2);
      h.HEAP16 = C = new Int16Array(a2);
      h.HEAP32 = D = new Int32Array(a2);
      h.HEAPU8 = A = new Uint8Array(a2);
      h.HEAPU16 = ka = new Uint16Array(a2);
      h.HEAPU32 = E = new Uint32Array(a2);
      h.HEAPF32 = la = new Float32Array(a2);
      h.HEAPF64 = ma = new Float64Array(a2);
    }
    var oa, pa = [], qa = [], ra = [];
    function sa() {
      var a2 = h.preRun.shift();
      pa.unshift(a2);
    }
    var F = 0, G2 = null;
    function x(a2) {
      if (h.onAbort) h.onAbort(a2);
      a2 = "Aborted(" + a2 + ")";
      v2(a2);
      ha = true;
      a2 = new WebAssembly.RuntimeError(a2 + ". Build with -sASSERTIONS for more info.");
      ca(a2);
      throw a2;
    }
    function ua(a2) {
      return a2.startsWith("data:application/octet-stream;base64,");
    }
    var H;
    H = "data:application/octet-stream;base64,AGFzbQEAAAABugM3YAF/AGACf38AYAF/AX9gA39/fwBgAn98AGACf38Bf2ADf39/AX9gBH9/f30BfWADf398AGAAAGAEf39/fwBgAX8BfGACf38BfGAFf39/f38Bf2AAAX9gA39/fwF9YAZ/f31/fX8AYAV/f39/fwBgAn9/AX1gBX9/f319AX1gAX8BfWADf35/AX5gB39/f39/f38AYAZ/f39/f38AYAR/f39/AX9gBn9/f319fQF9YAR/f31/AGADf399AX1gBn98f39/fwF/YAR/fHx/AGACf30AYAh/f39/f39/fwBgDX9/f39/f39/f39/f38AYAp/f39/f39/f39/AGAFf39/f38BfGAEfHx/fwF9YA1/fX1/f399fX9/f39/AX9gB39/f319f38AYAJ+fwF/YAN/fX0BfWABfAF8YAN/fHwAYAR/f319AGAHf39/fX19fQF9YA1/fX99f31/fX19fX1/AX9gC39/f39/f399fX19AX9gCH9/f39/f319AGAEf39+fgBgB39/f39/f38Bf2ACfH8BfGAFf398fH8AYAN/f38BfGAEf39/fABgA39/fQBgBn9/fX99fwF/ArUBHgFhAWEAHwFhAWIAAwFhAWMACQFhAWQAFgFhAWUAEQFhAWYAIAFhAWcAAAFhAWgAIQFhAWkAAwFhAWoAAAFhAWsAFwFhAWwACgFhAW0ABQFhAW4AAwFhAW8AAQFhAXAAFwFhAXEABgFhAXIAAAFhAXMAIgFhAXQACgFhAXUADQFhAXYAFgFhAXcAAgFhAXgAAwFhAXkAGAFhAXoAAgFhAUEAAQFhAUIAEQFhAUMAAQFhAUQAAAOiAqACAgMSBwcACRkDAAoRBgYKEwAPDxMBBiMTCgcHGgMUASQFJRQHAwMKCgMmAQYYDxobFAAKBw8KBwMDAgkCAAAFGwACBwIHBgIDAQMIDAABKAkHBQURACkZASoAAAIrLAIALQcHBy4HLwkFCgMCMA0xAgMJAgACAQYKAQIBBQEACQIFAQEABQAODQ0GFQIBHBUGAgkCEAAAAAUyDzMMBQYINAUCAwUODg41AgMCAgIDBgICNgIBDAwMAQsLCwsLCx0CAAIAAAABABABBQICAQMCEgMMCwEBAQEBAQsLAQICAwICAgICAgIDAgIICAEICAgEBAQEBAQEBAQABAQABAQEBAAE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GiABQQA2AvADIAFCADcC6AMgAigC7AMiAyACKALoAyIERwRAIAMgBGsiBEEASA0FIAEgBBAeIgM2AuwDIAEgAzYC6AMgASADIARqNgLwAyACKALoAyIEIAIoAuwDIghHBEADQCADIAQoAgA2AgAgA0EEaiEDIARBBGoiBCAIRw0ACwsgASADNgLsAwsgASACKQL0AzcC9AMgASACKAKEBDYChAQgASACKQL8AzcC/AMgAUEANgLkAwsgBSABNgIAIAEgADYC5AMLIAZBAWohBiAFQQRqIgUgB0cNAAsLDwsQAgALUAACQAJAAkACQAJAIAIOBAQAAQIDCyAAIAEgAUEwahBDDwsgACABIAFBMGogAxBEDwsgACABIAFBMGoQQg8LECQACyAAIAEgAUEwaiADEEULcAIBfwF9IwBBEGsiBCQAIARBCGogACABQQJ0QdwlaigCACACEDZDAADAfyEFAkACQAJAIAQtAAxBAWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwt5AgF/AX0jAEEQayIDJAAgA0EIaiAAIAFBAnRB7CVqKAIAIAIQU0MAAMB/IQQCQAJAAkAgAy0ADEEBaw4CAAECCyADKgIIIQQMAQsgAyoCCEMAAAAAlEMK1yM8lCEECyADQRBqJAAgBEMAAAAAl0MAAAAAIAQgBFsbC1QAAkACQAJAAkACQCACDgQEAAECAwsgACABIAFBwgBqEEMPCyAAIAEgAUHCAGogAxBEDwsgACABIAFBwgBqEEIPCxAkAAsgACABIAFBwgBqIAMQRQsvACAAIAJFQQF0IgIgASADEGAgACACIAEQS5IgACACIAEgAxB/IAAgAiABEFKSkgvOAQIDfwJ9IwBBEGsiAyQAQQEhBCADQQhqIABB/ABqIgUgACABQQF0akH2AGoiAS8BABAfAkACQCADKgIIIgcgAioCACIGXARAIAcgB1sEQCACLQAEIQIMAgsgBiAGXCEECyACLQAEIQIgBEUNACADLQAMIAJB/wFxRg0BCyAFIAEgBiACEDkDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALkAyIADQALCyADQRBqJAALzgECA38CfSMAQRBrIgMk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AWsOAgABAgsgBCoCCCEFDAELIAQqAgggA5RDCtcjPJQhBQsgBEEQaiQAIAVDAAAAACAFIAVbGwscACAAIAFBCCACpyACQiCIpyADpyADQiCIpxAVCwUAEFgACzkAIABFBEBBAA8LAn8gAUGAf3FBgL8DRiABQf8ATXJFBEBB/DtBGTYCAEF/DAELIAAgAToAAEEBCwvEAgACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQQlrDhIACgsMCgsCAwQFDAsMDAoLBwgJCyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCwALIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LAAsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAQALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC84BAgN/An0jAEEQayIDJABBASEEIANBCGogAEH8AGoiBSAAIAFBAXRqQegAaiIBLwEAEB8CQAJAIAMqAggiByACKgIAIgZcBEAgByAHWwRAIAItAAQhAgwCCyAGIAZcIQQLIAItAAQhAiAERQ0AIAMtAAwgAkH/AXFGDQELIAUgASAGIAIQOQNAIAAtAAAiAUEEcQ0BIAAgAUEEcjoAACAAKAIQIgEEQCAAIAERAAALIABBgICA/gc2ApwBIAAoAuQDIgANAAsLIANBEGokAAtdAQR/IAAoAgAhAgNAIAIsAAAiAxBXBEBBfyEEIAAgAkEBaiICNgIAIAFBzJmz5gBNBH9BfyADQTBrIgMgAUEKbCIEaiADIARB/////wdzShsFIAQLIQEMAQsLIAELrhQCEn8BfiMAQdAAayIIJAAgCCABNgJMIAhBN2ohFyAIQThqIRQCQAJAAkACQANAIAEhDSAHIA5B/////wdzSg0BIAcgDmohDgJAAkACQCANIgctAAAiCQRAA0ACQAJAIAlB/wFxIgFFBEAgByEBDAELIAFBJUcNASAH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IQEgAEIANwIEIAAgATYCACABIAA2AgQgAkEQaiQAIAALGwEBfyAABEAgACgCACIBBEAgARAjCyAAECMLC0kBAn9BBBAeIQFBIBAeIgBBADYCHCAAQoCAgICAgIDAPzcCFCAAQgA3AgwgAEEAOgAIIABBAzYCBCAAQQA2AgAgASAANgIAIAELIAAgAkEFR0EAIAIbRQRAQbgwIAMgBBBJDwsgAyAEEHALIgEBfiABIAKtIAOtQiCGhCAEIAARFQAiBUIgiKckASAFpwuoAQEFfyAAKAJUIgMoAgAhBSADKAIEIgQgACgCFCAAKAIcIgdrIgYgBCAGSRsiBgRAIAUgByAGECsaIAMgAygCACAGaiIFNgIAIAMgAygCBCAGayIENgIECyAEIAIgAiAESxsiBARAIAUgASAEECsaIAMgAygCACAEaiIFNgIAIAMgAygCBCAEazYCBAsgBUEAOgAAIAAgACgCLCIBNgIcIAAgATYCFCACCwQAQgALBABBAAuKBQIGfgJ/IAEgASgCAEEHakF4cSIBQRBqNgIAIAAhCSABKQMAIQMgASkDCCEGIwBBIGsiCCQAAkAgBkL///////////8AgyIEQoCAgICAgMCAPH0gBEKAgICAgIDA/8MAfVQEQCAGQgSGIANCPIiEIQQgA0L//////////w+DIgNCgYCAgICAgIAIWgRAIARCgYCAgICAgIDAAHwhAgwCCyAEQoCAgICAgICAQH0hAiADQoCAgICAgICACFINASACIARCAYN8IQIMAQsgA1AgBEKAgICAgIDA//8AVCAEQoCAgICAgMD//wBRG0UEQCAGQgSGIANCPIiEQv////////8Dg0KAgICAgICA/P8AhCECDAELQoCAgICAgID4/wAhAiAEQv///////7//wwBWDQBCACECIARCMIinIgBBkfcASQ0AIAMhAiAGQv///////z+DQoCAgICAgMAAhCIFIQcCQCAAQYH3AGsiAUHAAHEEQCACIAFBQGqthiEHQgAhAgwBCyABRQ0AIAcgAa0iBIYgAkHAACABa62IhCEHIAIgBIYhAgsgCCACNwMQIAggBzcDGAJAQYH4ACAAayIAQcAAcQRAIAUgAEFAaq2IIQNCACEFDAELIABFDQAgBUHAACAAa62GIAMgAK0iAoiEIQMgBSACiCEFCyAIIAM3AwAgCCAF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ASAAKAIAIQAgASACQQFxBH8gASgCACAAaigCAAUgAAsRCwALYQECfyMAQRBrIgIkACABIAAoAgQiA0EBdWohASAAKAIAIQAgAiABIANBAXEEfyABKAIAIABqKAIABSAACxEBAEEQEB4iACACKQMINwMIIAAgAikDADcDACACQRBqJAAgAAtjAQJ/IwBBEGsiAyQAIAEgACgCBCIEQQF1aiEBIAAoAgAhACADIAEgAiAEQQFxBH8gASgCACAAaigCAAUgAAsRAwBBEBAeIgAgAykDCDcDCCAAIAMpAwA3AwAgA0EQaiQAIAALNwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQAgASACIANBAXEEfyABKAIAIABqKAIABSAACxEEAAs5AQF/IAEgACgCBCIEQQF1aiEBIAAoAgAhACABIAIgAyAEQQFxBH8gASgCACAAaigCAAUgAAsRCAALCQAgASAAEQIACwUAQcM7Cw8AIAEgACgCAGogAjYCAAsNACABIAAoAgBqKAIACxgBAX9BEBAeIgBCADcDCCAAQQA2AgAgAAsYAQF/QRAQHiIAQgA3AwAgAEIANwMIIAALDABBMBAeQQBBMBAqCzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRHgALBQBBvjsLIQAgACABKAIAIAEgASwAC0EASBtBuzsgAigCABAQNgIACyoBAX9BDBAeIgFBADoABCABIAAoAgA2AgggAEEANgIAIAFB2Cc2AgAgAQsFAEG7OwsFAEG4OwshACAAIAEoAgAgASABLAALQQBIG0GkOyACKAIAEBA2AgAL2AEBBH8jAEEgayIDJAAgASgCACIEQfD///8HSQRAAkACQCAEQQtPBEAgBEEPckEBaiIFEB4hBiADIAVBgICAgHhyNgIQIAMgBjYCCCADIAQ2AgwgBCAGaiEFDAELIAMgBDoAEyADQQhqIgYgBGohBSAERQ0BCyAGIAFBBGogBBArGgsgBUEAOgAAIAMgAjYCACADQRhqIANBCGogAyAAEQMAIAMoAhgQHSADKAIYIgAQBiADKAIAEAYgAywAE0EASARAIAMoAggQIwsgA0EgaiQAIAAPCxACAAsqAQF/QQwQHiIBQQA6AAQgASAAKAIANgIIIABBADYCACABQeAmNgIA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AkEIaiAIIAYQHyACIAcgAC8AABAfQQEhAyACKgIIIgogAioCACILXAR/IAogClsNAyALIAtcBSADC0UNAiACLQAMIAItAARHDQILIABBAmohAEEBIQMgBCEGQQEhBCAGRQ0ACyABLwB6IgBBB3FFBEAgBS0AekEHcUUNAgsgCCAAECAiCiAHIAUvAHoQICILWw0BIAogClsNACALIAtcDQELIAFBFGogBUEUakHoABArGiABQfwAaiAFQfwAahCgAQNAIAEtAAAiAEEEcQ0BIAEgAEEEcjoAACABKAIQIgAEQCABIAARAAALIAFBgICA/gc2ApwBIAEoAuQDIgENAAsLIAJBEGokAAvGAwEEfyMAQaAEayICJAAgACgCBCEBIABBADYCBCABBEAgASABKAIAKAIEEQAACyAAKAIIIQEgAEEANgIIIAEEQCABIAEoAgAoAgQRAAALAkAgACgCACIAKALoAyAAKALsA0YEQCAAKALkAw0BIAAgAkEYaiAAKAL0AxBcIgEpAgA3AgAgACABKAIQNgIQIAAgASkCCDcCCCAAQRRqIAFBFGpB6AAQKxogACABKQKMATcCjAEgACABKQKEATcChAEgACABKQJ8NwJ8IAEoApQBIQQgAUEANgKUASAAKAKUASEDIAAgBDYClAEgAwRAIAMQWwsgAEGYAWogAUGYAWpB0AIQKxogACgC6AMiAwRAIAAgAzYC7AMgAxAjCyAAIAEoAugDNgLoAyAAIAEoAuwDNgLsAyAAIAEoAvADNgLwAyABQQA2AvADIAFCADcC6AMgACABKQL8AzcC/AMgACABKQL0AzcC9AMgACABKAKEBDYChAQgASgClAEhACABQQA2ApQBIAAEQCAAEFsLIAJBoARqJAAPCyACQfAcNgIQIABBBUHYJSACQRBqECwQJAALIAJB5hE2AgAgAEEFQdglIAIQLBAkAAsLAEEMEB4gABCiAQsLAEEMEB5BABCiAQsNACAAKAIALQAIQQFxCwoAIAAoAgAoAhQLGQAgAUH/AXEEQBACAAsgACgCACgCEEEBcQsYACAAKAIAIgAgAC0ACEH+AXEgAXI6AAgLJgAgASAAKAIAIgAoAhRHBEAgACABNgIUIAAgACgCDEEBajYCDAsLkgEBAn8jAEEQayICJAAgACgCACEAIAFDAAAAAGAEQCABIAAqAhhcBEAgACABOAIYIAAgACgCDEEBajYCDAsgAkEQaiQADwsgAkGIFDYCACMAQRBrIgMkACADIAI2AgwCQCAARQRAQbgwQdglIAIQSRoMAQsgAEEAQQVB2CUgAiAAKAIEEQ0AGgsgA0EQaiQAECQACz8AIAFB/wFxRQRAIAIgACgCACIAKAIQIgFBAXFHBEAgACABQX5xIAJyNgIQIAAgACgCDEEBajYCDAsPCxACAAsL4CYjAEGACAuBHk9ubHkgbGVhZiBub2RlcyB3aXRoIGN1c3RvbSBtZWFzdXJlIGZ1bmN0aW9ucyBzaG91bGQgbWFudWFsbHkgbWFyayB0aGVtc2VsdmVzIGFzIGRpcnR5AGlzRGlydHkAbWFya0RpcnR5AGRlc3Ryb3kAc2V0RGlzcGxheQBnZXREaXNwbGF5AHNldEZsZXgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABzZXRGbGV4R3JvdwBnZXRGbGV4R3JvdwBzZXRPdmVyZmxvdwBnZXRPdmVyZmxvdwBoYXNOZXdMYXlvdXQAY2FsY3VsYXRlTGF5b3V0AGdldENvbXB1dGVkTGF5b3V0AHVuc2lnbmVkIHNob3J0AGdldENoaWxkQ291bnQAdW5zaWduZWQgaW50AHNldEp1c3RpZnlDb250ZW50AGdldEp1c3RpZnlDb250ZW50AGF2YWlsYWJsZUhlaWdodCBpcyBpbmRlZmluaXRlIHNvIGhlaWdodFNpemluZ01vZGUgbXVzdCBiZSBTaXppbmdNb2RlOjpNYXhDb250ZW50AGF2YWlsYWJsZVdpZHRoIGlzIGluZGVmaW5pdGUgc28gd2lkdGhTaXppbmdNb2RlIG11c3QgYmUgU2l6aW5nTW9kZTo6TWF4Q29udGVudABzZXRBbGlnbkNvbnRlbnQAZ2V0QWxpZ25Db250ZW50AGdldFBhcmVudABpbXBsZW1lbnQAc2V0TWF4SGVpZ2h0UGVyY2VudABzZXRIZWlnaHRQZXJjZW50AHNldE1pbkhlaWdodFBlcmNlbnQAc2V0RmxleEJhc2lzUGVyY2VudABzZXRHYXBQZXJjZW50AHNldFBvc2l0aW9uUGVyY2VudABzZXRNYXJnaW5QZXJjZW50AHNldE1heFdpZHRoUGVyY2VudABzZXRXaWR0aFBlcmNlbnQAc2V0TWluV2lkdGhQZXJjZW50AHNldFBhZGRpbmdQZXJjZW50AGhhbmRsZS50eXBlKCkgPT0gU3R5bGVWYWx1ZUhhbmRsZTo6VHlwZTo6UG9pbnQgfHwgaGFuZGxlLnR5cGUoKSA9PSBTdHlsZVZhbHVlSGFuZGxlOjpUeXBlOjpQZXJjZW50AGNyZWF0ZURlZmF1bHQAdW5pdAByaWdodABoZWlnaHQAc2V0TWF4SGVpZ2h0AGdldE1heEhlaWdodABzZXRIZWlnaHQAZ2V0SGVpZ2h0AHNldE1pbkhlaWdodABnZXRNaW5IZWlnaHQAZ2V0Q29tcHV0ZWRIZWlnaHQAZ2V0Q29tcHV0ZWRSaWdodABsZWZ0AGdldENvbXB1dGVkTGVmdAByZXNldABfX2Rlc3RydWN0AGZsb2F0AHVpbnQ2NF90AHVzZVdlYkRlZmF1bHRzAHNldFVzZVdlYkRlZmF1bHRzAHNldEFsaWduSXRlbXMAZ2V0QWxpZ25JdGVtcwBzZXRGbGV4QmFzaXMAZ2V0RmxleEJhc2lzAENhbm5vdCBnZXQgbGF5b3V0IHByb3BlcnRpZXMgb2YgbXVsdGktZWRnZSBzaG9ydGhhbmRzAHNldFBvaW50U2NhbGVGYWN0b3IATWVhc3VyZUNhbGxiYWNrV3JhcHBlcgBEaXJ0aWVkQ2FsbGJhY2tXcmFwcGVyAENhbm5vdCByZXNldCBhIG5vZGUgc3RpbGwgYXR0YWNoZWQgdG8gYSBvd25lcgBzZXRCb3JkZXIAZ2V0Qm9yZGVyAGdldENvbXB1dGVkQm9yZGVyAGdldE51bWJlcgBoYW5kbGUudHlwZSgpID09IFN0eWxlVmFsdWVIYW5kbGU6OlR5cGU6Ok51bWJlcgB1bnNpZ25lZCBjaGFyAHRvcABnZXRDb21wdXRlZFRvcABzZXRGbGV4V3JhcABnZXRGbGV4V3JhcABzZXRHYXAAZ2V0R2FwACVwAHNldEhlaWdodEF1dG8Ac2V0RmxleEJhc2lzQXV0bwBzZXRQb3NpdGlvbkF1dG8Ac2V0TWFyZ2luQXV0bwBzZXRXaWR0aEF1dG8AU2NhbGUgZmFjdG9yIHNob3VsZCBub3QgYmUgbGVzcyB0aGFuIHplcm8Ac2V0QXNwZWN0UmF0aW8AZ2V0QXNwZWN0UmF0aW8Ac2V0UG9zaXRpb24AZ2V0UG9zaXRpb24Abm90aWZ5T25EZXN0cnVjdGlvbgBzZXRGbGV4RGlyZWN0aW9uAGdldEZsZXhEaXJlY3Rpb24Ac2V0RGlyZWN0aW9uAGdldERpcmVjdGlvbgBzZXRNYXJnaW4AZ2V0TWFyZ2luAGdldENvbXB1dGVkTWFyZ2luAG1hcmtMYXlvdXRTZWVuAG5hbgBib3R0b20AZ2V0Q29tcHV0ZWRCb3R0b20AYm9vbABlbXNjcmlwdGVuOjp2YWwAc2V0RmxleFNocmluawBnZXRGbGV4U2hyaW5rAHNldEFsd2F5c0Zvcm1zQ29udGFpbmluZ0Jsb2NrAE1lYXN1cmVDYWxsYmFjawBEaXJ0aWVkQ2FsbGJhY2sAZ2V0TGVuZ3RoAHdpZHRoAHNldE1heFdpZHRoAGdldE1heFdpZHRoAHNldFdpZHRoAGdldFdpZHRoAHNldE1pbldpZHRoAGdldE1pbldpZHRoAGdldENvbXB1dGVkV2lkdGgAcHVzaAAvaG9tZS9ydW5uZXIvd29yay95b2dhL3lvZ2EvamF2YXNjcmlwdC8uLi95b2dhL3N0eWxlL1NtYWxsVmFsdWVCdWZmZXIuaAAvaG9tZS9ydW5uZXIvd29yay95b2dhL3lvZ2EvamF2YXNjcmlwdC8uLi95b2dhL3N0eWxlL1N0eWxlVmFsdWVQb29sLmgAdW5zaWduZWQgbG9uZwBzZXRCb3hTaXppbmcAZ2V0Qm94U2l6aW5nAHN0ZDo6d3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBzZXRQYWRkaW5nAGdldFBhZGRpbmcAZ2V0Q29tcHV0ZWRQYWRkaW5nAFRyaWVkIHRvIGNvbnN0cnVjdCBZR05vZGUgd2l0aCBudWxsIGNvbmZpZwBBdHRlbXB0aW5nIHRvIGNvbnN0cnVjdCBOb2RlIHdpdGggbnVsbCBjb25maWcAY3JlYXRlV2l0aENvbmZpZwBpbmYAc2V0QWxpZ25TZWxmAGdldEFsaWduU2VsZgBTaXplAHZhbHVlAFZhbHVlAGNyZWF0ZQBtZWFzdXJlAHNldFBvc2l0aW9uVHlwZQBnZXRQb3NpdGlvblR5cGUAaXNSZWZlcmVuY2VCYXNlbGluZQBzZXRJc1JlZmVyZW5jZUJhc2VsaW5lAGNvcHlTdHlsZQBkb3VibGUATm9kZQBleHRlbmQAaW5zZXJ0Q2hpbGQAZ2V0Q2hpbGQAcmVtb3ZlQ2hpbGQAdm9pZABzZXRFeHBlcmltZW50YWxGZWF0dXJlRW5hYmxlZABpc0V4cGVyaW1lbnRhbEZlYXR1cmVFbmFibGVkAGRpcnRpZWQAQ2Fubm90IHJlc2V0IGEgbm9kZSB3aGljaCBzdGlsbCBoYXMgY2hpbGRyZW4gYXR0YWNoZWQAdW5zZXRNZWFzdXJlRnVuYwB1bnNldERpcnRpZWRGdW5jAHNldEVycmF0YQBnZXRFcnJhdGEATWVhc3VyZSBmdW5jdGlvbiByZXR1cm5lZCBhbiBpbnZhbGlkIGRpbWVuc2lvbiB0byBZb2dhOiBbd2lkdGg9JWYsIGhlaWdodD0lZl0ARXhwZWN0IGN1c3RvbSBiYXNlbGluZSBmdW5jdGlvbiB0byBub3QgcmV0dXJuIE5hTgBOQU4ASU5GAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVk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";
    if (!ua(H)) {
      var va = H;
      H = h.locateFile ? h.locateFile(va, q) : q + va;
    }
    function wa() {
      var a2 = H;
      try {
        if (a2 == H && w) return new Uint8Array(w);
        if (ua(a2)) try {
          var b2 = xa(a2.slice(37)), c2 = new Uint8Array(b2.length);
          for (a2 = 0; a2 < b2.length; ++a2) c2[a2] = b2.charCodeAt(a2);
          var d2 = c2;
        } catch (f2) {
          throw Error("Converting base64 string to bytes failed.");
        }
        else d2 = void 0;
        var e2 = d2;
        if (e2) return e2;
        throw "both async and sync fetching of the wasm failed";
      } catch (f2) {
        x(f2);
      }
    }
    function ya() {
      return w || "function" != typeof fetch ? Promise.resolve().then(function() {
        return wa();
      }) : fetch(H, { credentials: "same-origin" }).then(function(a2) {
        if (!a2.ok) throw "failed to load wasm binary file at '" + H + "'";
        return a2.arrayBuffer();
      }).catch(function() {
        return wa();
      });
    }
    function za(a2) {
      for (; 0 < a2.length; ) a2.shift()(h);
    }
    function Aa(a2) {
      if (void 0 === a2) return "_unknown";
      a2 = a2.replace(/[^a-zA-Z0-9_]/g, "$");
      var b2 = a2.charCodeAt(0);
      return 48 <= b2 && 57 >= b2 ? "_" + a2 : a2;
    }
    function Ba(a2, b2) {
      a2 = Aa(a2);
      return function() {
        return b2.apply(this, arguments);
      };
    }
    var J = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }], Ca = [];
    function Da(a2) {
      var b2 = Error, c2 = Ba(a2, function(d2) {
        this.name = a2;
        this.message = d2;
        d2 = Error(d2).stack;
        void 0 !== d2 && (this.stack = this.toString() + "\n" + d2.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      c2.prototype = Object.create(b2.prototype);
      c2.prototype.constructor = c2;
      c2.prototype.toString = function() {
        return void 0 === this.message ? this.name : this.name + ": " + this.message;
      };
      return c2;
    }
    var K = void 0;
    function L(a2) {
      throw new K(a2);
    }
    var M = (a2) => {
      a2 || L("Cannot use deleted val. handle = " + a2);
      return J[a2].value;
    }, Ea = (a2) => {
      switch (a2) {
        case void 0:
          return 1;
        case null:
          return 2;
        case true:
          return 3;
        case false:
          return 4;
        default:
          var b2 = Ca.length ? Ca.pop() : J.length;
          J[b2] = { ga: 1, value: a2 };
          return b2;
      }
    }, Fa = void 0, Ga = void 0;
    function N(a2) {
      for (var b2 = ""; A[a2]; ) b2 += Ga[A[a2++]];
      return b2;
    }
    var O = [];
    function Ha() {
      for (; O.length; ) {
        var a2 = O.pop();
        a2.M.$ = false;
        a2["delete"]();
      }
    }
    var P = void 0, Q = {};
    function Ia(a2, b2) {
      for (void 0 === b2 && L("ptr should not be undefined"); a2.R; ) b2 = a2.ba(b2), a2 = a2.R;
      return b2;
    }
    var R = {};
    function Ja(a2) {
      a2 = Ka(a2);
      var b2 = N(a2);
      S2(a2);
      return b2;
    }
    function La(a2, b2) {
      var c2 = R[a2];
      void 0 === c2 && L(b2 + " has unknown type " + Ja(a2));
      return c2;
    }
    function Ma() {
    }
    var Na = false;
    function Oa(a2) {
      --a2.count.value;
      0 === a2.count.value && (a2.T ? a2.U.W(a2.T) : a2.P.N.W(a2.O));
    }
    function Pa(a2, b2, c2) {
      if (b2 === c2) return a2;
      if (void 0 === c2.R) return null;
      a2 = Pa(a2, b2, c2.R);
      return null === a2 ? null : c2.na(a2);
    }
    var Qa = {};
    function Ra(a2, b2) {
      b2 = Ia(a2, b2);
      return Q[b2];
    }
    var Sa = void 0;
    function Ta(a2) {
      throw new Sa(a2);
    }
    function Ua(a2, b2) {
      b2.P && b2.O || Ta("makeClassHandle requires ptr and ptrType");
      !!b2.U !== !!b2.T && Ta("Both smartPtrType and smartPtr must be specified");
      b2.count = { value: 1 };
      return T(Object.create(a2, { M: { value: b2 } }));
    }
    function T(a2) {
      if ("undefined" === typeof FinalizationRegistry) return T = (b2) => b2, a2;
      Na = new FinalizationRegistry((b2) => {
        Oa(b2.M);
      });
      T = (b2) => {
        var c2 = b2.M;
        c2.T && Na.register(b2, { M: c2 }, b2);
        return b2;
      };
      Ma = (b2) => {
        Na.unregister(b2);
      };
      return T(a2);
    }
    var Va = {};
    function Wa(a2) {
      for (; a2.length; ) {
        var b2 = a2.pop();
        a2.pop()(b2);
      }
    }
    function Xa(a2) {
      return this.fromWireType(D[a2 >> 2]);
    }
    var U = {}, Ya = {};
    function V(a2, b2, c2) {
      function d2(k2) {
        k2 = c2(k2);
        k2.length !== a2.length && Ta("Mismatched type converter count");
        for (var m2 = 0; m2 < a2.length; ++m2) W(a2[m2], k2[m2]);
      }
      a2.forEach(function(k2) {
        Ya[k2] = b2;
      });
      var e2 = Array(b2.length), f2 = [], g = 0;
      b2.forEach((k2, m2) => {
        R.hasOwnProperty(k2) ? e2[m2] = R[k2] : (f2.push(k2), U.hasOwnProperty(k2) || (U[k2] = []), U[k2].push(() => {
          e2[m2] = R[k2];
          ++g;
          g === f2.length && d2(e2);
        }));
      });
      0 === f2.length && d2(e2);
    }
    function Za(a2) {
      switch (a2) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError("Unknown type size: " + a2);
      }
    }
    function W(a2, b2, c2 = {}) {
      if (!("argPackAdvance" in b2)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
      var d2 = b2.name;
      a2 || L('type "' + d2 + '" must have a positive integer typeid pointer');
      if (R.hasOwnProperty(a2)) {
        if (c2.ua) return;
        L("Cannot register type '" + d2 + "' twice");
      }
      R[a2] = b2;
      delete Ya[a2];
      U.hasOwnProperty(a2) && (b2 = U[a2], delete U[a2], b2.forEach((e2) => e2()));
    }
    function $a(a2) {
      L(a2.M.P.N.name + " instance already deleted");
    }
    function X() {
    }
    function ab(a2, b2, c2) {
      if (void 0 === a2[b2].S) {
        var d2 = a2[b2];
        a2[b2] = function() {
          a2[b2].S.hasOwnProperty(arguments.length) || L("Function '" + c2 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a2[b2].S + ")!");
          return a2[b2].S[arguments.length].apply(this, arguments);
        };
        a2[b2].S = [];
        a2[b2].S[d2.Z] = d2;
      }
    }
    function bb(a2, b2) {
      h.hasOwnProperty(a2) ? (L("Cannot register public name '" + a2 + "' twice"), ab(h, a2, a2), h.hasOwnProperty(void 0) && L("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), h[a2].S[void 0] = b2) : h[a2] = b2;
    }
    function cb(a2, b2, c2, d2, e2, f2, g, k2) {
      this.name = a2;
      this.constructor = b2;
      this.X = c2;
      this.W = d2;
      this.R = e2;
      this.pa = f2;
      this.ba = g;
      this.na = k2;
      this.ja = [];
    }
    function db(a2, b2, c2) {
      for (; b2 !== c2; ) b2.ba || L("Expected null or instance of " + c2.name + ", got an instance of " + b2.name), a2 = b2.ba(a2), b2 = b2.R;
      return a2;
    }
    function eb(a2, b2) {
      if (null === b2) return this.ea && L("null is not a valid " + this.name), 0;
      b2.M || L('Cannot pass "' + fb(b2) + '" as a ' + this.name);
      b2.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
      return db(b2.M.O, b2.M.P.N, this.N);
    }
    function gb(a2, b2) {
      if (null === b2) {
        this.ea && L("null is not a valid " + this.name);
        if (this.da) {
          var c2 = this.fa();
          null !== a2 && a2.push(this.W, c2);
          return c2;
        }
        return 0;
      }
      b2.M || L('Cannot pass "' + fb(b2) + '" as a ' + this.name);
      b2.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
      !this.ca && b2.M.P.ca && L("Cannot convert argument of type " + (b2.M.U ? b2.M.U.name : b2.M.P.name) + " to parameter type " + this.name);
      c2 = db(b2.M.O, b2.M.P.N, this.N);
      if (this.da) switch (void 0 === b2.M.T && L("Passing raw pointer to smart pointer is illegal"), this.Ba) {
        case 0:
          b2.M.U === this ? c2 = b2.M.T : L("Cannot convert argument of type " + (b2.M.U ? b2.M.U.name : b2.M.P.name) + " to parameter type " + this.name);
          break;
        case 1:
          c2 = b2.M.T;
          break;
        case 2:
          if (b2.M.U === this) c2 = b2.M.T;
          else {
            var d2 = b2.clone();
            c2 = this.xa(c2, Ea(function() {
              d2["delete"]();
            }));
            null !== a2 && a2.push(this.W, c2);
          }
          break;
        default:
          L("Unsupporting sharing policy");
      }
      return c2;
    }
    function hb(a2, b2) {
      if (null === b2) return this.ea && L("null is not a valid " + this.name), 0;
      b2.M || L('Cannot pass "' + fb(b2) + '" as a ' + this.name);
      b2.M.O || L("Cannot pass deleted object as a pointer of type " + this.name);
      b2.M.P.ca && L("Cannot convert argument of type " + b2.M.P.name + " to parameter type " + this.name);
      return db(b2.M.O, b2.M.P.N, this.N);
    }
    function Y(a2, b2, c2, d2) {
      this.name = a2;
      this.N = b2;
      this.ea = c2;
      this.ca = d2;
      this.da = false;
      this.W = this.xa = this.fa = this.ka = this.Ba = this.wa = void 0;
      void 0 !== b2.R ? this.toWireType = gb : (this.toWireType = d2 ? eb : hb, this.V = null);
    }
    function ib(a2, b2) {
      h.hasOwnProperty(a2) || Ta("Replacing nonexistant public symbol");
      h[a2] = b2;
      h[a2].Z = void 0;
    }
    function jb(a2, b2) {
      var c2 = [];
      return function() {
        c2.length = 0;
        Object.assign(c2, arguments);
        if (a2.includes("j")) {
          var d2 = h["dynCall_" + a2];
          d2 = c2 && c2.length ? d2.apply(null, [b2].concat(c2)) : d2.call(null, b2);
        } else d2 = oa.get(b2).apply(null, c2);
        return d2;
      };
    }
    function Z(a2, b2) {
      a2 = N(a2);
      var c2 = a2.includes("j") ? jb(a2, b2) : oa.get(b2);
      "function" != typeof c2 && L("unknown function pointer with signature " + a2 + ": " + b2);
      return c2;
    }
    var mb = void 0;
    function nb(a2, b2) {
      function c2(f2) {
        e2[f2] || R[f2] || (Ya[f2] ? Ya[f2].forEach(c2) : (d2.push(f2), e2[f2] = true));
      }
      var d2 = [], e2 = {};
      b2.forEach(c2);
      throw new mb(a2 + ": " + d2.map(Ja).join([", "]));
    }
    function ob(a2, b2, c2, d2, e2) {
      var f2 = b2.length;
      2 > f2 && L("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var g = null !== b2[1] && null !== c2, k2 = false;
      for (c2 = 1; c2 < b2.length; ++c2) if (null !== b2[c2] && void 0 === b2[c2].V) {
        k2 = true;
        break;
      }
      var m2 = "void" !== b2[0].name, l2 = f2 - 2, n3 = Array(l2), p2 = [], r2 = [];
      return function() {
        arguments.length !== l2 && L("function " + a2 + " called with " + arguments.length + " arguments, expected " + l2 + " args!");
        r2.length = 0;
        p2.length = g ? 2 : 1;
        p2[0] = e2;
        if (g) {
          var u2 = b2[1].toWireType(r2, this);
          p2[1] = u2;
        }
        for (var t2 = 0; t2 < l2; ++t2) n3[t2] = b2[t2 + 2].toWireType(r2, arguments[t2]), p2.push(n3[t2]);
        t2 = d2.apply(null, p2);
        if (k2) Wa(r2);
        else for (var y2 = g ? 1 : 2; y2 < b2.length; y2++) {
          var B = 1 === y2 ? u2 : n3[y2 - 2];
          null !== b2[y2].V && b2[y2].V(B);
        }
        u2 = m2 ? b2[0].fromWireType(t2) : void 0;
        return u2;
      };
    }
    function pb(a2, b2) {
      for (var c2 = [], d2 = 0; d2 < a2; d2++) c2.push(E[b2 + 4 * d2 >> 2]);
      return c2;
    }
    function qb(a2) {
      4 < a2 && 0 === --J[a2].ga && (J[a2] = void 0, Ca.push(a2));
    }
    function fb(a2) {
      if (null === a2) return "null";
      var b2 = typeof a2;
      return "object" === b2 || "array" === b2 || "function" === b2 ? a2.toString() : "" + a2;
    }
    function rb(a2, b2) {
      switch (b2) {
        case 2:
          return function(c2) {
            return this.fromWireType(la[c2 >> 2]);
          };
        case 3:
          return function(c2) {
            return this.fromWireType(ma[c2 >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + a2);
      }
    }
    function sb(a2, b2, c2) {
      switch (b2) {
        case 0:
          return c2 ? function(d2) {
            return ja[d2];
          } : function(d2) {
            return A[d2];
          };
        case 1:
          return c2 ? function(d2) {
            return C[d2 >> 1];
          } : function(d2) {
            return ka[d2 >> 1];
          };
        case 2:
          return c2 ? function(d2) {
            return D[d2 >> 2];
          } : function(d2) {
            return E[d2 >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + a2);
      }
    }
    function tb(a2, b2) {
      for (var c2 = "", d2 = 0; !(d2 >= b2 / 2); ++d2) {
        var e2 = C[a2 + 2 * d2 >> 1];
        if (0 == e2) break;
        c2 += String.fromCharCode(e2);
      }
      return c2;
    }
    function ub(a2, b2, c2) {
      void 0 === c2 && (c2 = 2147483647);
      if (2 > c2) return 0;
      c2 -= 2;
      var d2 = b2;
      c2 = c2 < 2 * a2.length ? c2 / 2 : a2.length;
      for (var e2 = 0; e2 < c2; ++e2) C[b2 >> 1] = a2.charCodeAt(e2), b2 += 2;
      C[b2 >> 1] = 0;
      return b2 - d2;
    }
    function vb(a2) {
      return 2 * a2.length;
    }
    function wb(a2, b2) {
      for (var c2 = 0, d2 = ""; !(c2 >= b2 / 4); ) {
        var e2 = D[a2 + 4 * c2 >> 2];
        if (0 == e2) break;
        ++c2;
        65536 <= e2 ? (e2 -= 65536, d2 += String.fromCharCode(55296 | e2 >> 10, 56320 | e2 & 1023)) : d2 += String.fromCharCode(e2);
      }
      return d2;
    }
    function xb(a2, b2, c2) {
      void 0 === c2 && (c2 = 2147483647);
      if (4 > c2) return 0;
      var d2 = b2;
      c2 = d2 + c2 - 4;
      for (var e2 = 0; e2 < a2.length; ++e2) {
        var f2 = a2.charCodeAt(e2);
        if (55296 <= f2 && 57343 >= f2) {
          var g = a2.charCodeAt(++e2);
          f2 = 65536 + ((f2 & 1023) << 10) | g & 1023;
        }
        D[b2 >> 2] = f2;
        b2 += 4;
        if (b2 + 4 > c2) break;
      }
      D[b2 >> 2] = 0;
      return b2 - d2;
    }
    function yb(a2) {
      for (var b2 = 0, c2 = 0; c2 < a2.length; ++c2) {
        var d2 = a2.charCodeAt(c2);
        55296 <= d2 && 57343 >= d2 && ++c2;
        b2 += 4;
      }
      return b2;
    }
    var zb = {};
    function Ab(a2) {
      var b2 = zb[a2];
      return void 0 === b2 ? N(a2) : b2;
    }
    var Bb = [];
    function Cb(a2) {
      var b2 = Bb.length;
      Bb.push(a2);
      return b2;
    }
    function Db(a2, b2) {
      for (var c2 = Array(a2), d2 = 0; d2 < a2; ++d2) c2[d2] = La(E[b2 + 4 * d2 >> 2], "parameter " + d2);
      return c2;
    }
    var Eb = [], Fb = [null, [], []];
    K = h.BindingError = Da("BindingError");
    h.count_emval_handles = function() {
      for (var a2 = 0, b2 = 5; b2 < J.length; ++b2) void 0 !== J[b2] && ++a2;
      return a2;
    };
    h.get_first_emval = function() {
      for (var a2 = 5; a2 < J.length; ++a2) if (void 0 !== J[a2]) return J[a2];
      return null;
    };
    Fa = h.PureVirtualError = Da("PureVirtualError");
    for (var Gb = Array(256), Hb = 0; 256 > Hb; ++Hb) Gb[Hb] = String.fromCharCode(Hb);
    Ga = Gb;
    h.getInheritedInstanceCount = function() {
      return Object.keys(Q).length;
    };
    h.getLiveInheritedInstances = function() {
      var a2 = [], b2;
      for (b2 in Q) Q.hasOwnProperty(b2) && a2.push(Q[b2]);
      return a2;
    };
    h.flushPendingDeletes = Ha;
    h.setDelayFunction = function(a2) {
      P = a2;
      O.length && P && P(Ha);
    };
    Sa = h.InternalError = Da("InternalError");
    X.prototype.isAliasOf = function(a2) {
      if (!(this instanceof X && a2 instanceof X)) return false;
      var b2 = this.M.P.N, c2 = this.M.O, d2 = a2.M.P.N;
      for (a2 = a2.M.O; b2.R; ) c2 = b2.ba(c2), b2 = b2.R;
      for (; d2.R; ) a2 = d2.ba(a2), d2 = d2.R;
      return b2 === d2 && c2 === a2;
    };
    X.prototype.clone = function() {
      this.M.O || $a(this);
      if (this.M.aa) return this.M.count.value += 1, this;
      var a2 = T, b2 = Object, c2 = b2.create, d2 = Object.getPrototypeOf(this), e2 = this.M;
      a2 = a2(c2.call(b2, d2, { M: { value: { count: e2.count, $: e2.$, aa: e2.aa, O: e2.O, P: e2.P, T: e2.T, U: e2.U } } }));
      a2.M.count.value += 1;
      a2.M.$ = false;
      return a2;
    };
    X.prototype["delete"] = function() {
      this.M.O || $a(this);
      this.M.$ && !this.M.aa && L("Object already scheduled for deletion");
      Ma(this);
      Oa(this.M);
      this.M.aa || (this.M.T = void 0, this.M.O = void 0);
    };
    X.prototype.isDeleted = function() {
      return !this.M.O;
    };
    X.prototype.deleteLater = function() {
      this.M.O || $a(this);
      this.M.$ && !this.M.aa && L("Object already scheduled for deletion");
      O.push(this);
      1 === O.length && P && P(Ha);
      this.M.$ = true;
      return this;
    };
    Y.prototype.qa = function(a2) {
      this.ka && (a2 = this.ka(a2));
      return a2;
    };
    Y.prototype.ha = function(a2) {
      this.W && this.W(a2);
    };
    Y.prototype.argPackAdvance = 8;
    Y.prototype.readValueFromPointer = Xa;
    Y.prototype.deleteObject = function(a2) {
      if (null !== a2) a2["delete"]();
    };
    Y.prototype.fromWireType = function(a2) {
      function b2() {
        return this.da ? Ua(this.N.X, { P: this.wa, O: c2, U: this, T: a2 }) : Ua(this.N.X, { P: this, O: a2 });
      }
      var c2 = this.qa(a2);
      if (!c2) return this.ha(a2), null;
      var d2 = Ra(this.N, c2);
      if (void 0 !== d2) {
        if (0 === d2.M.count.value) return d2.M.O = c2, d2.M.T = a2, d2.clone();
        d2 = d2.clone();
        this.ha(a2);
        return d2;
      }
      d2 = this.N.pa(c2);
      d2 = Qa[d2];
      if (!d2) return b2.call(this);
      d2 = this.ca ? d2.la : d2.pointerType;
      var e2 = Pa(c2, this.N, d2.N);
      return null === e2 ? b2.call(this) : this.da ? Ua(d2.N.X, { P: d2, O: e2, U: this, T: a2 }) : Ua(d2.N.X, { P: d2, O: e2 });
    };
    mb = h.UnboundTypeError = Da("UnboundTypeError");
    var xa = "function" == typeof atob ? atob : function(a2) {
      var b2 = "", c2 = 0;
      a2 = a2.replace(/[^A-Za-z0-9\+\/=]/g, "");
      do {
        var d2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
        var e2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
        var f2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
        var g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
        d2 = d2 << 2 | e2 >> 4;
        e2 = (e2 & 15) << 4 | f2 >> 2;
        var k2 = (f2 & 3) << 6 | g;
        b2 += String.fromCharCode(d2);
        64 !== f2 && (b2 += String.fromCharCode(e2));
        64 !== g && (b2 += String.fromCharCode(k2));
      } while (c2 < a2.length);
      return b2;
    }, Jb = {
      l: function(a2, b2, c2, d2) {
        x("Assertion failed: " + (a2 ? z(A, a2) : "") + ", at: " + [b2 ? b2 ? z(A, b2) : "" : "unknown filename", c2, d2 ? d2 ? z(A, d2) : "" : "unknown function"]);
      },
      q: function(a2, b2, c2) {
        a2 = N(a2);
        b2 = La(b2, "wrapper");
        c2 = M(c2);
        var d2 = [].slice, e2 = b2.N, f2 = e2.X, g = e2.R.X, k2 = e2.R.constructor;
        a2 = Ba(a2, function() {
          e2.R.ja.forEach((function(l2) {
            if (this[l2] === g[l2]) throw new Fa("Pure virtual function " + l2 + " must be implemented in JavaScript");
          }).bind(this));
          Object.defineProperty(this, "__parent", { value: f2 });
          this.__construct.apply(this, d2.call(arguments));
        });
        f2.__construct = function() {
          this === f2 && L("Pass correct 'this' to __construct");
          var l2 = k2.implement.apply(void 0, [this].concat(d2.call(arguments)));
          Ma(l2);
          var n3 = l2.M;
          l2.notifyOnDestruction();
          n3.aa = true;
          Object.defineProperties(this, { M: { value: n3 } });
          T(this);
          l2 = n3.O;
          l2 = Ia(e2, l2);
          Q.hasOwnProperty(l2) ? L("Tried to register registered instance: " + l2) : Q[l2] = this;
        };
        f2.__destruct = function() {
          this === f2 && L("Pass correct 'this' to __destruct");
          Ma(this);
          var l2 = this.M.O;
          l2 = Ia(e2, l2);
          Q.hasOwnProperty(l2) ? delete Q[l2] : L("Tried to unregister unregistered instance: " + l2);
        };
        a2.prototype = Object.create(f2);
        for (var m2 in c2) a2.prototype[m2] = c2[m2];
        return Ea(a2);
      },
      j: function(a2) {
        var b2 = Va[a2];
        delete Va[a2];
        var c2 = b2.fa, d2 = b2.W, e2 = b2.ia, f2 = e2.map((g) => g.ta).concat(e2.map((g) => g.za));
        V([a2], f2, (g) => {
          var k2 = {};
          e2.forEach((m2, l2) => {
            var n3 = g[l2], p2 = m2.ra, r2 = m2.sa, u2 = g[l2 + e2.length], t2 = m2.ya, y2 = m2.Aa;
            k2[m2.oa] = { read: (B) => n3.fromWireType(p2(r2, B)), write: (B, ba) => {
              var I = [];
              t2(
                y2,
                B,
                u2.toWireType(I, ba)
              );
              Wa(I);
            } };
          });
          return [{ name: b2.name, fromWireType: function(m2) {
            var l2 = {}, n3;
            for (n3 in k2) l2[n3] = k2[n3].read(m2);
            d2(m2);
            return l2;
          }, toWireType: function(m2, l2) {
            for (var n3 in k2) if (!(n3 in l2)) throw new TypeError('Missing field:  "' + n3 + '"');
            var p2 = c2();
            for (n3 in k2) k2[n3].write(p2, l2[n3]);
            null !== m2 && m2.push(d2, p2);
            return p2;
          }, argPackAdvance: 8, readValueFromPointer: Xa, V: d2 }];
        });
      },
      v: function() {
      },
      B: function(a2, b2, c2, d2, e2) {
        var f2 = Za(c2);
        b2 = N(b2);
        W(a2, {
          name: b2,
          fromWireType: function(g) {
            return !!g;
          },
          toWireType: function(g, k2) {
            return k2 ? d2 : e2;
          },
          argPackAdvance: 8,
          readValueFromPointer: function(g) {
            if (1 === c2) var k2 = ja;
            else if (2 === c2) k2 = C;
            else if (4 === c2) k2 = D;
            else throw new TypeError("Unknown boolean type size: " + b2);
            return this.fromWireType(k2[g >> f2]);
          },
          V: null
        });
      },
      f: function(a2, b2, c2, d2, e2, f2, g, k2, m2, l2, n3, p2, r2) {
        n3 = N(n3);
        f2 = Z(e2, f2);
        k2 && (k2 = Z(g, k2));
        l2 && (l2 = Z(m2, l2));
        r2 = Z(p2, r2);
        var u2 = Aa(n3);
        bb(u2, function() {
          nb("Cannot construct " + n3 + " due to unbound types", [d2]);
        });
        V([a2, b2, c2], d2 ? [d2] : [], function(t2) {
          t2 = t2[0];
          if (d2) {
            var y2 = t2.N;
            var B = y2.X;
          } else B = X.prototype;
          t2 = Ba(u2, function() {
            if (Object.getPrototypeOf(this) !== ba) throw new K("Use 'new' to construct " + n3);
            if (void 0 === I.Y) throw new K(n3 + " has no accessible constructor");
            var kb = I.Y[arguments.length];
            if (void 0 === kb) throw new K("Tried to invoke ctor of " + n3 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(I.Y).toString() + ") parameters instead!");
            return kb.apply(this, arguments);
          });
          var ba = Object.create(B, { constructor: { value: t2 } });
          t2.prototype = ba;
          var I = new cb(n3, t2, ba, r2, y2, f2, k2, l2);
          y2 = new Y(n3, I, true, false);
          B = new Y(n3 + "*", I, false, false);
          var lb = new Y(n3 + " const*", I, false, true);
          Qa[a2] = {
            pointerType: B,
            la: lb
          };
          ib(u2, t2);
          return [y2, B, lb];
        });
      },
      d: function(a2, b2, c2, d2, e2, f2, g) {
        var k2 = pb(c2, d2);
        b2 = N(b2);
        f2 = Z(e2, f2);
        V([], [a2], function(m2) {
          function l2() {
            nb("Cannot call " + n3 + " due to unbound types", k2);
          }
          m2 = m2[0];
          var n3 = m2.name + "." + b2;
          b2.startsWith("@@") && (b2 = Symbol[b2.substring(2)]);
          var p2 = m2.N.constructor;
          void 0 === p2[b2] ? (l2.Z = c2 - 1, p2[b2] = l2) : (ab(p2, b2, n3), p2[b2].S[c2 - 1] = l2);
          V([], k2, function(r2) {
            r2 = ob(n3, [r2[0], null].concat(r2.slice(1)), null, f2, g);
            void 0 === p2[b2].S ? (r2.Z = c2 - 1, p2[b2] = r2) : p2[b2].S[c2 - 1] = r2;
            return [];
          });
          return [];
        });
      },
      p: function(a2, b2, c2, d2, e2, f2) {
        0 < b2 || x();
        var g = pb(
          b2,
          c2
        );
        e2 = Z(d2, e2);
        V([], [a2], function(k2) {
          k2 = k2[0];
          var m2 = "constructor " + k2.name;
          void 0 === k2.N.Y && (k2.N.Y = []);
          if (void 0 !== k2.N.Y[b2 - 1]) throw new K("Cannot register multiple constructors with identical number of parameters (" + (b2 - 1) + ") for class '" + k2.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
          k2.N.Y[b2 - 1] = () => {
            nb("Cannot construct " + k2.name + " due to unbound types", g);
          };
          V([], g, function(l2) {
            l2.splice(1, 0, null);
            k2.N.Y[b2 - 1] = ob(m2, l2, null, e2, f2);
            return [];
          });
          return [];
        });
      },
      a: function(a2, b2, c2, d2, e2, f2, g, k2) {
        var m2 = pb(c2, d2);
        b2 = N(b2);
        f2 = Z(e2, f2);
        V([], [a2], function(l2) {
          function n3() {
            nb("Cannot call " + p2 + " due to unbound types", m2);
          }
          l2 = l2[0];
          var p2 = l2.name + "." + b2;
          b2.startsWith("@@") && (b2 = Symbol[b2.substring(2)]);
          k2 && l2.N.ja.push(b2);
          var r2 = l2.N.X, u2 = r2[b2];
          void 0 === u2 || void 0 === u2.S && u2.className !== l2.name && u2.Z === c2 - 2 ? (n3.Z = c2 - 2, n3.className = l2.name, r2[b2] = n3) : (ab(r2, b2, p2), r2[b2].S[c2 - 2] = n3);
          V([], m2, function(t2) {
            t2 = ob(p2, t2, l2, f2, g);
            void 0 === r2[b2].S ? (t2.Z = c2 - 2, r2[b2] = t2) : r2[b2].S[c2 - 2] = t2;
            return [];
          });
          return [];
        });
      },
      A: function(a2, b2) {
        b2 = N(b2);
        W(
          a2,
          { name: b2, fromWireType: function(c2) {
            var d2 = M(c2);
            qb(c2);
            return d2;
          }, toWireType: function(c2, d2) {
            return Ea(d2);
          }, argPackAdvance: 8, readValueFromPointer: Xa, V: null }
        );
      },
      n: function(a2, b2, c2) {
        c2 = Za(c2);
        b2 = N(b2);
        W(a2, { name: b2, fromWireType: function(d2) {
          return d2;
        }, toWireType: function(d2, e2) {
          return e2;
        }, argPackAdvance: 8, readValueFromPointer: rb(b2, c2), V: null });
      },
      e: function(a2, b2, c2, d2, e2) {
        b2 = N(b2);
        -1 === e2 && (e2 = 4294967295);
        e2 = Za(c2);
        var f2 = (k2) => k2;
        if (0 === d2) {
          var g = 32 - 8 * c2;
          f2 = (k2) => k2 << g >>> g;
        }
        c2 = b2.includes("unsigned") ? function(k2, m2) {
          return m2 >>> 0;
        } : function(k2, m2) {
          return m2;
        };
        W(a2, { name: b2, fromWireType: f2, toWireType: c2, argPackAdvance: 8, readValueFromPointer: sb(b2, e2, 0 !== d2), V: null });
      },
      b: function(a2, b2, c2) {
        function d2(f2) {
          f2 >>= 2;
          var g = E;
          return new e2(ia, g[f2 + 1], g[f2]);
        }
        var e2 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b2];
        c2 = N(c2);
        W(a2, { name: c2, fromWireType: d2, argPackAdvance: 8, readValueFromPointer: d2 }, { ua: true });
      },
      o: function(a2, b2) {
        b2 = N(b2);
        var c2 = "std::string" === b2;
        W(a2, { name: b2, fromWireType: function(d2) {
          var e2 = E[d2 >> 2], f2 = d2 + 4;
          if (c2) for (var g = f2, k2 = 0; k2 <= e2; ++k2) {
            var m2 = f2 + k2;
            if (k2 == e2 || 0 == A[m2]) {
              g = g ? z(A, g, m2 - g) : "";
              if (void 0 === l2) var l2 = g;
              else l2 += String.fromCharCode(0), l2 += g;
              g = m2 + 1;
            }
          }
          else {
            l2 = Array(e2);
            for (k2 = 0; k2 < e2; ++k2) l2[k2] = String.fromCharCode(A[f2 + k2]);
            l2 = l2.join("");
          }
          S2(d2);
          return l2;
        }, toWireType: function(d2, e2) {
          e2 instanceof ArrayBuffer && (e2 = new Uint8Array(e2));
          var f2, g = "string" == typeof e2;
          g || e2 instanceof Uint8Array || e2 instanceof Uint8ClampedArray || e2 instanceof Int8Array || L("Cannot pass non-string to std::string");
          if (c2 && g) {
            var k2 = 0;
            for (f2 = 0; f2 < e2.length; ++f2) {
              var m2 = e2.charCodeAt(f2);
              127 >= m2 ? k2++ : 2047 >= m2 ? k2 += 2 : 55296 <= m2 && 57343 >= m2 ? (k2 += 4, ++f2) : k2 += 3;
            }
            f2 = k2;
          } else f2 = e2.length;
          k2 = Ib(4 + f2 + 1);
          m2 = k2 + 4;
          E[k2 >> 2] = f2;
          if (c2 && g) {
            if (g = m2, m2 = f2 + 1, f2 = A, 0 < m2) {
              m2 = g + m2 - 1;
              for (var l2 = 0; l2 < e2.length; ++l2) {
                var n3 = e2.charCodeAt(l2);
                if (55296 <= n3 && 57343 >= n3) {
                  var p2 = e2.charCodeAt(++l2);
                  n3 = 65536 + ((n3 & 1023) << 10) | p2 & 1023;
                }
                if (127 >= n3) {
                  if (g >= m2) break;
                  f2[g++] = n3;
                } else {
                  if (2047 >= n3) {
                    if (g + 1 >= m2) break;
                    f2[g++] = 192 | n3 >> 6;
                  } else {
                    if (65535 >= n3) {
                      if (g + 2 >= m2) break;
                      f2[g++] = 224 | n3 >> 12;
                    } else {
                      if (g + 3 >= m2) break;
                      f2[g++] = 240 | n3 >> 18;
                      f2[g++] = 128 | n3 >> 12 & 63;
                    }
                    f2[g++] = 128 | n3 >> 6 & 63;
                  }
                  f2[g++] = 128 | n3 & 63;
                }
              }
              f2[g] = 0;
            }
          } else if (g) for (g = 0; g < f2; ++g) l2 = e2.charCodeAt(g), 255 < l2 && (S2(m2), L("String has UTF-16 code units that do not fit in 8 bits")), A[m2 + g] = l2;
          else for (g = 0; g < f2; ++g) A[m2 + g] = e2[g];
          null !== d2 && d2.push(S2, k2);
          return k2;
        }, argPackAdvance: 8, readValueFromPointer: Xa, V: function(d2) {
          S2(d2);
        } });
      },
      i: function(a2, b2, c2) {
        c2 = N(c2);
        if (2 === b2) {
          var d2 = tb;
          var e2 = ub;
          var f2 = vb;
          var g = () => ka;
          var k2 = 1;
        } else 4 === b2 && (d2 = wb, e2 = xb, f2 = yb, g = () => E, k2 = 2);
        W(a2, { name: c2, fromWireType: function(m2) {
          for (var l2 = E[m2 >> 2], n3 = g(), p2, r2 = m2 + 4, u2 = 0; u2 <= l2; ++u2) {
            var t2 = m2 + 4 + u2 * b2;
            if (u2 == l2 || 0 == n3[t2 >> k2]) r2 = d2(r2, t2 - r2), void 0 === p2 ? p2 = r2 : (p2 += String.fromCharCode(0), p2 += r2), r2 = t2 + b2;
          }
          S2(m2);
          return p2;
        }, toWireType: function(m2, l2) {
          "string" != typeof l2 && L("Cannot pass non-string to C++ string type " + c2);
          var n3 = f2(l2), p2 = Ib(4 + n3 + b2);
          E[p2 >> 2] = n3 >> k2;
          e2(l2, p2 + 4, n3 + b2);
          null !== m2 && m2.push(S2, p2);
          return p2;
        }, argPackAdvance: 8, readValueFromPointer: Xa, V: function(m2) {
          S2(m2);
        } });
      },
      k: function(a2, b2, c2, d2, e2, f2) {
        Va[a2] = { name: N(b2), fa: Z(c2, d2), W: Z(e2, f2), ia: [] };
      },
      h: function(a2, b2, c2, d2, e2, f2, g, k2, m2, l2) {
        Va[a2].ia.push({ oa: N(b2), ta: c2, ra: Z(d2, e2), sa: f2, za: g, ya: Z(k2, m2), Aa: l2 });
      },
      C: function(a2, b2) {
        b2 = N(b2);
        W(a2, {
          va: true,
          name: b2,
          argPackAdvance: 0,
          fromWireType: function() {
          },
          toWireType: function() {
          }
        });
      },
      s: function(a2, b2, c2, d2, e2) {
        a2 = Bb[a2];
        b2 = M(b2);
        c2 = Ab(c2);
        var f2 = [];
        E[d2 >> 2] = Ea(f2);
        return a2(b2, c2, f2, e2);
      },
      t: function(a2, b2, c2, d2) {
        a2 = Bb[a2];
        b2 = M(b2);
        c2 = Ab(c2);
        a2(b2, c2, null, d2);
      },
      g: qb,
      m: function(a2, b2) {
        var c2 = Db(a2, b2), d2 = c2[0];
        b2 = d2.name + "_$" + c2.slice(1).map(function(g) {
          return g.name;
        }).join("_") + "$";
        var e2 = Eb[b2];
        if (void 0 !== e2) return e2;
        var f2 = Array(a2 - 1);
        e2 = Cb((g, k2, m2, l2) => {
          for (var n3 = 0, p2 = 0; p2 < a2 - 1; ++p2) f2[p2] = c2[p2 + 1].readValueFromPointer(l2 + n3), n3 += c2[p2 + 1].argPackAdvance;
          g = g[k2].apply(
            g,
            f2
          );
          for (p2 = 0; p2 < a2 - 1; ++p2) c2[p2 + 1].ma && c2[p2 + 1].ma(f2[p2]);
          if (!d2.va) return d2.toWireType(m2, g);
        });
        return Eb[b2] = e2;
      },
      D: function(a2) {
        4 < a2 && (J[a2].ga += 1);
      },
      r: function(a2) {
        var b2 = M(a2);
        Wa(b2);
        qb(a2);
      },
      c: function() {
        x("");
      },
      x: function(a2, b2, c2) {
        A.copyWithin(a2, b2, b2 + c2);
      },
      w: function(a2) {
        var b2 = A.length;
        a2 >>>= 0;
        if (2147483648 < a2) return false;
        for (var c2 = 1; 4 >= c2; c2 *= 2) {
          var d2 = b2 * (1 + 0.2 / c2);
          d2 = Math.min(d2, a2 + 100663296);
          var e2 = Math;
          d2 = Math.max(a2, d2);
          e2 = e2.min.call(e2, 2147483648, d2 + (65536 - d2 % 65536) % 65536);
          a: {
            try {
              fa.grow(e2 - ia.byteLength + 65535 >>> 16);
              na();
              var f2 = 1;
              break a;
            } catch (g) {
            }
            f2 = void 0;
          }
          if (f2) return true;
        }
        return false;
      },
      z: function() {
        return 52;
      },
      u: function() {
        return 70;
      },
      y: function(a2, b2, c2, d2) {
        for (var e2 = 0, f2 = 0; f2 < c2; f2++) {
          var g = E[b2 >> 2], k2 = E[b2 + 4 >> 2];
          b2 += 8;
          for (var m2 = 0; m2 < k2; m2++) {
            var l2 = A[g + m2], n3 = Fb[a2];
            0 === l2 || 10 === l2 ? ((1 === a2 ? ea : v2)(z(n3, 0)), n3.length = 0) : n3.push(l2);
          }
          e2 += k2;
        }
        E[d2 >> 2] = e2;
        return 0;
      }
    };
    (function() {
      function a2(e2) {
        h.asm = e2.exports;
        fa = h.asm.E;
        na();
        oa = h.asm.J;
        qa.unshift(h.asm.F);
        F--;
        h.monitorRunDependencies && h.monitorRunDependencies(F);
        0 == F && (G2 && (e2 = G2, G2 = null, e2()));
      }
      function b2(e2) {
        a2(e2.instance);
      }
      function c2(e2) {
        return ya().then(function(f2) {
          return WebAssembly.instantiate(f2, d2);
        }).then(function(f2) {
          return f2;
        }).then(e2, function(f2) {
          v2("failed to asynchronously prepare wasm: " + f2);
          x(f2);
        });
      }
      var d2 = { a: Jb };
      F++;
      h.monitorRunDependencies && h.monitorRunDependencies(F);
      if (h.instantiateWasm) try {
        return h.instantiateWasm(
          d2,
          a2
        );
      } catch (e2) {
        v2("Module.instantiateWasm callback failed with error: " + e2), ca(e2);
      }
      (function() {
        return w || "function" != typeof WebAssembly.instantiateStreaming || ua(H) || "function" != typeof fetch ? c2(b2) : fetch(H, { credentials: "same-origin" }).then(function(e2) {
          return WebAssembly.instantiateStreaming(e2, d2).then(b2, function(f2) {
            v2("wasm streaming compile failed: " + f2);
            v2("falling back to ArrayBuffer instantiation");
            return c2(b2);
          });
        });
      })().catch(ca);
      return {};
    })();
    h.___wasm_call_ctors = function() {
      return (h.___wasm_call_ctors = h.asm.F).apply(null, arguments);
    };
    var Ka = h.___getTypeName = function() {
      return (Ka = h.___getTypeName = h.asm.G).apply(null, arguments);
    };
    h.__embind_initialize_bindings = function() {
      return (h.__embind_initialize_bindings = h.asm.H).apply(null, arguments);
    };
    var Ib = h._malloc = function() {
      return (Ib = h._malloc = h.asm.I).apply(null, arguments);
    }, S2 = h._free = function() {
      return (S2 = h._free = h.asm.K).apply(null, arguments);
    };
    h.dynCall_jiji = function() {
      return (h.dynCall_jiji = h.asm.L).apply(null, arguments);
    };
    var Kb;
    G2 = function Lb() {
      Kb || Mb();
      Kb || (G2 = Lb);
    };
    function Mb() {
      function a2() {
        if (!Kb && (Kb = true, h.calledRun = true, !ha)) {
          za(qa);
          aa(h);
          if (h.onRuntimeInitialized) h.onRuntimeInitialized();
          if (h.postRun) for ("function" == typeof h.postRun && (h.postRun = [h.postRun]); h.postRun.length; ) {
            var b2 = h.postRun.shift();
            ra.unshift(b2);
          }
          za(ra);
        }
      }
      if (!(0 < F)) {
        if (h.preRun) for ("function" == typeof h.preRun && (h.preRun = [h.preRun]); h.preRun.length; ) sa();
        za(pa);
        0 < F || (h.setStatus ? (h.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            h.setStatus("");
          }, 1);
          a2();
        }, 1)) : a2());
      }
    }
    if (h.preInit) for ("function" == typeof h.preInit && (h.preInit = [h.preInit]); 0 < h.preInit.length; ) h.preInit.pop()();
    Mb();
    return loadYoga2.ready;
  };
})();
let Align = /* @__PURE__ */ function(Align2) {
  Align2[Align2["Auto"] = 0] = "Auto";
  Align2[Align2["FlexStart"] = 1] = "FlexStart";
  Align2[Align2["Center"] = 2] = "Center";
  Align2[Align2["FlexEnd"] = 3] = "FlexEnd";
  Align2[Align2["Stretch"] = 4] = "Stretch";
  Align2[Align2["Baseline"] = 5] = "Baseline";
  Align2[Align2["SpaceBetween"] = 6] = "SpaceBetween";
  Align2[Align2["SpaceAround"] = 7] = "SpaceAround";
  Align2[Align2["SpaceEvenly"] = 8] = "SpaceEvenly";
  return Align2;
}({});
let BoxSizing = /* @__PURE__ */ function(BoxSizing2) {
  BoxSizing2[BoxSizing2["BorderBox"] = 0] = "BorderBox";
  BoxSizing2[BoxSizing2["ContentBox"] = 1] = "ContentBox";
  return BoxSizing2;
}({});
let Dimension = /* @__PURE__ */ function(Dimension2) {
  Dimension2[Dimension2["Width"] = 0] = "Width";
  Dimension2[Dimension2["Height"] = 1] = "Height";
  return Dimension2;
}({});
let Direction = /* @__PURE__ */ function(Direction2) {
  Direction2[Direction2["Inherit"] = 0] = "Inherit";
  Direction2[Direction2["LTR"] = 1] = "LTR";
  Direction2[Direction2["RTL"] = 2] = "RTL";
  return Direction2;
}({});
let Display = /* @__PURE__ */ function(Display2) {
  Display2[Display2["Flex"] = 0] = "Flex";
  Display2[Display2["None"] = 1] = "None";
  Display2[Display2["Contents"] = 2] = "Contents";
  return Display2;
}({});
let Edge = /* @__PURE__ */ function(Edge2) {
  Edge2[Edge2["Left"] = 0] = "Left";
  Edge2[Edge2["Top"] = 1] = "Top";
  Edge2[Edge2["Right"] = 2] = "Right";
  Edge2[Edge2["Bottom"] = 3] = "Bottom";
  Edge2[Edge2["Start"] = 4] = "Start";
  Edge2[Edge2["End"] = 5] = "End";
  Edge2[Edge2["Horizontal"] = 6] = "Horizontal";
  Edge2[Edge2["Vertical"] = 7] = "Vertical";
  Edge2[Edge2["All"] = 8] = "All";
  return Edge2;
}({});
let Errata = /* @__PURE__ */ function(Errata2) {
  Errata2[Errata2["None"] = 0] = "None";
  Errata2[Errata2["StretchFlexBasis"] = 1] = "StretchFlexBasis";
  Errata2[Errata2["AbsolutePositionWithoutInsetsExcludesPadding"] = 2] = "AbsolutePositionWithoutInsetsExcludesPadding";
  Errata2[Errata2["AbsolutePercentAgainstInnerSize"] = 4] = "AbsolutePercentAgainstInnerSize";
  Errata2[Errata2["All"] = 2147483647] = "All";
  Errata2[Errata2["Classic"] = 2147483646] = "Classic";
  return Errata2;
}({});
let ExperimentalFeature = /* @__PURE__ */ function(ExperimentalFeature2) {
  ExperimentalFeature2[ExperimentalFeature2["WebFlexBasis"] = 0] = "WebFlexBasis";
  return ExperimentalFeature2;
}({});
let FlexDirection = /* @__PURE__ */ function(FlexDirection2) {
  FlexDirection2[FlexDirection2["Column"] = 0] = "Column";
  FlexDirection2[FlexDirection2["ColumnReverse"] = 1] = "ColumnReverse";
  FlexDirection2[FlexDirection2["Row"] = 2] = "Row";
  FlexDirection2[FlexDirection2["RowReverse"] = 3] = "RowReverse";
  return FlexDirection2;
}({});
let Gutter = /* @__PURE__ */ function(Gutter2) {
  Gutter2[Gutter2["Column"] = 0] = "Column";
  Gutter2[Gutter2["Row"] = 1] = "Row";
  Gutter2[Gutter2["All"] = 2] = "All";
  return Gutter2;
}({});
let Justify = /* @__PURE__ */ function(Justify2) {
  Justify2[Justify2["FlexStart"] = 0] = "FlexStart";
  Justify2[Justify2["Center"] = 1] = "Center";
  Justify2[Justify2["FlexEnd"] = 2] = "FlexEnd";
  Justify2[Justify2["SpaceBetween"] = 3] = "SpaceBetween";
  Justify2[Justify2["SpaceAround"] = 4] = "SpaceAround";
  Justify2[Justify2["SpaceEvenly"] = 5] = "SpaceEvenly";
  return Justify2;
}({});
let LogLevel = /* @__PURE__ */ function(LogLevel2) {
  LogLevel2[LogLevel2["Error"] = 0] = "Error";
  LogLevel2[LogLevel2["Warn"] = 1] = "Warn";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Debug"] = 3] = "Debug";
  LogLevel2[LogLevel2["Verbose"] = 4] = "Verbose";
  LogLevel2[LogLevel2["Fatal"] = 5] = "Fatal";
  return LogLevel2;
}({});
let MeasureMode = /* @__PURE__ */ function(MeasureMode2) {
  MeasureMode2[MeasureMode2["Undefined"] = 0] = "Undefined";
  MeasureMode2[MeasureMode2["Exactly"] = 1] = "Exactly";
  MeasureMode2[MeasureMode2["AtMost"] = 2] = "AtMost";
  return MeasureMode2;
}({});
let NodeType = /* @__PURE__ */ function(NodeType2) {
  NodeType2[NodeType2["Default"] = 0] = "Default";
  NodeType2[NodeType2["Text"] = 1] = "Text";
  return NodeType2;
}({});
let Overflow = /* @__PURE__ */ function(Overflow2) {
  Overflow2[Overflow2["Visible"] = 0] = "Visible";
  Overflow2[Overflow2["Hidden"] = 1] = "Hidden";
  Overflow2[Overflow2["Scroll"] = 2] = "Scroll";
  return Overflow2;
}({});
let PositionType = /* @__PURE__ */ function(PositionType2) {
  PositionType2[PositionType2["Static"] = 0] = "Static";
  PositionType2[PositionType2["Relative"] = 1] = "Relative";
  PositionType2[PositionType2["Absolute"] = 2] = "Absolute";
  return PositionType2;
}({});
let Unit = /* @__PURE__ */ function(Unit2) {
  Unit2[Unit2["Undefined"] = 0] = "Undefined";
  Unit2[Unit2["Point"] = 1] = "Point";
  Unit2[Unit2["Percent"] = 2] = "Percent";
  Unit2[Unit2["Auto"] = 3] = "Auto";
  return Unit2;
}({});
let Wrap = /* @__PURE__ */ function(Wrap2) {
  Wrap2[Wrap2["NoWrap"] = 0] = "NoWrap";
  Wrap2[Wrap2["Wrap"] = 1] = "Wrap";
  Wrap2[Wrap2["WrapReverse"] = 2] = "WrapReverse";
  return Wrap2;
}({});
const constants = {
  ALIGN_AUTO: Align.Auto,
  ALIGN_FLEX_START: Align.FlexStart,
  ALIGN_CENTER: Align.Center,
  ALIGN_FLEX_END: Align.FlexEnd,
  ALIGN_STRETCH: Align.Stretch,
  ALIGN_BASELINE: Align.Baseline,
  ALIGN_SPACE_BETWEEN: Align.SpaceBetween,
  ALIGN_SPACE_AROUND: Align.SpaceAround,
  ALIGN_SPACE_EVENLY: Align.SpaceEvenly,
  BOX_SIZING_BORDER_BOX: BoxSizing.BorderBox,
  BOX_SIZING_CONTENT_BOX: BoxSizing.ContentBox,
  DIMENSION_WIDTH: Dimension.Width,
  DIMENSION_HEIGHT: Dimension.Height,
  DIRECTION_INHERIT: Direction.Inherit,
  DIRECTION_LTR: Direction.LTR,
  DIRECTION_RTL: Direction.RTL,
  DISPLAY_FLEX: Display.Flex,
  DISPLAY_NONE: Display.None,
  DISPLAY_CONTENTS: Display.Contents,
  EDGE_LEFT: Edge.Left,
  EDGE_TOP: Edge.Top,
  EDGE_RIGHT: Edge.Right,
  EDGE_BOTTOM: Edge.Bottom,
  EDGE_START: Edge.Start,
  EDGE_END: Edge.End,
  EDGE_HORIZONTAL: Edge.Horizontal,
  EDGE_VERTICAL: Edge.Vertical,
  EDGE_ALL: Edge.All,
  ERRATA_NONE: Errata.None,
  ERRATA_STRETCH_FLEX_BASIS: Errata.StretchFlexBasis,
  ERRATA_ABSOLUTE_POSITION_WITHOUT_INSETS_EXCLUDES_PADDING: Errata.AbsolutePositionWithoutInsetsExcludesPadding,
  ERRATA_ABSOLUTE_PERCENT_AGAINST_INNER_SIZE: Errata.AbsolutePercentAgainstInnerSize,
  ERRATA_ALL: Errata.All,
  ERRATA_CLASSIC: Errata.Classic,
  EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS: ExperimentalFeature.WebFlexBasis,
  FLEX_DIRECTION_COLUMN: FlexDirection.Column,
  FLEX_DIRECTION_COLUMN_REVERSE: FlexDirection.ColumnReverse,
  FLEX_DIRECTION_ROW: FlexDirection.Row,
  FLEX_DIRECTION_ROW_REVERSE: FlexDirection.RowReverse,
  GUTTER_COLUMN: Gutter.Column,
  GUTTER_ROW: Gutter.Row,
  GUTTER_ALL: Gutter.All,
  JUSTIFY_FLEX_START: Justify.FlexStart,
  JUSTIFY_CENTER: Justify.Center,
  JUSTIFY_FLEX_END: Justify.FlexEnd,
  JUSTIFY_SPACE_BETWEEN: Justify.SpaceBetween,
  JUSTIFY_SPACE_AROUND: Justify.SpaceAround,
  JUSTIFY_SPACE_EVENLY: Justify.SpaceEvenly,
  LOG_LEVEL_ERROR: LogLevel.Error,
  LOG_LEVEL_WARN: LogLevel.Warn,
  LOG_LEVEL_INFO: LogLevel.Info,
  LOG_LEVEL_DEBUG: LogLevel.Debug,
  LOG_LEVEL_VERBOSE: LogLevel.Verbose,
  LOG_LEVEL_FATAL: LogLevel.Fatal,
  MEASURE_MODE_UNDEFINED: MeasureMode.Undefined,
  MEASURE_MODE_EXACTLY: MeasureMode.Exactly,
  MEASURE_MODE_AT_MOST: MeasureMode.AtMost,
  NODE_TYPE_DEFAULT: NodeType.Default,
  NODE_TYPE_TEXT: NodeType.Text,
  OVERFLOW_VISIBLE: Overflow.Visible,
  OVERFLOW_HIDDEN: Overflow.Hidden,
  OVERFLOW_SCROLL: Overflow.Scroll,
  POSITION_TYPE_STATIC: PositionType.Static,
  POSITION_TYPE_RELATIVE: PositionType.Relative,
  POSITION_TYPE_ABSOLUTE: PositionType.Absolute,
  UNIT_UNDEFINED: Unit.Undefined,
  UNIT_POINT: Unit.Point,
  UNIT_PERCENT: Unit.Percent,
  UNIT_AUTO: Unit.Auto,
  WRAP_NO_WRAP: Wrap.NoWrap,
  WRAP_WRAP: Wrap.Wrap,
  WRAP_WRAP_REVERSE: Wrap.WrapReverse
};
function wrapAssembly(lib2) {
  function patch(prototype, name, fn) {
    const original = prototype[name];
    prototype[name] = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return fn.call(this, original, ...args);
    };
  }
  for (const fnName of ["setPosition", "setMargin", "setFlexBasis", "setWidth", "setHeight", "setMinWidth", "setMinHeight", "setMaxWidth", "setMaxHeight", "setPadding", "setGap"]) {
    const methods = {
      [Unit.Point]: lib2.Node.prototype[fnName],
      [Unit.Percent]: lib2.Node.prototype[`${fnName}Percent`],
      [Unit.Auto]: lib2.Node.prototype[`${fnName}Auto`]
    };
    patch(lib2.Node.prototype, fnName, function(original) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      const value2 = args.pop();
      let unit2, asNumber;
      if (value2 === "auto") {
        unit2 = Unit.Auto;
        asNumber = void 0;
      } else if (typeof value2 === "object") {
        unit2 = value2.unit;
        asNumber = value2.valueOf();
      } else {
        unit2 = typeof value2 === "string" && value2.endsWith("%") ? Unit.Percent : Unit.Point;
        asNumber = parseFloat(value2);
        if (value2 !== void 0 && !Number.isNaN(value2) && Number.isNaN(asNumber)) {
          throw new Error(`Invalid value ${value2} for ${fnName}`);
        }
      }
      if (!methods[unit2]) throw new Error(`Failed to execute "${fnName}": Unsupported unit '${value2}'`);
      if (asNumber !== void 0) {
        return methods[unit2].call(this, ...args, asNumber);
      } else {
        return methods[unit2].call(this, ...args);
      }
    });
  }
  function wrapMeasureFunction(measureFunction) {
    return lib2.MeasureCallback.implement({
      measure: function() {
        const {
          width,
          height: height2
        } = measureFunction(...arguments);
        return {
          width: width ?? NaN,
          height: height2 ?? NaN
        };
      }
    });
  }
  patch(lib2.Node.prototype, "setMeasureFunc", function(original, measureFunc) {
    if (measureFunc) {
      return original.call(this, wrapMeasureFunction(measureFunc));
    } else {
      return this.unsetMeasureFunc();
    }
  });
  function wrapDirtiedFunc(dirtiedFunction) {
    return lib2.DirtiedCallback.implement({
      dirtied: dirtiedFunction
    });
  }
  patch(lib2.Node.prototype, "setDirtiedFunc", function(original, dirtiedFunc) {
    original.call(this, wrapDirtiedFunc(dirtiedFunc));
  });
  patch(lib2.Config.prototype, "free", function() {
    lib2.Config.destroy(this);
  });
  patch(lib2.Node, "create", (_, config2) => {
    return config2 ? lib2.Node.createWithConfig(config2) : lib2.Node.createDefault();
  });
  patch(lib2.Node.prototype, "free", function() {
    lib2.Node.destroy(this);
  });
  patch(lib2.Node.prototype, "freeRecursive", function() {
    for (let t2 = 0, T = this.getChildCount(); t2 < T; ++t2) {
      this.getChild(0).freeRecursive();
    }
    this.free();
  });
  patch(lib2.Node.prototype, "calculateLayout", function(original) {
    let width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
    let height2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
    let direction = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Direction.LTR;
    return original.call(this, width, height2, direction);
  });
  return {
    Config: lib2.Config,
    Node: lib2.Node,
    ...constants
  };
}
async function loadYoga$1() {
  return wrapAssembly(await loadYoga$2());
}
const emojiRegex = () => {
  return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code.length; i2 < len; ++i2) {
    lookup[i2] = code[i2];
    revLookup[code.charCodeAt(i2)] = i2;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b642) {
  if (!inited) {
    init();
  }
  var i2, j, l2, tmp, placeHolders, arr;
  var len = b642.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b642[len - 2] === "=" ? 2 : b642[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i2 = 0, j = 0; i2 < l2; i2 += 4, j += 3) {
    tmp = revLookup[b642.charCodeAt(i2)] << 18 | revLookup[b642.charCodeAt(i2 + 1)] << 12 | revLookup[b642.charCodeAt(i2 + 2)] << 6 | revLookup[b642.charCodeAt(i2 + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b642.charCodeAt(i2)] << 2 | revLookup[b642.charCodeAt(i2 + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b642.charCodeAt(i2)] << 10 | revLookup[b642.charCodeAt(i2 + 1)] << 4 | revLookup[b642.charCodeAt(i2 + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint82, start2, end2) {
  var tmp;
  var output = [];
  for (var i2 = start2; i2 < end2; i2 += 3) {
    tmp = (uint82[i2] << 16) + (uint82[i2 + 1] << 8) + uint82[i2 + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint82) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint82, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset2, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer[offset2 + i2];
  i2 += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer[offset2 + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
}
function write3(buffer, value2, offset2, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer[offset2 + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer[offset2 + i2 - d2] |= s2 * 128;
}
var toString3 = {}.toString;
var isArray = Array.isArray || function(arr) {
  return toString3.call(arr) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var INSPECT_MAX_BYTES = 50;
Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
kMaxLength();
function kMaxLength() {
  return Buffer$1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length2) {
  if (kMaxLength() < length2) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length2);
    that.__proto__ = Buffer$1.prototype;
  } else {
    if (that === null) {
      that = new Buffer$1(length2);
    }
    that.length = length2;
  }
  return that;
}
function Buffer$1(arg, encodingOrOffset, length2) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
    return new Buffer$1(arg, encodingOrOffset, length2);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length2);
}
Buffer$1.poolSize = 8192;
Buffer$1._augment = function(arr) {
  arr.__proto__ = Buffer$1.prototype;
  return arr;
};
function from(that, value2, encodingOrOffset, length2) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value2, encodingOrOffset, length2);
  }
  if (typeof value2 === "string") {
    return fromString(that, value2, encodingOrOffset);
  }
  return fromObject(that, value2);
}
Buffer$1.from = function(value2, encodingOrOffset, length2) {
  return from(null, value2, encodingOrOffset, length2);
};
if (Buffer$1.TYPED_ARRAY_SUPPORT) {
  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
  Buffer$1.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer$1[Symbol.species] === Buffer$1) ;
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill4, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill4 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill4, encoding) : createBuffer(that, size).fill(fill4);
  }
  return createBuffer(that, size);
}
Buffer$1.alloc = function(size, fill4, encoding) {
  return alloc(null, size, fill4, encoding);
};
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (var i2 = 0; i2 < size; ++i2) {
      that[i2] = 0;
    }
  }
  return that;
}
Buffer$1.allocUnsafe = function(size) {
  return allocUnsafe(null, size);
};
Buffer$1.allocUnsafeSlow = function(size) {
  return allocUnsafe(null, size);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length2 = byteLength(string, encoding) | 0;
  that = createBuffer(that, length2);
  var actual = that.write(string, encoding);
  if (actual !== length2) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length2 = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length2);
  for (var i2 = 0; i2 < length2; i2 += 1) {
    that[i2] = array[i2] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length2) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length2 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length2 === void 0) {
    array = new Uint8Array(array);
  } else if (length2 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length2);
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer$1.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length2) {
  if (length2 >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length2 | 0;
}
Buffer$1.isBuffer = isBuffer$1;
function internalIsBuffer(b2) {
  return !!(b2 != null && b2._isBuffer);
}
Buffer$1.compare = function compare6(a2, b2) {
  if (!internalIsBuffer(a2) || !internalIsBuffer(b2)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a2 === b2) return 0;
  var x = a2.length;
  var y2 = b2.length;
  for (var i2 = 0, len = Math.min(x, y2); i2 < len; ++i2) {
    if (a2[i2] !== b2[i2]) {
      x = a2[i2];
      y2 = b2[i2];
      break;
    }
  }
  if (x < y2) return -1;
  if (y2 < x) return 1;
  return 0;
};
Buffer$1.isEncoding = function isEncoding3(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer$1.concat = function concat4(list, length2) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer$1.alloc(0);
  }
  var i2;
  if (length2 === void 0) {
    length2 = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      length2 += list[i2].length;
    }
  }
  var buffer = Buffer$1.allocUnsafe(length2);
  var pos = 0;
  for (i2 = 0; i2 < list.length; ++i2) {
    var buf = list[i2];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0) return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$1.byteLength = byteLength;
function slowToString(encoding, start2, end2) {
  var loweredCase = false;
  if (start2 === void 0 || start2 < 0) {
    start2 = 0;
  }
  if (start2 > this.length) {
    return "";
  }
  if (end2 === void 0 || end2 > this.length) {
    end2 = this.length;
  }
  if (end2 <= 0) {
    return "";
  }
  end2 >>>= 0;
  start2 >>>= 0;
  if (end2 <= start2) {
    return "";
  }
  if (!encoding) encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start2, end2);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start2, end2);
      case "ascii":
        return asciiSlice(this, start2, end2);
      case "latin1":
      case "binary":
        return latin1Slice(this, start2, end2);
      case "base64":
        return base64Slice(this, start2, end2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start2, end2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$1.prototype._isBuffer = true;
function swap(b2, n3, m2) {
  var i2 = b2[n3];
  b2[n3] = b2[m2];
  b2[m2] = i2;
}
Buffer$1.prototype.swap16 = function swap163() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 2) {
    swap(this, i2, i2 + 1);
  }
  return this;
};
Buffer$1.prototype.swap32 = function swap323() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 4) {
    swap(this, i2, i2 + 3);
    swap(this, i2 + 1, i2 + 2);
  }
  return this;
};
Buffer$1.prototype.swap64 = function swap643() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 8) {
    swap(this, i2, i2 + 7);
    swap(this, i2 + 1, i2 + 6);
    swap(this, i2 + 2, i2 + 5);
    swap(this, i2 + 3, i2 + 4);
  }
  return this;
};
Buffer$1.prototype.toString = function toString4() {
  var length2 = this.length | 0;
  if (length2 === 0) return "";
  if (arguments.length === 0) return utf8Slice(this, 0, length2);
  return slowToString.apply(this, arguments);
};
Buffer$1.prototype.equals = function equals3(b2) {
  if (!internalIsBuffer(b2)) throw new TypeError("Argument must be a Buffer");
  if (this === b2) return true;
  return Buffer$1.compare(this, b2) === 0;
};
Buffer$1.prototype.inspect = function inspect4() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2) str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer$1.prototype.compare = function compare7(target, start2, end2, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start2 === void 0) {
    start2 = 0;
  }
  if (end2 === void 0) {
    end2 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start2 >= end2) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start2 >= end2) {
    return 1;
  }
  start2 >>>= 0;
  end2 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y2 = end2 - start2;
  var len = Math.min(x, y2);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start2, end2);
  for (var i2 = 0; i2 < len; ++i2) {
    if (thisCopy[i2] !== targetCopy[i2]) {
      x = thisCopy[i2];
      y2 = targetCopy[i2];
      break;
    }
  }
  if (x < y2) return -1;
  if (y2 < x) return 1;
  return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1;
  }
  if (typeof val === "string") {
    val = Buffer$1.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i3) {
    if (indexSize === 1) {
      return buf[i3];
    } else {
      return buf.readUInt16BE(i3 * indexSize);
    }
  }
  var i2;
  if (dir) {
    var foundIndex = -1;
    for (i2 = byteOffset; i2 < arrLength; i2++) {
      if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1) foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i2 = byteOffset; i2 >= 0; i2--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i2 + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i2;
    }
  }
  return -1;
}
Buffer$1.prototype.includes = function includes4(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer$1.prototype.indexOf = function indexOf4(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer$1.prototype.lastIndexOf = function lastIndexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset2, length2) {
  offset2 = Number(offset2) || 0;
  var remaining = buf.length - offset2;
  if (!length2) {
    length2 = remaining;
  } else {
    length2 = Number(length2);
    if (length2 > remaining) {
      length2 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
  if (length2 > strLen / 2) {
    length2 = strLen / 2;
  }
  for (var i2 = 0; i2 < length2; ++i2) {
    var parsed = parseInt(string.substr(i2 * 2, 2), 16);
    if (isNaN(parsed)) return i2;
    buf[offset2 + i2] = parsed;
  }
  return i2;
}
function utf8Write(buf, string, offset2, length2) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset2), buf, offset2, length2);
}
function asciiWrite(buf, string, offset2, length2) {
  return blitBuffer(asciiToBytes(string), buf, offset2, length2);
}
function latin1Write(buf, string, offset2, length2) {
  return asciiWrite(buf, string, offset2, length2);
}
function base64Write(buf, string, offset2, length2) {
  return blitBuffer(base64ToBytes(string), buf, offset2, length2);
}
function ucs2Write(buf, string, offset2, length2) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset2), buf, offset2, length2);
}
Buffer$1.prototype.write = function write4(string, offset2, length2, encoding) {
  if (offset2 === void 0) {
    encoding = "utf8";
    length2 = this.length;
    offset2 = 0;
  } else if (length2 === void 0 && typeof offset2 === "string") {
    encoding = offset2;
    length2 = this.length;
    offset2 = 0;
  } else if (isFinite(offset2)) {
    offset2 = offset2 | 0;
    if (isFinite(length2)) {
      length2 = length2 | 0;
      if (encoding === void 0) encoding = "utf8";
    } else {
      encoding = length2;
      length2 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset2;
  if (length2 === void 0 || length2 > remaining) length2 = remaining;
  if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding) encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset2, length2);
      case "utf8":
      case "utf-8":
        return utf8Write(this, string, offset2, length2);
      case "ascii":
        return asciiWrite(this, string, offset2, length2);
      case "latin1":
      case "binary":
        return latin1Write(this, string, offset2, length2);
      case "base64":
        return base64Write(this, string, offset2, length2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset2, length2);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer$1.prototype.toJSON = function toJSON3() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start2, end2) {
  if (start2 === 0 && end2 === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start2, end2));
  }
}
function utf8Slice(buf, start2, end2) {
  end2 = Math.min(buf.length, end2);
  var res = [];
  var i2 = start2;
  while (i2 < end2) {
    var firstByte = buf[i2];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i2 + bytesPerSequence <= end2) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i2 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          fourthByte = buf[i2 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i2 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i2 = start2; i2 < end2; ++i2) {
    ret += String.fromCharCode(buf[i2] & 127);
  }
  return ret;
}
function latin1Slice(buf, start2, end2) {
  var ret = "";
  end2 = Math.min(buf.length, end2);
  for (var i2 = start2; i2 < end2; ++i2) {
    ret += String.fromCharCode(buf[i2]);
  }
  return ret;
}
function hexSlice(buf, start2, end2) {
  var len = buf.length;
  if (!start2 || start2 < 0) start2 = 0;
  if (!end2 || end2 < 0 || end2 > len) end2 = len;
  var out = "";
  for (var i2 = start2; i2 < end2; ++i2) {
    out += toHex(buf[i2]);
  }
  return out;
}
function utf16leSlice(buf, start2, end2) {
  var bytes = buf.slice(start2, end2);
  var res = "";
  for (var i2 = 0; i2 < bytes.length; i2 += 2) {
    res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
  }
  return res;
}
Buffer$1.prototype.slice = function slice4(start2, end2) {
  var len = this.length;
  start2 = ~~start2;
  end2 = end2 === void 0 ? len : ~~end2;
  if (start2 < 0) {
    start2 += len;
    if (start2 < 0) start2 = 0;
  } else if (start2 > len) {
    start2 = len;
  }
  if (end2 < 0) {
    end2 += len;
    if (end2 < 0) end2 = 0;
  } else if (end2 > len) {
    end2 = len;
  }
  if (end2 < start2) end2 = start2;
  var newBuf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start2, end2);
    newBuf.__proto__ = Buffer$1.prototype;
  } else {
    var sliceLen = end2 - start2;
    newBuf = new Buffer$1(sliceLen, void 0);
    for (var i2 = 0; i2 < sliceLen; ++i2) {
      newBuf[i2] = this[i2 + start2];
    }
  }
  return newBuf;
};
function checkOffset(offset2, ext, length2) {
  if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
  if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
}
Buffer$1.prototype.readUIntLE = function readUIntLE3(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) checkOffset(offset2, byteLength2, this.length);
  var val = this[offset2];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength2 && (mul *= 256)) {
    val += this[offset2 + i2] * mul;
  }
  return val;
};
Buffer$1.prototype.readUIntBE = function readUIntBE3(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    checkOffset(offset2, byteLength2, this.length);
  }
  var val = this[offset2 + --byteLength2];
  var mul = 1;
  while (byteLength2 > 0 && (mul *= 256)) {
    val += this[offset2 + --byteLength2] * mul;
  }
  return val;
};
Buffer$1.prototype.readUInt8 = function readUInt84(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 1, this.length);
  return this[offset2];
};
Buffer$1.prototype.readUInt16LE = function readUInt16LE4(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  return this[offset2] | this[offset2 + 1] << 8;
};
Buffer$1.prototype.readUInt16BE = function readUInt16BE4(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  return this[offset2] << 8 | this[offset2 + 1];
};
Buffer$1.prototype.readUInt32LE = function readUInt32LE4(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
};
Buffer$1.prototype.readUInt32BE = function readUInt32BE4(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
};
Buffer$1.prototype.readIntLE = function readIntLE3(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) checkOffset(offset2, byteLength2, this.length);
  var val = this[offset2];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength2 && (mul *= 256)) {
    val += this[offset2 + i2] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer$1.prototype.readIntBE = function readIntBE3(offset2, byteLength2, noAssert) {
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) checkOffset(offset2, byteLength2, this.length);
  var i2 = byteLength2;
  var mul = 1;
  var val = this[offset2 + --i2];
  while (i2 > 0 && (mul *= 256)) {
    val += this[offset2 + --i2] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer$1.prototype.readInt8 = function readInt83(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 1, this.length);
  if (!(this[offset2] & 128)) return this[offset2];
  return (255 - this[offset2] + 1) * -1;
};
Buffer$1.prototype.readInt16LE = function readInt16LE3(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  var val = this[offset2] | this[offset2 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$1.prototype.readInt16BE = function readInt16BE3(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 2, this.length);
  var val = this[offset2 + 1] | this[offset2] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$1.prototype.readInt32LE = function readInt32LE4(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
};
Buffer$1.prototype.readInt32BE = function readInt32BE4(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
};
Buffer$1.prototype.readFloatLE = function readFloatLE3(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return read(this, offset2, true, 23, 4);
};
Buffer$1.prototype.readFloatBE = function readFloatBE3(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 4, this.length);
  return read(this, offset2, false, 23, 4);
};
Buffer$1.prototype.readDoubleLE = function readDoubleLE3(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 8, this.length);
  return read(this, offset2, true, 52, 8);
};
Buffer$1.prototype.readDoubleBE = function readDoubleBE3(offset2, noAssert) {
  if (!noAssert) checkOffset(offset2, 8, this.length);
  return read(this, offset2, false, 52, 8);
};
function checkInt(buf, value2, offset2, ext, max2, min2) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max2 || value2 < min2) throw new RangeError('"value" argument is out of bounds');
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer$1.prototype.writeUIntLE = function writeUIntLE3(value2, offset2, byteLength2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value2, offset2, byteLength2, maxBytes, 0);
  }
  var mul = 1;
  var i2 = 0;
  this[offset2] = value2 & 255;
  while (++i2 < byteLength2 && (mul *= 256)) {
    this[offset2 + i2] = value2 / mul & 255;
  }
  return offset2 + byteLength2;
};
Buffer$1.prototype.writeUIntBE = function writeUIntBE3(value2, offset2, byteLength2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value2, offset2, byteLength2, maxBytes, 0);
  }
  var i2 = byteLength2 - 1;
  var mul = 1;
  this[offset2 + i2] = value2 & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    this[offset2 + i2] = value2 / mul & 255;
  }
  return offset2 + byteLength2;
};
Buffer$1.prototype.writeUInt8 = function writeUInt83(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 1, 255, 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
function objectWriteUInt16(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 65535 + value2 + 1;
  for (var i2 = 0, j = Math.min(buf.length - offset2, 2); i2 < j; ++i2) {
    buf[offset2 + i2] = (value2 & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
  }
}
Buffer$1.prototype.writeUInt16LE = function writeUInt16LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer$1.prototype.writeUInt16BE = function writeUInt16BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 65535, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt16(this, value2, offset2, false);
  }
  return offset2 + 2;
};
function objectWriteUInt32(buf, value2, offset2, littleEndian) {
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  for (var i2 = 0, j = Math.min(buf.length - offset2, 4); i2 < j; ++i2) {
    buf[offset2 + i2] = value2 >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
  }
}
Buffer$1.prototype.writeUInt32LE = function writeUInt32LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset2 + 3] = value2 >>> 24;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer$1.prototype.writeUInt32BE = function writeUInt32BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 4294967295, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset2, false);
  }
  return offset2 + 4;
};
Buffer$1.prototype.writeIntLE = function writeIntLE3(value2, offset2, byteLength2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value2, offset2, byteLength2, limit - 1, -limit);
  }
  var i2 = 0;
  var mul = 1;
  var sub = 0;
  this[offset2] = value2 & 255;
  while (++i2 < byteLength2 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i2 - 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i2] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength2;
};
Buffer$1.prototype.writeIntBE = function writeIntBE3(value2, offset2, byteLength2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value2, offset2, byteLength2, limit - 1, -limit);
  }
  var i2 = byteLength2 - 1;
  var mul = 1;
  var sub = 0;
  this[offset2 + i2] = value2 & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset2 + i2 + 1] !== 0) {
      sub = 1;
    }
    this[offset2 + i2] = (value2 / mul >> 0) - sub & 255;
  }
  return offset2 + byteLength2;
};
Buffer$1.prototype.writeInt8 = function writeInt83(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 1, 127, -128);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  if (value2 < 0) value2 = 255 + value2 + 1;
  this[offset2] = value2 & 255;
  return offset2 + 1;
};
Buffer$1.prototype.writeInt16LE = function writeInt16LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16(this, value2, offset2, true);
  }
  return offset2 + 2;
};
Buffer$1.prototype.writeInt16BE = function writeInt16BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 2, 32767, -32768);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 8;
    this[offset2 + 1] = value2 & 255;
  } else {
    objectWriteUInt16(this, value2, offset2, false);
  }
  return offset2 + 2;
};
Buffer$1.prototype.writeInt32LE = function writeInt32LE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >>> 8;
    this[offset2 + 2] = value2 >>> 16;
    this[offset2 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt32(this, value2, offset2, true);
  }
  return offset2 + 4;
};
Buffer$1.prototype.writeInt32BE = function writeInt32BE3(value2, offset2, noAssert) {
  value2 = +value2;
  offset2 = offset2 | 0;
  if (!noAssert) checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset2] = value2 >>> 24;
    this[offset2 + 1] = value2 >>> 16;
    this[offset2 + 2] = value2 >>> 8;
    this[offset2 + 3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset2, false);
  }
  return offset2 + 4;
};
function checkIEEE754(buf, value2, offset2, ext, max2, min2) {
  if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  if (offset2 < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value2, offset2, 4);
  }
  write3(buf, value2, offset2, littleEndian, 23, 4);
  return offset2 + 4;
}
Buffer$1.prototype.writeFloatLE = function writeFloatLE3(value2, offset2, noAssert) {
  return writeFloat(this, value2, offset2, true, noAssert);
};
Buffer$1.prototype.writeFloatBE = function writeFloatBE3(value2, offset2, noAssert) {
  return writeFloat(this, value2, offset2, false, noAssert);
};
function writeDouble(buf, value2, offset2, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value2, offset2, 8);
  }
  write3(buf, value2, offset2, littleEndian, 52, 8);
  return offset2 + 8;
}
Buffer$1.prototype.writeDoubleLE = function writeDoubleLE3(value2, offset2, noAssert) {
  return writeDouble(this, value2, offset2, true, noAssert);
};
Buffer$1.prototype.writeDoubleBE = function writeDoubleBE3(value2, offset2, noAssert) {
  return writeDouble(this, value2, offset2, false, noAssert);
};
Buffer$1.prototype.copy = function copy4(target, targetStart, start2, end2) {
  if (!start2) start2 = 0;
  if (!end2 && end2 !== 0) end2 = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end2 > 0 && end2 < start2) end2 = start2;
  if (end2 === start2) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start2 < 0 || start2 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
  if (end2 > this.length) end2 = this.length;
  if (target.length - targetStart < end2 - start2) {
    end2 = target.length - targetStart + start2;
  }
  var len = end2 - start2;
  var i2;
  if (this === target && start2 < targetStart && targetStart < end2) {
    for (i2 = len - 1; i2 >= 0; --i2) {
      target[i2 + targetStart] = this[i2 + start2];
    }
  } else if (len < 1e3 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (i2 = 0; i2 < len; ++i2) {
      target[i2 + targetStart] = this[i2 + start2];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start2, start2 + len),
      targetStart
    );
  }
  return len;
};
Buffer$1.prototype.fill = function fill3(val, start2, end2, encoding) {
  if (typeof val === "string") {
    if (typeof start2 === "string") {
      encoding = start2;
      start2 = 0;
      end2 = this.length;
    } else if (typeof end2 === "string") {
      encoding = end2;
      end2 = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer$1.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start2 < 0 || this.length < start2 || this.length < end2) {
    throw new RangeError("Out of range index");
  }
  if (end2 <= start2) {
    return this;
  }
  start2 = start2 >>> 0;
  end2 = end2 === void 0 ? this.length : end2 >>> 0;
  if (!val) val = 0;
  var i2;
  if (typeof val === "number") {
    for (i2 = start2; i2 < end2; ++i2) {
      this[i2] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer$1(val, encoding).toString());
    var len = bytes.length;
    for (i2 = 0; i2 < end2 - start2; ++i2) {
      this[i2 + start2] = bytes[i2 % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2) return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n3) {
  if (n3 < 16) return "0" + n3.toString(16);
  return n3.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length2 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i2 = 0; i2 < length2; ++i2) {
    codePoint = string.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length2) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    byteArray.push(str.charCodeAt(i2) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    if ((units -= 2) < 0) break;
    c2 = str.charCodeAt(i2);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src2, dst, offset2, length2) {
  for (var i2 = 0; i2 < length2; ++i2) {
    if (i2 + offset2 >= dst.length || i2 >= src2.length) break;
    dst[i2 + offset2] = src2[i2];
  }
  return i2;
}
function isnan(val) {
  return val !== val;
}
function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
class PNG2 {
  constructor(data2) {
    __publicField(this, "data");
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "format");
    const png = new PNG$1(data2);
    this.data = data2;
    this.width = png.width;
    this.height = png.height;
    this.format = "png";
  }
  static isValid(data2) {
    try {
      return !!new PNG2(data2);
    } catch {
      return false;
    }
  }
}
class JPEG2 {
  constructor(data2) {
    __publicField(this, "data");
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "format");
    this.data = data2;
    this.format = "jpeg";
    this.width = 0;
    this.height = 0;
    if (data2.readUInt16BE(0) !== 65496) {
      throw new Error("SOI not found in JPEG");
    }
    const markers = _JPEG.decode(this.data);
    let orientation;
    for (let i2 = 0; i2 < markers.length; i2 += 1) {
      const marker = markers[i2];
      if (marker.name === "EXIF" && marker.entries.orientation) {
        orientation = marker.entries.orientation;
      }
      if (marker.name === "SOF") {
        this.width || (this.width = marker.width);
        this.height || (this.height = marker.height);
      }
    }
    if (orientation > 4) {
      [this.width, this.height] = [this.height, this.width];
    }
  }
  static isValid(data2) {
    return data2 && Buffer$1.isBuffer(data2) && data2.readUInt16BE(0) === 65496;
  }
}
const createCache = ({ limit = 100 } = {}) => {
  let cache2 = {};
  let keys = [];
  return {
    get: (key) => key ? cache2[key] : null,
    set: (key, value2) => {
      keys.push(key);
      if (keys.length > limit) {
        delete cache2[keys.shift()];
      }
      cache2[key] = value2;
    },
    reset: () => {
      cache2 = {};
      keys = [];
    },
    length: () => keys.length
  };
};
const IMAGE_CACHE = createCache({ limit: 30 });
const isBuffer = Buffer$1.isBuffer;
const isBlob = (src2) => {
  return typeof Blob !== "undefined" && src2 instanceof Blob;
};
const isDataImageSrc = (src2) => {
  return "data" in src2;
};
const isBase64Src = (imageSrc) => "uri" in imageSrc && /^data:image\/[a-zA-Z]*;base64,[^"]*/g.test(imageSrc.uri);
const fetchRemoteFile = async (src2) => {
  const { method = "GET", headers, body, credentials } = src2;
  const response = await fetch(src2.uri, {
    method,
    headers,
    body,
    credentials
  });
  const buffer = await response.arrayBuffer();
  return Buffer$1.from(buffer);
};
const isValidFormat = (format2) => {
  const lower = format2.toLowerCase();
  return lower === "jpg" || lower === "jpeg" || lower === "png";
};
const guessFormat = (buffer) => {
  let format2;
  if (JPEG2.isValid(buffer)) {
    format2 = "jpg";
  } else if (PNG2.isValid(buffer)) {
    format2 = "png";
  }
  return format2;
};
function getImage(body, format2) {
  switch (format2.toLowerCase()) {
    case "jpg":
    case "jpeg":
      return new JPEG2(body);
    case "png":
      return new PNG2(body);
    default:
      return null;
  }
}
const resolveBase64Image = async ({ uri }) => {
  const match = /^data:image\/([a-zA-Z]*);base64,([^"]*)/g.exec(uri);
  if (!match)
    throw new Error(`Invalid base64 image: ${uri}`);
  const format2 = match[1];
  const data2 = match[2];
  if (!isValidFormat(format2))
    throw new Error(`Base64 image invalid format: ${format2}`);
  return getImage(Buffer$1.from(data2, "base64"), format2);
};
const resolveImageFromData = async (src2) => {
  if (src2.data && src2.format) {
    return getImage(src2.data, src2.format);
  }
  throw new Error(`Invalid data given for local file: ${JSON.stringify(src2)}`);
};
const resolveBufferImage = async (buffer) => {
  const format2 = guessFormat(buffer);
  if (format2) {
    return getImage(buffer, format2);
  }
  return null;
};
const resolveBlobImage = async (blob) => {
  const { type } = blob;
  if (!type || type === "application/octet-stream") {
    const arrayBuffer = await blob.arrayBuffer();
    const buffer2 = Buffer$1.from(arrayBuffer);
    return resolveBufferImage(buffer2);
  }
  if (!type.startsWith("image/")) {
    throw new Error(`Invalid blob type: ${type}`);
  }
  const format2 = type.replace("image/", "");
  if (!isValidFormat(format2)) {
    throw new Error(`Invalid blob type: ${type}`);
  }
  const buffer = await blob.arrayBuffer();
  return getImage(Buffer$1.from(buffer), format2);
};
const getImageFormat = (body) => {
  const isPng = body[0] === 137 && body[1] === 80 && body[2] === 78 && body[3] === 71 && body[4] === 13 && body[5] === 10 && body[6] === 26 && body[7] === 10;
  const isJpg = body[0] === 255 && body[1] === 216 && body[2] === 255;
  let extension = "";
  if (isPng) {
    extension = "png";
  } else if (isJpg) {
    extension = "jpg";
  } else {
    throw new Error("Not valid image extension");
  }
  return extension;
};
const resolveImageFromUrl = async (src2) => {
  const data2 = await fetchRemoteFile(src2);
  const format2 = getImageFormat(data2);
  return getImage(data2, format2);
};
const getCacheKey = (src2) => {
  if (isBlob(src2) || isBuffer(src2))
    return null;
  if (isDataImageSrc(src2))
    return src2.data.toString();
  return src2.uri;
};
const resolveImage = (src2, { cache: cache2 = true } = {}) => {
  let image;
  const cacheKey = getCacheKey(src2);
  if (isBlob(src2)) {
    image = resolveBlobImage(src2);
  } else if (isBuffer(src2)) {
    image = resolveBufferImage(src2);
  } else if (cache2 && IMAGE_CACHE.get(cacheKey)) {
    return IMAGE_CACHE.get(cacheKey);
  } else if (isBase64Src(src2)) {
    image = resolveBase64Image(src2);
  } else if (isDataImageSrc(src2)) {
    image = resolveImageFromData(src2);
  } else {
    image = resolveImageFromUrl(src2);
  }
  if (!image) {
    throw new Error("Cannot resolve image");
  }
  if (cache2 && cacheKey) {
    IMAGE_CACHE.set(cacheKey, image);
  }
  return image;
};
const transformText = (text, transformation) => {
  switch (transformation) {
    case "uppercase":
      return text.toUpperCase();
    case "lowercase":
      return text.toLowerCase();
    case "capitalize":
      return capitalize(text);
    case "upperfirst":
      return upperFirst(text);
    default:
      return text;
  }
};
const isTspan = (node) => node.type === Tspan;
const isTextInstance$4 = (node) => node.type === TextInstance;
const engines$1 = {
  bidi: bidiEngine,
  linebreaker,
  justification,
  textDecoration,
  scriptItemizer,
  wordHyphenation,
  fontSubstitution
};
const engine$1 = layoutEngine(engines$1);
const getFragments$1 = (fontStore2, instance) => {
  if (!instance)
    return [{ string: "" }];
  const fragments = [];
  const { fill: fill4 = "black", fontFamily = "Helvetica", fontWeight, fontStyle, fontSize = 18, textDecorationColor, textDecorationStyle, textTransform, opacity } = instance.props;
  const _textDecoration = instance.props.textDecoration;
  const fontFamilies = typeof fontFamily === "string" ? [fontFamily] : [...fontFamily || []];
  fontFamilies.push("Helvetica");
  const font = fontFamilies.map((fontFamilyName) => {
    const opts2 = { fontFamily: fontFamilyName, fontWeight, fontStyle };
    const obj = fontStore2.getFont(opts2);
    return obj == null ? void 0 : obj.data;
  });
  const attributes2 = {
    font,
    opacity,
    fontSize,
    color: fill4,
    underlineStyle: textDecorationStyle,
    underline: _textDecoration === "underline" || _textDecoration === "underline line-through" || _textDecoration === "line-through underline",
    underlineColor: textDecorationColor || fill4,
    strike: _textDecoration === "line-through" || _textDecoration === "underline line-through" || _textDecoration === "line-through underline",
    strikeStyle: textDecorationStyle,
    strikeColor: textDecorationColor || fill4
  };
  for (let i2 = 0; i2 < instance.children.length; i2 += 1) {
    const child = instance.children[i2];
    if (isTextInstance$4(child)) {
      fragments.push({
        string: transformText(child.value, textTransform),
        attributes: attributes2
      });
    } else if (child) {
      fragments.push(...getFragments$1(fontStore2, child));
    }
  }
  return fragments;
};
const getAttributedString$1 = (fontStore2, instance) => fromFragments(getFragments$1(fontStore2, instance));
const AlmostInfinity = 999999999999;
const shrinkWhitespaceFactor = { before: -0.5, after: -0.5 };
const layoutTspan = (fontStore2) => (node, xOffset) => {
  var _a;
  const attributedString = getAttributedString$1(fontStore2, node);
  const x = node.props.x === void 0 ? xOffset : node.props.x;
  const y2 = ((_a = node.props) == null ? void 0 : _a.y) || 0;
  const container = { x, y: y2, width: AlmostInfinity, height: AlmostInfinity };
  const hyphenationCallback = node.props.hyphenationCallback || (fontStore2 == null ? void 0 : fontStore2.getHyphenationCallback()) || null;
  const layoutOptions = { hyphenationCallback, shrinkWhitespaceFactor };
  const lines = engine$1(attributedString, container, layoutOptions).flat();
  return Object.assign({}, node, { lines });
};
const joinTSpanLines = (node) => {
  const children = node.children.map((child, index2) => {
    if (!isTspan(child))
      return child;
    const textInstance = child.children[0];
    if (child.props.x === void 0 && index2 < node.children.length - 1 && (textInstance == null ? void 0 : textInstance.value)) {
      return Object.assign({}, child, {
        children: [{ ...textInstance, value: `${textInstance.value} ` }]
      });
    }
    return child;
  }, []);
  return Object.assign({}, node, { children });
};
const layoutText$1 = (fontStore2, node) => {
  var _a;
  if (!node.children)
    return node;
  let currentXOffset = ((_a = node.props) == null ? void 0 : _a.x) || 0;
  const layoutFn = layoutTspan(fontStore2);
  const joinedNode = joinTSpanLines(node);
  const children = joinedNode.children.map((child) => {
    const childWithLayout = layoutFn(child, currentXOffset);
    currentXOffset += childWithLayout.lines[0].xAdvance;
    return childWithLayout;
  });
  return Object.assign({}, node, { children });
};
const isDefs = (node) => node.type === Defs;
const getDefs = (node) => {
  const children = node.children || [];
  const defs = children.find(isDefs);
  const values = (defs == null ? void 0 : defs.children) || [];
  return values.reduce((acc, value2) => {
    var _a;
    const id = (_a = value2.props) == null ? void 0 : _a.id;
    if (id)
      acc[id] = value2;
    return acc;
  }, {});
};
const isNotDefs = (node) => node.type !== Defs;
const detachDefs = (node) => {
  if (!node.children)
    return node;
  const children = node.children.filter(isNotDefs);
  return Object.assign({}, node, { children });
};
const URL_REGEX = /url\(['"]?#([^'"]+)['"]?\)/;
const replaceDef = (defs, value2) => {
  if (!value2)
    return void 0;
  if (!URL_REGEX.test(value2))
    return value2;
  const match = value2.match(URL_REGEX);
  return defs[match[1]];
};
const parseNodeDefs = (defs) => (node) => {
  const props = node.props;
  const fill4 = `fill` in props ? replaceDef(defs, props == null ? void 0 : props.fill) : void 0;
  const clipPath2 = `clipPath` in props ? replaceDef(defs, props == null ? void 0 : props.clipPath) : void 0;
  const newProps = Object.assign({}, node.props, { fill: fill4, clipPath: clipPath2 });
  const children = node.children ? node.children.map(parseNodeDefs(defs)) : void 0;
  return Object.assign({}, node, { props: newProps, children });
};
const parseDefs = (root) => {
  if (!root.children)
    return root;
  const defs = getDefs(root);
  const children = root.children.map(parseNodeDefs(defs));
  return Object.assign({}, root, { children });
};
const replaceDefs = (node) => {
  return detachDefs(parseDefs(node));
};
const parseViewbox = (value2) => {
  if (!value2)
    return null;
  if (typeof value2 !== "string")
    return value2;
  const values = value2.split(/[,\s]+/).map(parseFloat$1);
  if (values.length !== 4)
    return null;
  return { minX: values[0], minY: values[1], maxX: values[2], maxY: values[3] };
};
const getContainer$1 = (node) => {
  const viewbox = parseViewbox(node.props.viewBox);
  if (viewbox) {
    return { width: viewbox.maxX, height: viewbox.maxY };
  }
  if (node.props.width && node.props.height) {
    return {
      width: parseFloat$1(node.props.width),
      height: parseFloat$1(node.props.height)
    };
  }
  return { width: 0, height: 0 };
};
const BASE_SVG_INHERITED_PROPS = [
  "x",
  "y",
  "clipPath",
  "clipRule",
  "opacity",
  "fill",
  "fillOpacity",
  "fillRule",
  "stroke",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeOpacity",
  "strokeWidth",
  "textAnchor",
  "dominantBaseline",
  "color",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "opacity",
  "textDecoration",
  "lineHeight",
  "textAlign",
  "visibility",
  "wordSpacing"
];
const TEXT_SVG_INHERITED_PROPS = without(["x"], BASE_SVG_INHERITED_PROPS);
const SVG_INHERITED_PROPS = {
  [Text]: TEXT_SVG_INHERITED_PROPS
};
const getInheritProps = (node) => {
  const props = node.props || {};
  const svgInheritedProps = SVG_INHERITED_PROPS[node.type] ?? BASE_SVG_INHERITED_PROPS;
  return pick(svgInheritedProps, props);
};
const inheritProps = (node) => {
  if (!node.children)
    return node;
  const inheritedProps = getInheritProps(node);
  const children = node.children.map((child) => {
    const props = Object.assign({}, inheritedProps, child.props || {});
    const newChild = Object.assign({}, child, { props });
    return inheritProps(newChild);
  });
  return Object.assign({}, node, { children });
};
const parseAspectRatio = (value2) => {
  if (typeof value2 !== "string")
    return value2;
  const match = value2.replace(/[\s\r\t\n]+/gm, " ").replace(/^defer\s/, "").split(" ");
  const align = match[0] || "xMidYMid";
  const meetOrSlice = match[1] || "meet";
  return { align, meetOrSlice };
};
const STYLE_PROPS = [
  "width",
  "height",
  "color",
  "stroke",
  "strokeWidth",
  "opacity",
  "fillOpacity",
  "strokeOpacity",
  "fill",
  "fillRule",
  "clipPath",
  "offset",
  "transform",
  "strokeLinejoin",
  "strokeLinecap",
  "strokeDasharray",
  "gradientUnits",
  "gradientTransform"
];
const VERTICAL_PROPS = ["y", "y1", "y2", "height", "cy", "ry"];
const HORIZONTAL_PROPS = ["x", "x1", "x2", "width", "cx", "rx"];
const isSvg$3 = (node) => node.type === Svg;
const isText$5 = (node) => node.type === Text;
const isTextInstance$3 = (node) => node.type === TextInstance;
const transformPercent = (container) => (props) => mapValues(props, (value2, key) => {
  const match = matchPercent(value2);
  if (match && VERTICAL_PROPS.includes(key)) {
    return match.percent * container.height;
  }
  if (match && HORIZONTAL_PROPS.includes(key)) {
    return match.percent * container.width;
  }
  return value2;
});
const parsePercent = (value2) => {
  const match = matchPercent(value2);
  return match ? match.percent : parseFloat$1(value2);
};
const parseTransform = (container) => (value2) => {
  return resolveStyles$1(container, { transform: value2 }).transform;
};
const parseProps = (container) => (node) => {
  let props = transformPercent(container)(node.props);
  props = evolve({
    x: parseFloat$1,
    x1: parseFloat$1,
    x2: parseFloat$1,
    y: parseFloat$1,
    y1: parseFloat$1,
    y2: parseFloat$1,
    r: parseFloat$1,
    rx: parseFloat$1,
    ry: parseFloat$1,
    cx: parseFloat$1,
    cy: parseFloat$1,
    width: parseFloat$1,
    height: parseFloat$1,
    offset: parsePercent,
    fill: transformColor,
    opacity: parsePercent,
    stroke: transformColor,
    stopOpacity: parsePercent,
    stopColor: transformColor,
    transform: parseTransform(container),
    gradientTransform: parseTransform(container)
  }, props);
  return Object.assign({}, node, { props });
};
const mergeStyles$1 = (node) => {
  const style = node.style || {};
  const props = Object.assign({}, style, node.props);
  return Object.assign({}, node, { props });
};
const removeNoneValues = (node) => {
  const removeNone = (value2) => value2 === "none" ? null : value2;
  const props = mapValues(node.props, removeNone);
  return Object.assign({}, node, { props });
};
const pickStyleProps = (node) => {
  const props = node.props || {};
  const styleProps = pick(STYLE_PROPS, props);
  const style = Object.assign({}, styleProps, node.style || {});
  return Object.assign({}, node, { style });
};
const parseSvgProps = (node) => {
  const props = evolve({
    width: parseFloat$1,
    height: parseFloat$1,
    viewBox: parseViewbox,
    preserveAspectRatio: parseAspectRatio
  }, node.props);
  return Object.assign({}, node, { props });
};
const wrapBetweenTspan = (node) => ({
  type: Tspan,
  props: {},
  style: {},
  children: [node]
});
const addMissingTspan = (node) => {
  if (!isText$5(node))
    return node;
  if (!node.children)
    return node;
  const resolveChild = (child) => isTextInstance$3(child) ? wrapBetweenTspan(child) : child;
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, { children });
};
const parseText = (fontStore2) => (node) => {
  if (isText$5(node))
    return layoutText$1(fontStore2, node);
  if (!node.children)
    return node;
  const children = node.children.map(parseText(fontStore2));
  return Object.assign({}, node, { children });
};
const resolveSvgNode = (container) => compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles$1);
const resolveChildren = (container) => (node) => {
  if (!node.children)
    return node;
  const resolveChild = compose(resolveChildren(container), resolveSvgNode(container));
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, { children });
};
const buildXLinksIndex = (node) => {
  var _a;
  const idIndex = {};
  const listToExplore = ((_a = node.children) == null ? void 0 : _a.slice(0)) || [];
  while (listToExplore.length > 0) {
    const child = listToExplore.shift();
    if (child.props && "id" in child.props) {
      idIndex[child.props.id] = child;
    }
    if (child.children)
      listToExplore.push(...child.children);
  }
  return idIndex;
};
const replaceXLinks = (node, idIndex) => {
  var _a;
  if (node.props && "xlinkHref" in node.props) {
    const linkedNode = idIndex[node.props.xlinkHref.replace(/^#/, "")];
    if (!linkedNode)
      return node;
    const newProps = Object.assign({}, linkedNode.props, node.props);
    delete newProps.xlinkHref;
    return Object.assign({}, linkedNode, { props: newProps });
  }
  const children = (_a = node.children) == null ? void 0 : _a.map((child) => replaceXLinks(child, idIndex));
  return Object.assign({}, node, { children });
};
const resolveXLinks = (node) => {
  const idIndex = buildXLinksIndex(node);
  return replaceXLinks(node, idIndex);
};
const resolveSvgRoot = (node, fontStore2) => {
  const container = getContainer$1(node);
  return compose(replaceDefs, parseText(fontStore2), parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container), resolveXLinks)(node);
};
const resolveSvg = (node, fontStore2) => {
  var _a;
  if (!("children" in node))
    return node;
  const resolveChild = (child) => resolveSvg(child, fontStore2);
  const root = isSvg$3(node) ? resolveSvgRoot(node, fontStore2) : node;
  const children = (_a = root.children) == null ? void 0 : _a.map(resolveChild);
  return Object.assign({}, root, { children });
};
let instancePromise;
const loadYoga = async () => {
  const instance = await (instancePromise ?? (instancePromise = loadYoga$1()));
  const config2 = instance.Config.create();
  config2.setPointScaleFactor(0);
  const node = { create: () => instance.Node.createWithConfig(config2) };
  return { node };
};
const resolveYoga = async (root) => {
  const yoga = await loadYoga();
  return Object.assign({}, root, { yoga });
};
const getZIndex = (node) => node.style.zIndex;
const shouldSort = (node) => node.type !== Document && node.type !== Svg;
const sortZIndex = (a2, b2) => {
  const za = getZIndex(a2);
  const zb = getZIndex(b2);
  if (!za && !zb)
    return 0;
  if (!za)
    return 1;
  if (!zb)
    return -1;
  return zb - za;
};
const resolveNodeZIndex = (node) => {
  if (!node.children)
    return node;
  const sortedChildren = shouldSort(node) ? node.children.sort(sortZIndex) : node.children;
  const children = sortedChildren.map(resolveNodeZIndex);
  return Object.assign({}, node, { children });
};
const resolveZIndex = (root) => resolveNodeZIndex(root);
const emojis = {};
const regex = emojiRegex();
const removeVariationSelectors = (x) => x !== "";
const getCodePoints = (string, withVariationSelectors = false) => Array.from(string).filter(withVariationSelectors ? () => true : removeVariationSelectors).map((char) => char.codePointAt(0).toString(16)).join("-");
const buildEmojiUrl = (emoji, source) => {
  if ("builder" in source) {
    return source.builder(getCodePoints(emoji, source.withVariationSelectors));
  }
  const { url, format: format2 = "png", withVariationSelectors } = source;
  return `${url}${getCodePoints(emoji, withVariationSelectors)}.${format2}`;
};
const fetchEmojis = (string, source) => {
  if (!source)
    return [];
  const promises = [];
  Array.from(string.matchAll(regex)).forEach((match) => {
    const emoji = match[0];
    if (!emojis[emoji] || emojis[emoji].loading) {
      const emojiUrl = buildEmojiUrl(emoji, source);
      emojis[emoji] = { loading: true };
      promises.push(resolveImage({ uri: emojiUrl }).then((image) => {
        emojis[emoji].loading = false;
        emojis[emoji].data = image.data;
      }));
    }
  });
  return promises;
};
const embedEmojis = (fragments) => {
  const result = [];
  for (let i2 = 0; i2 < fragments.length; i2 += 1) {
    const fragment = fragments[i2];
    let lastIndex = 0;
    Array.from(fragment.string.matchAll(regex)).forEach((match) => {
      const { index: index2 } = match;
      const emoji = match[0];
      const emojiSize = fragment.attributes.fontSize;
      const chunk = fragment.string.slice(lastIndex, index2 + match[0].length);
      if (emojis[emoji] && emojis[emoji].data) {
        result.push({
          string: chunk.replace(match[0], String.fromCharCode(65532)),
          attributes: {
            ...fragment.attributes,
            attachment: {
              width: emojiSize,
              height: emojiSize,
              yOffset: Math.floor(emojiSize * 0.1),
              image: emojis[emoji].data
            }
          }
        });
      } else {
        result.push({
          string: chunk,
          attributes: fragment.attributes
        });
      }
      lastIndex = index2 + emoji.length;
    });
    if (lastIndex < fragment.string.length) {
      result.push({
        string: fragment.string.slice(lastIndex),
        attributes: fragment.attributes
      });
    }
  }
  return result;
};
const getSource = (node) => {
  if (node.props.src)
    return node.props.src;
  if (node.props.source)
    return node.props.source;
};
const resolveSource = async (src2) => {
  const source = typeof src2 === "function" ? await src2() : await src2;
  return typeof source === "string" ? { uri: source } : source;
};
const fetchImage = async (node) => {
  const src2 = getSource(node);
  const { cache: cache2 } = node.props;
  if (!src2) {
    console.warn(false, 'Image should receive either a "src" or "source" prop');
    return;
  }
  try {
    const source = await resolveSource(src2);
    if (!source) {
      throw new Error(`Image's "src" or "source" prop returned ${source}`);
    }
    node.image = await resolveImage(source, { cache: cache2 });
    if (Buffer.isBuffer(source) || source instanceof Blob)
      return;
    node.image.key = "data" in source ? source.data.toString() : source.uri;
  } catch (e2) {
    console.warn(e2.message);
  }
};
const isImage$2 = (node) => node.type === Image;
const fetchAssets = (fontStore2, node) => {
  var _a, _b;
  const promises = [];
  const listToExplore = ((_a = node.children) == null ? void 0 : _a.slice(0)) || [];
  const emojiSource = fontStore2 ? fontStore2.getEmojiSource() : null;
  while (listToExplore.length > 0) {
    const n3 = listToExplore.shift();
    if (isImage$2(n3)) {
      promises.push(fetchImage(n3));
    }
    if (fontStore2 && ((_b = n3.style) == null ? void 0 : _b.fontFamily)) {
      const fontFamilies = castArray(n3.style.fontFamily);
      promises.push(...fontFamilies.map((fontFamily) => fontStore2.load({
        fontFamily,
        fontStyle: n3.style.fontStyle,
        fontWeight: n3.style.fontWeight
      })));
    }
    if (typeof n3 === "string") {
      promises.push(...fetchEmojis(n3, emojiSource));
    }
    if ("value" in n3 && typeof n3.value === "string") {
      promises.push(...fetchEmojis(n3.value, emojiSource));
    }
    if (n3.children) {
      n3.children.forEach((childNode) => {
        listToExplore.push(childNode);
      });
    }
  }
  return promises;
};
const resolveAssets = async (node, fontStore2) => {
  const promises = fetchAssets(fontStore2, node);
  await Promise.all(promises);
  return node;
};
const isLink$1 = (node) => node.type === Link;
const DEFAULT_LINK_STYLES = {
  color: "blue",
  textDecoration: "underline"
};
const computeStyle = (container, node) => {
  let baseStyle = [node.style];
  if (isLink$1(node)) {
    baseStyle = Array.isArray(node.style) ? [DEFAULT_LINK_STYLES, ...node.style] : [DEFAULT_LINK_STYLES, node.style];
  }
  return resolveStyles$1(container, baseStyle);
};
const resolveNodeStyles = (container) => (node) => {
  const style = computeStyle(container, node);
  if (!node.children)
    return Object.assign({}, node, { style });
  const children = node.children.map(resolveNodeStyles(container));
  return Object.assign({}, node, { style, children });
};
const resolvePageStyles = (page) => {
  var _a, _b, _c, _d;
  const dpi = ((_a = page.props) == null ? void 0 : _a.dpi) || 72;
  const style = page.style;
  const width = ((_b = page.box) == null ? void 0 : _b.width) || style.width;
  const height2 = ((_c = page.box) == null ? void 0 : _c.height) || style.height;
  const orientation = ((_d = page.props) == null ? void 0 : _d.orientation) || "portrait";
  const remBase = (style == null ? void 0 : style.fontSize) || 18;
  const container = { width, height: height2, orientation, dpi, remBase };
  return resolveNodeStyles(container)(page);
};
const resolveStyles = (root) => {
  if (!root.children)
    return root;
  const children = root.children.map(resolvePageStyles);
  return Object.assign({}, root, { children });
};
const getTransformStyle = (s2) => (node) => {
  var _a, _b;
  return isNil((_a = node.style) == null ? void 0 : _a[s2]) ? "50%" : ((_b = node.style) == null ? void 0 : _b[s2]) ?? null;
};
const getOrigin = (node) => {
  if (!node.box)
    return null;
  const { left, top, width, height: height2 } = node.box;
  const transformOriginX = getTransformStyle("transformOriginX")(node);
  const transformOriginY = getTransformStyle("transformOriginY")(node);
  const percentX = matchPercent(transformOriginX);
  const percentY = matchPercent(transformOriginY);
  const offsetX = percentX ? width * percentX.percent : transformOriginX;
  const offsetY = percentY ? height2 * percentY.percent : transformOriginY;
  if (isNil(offsetX) || typeof offsetX === "string")
    throw new Error(`Invalid origin offsetX: ${offsetX}`);
  if (isNil(offsetY) || typeof offsetY === "string")
    throw new Error(`Invalid origin offsetY: ${offsetY}`);
  return { left: left + offsetX, top: top + offsetY };
};
const resolveNodeOrigin = (node) => {
  const origin = getOrigin(node);
  const newNode = Object.assign({}, node, { origin });
  if (!node.children)
    return newNode;
  const children = node.children.map(resolveNodeOrigin);
  return Object.assign({}, newNode, { children });
};
const resolveOrigin = (root) => {
  if (!root.children)
    return root;
  const children = root.children.map(resolveNodeOrigin);
  return Object.assign({}, root, { children });
};
const getBookmarkValue = (bookmark) => {
  return typeof bookmark === "string" ? { title: bookmark, fit: false, expanded: false } : bookmark;
};
const resolveBookmarks = (node) => {
  let refs = 0;
  const children = (node.children || []).slice(0);
  const listToExplore = children.map((value2) => ({
    value: value2,
    parent: null
  }));
  while (listToExplore.length > 0) {
    const element = listToExplore.shift();
    if (!element)
      break;
    const child = element.value;
    let parent = element.parent;
    if (child.props && "bookmark" in child.props) {
      const bookmark = getBookmarkValue(child.props.bookmark);
      const ref = refs++;
      const newHierarchy = { ref, parent: parent == null ? void 0 : parent.ref, ...bookmark };
      child.props.bookmark = newHierarchy;
      parent = newHierarchy;
    }
    if (child.children) {
      child.children.forEach((childNode) => {
        listToExplore.push({ value: childNode, parent });
      });
    }
  }
  return node;
};
const VALID_ORIENTATIONS = ["portrait", "landscape"];
const getOrientation = (page) => {
  var _a;
  const value2 = ((_a = page.props) == null ? void 0 : _a.orientation) || "portrait";
  return VALID_ORIENTATIONS.includes(value2) ? value2 : "portrait";
};
const isLandscape = (page) => getOrientation(page) === "landscape";
const PAGE_SIZES = {
  "4A0": [4767.87, 6740.79],
  "2A0": [3370.39, 4767.87],
  A0: [2383.94, 3370.39],
  A1: [1683.78, 2383.94],
  A2: [1190.55, 1683.78],
  A3: [841.89, 1190.55],
  A4: [595.28, 841.89],
  A5: [419.53, 595.28],
  A6: [297.64, 419.53],
  A7: [209.76, 297.64],
  A8: [147.4, 209.76],
  A9: [104.88, 147.4],
  A10: [73.7, 104.88],
  B0: [2834.65, 4008.19],
  B1: [2004.09, 2834.65],
  B2: [1417.32, 2004.09],
  B3: [1000.63, 1417.32],
  B4: [708.66, 1000.63],
  B5: [498.9, 708.66],
  B6: [354.33, 498.9],
  B7: [249.45, 354.33],
  B8: [175.75, 249.45],
  B9: [124.72, 175.75],
  B10: [87.87, 124.72],
  C0: [2599.37, 3676.54],
  C1: [1836.85, 2599.37],
  C2: [1298.27, 1836.85],
  C3: [918.43, 1298.27],
  C4: [649.13, 918.43],
  C5: [459.21, 649.13],
  C6: [323.15, 459.21],
  C7: [229.61, 323.15],
  C8: [161.57, 229.61],
  C9: [113.39, 161.57],
  C10: [79.37, 113.39],
  RA0: [2437.8, 3458.27],
  RA1: [1729.13, 2437.8],
  RA2: [1218.9, 1729.13],
  RA3: [864.57, 1218.9],
  RA4: [609.45, 864.57],
  SRA0: [2551.18, 3628.35],
  SRA1: [1814.17, 2551.18],
  SRA2: [1275.59, 1814.17],
  SRA3: [907.09, 1275.59],
  SRA4: [637.8, 907.09],
  EXECUTIVE: [521.86, 756],
  FOLIO: [612, 936],
  LEGAL: [612, 1008],
  LETTER: [612, 792],
  TABLOID: [792, 1224],
  ID1: [153, 243]
};
const parseValue = (value2) => {
  if (typeof value2 === "number")
    return { value: value2, unit: void 0 };
  const match = /^(-?\d*\.?\d+)(in|mm|cm|pt|px)?$/g.exec(value2);
  return match ? { value: parseFloat(match[1]), unit: match[2] || "pt" } : { value: value2, unit: void 0 };
};
const transformUnit = (value2, inputDpi) => {
  if (!value2)
    return 0;
  const scalar = parseValue(value2);
  const outputDpi = 72;
  const mmFactor = 1 / 25.4 * outputDpi;
  const cmFactor = 1 / 2.54 * outputDpi;
  if (typeof scalar.value === "string")
    throw new Error(`Invalid page size: ${value2}`);
  switch (scalar.unit) {
    case "in":
      return scalar.value * outputDpi;
    case "mm":
      return scalar.value * mmFactor;
    case "cm":
      return scalar.value * cmFactor;
    case "px":
      return Math.round(scalar.value * (outputDpi / inputDpi));
    default:
      return scalar.value;
  }
};
const transformUnits = ({ width, height: height2 }, dpi) => ({
  width: transformUnit(width, dpi),
  height: transformUnit(height2, dpi)
});
const toSizeObject = (v2) => ({
  width: v2[0],
  height: v2[1]
});
const flipSizeObject = (v2) => ({
  width: v2.height,
  height: v2.width
});
const getStringSize = (v2) => {
  return toSizeObject(PAGE_SIZES[v2.toUpperCase()]);
};
const getNumberSize = (n3) => toSizeObject([n3, n3]);
const getSize = (page) => {
  var _a, _b;
  const value2 = ((_a = page.props) == null ? void 0 : _a.size) || "A4";
  const dpi = ((_b = page.props) == null ? void 0 : _b.dpi) || 72;
  let size;
  if (typeof value2 === "string") {
    size = getStringSize(value2);
  } else if (Array.isArray(value2)) {
    size = transformUnits(toSizeObject(value2), dpi);
  } else if (typeof value2 === "number") {
    size = transformUnits(getNumberSize(value2), dpi);
  } else {
    size = transformUnits(value2, dpi);
  }
  return isLandscape(page) ? flipSizeObject(size) : size;
};
const resolvePageSize = (page) => {
  const size = getSize(page);
  const style = flatten$1(page.style || {});
  return { ...page, style: { ...style, ...size } };
};
const resolvePageSizes = (root) => {
  if (!root.children)
    return root;
  const children = root.children.map(resolvePageSize);
  return Object.assign({}, root, { children });
};
const isFixed = (node) => {
  if (!node.props)
    return false;
  return "fixed" in node.props ? node.props.fixed === true : false;
};
const lineIndexAtHeight = (node, height2) => {
  let y2 = 0;
  if (!node.lines)
    return 0;
  for (let i2 = 0; i2 < node.lines.length; i2 += 1) {
    const line2 = node.lines[i2];
    if (y2 + line2.box.height > height2)
      return i2;
    y2 += line2.box.height;
  }
  return node.lines.length;
};
const heightAtLineIndex = (node, index2) => {
  let counter = 0;
  if (!node.lines)
    return counter;
  for (let i2 = 0; i2 < index2; i2 += 1) {
    const line2 = node.lines[i2];
    if (!line2)
      break;
    counter += line2.box.height;
  }
  return counter;
};
const getLineBreak = (node, height2) => {
  var _a;
  const top = ((_a = node.box) == null ? void 0 : _a.top) || 0;
  const widows = node.props.widows || 2;
  const orphans = node.props.orphans || 2;
  const linesQuantity = node.lines.length;
  const slicedLine = lineIndexAtHeight(node, height2 - top);
  if (slicedLine === 0) {
    return 0;
  }
  if (linesQuantity < orphans) {
    return linesQuantity;
  }
  if (slicedLine < orphans || linesQuantity < orphans + widows) {
    return 0;
  }
  if (linesQuantity === orphans + widows) {
    return orphans;
  }
  if (linesQuantity - slicedLine < widows) {
    return linesQuantity - widows;
  }
  return slicedLine;
};
const splitText = (node, height2) => {
  const slicedLineIndex = getLineBreak(node, height2);
  const currentHeight = heightAtLineIndex(node, slicedLineIndex);
  const nextHeight = node.box.height - currentHeight;
  const current = Object.assign({}, node, {
    box: {
      ...node.box,
      height: currentHeight,
      borderBottomWidth: 0
    },
    style: {
      ...node.style,
      marginBottom: 0,
      paddingBottom: 0,
      borderBottomWidth: 0,
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    },
    lines: node.lines.slice(0, slicedLineIndex)
  });
  const next = Object.assign({}, node, {
    box: {
      ...node.box,
      top: 0,
      height: nextHeight,
      borderTopWidth: 0
    },
    style: {
      ...node.style,
      marginTop: 0,
      paddingTop: 0,
      borderTopWidth: 0,
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0
    },
    lines: node.lines.slice(slicedLineIndex)
  });
  return [current, next];
};
const getTop$1 = (node) => {
  var _a;
  return ((_a = node.box) == null ? void 0 : _a.top) || 0;
};
const hasFixedHeight = (node) => {
  var _a;
  return !isNil((_a = node.style) == null ? void 0 : _a.height);
};
const splitNode = (node, height2) => {
  if (!node)
    return [null, null];
  const nodeTop = getTop$1(node);
  const current = Object.assign({}, node, {
    box: {
      ...node.box,
      borderBottomWidth: 0
    },
    style: {
      ...node.style,
      marginBottom: 0,
      paddingBottom: 0,
      borderBottomWidth: 0,
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    }
  });
  current.style.height = height2 - nodeTop;
  const nextHeight = hasFixedHeight(node) ? node.box.height - (height2 - nodeTop) : null;
  const next = Object.assign({}, node, {
    box: {
      ...node.box,
      top: 0,
      borderTopWidth: 0
    },
    style: {
      ...node.style,
      marginTop: 0,
      paddingTop: 0,
      borderTopWidth: 0,
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0
    }
  });
  if (nextHeight) {
    next.style.height = nextHeight;
  }
  return [current, next];
};
const NON_WRAP_TYPES = [Svg, Note, Image, Canvas];
const getWrap = (node) => {
  if (NON_WRAP_TYPES.includes(node.type))
    return false;
  if (!node.props)
    return true;
  return "wrap" in node.props ? node.props.wrap : true;
};
const getComputedPadding = (node, edge) => {
  const { yogaNode } = node;
  return yogaNode ? yogaNode.getComputedPadding(edge) : null;
};
const getPadding = (node) => {
  const { style, box } = node;
  const paddingTop = getComputedPadding(node, Edge.Top) || (box == null ? void 0 : box.paddingTop) || (style == null ? void 0 : style.paddingTop) || 0;
  const paddingRight = getComputedPadding(node, Edge.Right) || (box == null ? void 0 : box.paddingRight) || (style == null ? void 0 : style.paddingRight) || 0;
  const paddingBottom = getComputedPadding(node, Edge.Bottom) || (box == null ? void 0 : box.paddingBottom) || (style == null ? void 0 : style.paddingBottom) || 0;
  const paddingLeft = getComputedPadding(node, Edge.Left) || (box == null ? void 0 : box.paddingLeft) || (style == null ? void 0 : style.paddingLeft) || 0;
  return { paddingTop, paddingRight, paddingBottom, paddingLeft };
};
const getWrapArea = (page) => {
  var _a;
  const height2 = (_a = page.style) == null ? void 0 : _a.height;
  const { paddingBottom } = getPadding(page);
  return height2 - paddingBottom;
};
const getContentArea = (page) => {
  var _a;
  const height2 = (_a = page.style) == null ? void 0 : _a.height;
  const { paddingTop, paddingBottom } = getPadding(page);
  return height2 - paddingBottom - paddingTop;
};
const isString = (value2) => typeof value2 === "string";
const isNumber = (value2) => typeof value2 === "number";
const isBoolean = (value2) => typeof value2 === "boolean";
const isFragment = (value2) => value2 && value2.type === Symbol.for("react.fragment");
const createInstances = (element) => {
  if (!element)
    return [];
  if (Array.isArray(element)) {
    return element.reduce((acc, el) => acc.concat(createInstances(el)), []);
  }
  if (isBoolean(element)) {
    return [];
  }
  if (isString(element) || isNumber(element)) {
    return [{ type: TextInstance, value: `${element}` }];
  }
  if (isFragment(element)) {
    return createInstances(element.props.children);
  }
  if (!isString(element.type)) {
    return createInstances(element.type(element.props));
  }
  const { type, props: { style = {}, children, ...props } } = element;
  const nextChildren = castArray(children).reduce((acc, child) => acc.concat(createInstances(child)), []);
  return [
    {
      type,
      style,
      props,
      children: nextChildren
    }
  ];
};
const getBreak = (node) => "break" in node.props ? node.props.break : false;
const getMinPresenceAhead = (node) => "minPresenceAhead" in node.props ? node.props.minPresenceAhead : 0;
const getFurthestEnd = (elements) => Math.max(...elements.map((node) => node.box.top + node.box.height));
const getEndOfMinPresenceAhead = (child) => {
  return child.box.top + child.box.height + child.box.marginBottom + getMinPresenceAhead(child);
};
const getEndOfPresence = (child, futureElements) => {
  const afterMinPresenceAhead = getEndOfMinPresenceAhead(child);
  const endOfFurthestFutureElement = getFurthestEnd(futureElements.filter((node) => !("fixed" in node.props)));
  return Math.min(afterMinPresenceAhead, endOfFurthestFutureElement);
};
const shouldBreak = (child, futureElements, height2) => {
  if ("fixed" in child.props)
    return false;
  const shouldSplit = height2 < child.box.top + child.box.height;
  const canWrap = getWrap(child);
  const endOfPresence = getEndOfPresence(child, futureElements);
  const breakingImprovesPresence = child.box.top > child.box.marginTop;
  return getBreak(child) || shouldSplit && !canWrap || !shouldSplit && endOfPresence > height2 && breakingImprovesPresence;
};
const IGNORABLE_CODEPOINTS = [
  8232,
  // LINE_SEPARATOR
  8233
  // PARAGRAPH_SEPARATOR
];
const buildSubsetForFont = (font) => IGNORABLE_CODEPOINTS.reduce((acc, codePoint) => {
  if (font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {
    return acc;
  }
  return [...acc, String.fromCharCode(codePoint)];
}, []);
const ignoreChars = (fragments) => fragments.map((fragment) => {
  const charSubset = buildSubsetForFont(fragment.attributes.font[0]);
  const subsetRegex = new RegExp(charSubset.join("|"));
  return {
    string: fragment.string.replace(subsetRegex, ""),
    attributes: fragment.attributes
  };
});
const PREPROCESSORS = [ignoreChars, embedEmojis];
const isImage$1 = (node) => node.type === Image;
const isTextInstance$2 = (node) => node.type === TextInstance;
const getFragments = (fontStore2, instance, parentLink = null, level = 0) => {
  var _a, _b;
  if (!instance)
    return [{ string: "" }];
  let fragments = [];
  const { color = "black", direction = "ltr", fontFamily = "Helvetica", fontWeight, fontStyle, fontSize = 18, textAlign, lineHeight, textDecoration: textDecoration2, textDecorationColor, textDecorationStyle, textTransform, letterSpacing, textIndent, opacity, verticalAlign } = instance.style;
  const fontFamilies = typeof fontFamily === "string" ? [fontFamily] : [...fontFamily || []];
  fontFamilies.push("Helvetica");
  const font = fontFamilies.map((fontFamilyName) => {
    const opts2 = { fontFamily: fontFamilyName, fontWeight, fontStyle };
    const obj = fontStore2.getFont(opts2);
    return obj == null ? void 0 : obj.data;
  });
  const backgroundColor = level === 0 ? null : instance.style.backgroundColor;
  const attributes2 = {
    font,
    color,
    opacity,
    fontSize,
    lineHeight,
    direction,
    verticalAlign,
    backgroundColor,
    indent: textIndent,
    characterSpacing: letterSpacing,
    strikeStyle: textDecorationStyle,
    underlineStyle: textDecorationStyle,
    underline: textDecoration2 === "underline" || textDecoration2 === "underline line-through" || textDecoration2 === "line-through underline",
    strike: textDecoration2 === "line-through" || textDecoration2 === "underline line-through" || textDecoration2 === "line-through underline",
    strikeColor: textDecorationColor || color,
    underlineColor: textDecorationColor || color,
    // @ts-expect-error allow this props access
    link: parentLink || ((_a = instance.props) == null ? void 0 : _a.src) || ((_b = instance.props) == null ? void 0 : _b.href),
    align: textAlign || (direction === "rtl" ? "right" : "left")
  };
  for (let i2 = 0; i2 < instance.children.length; i2 += 1) {
    const child = instance.children[i2];
    if (isImage$1(child)) {
      fragments.push({
        string: String.fromCharCode(65532),
        attributes: {
          ...attributes2,
          attachment: {
            width: child.style.width || fontSize,
            height: child.style.height || fontSize,
            image: child.image.data
          }
        }
      });
    } else if (isTextInstance$2(child)) {
      fragments.push({
        string: transformText(child.value, textTransform),
        attributes: attributes2
      });
    } else if (child) {
      fragments.push(...getFragments(fontStore2, child, attributes2.link, level + 1));
    }
  }
  for (let i2 = 0; i2 < PREPROCESSORS.length; i2 += 1) {
    const preprocessor = PREPROCESSORS[i2];
    fragments = preprocessor(fragments);
  }
  return fragments;
};
const getAttributedString = (fontStore2, instance) => {
  const fragments = getFragments(fontStore2, instance);
  return fromFragments(fragments);
};
const engines = {
  bidi: bidiEngine,
  linebreaker,
  justification,
  textDecoration,
  scriptItemizer,
  wordHyphenation,
  fontSubstitution
};
const engine = layoutEngine(engines);
const getMaxLines = (node) => {
  var _a;
  return (_a = node.style) == null ? void 0 : _a.maxLines;
};
const getTextOverflow = (node) => {
  var _a;
  return (_a = node.style) == null ? void 0 : _a.textOverflow;
};
const getContainer = (width, height2, node) => {
  const maxLines = getMaxLines(node);
  const textOverflow = getTextOverflow(node);
  return {
    x: 0,
    y: 0,
    width,
    maxLines,
    height: height2 || Infinity,
    truncateMode: textOverflow
  };
};
const getLayoutOptions = (fontStore2, node) => ({
  hyphenationPenalty: node.props.hyphenationPenalty,
  shrinkWhitespaceFactor: { before: -0.5, after: -0.5 },
  hyphenationCallback: node.props.hyphenationCallback || (fontStore2 == null ? void 0 : fontStore2.getHyphenationCallback()) || null
});
const layoutText = (node, width, height2, fontStore2) => {
  const attributedString = getAttributedString(fontStore2, node);
  const container = getContainer(width, height2, node);
  const options = getLayoutOptions(fontStore2, node);
  const lines = engine(attributedString, container, options);
  return lines.reduce((acc, line2) => [...acc, ...line2], []);
};
const isSvg$2 = (node) => node.type === Svg;
const isText$4 = (node) => node.type === Text;
const shouldIterate = (node) => !isSvg$2(node) && !isText$4(node);
const shouldLayoutText = (node) => isText$4(node) && !node.lines;
const resolveTextLayout = (node, fontStore2) => {
  if (shouldLayoutText(node)) {
    const width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);
    const height2 = node.box.height - (node.box.paddingTop + node.box.paddingBottom);
    node.lines = layoutText(node, width, height2, fontStore2);
  }
  if (shouldIterate(node)) {
    if (!node.children)
      return node;
    const mapChild = (child) => resolveTextLayout(child, fontStore2);
    const children = node.children.map(mapChild);
    return Object.assign({}, node, { children });
  }
  return node;
};
const BASE_INHERITABLE_PROPERTIES = [
  "color",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "opacity",
  "textDecoration",
  "textTransform",
  "lineHeight",
  "textAlign",
  "visibility",
  "wordSpacing"
];
const TEXT_INHERITABLE_PROPERTIES = [
  ...BASE_INHERITABLE_PROPERTIES,
  "backgroundColor"
];
const isType$2 = (type) => (node) => node.type === type;
const isSvg$1 = isType$2(Svg);
const isText$3 = isType$2(Text);
const mergeValues = (styleName, value2, inheritedValue) => {
  switch (styleName) {
    case "textDecoration": {
      return [inheritedValue, value2].filter((v2) => v2 && v2 !== "none").join(" ");
    }
    default:
      return value2;
  }
};
const merge = (inheritedStyles, style) => {
  const mergedStyles = { ...inheritedStyles };
  Object.entries(style).forEach(([styleName, value2]) => {
    mergedStyles[styleName] = mergeValues(styleName, value2, inheritedStyles[styleName]);
  });
  return mergedStyles;
};
const mergeStyles = (inheritedStyles) => (node) => {
  const style = merge(inheritedStyles, node.style || {});
  return Object.assign({}, node, { style });
};
const resolveInheritance = (node) => {
  if (isSvg$1(node))
    return node;
  if (!("children" in node))
    return node;
  const inheritableProperties = isText$3(node) ? TEXT_INHERITABLE_PROPERTIES : BASE_INHERITABLE_PROPERTIES;
  const inheritStyles = pick(inheritableProperties, node.style || {});
  const resolveChild = compose(resolveInheritance, mergeStyles(inheritStyles));
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, { children });
};
const getComputedMargin = (node, edge) => {
  const { yogaNode } = node;
  return yogaNode ? yogaNode.getComputedMargin(edge) : null;
};
const getMargin = (node) => {
  const { style, box } = node;
  const marginTop = getComputedMargin(node, Edge.Top) || (box == null ? void 0 : box.marginTop) || (style == null ? void 0 : style.marginTop) || 0;
  const marginRight = getComputedMargin(node, Edge.Right) || (box == null ? void 0 : box.marginRight) || (style == null ? void 0 : style.marginRight) || 0;
  const marginBottom = getComputedMargin(node, Edge.Bottom) || (box == null ? void 0 : box.marginBottom) || (style == null ? void 0 : style.marginBottom) || 0;
  const marginLeft = getComputedMargin(node, Edge.Left) || (box == null ? void 0 : box.marginLeft) || (style == null ? void 0 : style.marginLeft) || 0;
  return { marginTop, marginRight, marginBottom, marginLeft };
};
const getPosition = (node) => {
  const { yogaNode } = node;
  return {
    top: (yogaNode == null ? void 0 : yogaNode.getComputedTop()) || 0,
    right: (yogaNode == null ? void 0 : yogaNode.getComputedRight()) || 0,
    bottom: (yogaNode == null ? void 0 : yogaNode.getComputedBottom()) || 0,
    left: (yogaNode == null ? void 0 : yogaNode.getComputedLeft()) || 0
  };
};
const DEFAULT_DIMENSION = {
  width: 0,
  height: 0
};
const getDimension = (node) => {
  const { yogaNode } = node;
  if (!yogaNode)
    return DEFAULT_DIMENSION;
  return {
    width: yogaNode.getComputedWidth(),
    height: yogaNode.getComputedHeight()
  };
};
const getComputedBorder = (yogaNode, edge) => yogaNode ? yogaNode.getComputedBorder(edge) : 0;
const getBorderWidth = (node) => {
  const { yogaNode } = node;
  return {
    borderTopWidth: getComputedBorder(yogaNode, Edge.Top),
    borderRightWidth: getComputedBorder(yogaNode, Edge.Right),
    borderBottomWidth: getComputedBorder(yogaNode, Edge.Bottom),
    borderLeftWidth: getComputedBorder(yogaNode, Edge.Left)
  };
};
const setDisplay = (value2) => (node) => {
  const { yogaNode } = node;
  if (yogaNode) {
    yogaNode.setDisplay(value2 === "none" ? Display.None : Display.Flex);
  }
  return node;
};
const OVERFLOW = {
  hidden: Overflow.Hidden,
  scroll: Overflow.Scroll
};
const setOverflow = (value2) => (node) => {
  const { yogaNode } = node;
  if (!isNil(value2) && yogaNode) {
    const overflow = OVERFLOW[value2] || Overflow.Visible;
    yogaNode.setOverflow(overflow);
  }
  return node;
};
const FLEX_WRAP = {
  wrap: Wrap.Wrap,
  "wrap-reverse": Wrap.WrapReverse
};
const setFlexWrap = (value2) => (node) => {
  const { yogaNode } = node;
  if (yogaNode) {
    const flexWrap = FLEX_WRAP[value2] || Wrap.NoWrap;
    yogaNode.setFlexWrap(flexWrap);
  }
  return node;
};
const setYogaValue = (attr, edge) => (value2) => (node) => {
  var _a, _b, _c, _d, _e, _f;
  const { yogaNode } = node;
  if (!isNil(value2) && yogaNode) {
    const hasEdge = !isNil(edge);
    const fixedMethod = `set${upperFirst(attr)}`;
    const autoMethod = `${fixedMethod}Auto`;
    const percentMethod = `${fixedMethod}Percent`;
    const percent = matchPercent(value2);
    if (percent && !yogaNode[percentMethod]) {
      throw new Error(`You can't pass percentage values to ${attr} property`);
    }
    if (percent) {
      if (hasEdge) {
        (_a = yogaNode[percentMethod]) == null ? void 0 : _a.call(yogaNode, edge, percent.value);
      } else {
        (_b = yogaNode[percentMethod]) == null ? void 0 : _b.call(yogaNode, percent.value);
      }
    } else if (value2 === "auto") {
      if (hasEdge) {
        (_c = yogaNode[autoMethod]) == null ? void 0 : _c.call(yogaNode, edge);
      } else {
        (_d = yogaNode[autoMethod]) == null ? void 0 : _d.call(yogaNode);
      }
    } else if (hasEdge) {
      (_e = yogaNode[fixedMethod]) == null ? void 0 : _e.call(yogaNode, edge, value2);
    } else {
      (_f = yogaNode[fixedMethod]) == null ? void 0 : _f.call(yogaNode, value2);
    }
  }
  return node;
};
const setFlexGrow = (value2) => (node) => {
  return setYogaValue("flexGrow")(value2 || 0)(node);
};
const setFlexBasis = setYogaValue("flexBasis");
const ALIGN = {
  "flex-start": Align.FlexStart,
  center: Align.Center,
  "flex-end": Align.FlexEnd,
  stretch: Align.Stretch,
  baseline: Align.Baseline,
  "space-between": Align.SpaceBetween,
  "space-around": Align.SpaceAround,
  "space-evenly": Align.SpaceEvenly
};
const setAlign = (attr) => (value2) => (node) => {
  const { yogaNode } = node;
  const defaultValue = attr === "items" ? Align.Stretch : Align.Auto;
  if (yogaNode) {
    const align = ALIGN[value2] || defaultValue;
    yogaNode[`setAlign${upperFirst(attr)}`](align);
  }
  return node;
};
const setAlignSelf = setAlign("self");
const setAlignItems = setAlign("items");
const setFlexShrink = (value2) => (node) => {
  return setYogaValue("flexShrink")(value2 || 1)(node);
};
const setAspectRatio = (value2) => (node) => {
  const { yogaNode } = node;
  if (!isNil(value2) && yogaNode) {
    yogaNode.setAspectRatio(value2);
  }
  return node;
};
const setAlignContent = setAlign("content");
const POSITION = {
  absolute: PositionType.Absolute,
  relative: PositionType.Relative,
  static: PositionType.Static
};
const setPositionType = (value2) => (node) => {
  const { yogaNode } = node;
  if (!isNil(value2) && yogaNode) {
    yogaNode.setPositionType(POSITION[value2]);
  }
  return node;
};
const FLEX_DIRECTIONS = {
  row: FlexDirection.Row,
  "row-reverse": FlexDirection.RowReverse,
  "column-reverse": FlexDirection.ColumnReverse
};
const setFlexDirection = (value2) => (node) => {
  const { yogaNode } = node;
  if (yogaNode) {
    const flexDirection = FLEX_DIRECTIONS[value2] || FlexDirection.Column;
    yogaNode.setFlexDirection(flexDirection);
  }
  return node;
};
const JUSTIFY_CONTENT = {
  center: Justify.Center,
  "flex-end": Justify.FlexEnd,
  "space-between": Justify.SpaceBetween,
  "space-around": Justify.SpaceAround,
  "space-evenly": Justify.SpaceEvenly
};
const setJustifyContent = (value2) => (node) => {
  const { yogaNode } = node;
  if (!isNil(value2) && yogaNode) {
    const justifyContent = JUSTIFY_CONTENT[value2] || Justify.FlexStart;
    yogaNode.setJustifyContent(justifyContent);
  }
  return node;
};
const setMarginTop = setYogaValue("margin", Edge.Top);
const setMarginRight = setYogaValue("margin", Edge.Right);
const setMarginBottom = setYogaValue("margin", Edge.Bottom);
const setMarginLeft = setYogaValue("margin", Edge.Left);
const setPaddingTop = setYogaValue("padding", Edge.Top);
const setPaddingRight = setYogaValue("padding", Edge.Right);
const setPaddingBottom = setYogaValue("padding", Edge.Bottom);
const setPaddingLeft = setYogaValue("padding", Edge.Left);
const setBorderTop = setYogaValue("border", Edge.Top);
const setBorderRight = setYogaValue("border", Edge.Right);
const setBorderBottom = setYogaValue("border", Edge.Bottom);
const setBorderLeft = setYogaValue("border", Edge.Left);
const setPositionTop = setYogaValue("position", Edge.Top);
const setPositionRight = setYogaValue("position", Edge.Right);
const setPositionBottom = setYogaValue("position", Edge.Bottom);
const setPositionLeft = setYogaValue("position", Edge.Left);
const setWidth = setYogaValue("width");
const setMinWidth = setYogaValue("minWidth");
const setMaxWidth = setYogaValue("maxWidth");
const setHeight = setYogaValue("height");
const setMinHeight = setYogaValue("minHeight");
const setMaxHeight = setYogaValue("maxHeight");
const setRowGap = setYogaValue("gap", Gutter.Row);
const setColumnGap = setYogaValue("gap", Gutter.Column);
const getAspectRatio = (viewbox) => {
  if (!viewbox)
    return null;
  if (typeof viewbox === "string")
    return null;
  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);
};
const measureCanvas$1 = (page, node) => (width, widthMode, height2, heightMode) => {
  const aspectRatio = getAspectRatio(node.props.viewBox) || 1;
  if (widthMode === MeasureMode.Exactly || widthMode === MeasureMode.AtMost) {
    return { width, height: width / aspectRatio };
  }
  if (heightMode === MeasureMode.Exactly) {
    return { width: height2 * aspectRatio };
  }
  return {};
};
const linesWidth = (node) => {
  if (!node.lines)
    return 0;
  return Math.max(0, ...node.lines.map((line2) => line2.xAdvance));
};
const linesHeight = (node) => {
  if (!node.lines)
    return -1;
  return node.lines.reduce((acc, line2) => acc + line2.box.height, 0);
};
const ALIGNMENT_FACTORS = { center: 0.5, right: 1 };
const measureText = (page, node, fontStore2) => (width, widthMode, height2) => {
  var _a;
  if (widthMode === MeasureMode.Exactly) {
    if (!node.lines)
      node.lines = layoutText(node, width, height2, fontStore2);
    return { height: linesHeight(node) };
  }
  if (widthMode === MeasureMode.AtMost) {
    const alignFactor = ALIGNMENT_FACTORS[(_a = node.style) == null ? void 0 : _a.textAlign] || 0;
    if (!node.lines) {
      node.lines = layoutText(node, width, height2, fontStore2);
      node.alignOffset = (width - linesWidth(node)) * alignFactor;
    }
    return {
      height: linesHeight(node),
      width: Math.min(width, linesWidth(node))
    };
  }
  return {};
};
const getRatio = (node) => {
  var _a;
  return ((_a = node.image) == null ? void 0 : _a.data) ? node.image.width / node.image.height : 1;
};
const isHeightAuto = (page) => {
  var _a;
  return isNil((_a = page.box) == null ? void 0 : _a.height);
};
const SAFETY_HEIGHT$1 = 10;
const measureImage = (page, node) => (width, widthMode, height2, heightMode) => {
  var _a;
  const imageRatio = getRatio(node);
  const imageMargin = getMargin(node);
  const pagePadding = getPadding(page);
  const pageArea = isHeightAuto(page) ? Infinity : (((_a = page.box) == null ? void 0 : _a.height) || 0) - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT$1;
  if (!node.image)
    return { width: 0, height: 0 };
  if (widthMode === MeasureMode.Exactly && heightMode === MeasureMode.Undefined) {
    const scaledHeight = width / imageRatio;
    return { height: Math.min(pageArea, scaledHeight) };
  }
  if (heightMode === MeasureMode.Exactly && (widthMode === MeasureMode.AtMost || widthMode === MeasureMode.Undefined)) {
    return { width: Math.min(height2 * imageRatio, width) };
  }
  if (widthMode === MeasureMode.Exactly && heightMode === MeasureMode.AtMost) {
    const scaledHeight = width / imageRatio;
    return { height: Math.min(height2, pageArea, scaledHeight) };
  }
  if (widthMode === MeasureMode.AtMost && heightMode === MeasureMode.AtMost) {
    if (imageRatio > 1) {
      return {
        width,
        height: Math.min(width / imageRatio, height2)
      };
    }
    return {
      height: height2,
      width: Math.min(height2 * imageRatio, width)
    };
  }
  return { height: height2, width };
};
const SAFETY_HEIGHT = 10;
const getMax = (values) => Math.max(-Infinity, ...values);
const measureCtx = () => {
  const ctx = {};
  const points = [];
  const nil = () => ctx;
  const addPoint = (x, y2) => points.push([x, y2]);
  const moveTo = (x, y2) => {
    addPoint(x, y2);
    return ctx;
  };
  const rect = (x, y2, w, h) => {
    addPoint(x, y2);
    addPoint(x + w, y2);
    addPoint(x, y2 + h);
    addPoint(x + w, y2 + h);
    return ctx;
  };
  const ellipse = (x, y2, rx, ry) => {
    ry = ry || rx;
    addPoint(x - rx, y2 - ry);
    addPoint(x + rx, y2 - ry);
    addPoint(x + rx, y2 + ry);
    addPoint(x - rx, y2 + ry);
    return ctx;
  };
  const polygon = (...pts) => {
    points.push(...pts);
    return ctx;
  };
  ctx.rect = rect;
  ctx.moveTo = moveTo;
  ctx.lineTo = moveTo;
  ctx.circle = ellipse;
  ctx.polygon = polygon;
  ctx.ellipse = ellipse;
  ctx.roundedRect = rect;
  ctx.text = nil;
  ctx.path = nil;
  ctx.lineWidth = nil;
  ctx.bezierCurveTo = nil;
  ctx.quadraticCurveTo = nil;
  ctx.scale = nil;
  ctx.rotate = nil;
  ctx.translate = nil;
  ctx.dash = nil;
  ctx.clip = nil;
  ctx.save = nil;
  ctx.fill = nil;
  ctx.font = nil;
  ctx.stroke = nil;
  ctx.lineCap = nil;
  ctx.opacity = nil;
  ctx.restore = nil;
  ctx.lineJoin = nil;
  ctx.fontSize = nil;
  ctx.fillColor = nil;
  ctx.miterLimit = nil;
  ctx.strokeColor = nil;
  ctx.fillOpacity = nil;
  ctx.strokeOpacity = nil;
  ctx.linearGradient = nil;
  ctx.radialGradient = nil;
  ctx.getWidth = () => getMax(points.map((p2) => p2[0]));
  ctx.getHeight = () => getMax(points.map((p2) => p2[1]));
  return ctx;
};
const measureCanvas = (page, node) => () => {
  var _a;
  const imageMargin = getMargin(node);
  const pagePadding = getPadding(page);
  const pageArea = isHeightAuto(page) ? Infinity : (((_a = page.box) == null ? void 0 : _a.height) || 0) - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT;
  const ctx = measureCtx();
  node.props.paint(ctx);
  const width = ctx.getWidth();
  const height2 = Math.min(pageArea, ctx.getHeight());
  return { width, height: height2 };
};
const isType$1 = (type) => (node) => node.type === type;
const isSvg = isType$1(Svg);
const isText$2 = isType$1(Text);
const isNote = isType$1(Note);
const isPage = isType$1(Page);
const isImage = isType$1(Image);
const isCanvas = isType$1(Canvas);
const isTextInstance$1 = isType$1(TextInstance);
const setNodeHeight = (node) => {
  var _a, _b;
  const value2 = isPage(node) ? (_a = node.box) == null ? void 0 : _a.height : (_b = node.style) == null ? void 0 : _b.height;
  return setHeight(value2);
};
const setYogaValues = (node) => {
  compose(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink), setRowGap(node.style.rowGap), setColumnGap(node.style.columnGap))(node);
};
const insertYogaNodes = (parent) => (child) => {
  parent.insertChild(child.yogaNode, parent.getChildCount());
  return child;
};
const setMeasureFunc = (node, page, fontStore2) => {
  const { yogaNode } = node;
  if (isText$2(node)) {
    yogaNode.setMeasureFunc(measureText(page, node, fontStore2));
  }
  if (isImage(node)) {
    yogaNode.setMeasureFunc(measureImage(page, node));
  }
  if (isCanvas(node)) {
    yogaNode.setMeasureFunc(measureCanvas(page, node));
  }
  if (isSvg(node)) {
    yogaNode.setMeasureFunc(measureCanvas$1(page, node));
  }
  return node;
};
const isLayoutElement = (node) => !isText$2(node) && !isNote(node) && !isSvg(node);
const createYogaNodes = (page, fontStore2, yoga) => (node) => {
  const yogaNode = yoga.node.create();
  const result = Object.assign({}, node, { yogaNode });
  setYogaValues(result);
  if (isLayoutElement(node) && node.children) {
    const resolveChild = compose(insertYogaNodes(yogaNode), createYogaNodes(page, fontStore2, yoga));
    result.children = node.children.map(resolveChild);
  }
  setMeasureFunc(result, page, fontStore2);
  return result;
};
const calculateLayout = (page) => {
  page.yogaNode.calculateLayout();
  return page;
};
const persistDimensions = (node) => {
  if (isTextInstance$1(node))
    return node;
  const box = Object.assign(getPadding(node), getMargin(node), getBorderWidth(node), getPosition(node), getDimension(node));
  const newNode = Object.assign({}, node, { box });
  if (!node.children)
    return newNode;
  const children = node.children.map(persistDimensions);
  return Object.assign({}, newNode, { children });
};
const destroyYogaNodes = (node) => {
  const newNode = Object.assign({}, node);
  delete newNode.yogaNode;
  if (!node.children)
    return newNode;
  const children = node.children.map(destroyYogaNodes);
  return Object.assign({}, newNode, { children });
};
const freeYogaNodes = (node) => {
  if (node.yogaNode)
    node.yogaNode.freeRecursive();
  return node;
};
const resolvePageDimensions = (page, fontStore2, yoga) => {
  if (isNil(page))
    return null;
  return compose(destroyYogaNodes, freeYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page, fontStore2, yoga))(page);
};
const resolveDimensions = (node, fontStore2) => {
  if (!node.children)
    return node;
  const resolveChild = (child) => resolvePageDimensions(child, fontStore2, node.yoga);
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, { children });
};
const isText$1 = (node) => node.type === Text;
const SAFETY_THRESHOLD = 1e-3;
const assingChildren = (children, node) => Object.assign({}, node, { children });
const getTop = (node) => {
  var _a;
  return ((_a = node.box) == null ? void 0 : _a.top) || 0;
};
const allFixed = (nodes) => nodes.every(isFixed);
const isDynamic = (node) => node.props && "render" in node.props;
const relayoutPage = compose(resolveTextLayout, resolvePageDimensions, resolveInheritance, resolvePageStyles);
const warnUnavailableSpace = (node) => {
  console.warn(`Node of type ${node.type} can't wrap between pages and it's bigger than available page height`);
};
const splitNodes = (height2, contentArea, nodes) => {
  const currentChildren = [];
  const nextChildren = [];
  for (let i2 = 0; i2 < nodes.length; i2 += 1) {
    const child = nodes[i2];
    const futureNodes = nodes.slice(i2 + 1);
    const futureFixedNodes = futureNodes.filter(isFixed);
    const nodeTop = getTop(child);
    const nodeHeight = child.box.height;
    const isOutside = height2 <= nodeTop;
    const shouldBreak$1 = shouldBreak(child, futureNodes, height2);
    const shouldSplit = height2 + SAFETY_THRESHOLD < nodeTop + nodeHeight;
    const canWrap = getWrap(child);
    const fitsInsidePage = nodeHeight <= contentArea;
    if (isFixed(child)) {
      nextChildren.push(child);
      currentChildren.push(child);
      continue;
    }
    if (isOutside) {
      const box = Object.assign({}, child.box, { top: child.box.top - height2 });
      const next = Object.assign({}, child, { box });
      nextChildren.push(next);
      continue;
    }
    if (!fitsInsidePage && !canWrap) {
      currentChildren.push(child);
      nextChildren.push(...futureNodes);
      warnUnavailableSpace(child);
      break;
    }
    if (shouldBreak$1) {
      const box = Object.assign({}, child.box, { top: child.box.top - height2 });
      const props = Object.assign({}, child.props, {
        wrap: true,
        break: false
      });
      const next = Object.assign({}, child, { box, props });
      currentChildren.push(...futureFixedNodes);
      nextChildren.push(next, ...futureNodes);
      break;
    }
    if (shouldSplit) {
      const [currentChild, nextChild] = split(child, height2, contentArea);
      if (child.children.length > 0 && currentChild.children.length === 0) {
        if (currentChildren.length === 0) {
          currentChildren.push(child, ...futureFixedNodes);
          nextChildren.push(...futureNodes);
        } else {
          const box = Object.assign({}, child.box, {
            top: child.box.top - height2
          });
          const next = Object.assign({}, child, { box });
          currentChildren.push(...futureFixedNodes);
          nextChildren.push(next, ...futureNodes);
        }
        break;
      }
      if (currentChild)
        currentChildren.push(currentChild);
      if (nextChild)
        nextChildren.push(nextChild);
      continue;
    }
    currentChildren.push(child);
  }
  return [currentChildren, nextChildren];
};
const splitChildren = (height2, contentArea, node) => {
  const children = node.children || [];
  const availableHeight = height2 - getTop(node);
  return splitNodes(availableHeight, contentArea, children);
};
const splitView = (node, height2, contentArea) => {
  const [currentNode, nextNode] = splitNode(node, height2);
  const [currentChilds, nextChildren] = splitChildren(height2, contentArea, node);
  return [
    assingChildren(currentChilds, currentNode),
    assingChildren(nextChildren, nextNode)
  ];
};
const split = (node, height2, contentArea) => isText$1(node) ? splitText(node, height2) : splitView(node, height2, contentArea);
const shouldResolveDynamicNodes = (node) => {
  const children = node.children || [];
  return isDynamic(node) || children.some(shouldResolveDynamicNodes);
};
const resolveDynamicNodes = (props, node) => {
  const isNodeDynamic = isDynamic(node);
  const resolveChildren2 = (children2 = []) => {
    if (isNodeDynamic) {
      const res = node.props.render(props);
      return createInstances(res).filter(Boolean).map((n3) => resolveDynamicNodes(props, n3));
    }
    return children2.map((c2) => resolveDynamicNodes(props, c2));
  };
  const resetHeight = isNodeDynamic && isText$1(node);
  const box = resetHeight ? { ...node.box, height: 0 } : node.box;
  const children = resolveChildren2(node.children);
  const lines = isNodeDynamic ? null : node.lines;
  return Object.assign({}, node, { box, lines, children });
};
const resolveDynamicPage = (props, page, fontStore2, yoga) => {
  if (shouldResolveDynamicNodes(page)) {
    const resolvedPage = resolveDynamicNodes(props, page);
    return relayoutPage(resolvedPage, fontStore2, yoga);
  }
  return page;
};
const splitPage = (page, pageNumber, fontStore2, yoga) => {
  const wrapArea = getWrapArea(page);
  const contentArea = getContentArea(page);
  const dynamicPage = resolveDynamicPage({ pageNumber }, page, fontStore2, yoga);
  const height2 = page.style.height;
  const [currentChilds, nextChilds] = splitNodes(wrapArea, contentArea, dynamicPage.children);
  const relayout = (node) => (
    // @ts-expect-error rework pagination
    relayoutPage(node, fontStore2, yoga)
  );
  const currentBox = { ...page.box, height: height2 };
  const currentPage = relayout(Object.assign({}, page, { box: currentBox, children: currentChilds }));
  if (nextChilds.length === 0 || allFixed(nextChilds))
    return [currentPage, null];
  const nextBox = omit$1("height", page.box);
  const nextProps = omit$1("bookmark", page.props);
  const nextPage = relayout(Object.assign({}, page, {
    props: nextProps,
    box: nextBox,
    children: nextChilds
  }));
  return [currentPage, nextPage];
};
const resolvePageIndices = (fontStore2, yoga, page, pageNumber, pages) => {
  const totalPages = pages.length;
  const props = {
    totalPages,
    pageNumber: pageNumber + 1,
    subPageNumber: page.subPageNumber + 1,
    subPageTotalPages: page.subPageTotalPages
  };
  return resolveDynamicPage(props, page, fontStore2, yoga);
};
const assocSubPageData = (subpages) => {
  return subpages.map((page, i2) => ({
    ...page,
    subPageNumber: i2,
    subPageTotalPages: subpages.length
  }));
};
const dissocSubPageData = (page) => {
  return omit$1(["subPageNumber", "subPageTotalPages"], page);
};
const paginate = (page, pageNumber, fontStore2, yoga) => {
  var _a;
  if (!page)
    return [];
  if (((_a = page.props) == null ? void 0 : _a.wrap) === false)
    return [page];
  let splittedPage = splitPage(page, pageNumber, fontStore2, yoga);
  const pages = [splittedPage[0]];
  let nextPage = splittedPage[1];
  while (nextPage !== null) {
    splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore2, yoga);
    pages.push(splittedPage[0]);
    nextPage = splittedPage[1];
  }
  return pages;
};
const resolvePagination = (root, fontStore2) => {
  let pages = [];
  let pageNumber = 1;
  for (let i2 = 0; i2 < root.children.length; i2 += 1) {
    const page = root.children[i2];
    let subpages = paginate(page, pageNumber, fontStore2, root.yoga);
    subpages = assocSubPageData(subpages);
    pageNumber += subpages.length;
    pages = pages.concat(subpages);
  }
  pages = pages.map((...args) => dissocSubPageData(resolvePageIndices(fontStore2, root.yoga, ...args)));
  return assingChildren(pages, root);
};
const resolvePageHorizontalPadding = (container) => (value2) => {
  const match = matchPercent(value2);
  const width = container.width;
  return match ? match.percent * width : value2;
};
const resolvePageVerticalPadding = (container) => (value2) => {
  const match = matchPercent(value2);
  const height2 = container.height;
  return match ? match.percent * height2 : value2;
};
const resolvePagePaddings = (page) => {
  const container = page.style;
  const style = evolve({
    paddingTop: resolvePageVerticalPadding(container),
    paddingLeft: resolvePageHorizontalPadding(container),
    paddingRight: resolvePageHorizontalPadding(container),
    paddingBottom: resolvePageVerticalPadding(container)
  }, page.style);
  return Object.assign({}, page, { style });
};
const resolvePagesPaddings = (root) => {
  if (!root.children)
    return root;
  const children = root.children.map(resolvePagePaddings);
  return Object.assign({}, root, { children });
};
const resolveRadius = (box) => (value2) => {
  if (!value2)
    return void 0;
  const match = matchPercent(value2);
  return match ? match.percent * Math.min(box.width, box.height) : value2;
};
const resolvePercentRadius = (node) => {
  const style = evolve({
    borderTopLeftRadius: resolveRadius(node.box),
    borderTopRightRadius: resolveRadius(node.box),
    borderBottomRightRadius: resolveRadius(node.box),
    borderBottomLeftRadius: resolveRadius(node.box)
  }, node.style || {});
  const newNode = Object.assign({}, node, { style });
  if (!node.children)
    return newNode;
  const children = node.children.map(resolvePercentRadius);
  return Object.assign({}, newNode, { children });
};
const transformHeight = (pageArea, height2) => {
  const match = matchPercent(height2);
  return match ? match.percent * pageArea : height2;
};
const getPageArea = (page) => {
  var _a, _b;
  const pageHeight = page.style.height;
  const pagePaddingTop = ((_a = page.style) == null ? void 0 : _a.paddingTop) || 0;
  const pagePaddingBottom = ((_b = page.style) == null ? void 0 : _b.paddingBottom) || 0;
  return pageHeight - pagePaddingTop - pagePaddingBottom;
};
const resolveNodePercentHeight = (page, node) => {
  var _a, _b;
  if (isNil((_a = page.style) == null ? void 0 : _a.height))
    return node;
  if (isNil((_b = node.style) == null ? void 0 : _b.height))
    return node;
  const pageArea = getPageArea(page);
  const height2 = transformHeight(pageArea, node.style.height);
  const style = Object.assign({}, node.style, { height: height2 });
  return Object.assign({}, node, { style });
};
const resolvePagePercentHeight = (page) => {
  if (!page.children)
    return page;
  const resolveChild = (child) => resolveNodePercentHeight(page, child);
  const children = page.children.map(resolveChild);
  return Object.assign({}, page, { children });
};
const resolvePercentHeight = (root) => {
  if (!root.children)
    return root;
  const children = root.children.map(resolvePagePercentHeight);
  return Object.assign({}, root, { children });
};
const isType = (type) => (node) => node.type === type;
const isLink = isType(Link);
const isText = isType(Text);
const isTextInstance = isType(TextInstance);
const hasRenderProp = (node) => "render" in node.props;
const isTextType = (node) => isText(node) || isTextInstance(node);
const isTextLink = (node) => {
  const children = node.children || [];
  if (children.every(isTextInstance))
    return true;
  if (children.every(isText))
    return false;
  return children.every(isTextType);
};
const wrapText = (node) => {
  const textElement = {
    type: Text,
    props: {},
    style: {},
    box: {},
    children: node.children
  };
  return Object.assign({}, node, { children: [textElement] });
};
const transformLink = (node) => {
  if (!isLink(node))
    return node;
  if (hasRenderProp(node))
    return Object.assign({}, node, { type: Text });
  if (isTextLink(node))
    return wrapText(node);
  return node;
};
const resolveLinkSubstitution = (node) => {
  if (!node.children)
    return node;
  const resolveChild = compose(transformLink, resolveLinkSubstitution);
  const children = node.children.map(resolveChild);
  return Object.assign({}, node, { children });
};
const layout = asyncCompose(resolveZIndex, resolveOrigin, resolveAssets, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagesPaddings, resolveStyles, resolveLinkSubstitution, resolveBookmarks, resolvePageSizes, resolveYoga);
var scheduler = { exports: {} };
var scheduler_production = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production;
function requireScheduler_production() {
  if (hasRequiredScheduler_production) return scheduler_production;
  hasRequiredScheduler_production = 1;
  (function(exports) {
    function push(heap, node) {
      var index2 = heap.length;
      heap.push(node);
      a: for (; 0 < index2; ) {
        var parentIndex = index2 - 1 >>> 1, parent = heap[parentIndex];
        if (0 < compare8(parent, node))
          heap[parentIndex] = node, heap[index2] = parent, index2 = parentIndex;
        else break a;
      }
    }
    function peek(heap) {
      return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
      if (0 === heap.length) return null;
      var first = heap[0], last2 = heap.pop();
      if (last2 !== first) {
        heap[0] = last2;
        a: for (var index2 = 0, length2 = heap.length, halfLength = length2 >>> 1; index2 < halfLength; ) {
          var leftIndex = 2 * (index2 + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
          if (0 > compare8(left, last2))
            rightIndex < length2 && 0 > compare8(right, left) ? (heap[index2] = right, heap[rightIndex] = last2, index2 = rightIndex) : (heap[index2] = left, heap[leftIndex] = last2, index2 = leftIndex);
          else if (rightIndex < length2 && 0 > compare8(right, last2))
            heap[index2] = right, heap[rightIndex] = last2, index2 = rightIndex;
          else break a;
        }
      }
      return first;
    }
    function compare8(a2, b2) {
      var diff = a2.sortIndex - b2.sortIndex;
      return 0 !== diff ? diff : a2.id - b2.id;
    }
    exports.unstable_now = void 0;
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var localPerformance = performance;
      exports.unstable_now = function() {
        return localPerformance.now();
      };
    } else {
      var localDate = Date, initialTime = localDate.now();
      exports.unstable_now = function() {
        return localDate.now() - initialTime;
      };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); null !== timer; ) {
        if (null === timer.callback) pop(timerQueue);
        else if (timer.startTime <= currentTime)
          pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
        else break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = false;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (null !== peek(taskQueue))
          isHostCallbackScheduled = true, requestHostCallback();
        else {
          var firstTimer = peek(timerQueue);
          null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime2 = -1;
    function shouldYieldToHost() {
      return exports.unstable_now() - startTime2 < frameInterval ? false : true;
    }
    function performWorkUntilDeadline() {
      if (isMessageLoopRunning) {
        var currentTime = exports.unstable_now();
        startTime2 = currentTime;
        var hasMoreWork = true;
        try {
          a: {
            isHostCallbackScheduled = false;
            isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                  var callback = currentTask.callback;
                  if ("function" === typeof callback) {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(
                      currentTask.expirationTime <= currentTime
                    );
                    currentTime = exports.unstable_now();
                    if ("function" === typeof continuationCallback) {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = true;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (null !== currentTask) hasMoreWork = true;
                else {
                  var firstTimer = peek(timerQueue);
                  null !== firstTimer && requestHostTimeout(
                    handleTimeout,
                    firstTimer.startTime - currentTime
                  );
                  hasMoreWork = false;
                }
              }
              break a;
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
            }
            hasMoreWork = void 0;
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
        }
      }
    }
    var schedulePerformWorkUntilDeadline;
    if ("function" === typeof localSetImmediate)
      schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline);
      };
    else if ("undefined" !== typeof MessageChannel) {
      var channel = new MessageChannel(), port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function() {
        port.postMessage(null);
      };
    } else
      schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0);
      };
    function requestHostCallback() {
      isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
    }
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function() {
        callback(exports.unstable_now());
      }, ms);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
      task.callback = null;
    };
    exports.unstable_continueExecution = function() {
      isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, requestHostCallback());
    };
    exports.unstable_forceFrameRate = function(fps) {
      0 > fps || 125 < fps ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return currentPriorityLevel;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return peek(taskQueue);
    };
    exports.unstable_next = function(eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
      var currentTime = exports.unstable_now();
      "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5e3;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback,
        priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, requestHostCallback()));
      return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function() {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
  })(scheduler_production);
  return scheduler_production;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production();
  }
  return scheduler.exports;
}
var schedulerExports = requireScheduler();
const index$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(schedulerExports);
const n = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$1
}, [schedulerExports]);
function t(e2) {
  return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
}
function r$1(e2) {
  if (e2.__esModule) return e2;
  var n22 = e2.default;
  if ("function" == typeof n22) {
    var t2 = function e3() {
      return this instanceof e3 ? Reflect.construct(n22, arguments, this.constructor) : n22.apply(this, arguments);
    };
    t2.prototype = n22.prototype;
  } else t2 = {};
  return Object.defineProperty(t2, "__esModule", { value: true }), Object.keys(e2).forEach(function(n3) {
    var r2 = Object.getOwnPropertyDescriptor(e2, n3);
    Object.defineProperty(t2, n3, r2.get ? r2 : { enumerable: true, get: function() {
      return e2[n3];
    } });
  }), t2;
}
var l$1, a$1 = { exports: {} }, o$1 = { exports: {} }, u$1 = r$1(n);
var s$1;
/**
 * @license React
 * react-reconciler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
a$1.exports = (l$1 || (l$1 = 1, (s$1 = o$1).exports = function(n22) {
  function t2(e2, n3, t3, r3) {
    return new $r(e2, n3, t3, r3);
  }
  function r2(e2) {
    var n3 = "https://react.dev/errors/" + e2;
    if (1 < arguments.length) {
      n3 += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var t3 = 2; t3 < arguments.length; t3++) n3 += "&args[]=" + encodeURIComponent(arguments[t3]);
    }
    return "Minified React error #" + e2 + "; visit " + n3 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function l2(e2) {
    return null === e2 || "object" != typeof e2 ? null : "function" == typeof (e2 = Cl && e2[Cl] || e2["@@iterator"]) ? e2 : null;
  }
  function a2(e2) {
    if (null == e2) return null;
    if ("function" == typeof e2) return e2.$$typeof === El ? null : e2.displayName || e2.name || null;
    if ("string" == typeof e2) return e2;
    switch (e2) {
      case dl:
        return "Fragment";
      case fl:
        return "Portal";
      case ml:
        return "Profiler";
      case pl:
        return "StrictMode";
      case vl:
        return "Suspense";
      case Sl:
        return "SuspenseList";
    }
    if ("object" == typeof e2) switch (e2.$$typeof) {
      case yl:
        return (e2.displayName || "Context") + ".Provider";
      case gl:
        return (e2._context.displayName || "Context") + ".Consumer";
      case bl:
        var n3 = e2.render;
        return (e2 = e2.displayName) || (e2 = "" !== (e2 = n3.displayName || n3.name || "") ? "ForwardRef(" + e2 + ")" : "ForwardRef"), e2;
      case kl:
        return null !== (n3 = e2.displayName || null) ? n3 : a2(e2.type) || "Memo";
      case wl:
        n3 = e2._payload, e2 = e2._init;
        try {
          return a2(e2(n3));
        } catch (e3) {
        }
    }
    return null;
  }
  function o2(e2) {
    if (void 0 === rl) try {
      throw Error();
    } catch (e3) {
      var n3 = e3.stack.trim().match(/\n( *(at )?)/);
      rl = n3 && n3[1] || "", ll = -1 < e3.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < e3.stack.indexOf("@") ? "@unknown:0:0" : "";
    }
    return "\n" + rl + e2 + ll;
  }
  function i2(e2, n3) {
    if (!e2 || _l) return "";
    _l = true;
    var t3 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var r3 = { DetermineComponentFrameRoot: function() {
        try {
          if (n3) {
            var t4 = function() {
              throw Error();
            };
            if (Object.defineProperty(t4.prototype, "props", { set: function() {
              throw Error();
            } }), "object" == typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(t4, []);
              } catch (e3) {
                var r4 = e3;
              }
              Reflect.construct(e2, [], t4);
            } else {
              try {
                t4.call();
              } catch (e3) {
                r4 = e3;
              }
              e2.call(t4.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (e3) {
              r4 = e3;
            }
            (t4 = e2()) && "function" == typeof t4.catch && t4.catch(function() {
            });
          }
        } catch (e3) {
          if (e3 && r4 && "string" == typeof e3.stack) return [e3.stack, r4.stack];
        }
        return [null, null];
      } };
      r3.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var l3 = Object.getOwnPropertyDescriptor(r3.DetermineComponentFrameRoot, "name");
      l3 && l3.configurable && Object.defineProperty(r3.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
      var a3 = r3.DetermineComponentFrameRoot(), u2 = a3[0], i3 = a3[1];
      if (u2 && i3) {
        var s3 = u2.split("\n"), c3 = i3.split("\n");
        for (l3 = r3 = 0; r3 < s3.length && !s3[r3].includes("DetermineComponentFrameRoot"); ) r3++;
        for (; l3 < c3.length && !c3[l3].includes("DetermineComponentFrameRoot"); ) l3++;
        if (r3 === s3.length || l3 === c3.length) for (r3 = s3.length - 1, l3 = c3.length - 1; 1 <= r3 && 0 <= l3 && s3[r3] !== c3[l3]; ) l3--;
        for (; 1 <= r3 && 0 <= l3; r3--, l3--) if (s3[r3] !== c3[l3]) {
          if (1 !== r3 || 1 !== l3) do {
            if (r3--, 0 > --l3 || s3[r3] !== c3[l3]) {
              var f3 = "\n" + s3[r3].replace(" at new ", " at ");
              return e2.displayName && f3.includes("<anonymous>") && (f3 = f3.replace("<anonymous>", e2.displayName)), f3;
            }
          } while (1 <= r3 && 0 <= l3);
          break;
        }
      }
    } finally {
      _l = false, Error.prepareStackTrace = t3;
    }
    return (t3 = e2 ? e2.displayName || e2.name : "") ? o2(t3) : "";
  }
  function s2(e2) {
    switch (e2.tag) {
      case 26:
      case 27:
      case 5:
        return o2(e2.type);
      case 16:
        return o2("Lazy");
      case 13:
        return o2("Suspense");
      case 19:
        return o2("SuspenseList");
      case 0:
      case 15:
        return i2(e2.type, false);
      case 11:
        return i2(e2.type.render, false);
      case 1:
        return i2(e2.type, true);
      default:
        return "";
    }
  }
  function c2(e2) {
    try {
      var n3 = "";
      do {
        n3 += s2(e2), e2 = e2.return;
      } while (e2);
      return n3;
    } catch (e3) {
      return "\nError generating stack: " + e3.message + "\n" + e3.stack;
    }
  }
  function f2(e2) {
    return { current: e2 };
  }
  function d2(e2) {
    0 > Na || (e2.current = Ta[Na], Ta[Na] = null, Na--);
  }
  function p2(e2, n3) {
    Na++, Ta[Na] = e2.current, e2.current = n3;
  }
  function m2(e2) {
    var n3 = 42 & e2;
    if (0 !== n3) return n3;
    switch (e2 & -e2) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return 4194176 & e2;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return 62914560 & e2;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return e2;
    }
  }
  function h2(e2, n3) {
    var t3 = e2.pendingLanes;
    if (0 === t3) return 0;
    var r3 = 0, l3 = e2.suspendedLanes;
    e2 = e2.pingedLanes;
    var a3 = 134217727 & t3;
    return 0 !== a3 ? 0 != (t3 = a3 & ~l3) ? r3 = m2(t3) : 0 != (e2 &= a3) && (r3 = m2(e2)) : 0 != (t3 &= ~l3) ? r3 = m2(t3) : 0 !== e2 && (r3 = m2(e2)), 0 === r3 ? 0 : 0 !== n3 && n3 !== r3 && 0 == (n3 & l3) && ((l3 = r3 & -r3) >= (e2 = n3 & -n3) || 32 === l3 && 0 != (4194176 & e2)) ? n3 : r3;
  }
  function g2(e2, n3) {
    switch (e2) {
      case 1:
      case 2:
      case 4:
      case 8:
        return n3 + 250;
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return n3 + 5e3;
      default:
        return -1;
    }
  }
  function y2() {
    var e2 = Fa;
    return 0 == (4194176 & (Fa <<= 1)) && (Fa = 128), e2;
  }
  function b2() {
    var e2 = Ma;
    return 0 == (62914560 & (Ma <<= 1)) && (Ma = 4194304), e2;
  }
  function v2(e2) {
    for (var n3 = [], t3 = 0; 31 > t3; t3++) n3.push(e2);
    return n3;
  }
  function S2(e2, n3) {
    e2.pendingLanes |= n3, 268435456 !== n3 && (e2.suspendedLanes = 0, e2.pingedLanes = 0, e2.warmLanes = 0);
  }
  function k2(e2, n3, t3) {
    e2.pendingLanes |= n3, e2.suspendedLanes &= ~n3;
    var r3 = 31 - Ua(n3);
    e2.entangledLanes |= n3, e2.entanglements[r3] = 1073741824 | e2.entanglements[r3] | 4194218 & t3;
  }
  function w(e2, n3) {
    var t3 = e2.entangledLanes |= n3;
    for (e2 = e2.entanglements; t3; ) {
      var r3 = 31 - Ua(t3), l3 = 1 << r3;
      l3 & n3 | e2[r3] & n3 && (e2[r3] |= n3), t3 &= ~l3;
    }
  }
  function x(e2) {
    return 2 < (e2 &= -e2) ? 8 < e2 ? 0 != (134217727 & e2) ? 32 : 268435456 : 8 : 2;
  }
  function z(e2) {
    "function" == typeof qa && Ya(e2);
  }
  function C(e2, n3) {
    if ("object" == typeof e2 && null !== e2) {
      var t3 = Ka.get(e2);
      return void 0 !== t3 ? t3 : (n3 = { value: e2, source: n3, stack: c2(n3) }, Ka.set(e2, n3), n3);
    }
    return { value: e2, source: n3, stack: c2(n3) };
  }
  function E(e2) {
    for (; e2 === eo; ) eo = Xa[--Za], Xa[Za] = null, Xa[--Za], Xa[Za] = null;
    for (; e2 === ro; ) ro = no[--to], no[to] = null, no[--to], no[to] = null, no[--to], no[to] = null;
  }
  function P(e2, n3) {
    p2(oo, n3), p2(ao, e2), p2(lo, null), e2 = Nl(n3), d2(lo), p2(lo, e2);
  }
  function _() {
    d2(lo), d2(ao), d2(oo);
  }
  function R(e2) {
    null !== e2.memoizedState && p2(uo, e2);
    var n3 = lo.current, t3 = Ll(n3, e2.type);
    n3 !== t3 && (p2(ao, e2), p2(lo, t3));
  }
  function T(e2) {
    ao.current === e2 && (d2(lo), d2(ao)), uo.current === e2 && (d2(uo), ra._currentValue2 = ta);
  }
  function N() {
    for (var e2 = fo, n3 = po = fo = 0; n3 < e2; ) {
      var t3 = co[n3];
      co[n3++] = null;
      var r3 = co[n3];
      co[n3++] = null;
      var l3 = co[n3];
      co[n3++] = null;
      var a3 = co[n3];
      if (co[n3++] = null, null !== r3 && null !== l3) {
        var o3 = r3.pending;
        null === o3 ? l3.next = l3 : (l3.next = o3.next, o3.next = l3), r3.pending = l3;
      }
      0 !== a3 && I(t3, l3, a3);
    }
  }
  function L(e2, n3, t3, r3) {
    co[fo++] = e2, co[fo++] = n3, co[fo++] = t3, co[fo++] = r3, po |= r3, e2.lanes |= r3, null !== (e2 = e2.alternate) && (e2.lanes |= r3);
  }
  function U(e2, n3, t3, r3) {
    return L(e2, n3, t3, r3), F(e2);
  }
  function D(e2, n3) {
    return L(e2, null, null, n3), F(e2);
  }
  function I(e2, n3, t3) {
    e2.lanes |= t3;
    var r3 = e2.alternate;
    null !== r3 && (r3.lanes |= t3);
    for (var l3 = false, a3 = e2.return; null !== a3; ) a3.childLanes |= t3, null !== (r3 = a3.alternate) && (r3.childLanes |= t3), 22 === a3.tag && (null === (e2 = a3.stateNode) || 1 & e2._visibility || (l3 = true)), e2 = a3, a3 = a3.return;
    l3 && null !== n3 && 3 === e2.tag && (a3 = e2.stateNode, l3 = 31 - Ua(t3), null === (e2 = (a3 = a3.hiddenUpdates)[l3]) ? a3[l3] = [n3] : e2.push(n3), n3.lane = 536870912 | t3);
  }
  function F(e2) {
    if (50 < ti) throw ti = 0, ri = null, Error(r2(185));
    for (var n3 = e2.return; null !== n3; ) n3 = (e2 = n3).return;
    return 3 === e2.tag ? e2.stateNode : null;
  }
  function M(e2) {
    e2 !== ho && null === e2.next && (null === ho ? mo = ho = e2 : ho = ho.next = e2), yo = true, go || (go = true, Wa(Oa, H));
  }
  function W(e2, n3) {
    if (!bo && yo) {
      bo = true;
      do {
        for (var t3 = false, r3 = mo; null !== r3; ) {
          if (0 !== e2) {
            var l3 = r3.pendingLanes;
            if (0 === l3) var a3 = 0;
            else {
              var o3 = r3.suspendedLanes, u2 = r3.pingedLanes;
              a3 = (1 << 31 - Ua(42 | e2) + 1) - 1, a3 = 201326677 & (a3 &= l3 & ~(o3 & ~u2)) ? 201326677 & a3 | 1 : a3 ? 2 | a3 : 0;
            }
            0 !== a3 && (t3 = true, Q(r3, a3));
          } else a3 = Lu, 0 != (3 & (a3 = h2(r3, r3 === Tu ? a3 : 0))) && (t3 = true, Q(r3, a3));
          r3 = r3.next;
        }
      } while (t3);
      bo = false;
    }
  }
  function H() {
    yo = go = false;
    var e2 = 0;
    0 !== vo && (Gl() && (e2 = vo), vo = 0);
    for (var n3 = Qa(), t3 = null, r3 = mo; null !== r3; ) {
      var l3 = r3.next, a3 = j(r3, n3);
      0 === a3 ? (r3.next = null, null === t3 ? mo = l3 : t3.next = l3, null === l3 && (ho = t3)) : (t3 = r3, (0 !== e2 || 0 != (3 & a3)) && (yo = true)), r3 = l3;
    }
    W(e2);
  }
  function j(e2, n3) {
    for (var t3 = e2.suspendedLanes, r3 = e2.pingedLanes, l3 = e2.expirationTimes, a3 = -62914561 & e2.pendingLanes; 0 < a3; ) {
      var o3 = 31 - Ua(a3), u2 = 1 << o3, i3 = l3[o3];
      -1 === i3 ? 0 != (u2 & t3) && 0 == (u2 & r3) || (l3[o3] = g2(u2, n3)) : i3 <= n3 && (e2.expiredLanes |= u2), a3 &= ~u2;
    }
    if (t3 = Lu, t3 = h2(e2, e2 === (n3 = Tu) ? t3 : 0), r3 = e2.callbackNode, 0 === t3 || e2 === n3 && 2 === Uu || null !== e2.cancelPendingCommit) return null !== r3 && null !== r3 && Ha(r3), e2.callbackNode = null, e2.callbackPriority = 0;
    if (0 != (3 & t3)) return null !== r3 && null !== r3 && Ha(r3), e2.callbackPriority = 2, e2.callbackNode = null, 2;
    if ((n3 = t3 & -t3) === e2.callbackPriority) return n3;
    switch (null !== r3 && Ha(r3), x(t3)) {
      case 2:
        t3 = Oa;
        break;
      case 8:
        t3 = Ba;
        break;
      case 32:
      default:
        t3 = Va;
        break;
      case 268435456:
        t3 = $a;
    }
    return r3 = A.bind(null, e2), t3 = Wa(t3, r3), e2.callbackPriority = n3, e2.callbackNode = t3, n3;
  }
  function A(e2, n3) {
    var t3 = e2.callbackNode;
    if (Wr() && e2.callbackNode !== t3) return null;
    var r3 = Lu;
    return 0 === (r3 = h2(e2, e2 === Tu ? r3 : 0)) ? null : (gr(e2, r3, n3), j(e2, Qa()), e2.callbackNode === t3 ? A.bind(null, e2) : null);
  }
  function Q(e2, n3) {
    if (Wr()) return null;
    gr(e2, n3, true);
  }
  function O() {
    return 0 === vo && (vo = y2()), vo;
  }
  function B() {
    if (0 == --ko && null !== So) {
      null !== xo && (xo.status = "fulfilled");
      var e2 = So;
      So = null, wo = 0, xo = null;
      for (var n3 = 0; n3 < e2.length; n3++) (0, e2[n3])();
    }
  }
  function V(e2) {
    e2.updateQueue = { baseState: e2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null };
  }
  function $(e2, n3) {
    e2 = e2.updateQueue, n3.updateQueue === e2 && (n3.updateQueue = { baseState: e2.baseState, firstBaseUpdate: e2.firstBaseUpdate, lastBaseUpdate: e2.lastBaseUpdate, shared: e2.shared, callbacks: null });
  }
  function q(e2) {
    return { lane: e2, tag: 0, payload: null, callback: null, next: null };
  }
  function Y(e2, n3, t3) {
    var r3 = e2.updateQueue;
    if (null === r3) return null;
    if (r3 = r3.shared, 0 != (2 & Ru)) {
      var l3 = r3.pending;
      return null === l3 ? n3.next = n3 : (n3.next = l3.next, l3.next = n3), r3.pending = n3, n3 = F(e2), I(e2, null, t3), n3;
    }
    return L(e2, r3, n3, t3), F(e2);
  }
  function G2(e2, n3, t3) {
    if (null !== (n3 = n3.updateQueue) && (n3 = n3.shared, 0 != (4194176 & t3))) {
      var r3 = n3.lanes;
      t3 |= r3 &= e2.pendingLanes, n3.lanes = t3, w(e2, t3);
    }
  }
  function J(e2, n3) {
    var t3 = e2.updateQueue, r3 = e2.alternate;
    if (null !== r3 && t3 === (r3 = r3.updateQueue)) {
      var l3 = null, a3 = null;
      if (null !== (t3 = t3.firstBaseUpdate)) {
        do {
          var o3 = { lane: t3.lane, tag: t3.tag, payload: t3.payload, callback: null, next: null };
          null === a3 ? l3 = a3 = o3 : a3 = a3.next = o3, t3 = t3.next;
        } while (null !== t3);
        null === a3 ? l3 = a3 = n3 : a3 = a3.next = n3;
      } else l3 = a3 = n3;
      return t3 = { baseState: r3.baseState, firstBaseUpdate: l3, lastBaseUpdate: a3, shared: r3.shared, callbacks: r3.callbacks }, void (e2.updateQueue = t3);
    }
    null === (e2 = t3.lastBaseUpdate) ? t3.firstBaseUpdate = n3 : e2.next = n3, t3.lastBaseUpdate = n3;
  }
  function K() {
    if (Co && null !== xo) throw xo;
  }
  function X(e2, n3, t3, r3) {
    Co = false;
    var l3 = e2.updateQueue;
    zo = false;
    var a3 = l3.firstBaseUpdate, o3 = l3.lastBaseUpdate, u2 = l3.shared.pending;
    if (null !== u2) {
      l3.shared.pending = null;
      var i3 = u2, s3 = i3.next;
      i3.next = null, null === o3 ? a3 = s3 : o3.next = s3, o3 = i3;
      var c3 = e2.alternate;
      null !== c3 && (u2 = (c3 = c3.updateQueue).lastBaseUpdate) !== o3 && (null === u2 ? c3.firstBaseUpdate = s3 : u2.next = s3, c3.lastBaseUpdate = i3);
    }
    if (null !== a3) {
      var f3 = l3.baseState;
      for (o3 = 0, c3 = s3 = i3 = null, u2 = a3; ; ) {
        var d3 = -536870913 & u2.lane, p3 = d3 !== u2.lane;
        if (p3 ? (Lu & d3) === d3 : (r3 & d3) === d3) {
          0 !== d3 && d3 === wo && (Co = true), null !== c3 && (c3 = c3.next = { lane: 0, tag: u2.tag, payload: u2.payload, callback: null, next: null });
          e: {
            var m3 = e2, h3 = u2;
            d3 = n3;
            var g3 = t3;
            switch (h3.tag) {
              case 1:
                if ("function" == typeof (m3 = h3.payload)) {
                  f3 = m3.call(g3, f3, d3);
                  break e;
                }
                f3 = m3;
                break e;
              case 3:
                m3.flags = -65537 & m3.flags | 128;
              case 0:
                if (null == (d3 = "function" == typeof (m3 = h3.payload) ? m3.call(g3, f3, d3) : m3)) break e;
                f3 = il({}, f3, d3);
                break e;
              case 2:
                zo = true;
            }
          }
          null !== (d3 = u2.callback) && (e2.flags |= 64, p3 && (e2.flags |= 8192), null === (p3 = l3.callbacks) ? l3.callbacks = [d3] : p3.push(d3));
        } else p3 = { lane: d3, tag: u2.tag, payload: u2.payload, callback: u2.callback, next: null }, null === c3 ? (s3 = c3 = p3, i3 = f3) : c3 = c3.next = p3, o3 |= d3;
        if (null === (u2 = u2.next)) {
          if (null === (u2 = l3.shared.pending)) break;
          u2 = (p3 = u2).next, p3.next = null, l3.lastBaseUpdate = p3, l3.shared.pending = null;
        }
      }
      null === c3 && (i3 = f3), l3.baseState = i3, l3.firstBaseUpdate = s3, l3.lastBaseUpdate = c3, null === a3 && (l3.shared.lanes = 0), Hu |= o3, e2.lanes = o3, e2.memoizedState = f3;
    }
  }
  function Z(e2, n3) {
    if ("function" != typeof e2) throw Error(r2(191, e2));
    e2.call(n3);
  }
  function ee(e2, n3) {
    var t3 = e2.callbacks;
    if (null !== t3) for (e2.callbacks = null, e2 = 0; e2 < t3.length; e2++) Z(t3[e2], n3);
  }
  function ne(e2, n3) {
    if (Ja(e2, n3)) return true;
    if ("object" != typeof e2 || null === e2 || "object" != typeof n3 || null === n3) return false;
    var t3 = Object.keys(e2), r3 = Object.keys(n3);
    if (t3.length !== r3.length) return false;
    for (r3 = 0; r3 < t3.length; r3++) {
      var l3 = t3[r3];
      if (!Eo.call(n3, l3) || !Ja(e2[l3], n3[l3])) return false;
    }
    return true;
  }
  function te(e2) {
    return "fulfilled" === (e2 = e2.status) || "rejected" === e2;
  }
  function re() {
  }
  function le(e2, n3, t3) {
    switch (void 0 === (t3 = e2[t3]) ? e2.push(n3) : t3 !== n3 && (n3.then(re, re), n3 = t3), n3.status) {
      case "fulfilled":
        return n3.value;
      case "rejected":
        if ((e2 = n3.reason) === Po) throw Error(r2(483));
        throw e2;
      default:
        if ("string" == typeof n3.status) n3.then(re, re);
        else {
          if (null !== (e2 = Tu) && 100 < e2.shellSuspendCounter) throw Error(r2(482));
          (e2 = n3).status = "pending", e2.then(function(e3) {
            if ("pending" === n3.status) {
              var t4 = n3;
              t4.status = "fulfilled", t4.value = e3;
            }
          }, function(e3) {
            if ("pending" === n3.status) {
              var t4 = n3;
              t4.status = "rejected", t4.reason = e3;
            }
          });
        }
        switch (n3.status) {
          case "fulfilled":
            return n3.value;
          case "rejected":
            if ((e2 = n3.reason) === Po) throw Error(r2(483));
            throw e2;
        }
        throw To = n3, Po;
    }
  }
  function ae() {
    if (null === To) throw Error(r2(459));
    var e2 = To;
    return To = null, e2;
  }
  function oe(e2) {
    var n3 = Lo;
    return Lo += 1, null === No && (No = []), le(No, e2, n3);
  }
  function ue(e2, n3, t3, r3) {
    e2 = r3.props.ref, t3.ref = void 0 !== e2 ? e2 : null;
  }
  function ie(e2, n3) {
    if (n3.$$typeof === sl) throw Error(r2(525));
    throw e2 = Object.prototype.toString.call(n3), Error(r2(31, "[object Object]" === e2 ? "object with keys {" + Object.keys(n3).join(", ") + "}" : e2));
  }
  function se(e2) {
    return (0, e2._init)(e2._payload);
  }
  function ce(e2) {
    function n3(n4, t3) {
      if (e2) {
        var r3 = n4.deletions;
        null === r3 ? (n4.deletions = [t3], n4.flags |= 16) : r3.push(t3);
      }
    }
    function a3(t3, r3) {
      if (!e2) return null;
      for (; null !== r3; ) n3(t3, r3), r3 = r3.sibling;
      return null;
    }
    function o3(e3) {
      for (var n4 = /* @__PURE__ */ new Map(); null !== e3; ) null !== e3.key ? n4.set(e3.key, e3) : n4.set(e3.index, e3), e3 = e3.sibling;
      return n4;
    }
    function u2(e3, n4) {
      return (e3 = Yr(e3, n4)).index = 0, e3.sibling = null, e3;
    }
    function i3(n4, t3, r3) {
      return n4.index = r3, e2 ? null !== (r3 = n4.alternate) ? (r3 = r3.index) < t3 ? (n4.flags |= 33554434, t3) : r3 : (n4.flags |= 33554434, t3) : (n4.flags |= 1048576, t3);
    }
    function s3(n4) {
      return e2 && null === n4.alternate && (n4.flags |= 33554434), n4;
    }
    function c3(e3, n4, t3, r3) {
      return null === n4 || 6 !== n4.tag ? ((n4 = Zr(t3, e3.mode, r3)).return = e3, n4) : ((n4 = u2(n4, t3)).return = e3, n4);
    }
    function f3(e3, n4, t3, r3) {
      var l3 = t3.type;
      return l3 === dl ? p3(e3, n4, t3.props.children, r3, t3.key) : null !== n4 && (n4.elementType === l3 || "object" == typeof l3 && null !== l3 && l3.$$typeof === wl && se(l3) === n4.type) ? (ue(e3, 0, r3 = u2(n4, t3.props), t3), r3.return = e3, r3) : (ue(e3, 0, r3 = Jr(t3.type, t3.key, t3.props, null, e3.mode, r3), t3), r3.return = e3, r3);
    }
    function d3(e3, n4, t3, r3) {
      return null === n4 || 4 !== n4.tag || n4.stateNode.containerInfo !== t3.containerInfo || n4.stateNode.implementation !== t3.implementation ? ((n4 = el(t3, e3.mode, r3)).return = e3, n4) : ((n4 = u2(n4, t3.children || [])).return = e3, n4);
    }
    function p3(e3, n4, t3, r3, l3) {
      return null === n4 || 7 !== n4.tag ? ((n4 = Kr(t3, e3.mode, r3, l3)).return = e3, n4) : ((n4 = u2(n4, t3)).return = e3, n4);
    }
    function m3(e3, n4, t3) {
      if ("string" == typeof n4 && "" !== n4 || "number" == typeof n4 || "bigint" == typeof n4) return (n4 = Zr("" + n4, e3.mode, t3)).return = e3, n4;
      if ("object" == typeof n4 && null !== n4) {
        switch (n4.$$typeof) {
          case cl:
            return ue(e3, 0, t3 = Jr(n4.type, n4.key, n4.props, null, e3.mode, t3), n4), t3.return = e3, t3;
          case fl:
            return (n4 = el(n4, e3.mode, t3)).return = e3, n4;
          case wl:
            return m3(e3, n4 = (0, n4._init)(n4._payload), t3);
        }
        if (Rl(n4) || l2(n4)) return (n4 = Kr(n4, e3.mode, t3, null)).return = e3, n4;
        if ("function" == typeof n4.then) return m3(e3, oe(n4), t3);
        if (n4.$$typeof === yl) return m3(e3, yt(e3, n4), t3);
        ie(e3, n4);
      }
      return null;
    }
    function h3(e3, n4, t3, r3) {
      var a4 = null !== n4 ? n4.key : null;
      if ("string" == typeof t3 && "" !== t3 || "number" == typeof t3 || "bigint" == typeof t3) return null !== a4 ? null : c3(e3, n4, "" + t3, r3);
      if ("object" == typeof t3 && null !== t3) {
        switch (t3.$$typeof) {
          case cl:
            return t3.key === a4 ? f3(e3, n4, t3, r3) : null;
          case fl:
            return t3.key === a4 ? d3(e3, n4, t3, r3) : null;
          case wl:
            return h3(e3, n4, t3 = (a4 = t3._init)(t3._payload), r3);
        }
        if (Rl(t3) || l2(t3)) return null !== a4 ? null : p3(e3, n4, t3, r3, null);
        if ("function" == typeof t3.then) return h3(e3, n4, oe(t3), r3);
        if (t3.$$typeof === yl) return h3(e3, n4, yt(e3, t3), r3);
        ie(e3, t3);
      }
      return null;
    }
    function g3(e3, n4, t3, r3, a4) {
      if ("string" == typeof r3 && "" !== r3 || "number" == typeof r3 || "bigint" == typeof r3) return c3(n4, e3 = e3.get(t3) || null, "" + r3, a4);
      if ("object" == typeof r3 && null !== r3) {
        switch (r3.$$typeof) {
          case cl:
            return f3(n4, e3 = e3.get(null === r3.key ? t3 : r3.key) || null, r3, a4);
          case fl:
            return d3(n4, e3 = e3.get(null === r3.key ? t3 : r3.key) || null, r3, a4);
          case wl:
            return g3(e3, n4, t3, r3 = (0, r3._init)(r3._payload), a4);
        }
        if (Rl(r3) || l2(r3)) return p3(n4, e3 = e3.get(t3) || null, r3, a4, null);
        if ("function" == typeof r3.then) return g3(e3, n4, t3, oe(r3), a4);
        if (r3.$$typeof === yl) return g3(e3, n4, t3, yt(n4, r3), a4);
        ie(n4, r3);
      }
      return null;
    }
    function y3(t3, c4, f4, d4) {
      if ("object" == typeof f4 && null !== f4 && f4.type === dl && null === f4.key && (f4 = f4.props.children), "object" == typeof f4 && null !== f4) {
        switch (f4.$$typeof) {
          case cl:
            e: {
              for (var p4 = f4.key, b3 = c4; null !== b3; ) {
                if (b3.key === p4) {
                  if ((p4 = f4.type) === dl) {
                    if (7 === b3.tag) {
                      a3(t3, b3.sibling), (c4 = u2(b3, f4.props.children)).return = t3, t3 = c4;
                      break e;
                    }
                  } else if (b3.elementType === p4 || "object" == typeof p4 && null !== p4 && p4.$$typeof === wl && se(p4) === b3.type) {
                    a3(t3, b3.sibling), ue(t3, 0, c4 = u2(b3, f4.props), f4), c4.return = t3, t3 = c4;
                    break e;
                  }
                  a3(t3, b3);
                  break;
                }
                n3(t3, b3), b3 = b3.sibling;
              }
              f4.type === dl ? ((c4 = Kr(f4.props.children, t3.mode, d4, f4.key)).return = t3, t3 = c4) : (ue(t3, 0, d4 = Jr(f4.type, f4.key, f4.props, null, t3.mode, d4), f4), d4.return = t3, t3 = d4);
            }
            return s3(t3);
          case fl:
            e: {
              for (b3 = f4.key; null !== c4; ) {
                if (c4.key === b3) {
                  if (4 === c4.tag && c4.stateNode.containerInfo === f4.containerInfo && c4.stateNode.implementation === f4.implementation) {
                    a3(t3, c4.sibling), (c4 = u2(c4, f4.children || [])).return = t3, t3 = c4;
                    break e;
                  }
                  a3(t3, c4);
                  break;
                }
                n3(t3, c4), c4 = c4.sibling;
              }
              (c4 = el(f4, t3.mode, d4)).return = t3, t3 = c4;
            }
            return s3(t3);
          case wl:
            return y3(t3, c4, f4 = (b3 = f4._init)(f4._payload), d4);
        }
        if (Rl(f4)) return function(t4, r3, l3, u3) {
          for (var s4 = null, c5 = null, f5 = r3, d5 = r3 = 0, p5 = null; null !== f5 && d5 < l3.length; d5++) {
            f5.index > d5 ? (p5 = f5, f5 = null) : p5 = f5.sibling;
            var y4 = h3(t4, f5, l3[d5], u3);
            if (null === y4) {
              null === f5 && (f5 = p5);
              break;
            }
            e2 && f5 && null === y4.alternate && n3(t4, f5), r3 = i3(y4, r3, d5), null === c5 ? s4 = y4 : c5.sibling = y4, c5 = y4, f5 = p5;
          }
          if (d5 === l3.length) return a3(t4, f5), s4;
          if (null === f5) {
            for (; d5 < l3.length; d5++) null !== (f5 = m3(t4, l3[d5], u3)) && (r3 = i3(f5, r3, d5), null === c5 ? s4 = f5 : c5.sibling = f5, c5 = f5);
            return s4;
          }
          for (f5 = o3(f5); d5 < l3.length; d5++) null !== (p5 = g3(f5, t4, d5, l3[d5], u3)) && (e2 && null !== p5.alternate && f5.delete(null === p5.key ? d5 : p5.key), r3 = i3(p5, r3, d5), null === c5 ? s4 = p5 : c5.sibling = p5, c5 = p5);
          return e2 && f5.forEach(function(e3) {
            return n3(t4, e3);
          }), s4;
        }(t3, c4, f4, d4);
        if (l2(f4)) {
          if ("function" != typeof (b3 = l2(f4))) throw Error(r2(150));
          return function(t4, l3, u3, s4) {
            if (null == u3) throw Error(r2(151));
            for (var c5 = null, f5 = null, d5 = l3, p5 = l3 = 0, y4 = null, b4 = u3.next(); null !== d5 && !b4.done; p5++, b4 = u3.next()) {
              d5.index > p5 ? (y4 = d5, d5 = null) : y4 = d5.sibling;
              var v3 = h3(t4, d5, b4.value, s4);
              if (null === v3) {
                null === d5 && (d5 = y4);
                break;
              }
              e2 && d5 && null === v3.alternate && n3(t4, d5), l3 = i3(v3, l3, p5), null === f5 ? c5 = v3 : f5.sibling = v3, f5 = v3, d5 = y4;
            }
            if (b4.done) return a3(t4, d5), c5;
            if (null === d5) {
              for (; !b4.done; p5++, b4 = u3.next()) null !== (b4 = m3(t4, b4.value, s4)) && (l3 = i3(b4, l3, p5), null === f5 ? c5 = b4 : f5.sibling = b4, f5 = b4);
              return c5;
            }
            for (d5 = o3(d5); !b4.done; p5++, b4 = u3.next()) null !== (b4 = g3(d5, t4, p5, b4.value, s4)) && (e2 && null !== b4.alternate && d5.delete(null === b4.key ? p5 : b4.key), l3 = i3(b4, l3, p5), null === f5 ? c5 = b4 : f5.sibling = b4, f5 = b4);
            return e2 && d5.forEach(function(e3) {
              return n3(t4, e3);
            }), c5;
          }(t3, c4, f4 = b3.call(f4), d4);
        }
        if ("function" == typeof f4.then) return y3(t3, c4, oe(f4), d4);
        if (f4.$$typeof === yl) return y3(t3, c4, yt(t3, f4), d4);
        ie(t3, f4);
      }
      return "string" == typeof f4 && "" !== f4 || "number" == typeof f4 || "bigint" == typeof f4 ? (f4 = "" + f4, null !== c4 && 6 === c4.tag ? (a3(t3, c4.sibling), (c4 = u2(c4, f4)).return = t3, t3 = c4) : (a3(t3, c4), (c4 = Zr(f4, t3.mode, d4)).return = t3, t3 = c4), s3(t3)) : a3(t3, c4);
    }
    return function(e3, n4, r3, l3) {
      try {
        Lo = 0;
        var a4 = y3(e3, n4, r3, l3);
        return No = null, a4;
      } catch (n5) {
        if (n5 === Po) throw n5;
        var o4 = t2(29, n5, null, e3.mode);
        return o4.lanes = l3, o4.return = e3, o4;
      }
    };
  }
  function fe(e2, n3) {
    p2(Fo, e2 = Mu), p2(Io, n3), Mu = e2 | n3.baseLanes;
  }
  function de() {
    p2(Fo, Mu), p2(Io, Io.current);
  }
  function pe() {
    Mu = Fo.current, d2(Io), d2(Fo);
  }
  function me(e2) {
    var n3 = e2.alternate;
    p2(Ho, 1 & Ho.current), p2(Mo, e2), null === Wo && (null === n3 || null !== Io.current || null !== n3.memoizedState) && (Wo = e2);
  }
  function he(e2) {
    if (22 === e2.tag) {
      if (p2(Ho, Ho.current), p2(Mo, e2), null === Wo) {
        var n3 = e2.alternate;
        null !== n3 && null !== n3.memoizedState && (Wo = e2);
      }
    } else ge();
  }
  function ge() {
    p2(Ho, Ho.current), p2(Mo, Mo.current);
  }
  function ye(e2) {
    d2(Mo), Wo === e2 && (Wo = null), d2(Ho);
  }
  function be(e2) {
    for (var n3 = e2; null !== n3; ) {
      if (13 === n3.tag) {
        var t3 = n3.memoizedState;
        if (null !== t3 && (null === (t3 = t3.dehydrated) || Sa(t3) || ka(t3))) return n3;
      } else if (19 === n3.tag && void 0 !== n3.memoizedProps.revealOrder) {
        if (0 != (128 & n3.flags)) return n3;
      } else if (null !== n3.child) {
        n3.child.return = n3, n3 = n3.child;
        continue;
      }
      if (n3 === e2) break;
      for (; null === n3.sibling; ) {
        if (null === n3.return || n3.return === e2) return null;
        n3 = n3.return;
      }
      n3.sibling.return = n3.return, n3 = n3.sibling;
    }
    return null;
  }
  function ve() {
    throw Error(r2(321));
  }
  function Se(e2, n3) {
    if (null === n3) return false;
    for (var t3 = 0; t3 < n3.length && t3 < e2.length; t3++) if (!Ja(e2[t3], n3[t3])) return false;
    return true;
  }
  function ke(e2, n3, t3, r3, l3, a3) {
    return jo = a3, Ao = n3, n3.memoizedState = null, n3.updateQueue = null, n3.lanes = 0, Pl.H = null === e2 || null === e2.memoizedState ? Zo : eu, $o = false, a3 = t3(r3, l3), $o = false, Vo && (a3 = xe(n3, t3, r3, l3)), we(e2), a3;
  }
  function we(e2) {
    Pl.H = Xo;
    var n3 = null !== Qo && null !== Qo.next;
    if (jo = 0, Oo = Qo = Ao = null, Bo = false, Yo = 0, Go = null, n3) throw Error(r2(300));
    null === e2 || lu || null !== (e2 = e2.dependencies) && mt(e2) && (lu = true);
  }
  function xe(e2, n3, t3, l3) {
    Ao = e2;
    var a3 = 0;
    do {
      if (Vo && (Go = null), Yo = 0, Vo = false, 25 <= a3) throw Error(r2(301));
      if (a3 += 1, Oo = Qo = null, null != e2.updateQueue) {
        var o3 = e2.updateQueue;
        o3.lastEffect = null, o3.events = null, o3.stores = null, null != o3.memoCache && (o3.memoCache.index = 0);
      }
      Pl.H = nu, o3 = n3(t3, l3);
    } while (Vo);
    return o3;
  }
  function ze() {
    var e2 = Pl.H, n3 = e2.useState()[0];
    return n3 = "function" == typeof n3.then ? Te(n3) : n3, e2 = e2.useState()[0], (null !== Qo ? Qo.memoizedState : null) !== e2 && (Ao.flags |= 1024), n3;
  }
  function Ce() {
    var e2 = 0 !== qo;
    return qo = 0, e2;
  }
  function Ee(e2, n3, t3) {
    n3.updateQueue = e2.updateQueue, n3.flags &= -2053, e2.lanes &= ~t3;
  }
  function Pe(e2) {
    if (Bo) {
      for (e2 = e2.memoizedState; null !== e2; ) {
        var n3 = e2.queue;
        null !== n3 && (n3.pending = null), e2 = e2.next;
      }
      Bo = false;
    }
    jo = 0, Oo = Qo = Ao = null, Vo = false, Yo = qo = 0, Go = null;
  }
  function _e() {
    var e2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return null === Oo ? Ao.memoizedState = Oo = e2 : Oo = Oo.next = e2, Oo;
  }
  function Re() {
    if (null === Qo) {
      var e2 = Ao.alternate;
      e2 = null !== e2 ? e2.memoizedState : null;
    } else e2 = Qo.next;
    var n3 = null === Oo ? Ao.memoizedState : Oo.next;
    if (null !== n3) Oo = n3, Qo = e2;
    else {
      if (null === e2) {
        if (null === Ao.alternate) throw Error(r2(467));
        throw Error(r2(310));
      }
      e2 = { memoizedState: (Qo = e2).memoizedState, baseState: Qo.baseState, baseQueue: Qo.baseQueue, queue: Qo.queue, next: null }, null === Oo ? Ao.memoizedState = Oo = e2 : Oo = Oo.next = e2;
    }
    return Oo;
  }
  function Te(e2) {
    var n3 = Yo;
    return Yo += 1, null === Go && (Go = []), e2 = le(Go, e2, n3), n3 = Ao, null === (null === Oo ? n3.memoizedState : Oo.next) && (n3 = n3.alternate, Pl.H = null === n3 || null === n3.memoizedState ? Zo : eu), e2;
  }
  function Ne(e2) {
    if (null !== e2 && "object" == typeof e2) {
      if ("function" == typeof e2.then) return Te(e2);
      if (e2.$$typeof === yl) return gt(e2);
    }
    throw Error(r2(438, String(e2)));
  }
  function Le(e2) {
    var n3 = null, t3 = Ao.updateQueue;
    if (null !== t3 && (n3 = t3.memoCache), null == n3) {
      var r3 = Ao.alternate;
      null !== r3 && null !== (r3 = r3.updateQueue) && null != (r3 = r3.memoCache) && (n3 = { data: r3.data.map(function(e3) {
        return e3.slice();
      }), index: 0 });
    }
    if (null == n3 && (n3 = { data: [], index: 0 }), null === t3 && (t3 = Ko(), Ao.updateQueue = t3), t3.memoCache = n3, void 0 === (t3 = n3.data[n3.index])) for (t3 = n3.data[n3.index] = Array(e2), r3 = 0; r3 < e2; r3++) t3[r3] = zl;
    return n3.index++, t3;
  }
  function Ue(e2, n3) {
    return "function" == typeof n3 ? n3(e2) : n3;
  }
  function De(e2) {
    return Ie(Re(), Qo, e2);
  }
  function Ie(e2, n3, t3) {
    var l3 = e2.queue;
    if (null === l3) throw Error(r2(311));
    l3.lastRenderedReducer = t3;
    var a3 = e2.baseQueue, o3 = l3.pending;
    if (null !== o3) {
      if (null !== a3) {
        var u2 = a3.next;
        a3.next = o3.next, o3.next = u2;
      }
      n3.baseQueue = a3 = o3, l3.pending = null;
    }
    if (o3 = e2.baseState, null === a3) e2.memoizedState = o3;
    else {
      var i3 = u2 = null, s3 = null, c3 = n3 = a3.next, f3 = false;
      do {
        var d3 = -536870913 & c3.lane;
        if (d3 !== c3.lane ? (Lu & d3) === d3 : (jo & d3) === d3) {
          var p3 = c3.revertLane;
          if (0 === p3) null !== s3 && (s3 = s3.next = { lane: 0, revertLane: 0, action: c3.action, hasEagerState: c3.hasEagerState, eagerState: c3.eagerState, next: null }), d3 === wo && (f3 = true);
          else {
            if ((jo & p3) === p3) {
              c3 = c3.next, p3 === wo && (f3 = true);
              continue;
            }
            d3 = { lane: 0, revertLane: c3.revertLane, action: c3.action, hasEagerState: c3.hasEagerState, eagerState: c3.eagerState, next: null }, null === s3 ? (i3 = s3 = d3, u2 = o3) : s3 = s3.next = d3, Ao.lanes |= p3, Hu |= p3;
          }
          d3 = c3.action, $o && t3(o3, d3), o3 = c3.hasEagerState ? c3.eagerState : t3(o3, d3);
        } else p3 = { lane: d3, revertLane: c3.revertLane, action: c3.action, hasEagerState: c3.hasEagerState, eagerState: c3.eagerState, next: null }, null === s3 ? (i3 = s3 = p3, u2 = o3) : s3 = s3.next = p3, Ao.lanes |= d3, Hu |= d3;
        c3 = c3.next;
      } while (null !== c3 && c3 !== n3);
      if (null === s3 ? u2 = o3 : s3.next = i3, !Ja(o3, e2.memoizedState) && (lu = true, f3 && null !== (t3 = xo))) throw t3;
      e2.memoizedState = o3, e2.baseState = u2, e2.baseQueue = s3, l3.lastRenderedState = o3;
    }
    return null === a3 && (l3.lanes = 0), [e2.memoizedState, l3.dispatch];
  }
  function Fe(e2) {
    var n3 = Re(), t3 = n3.queue;
    if (null === t3) throw Error(r2(311));
    t3.lastRenderedReducer = e2;
    var l3 = t3.dispatch, a3 = t3.pending, o3 = n3.memoizedState;
    if (null !== a3) {
      t3.pending = null;
      var u2 = a3 = a3.next;
      do {
        o3 = e2(o3, u2.action), u2 = u2.next;
      } while (u2 !== a3);
      Ja(o3, n3.memoizedState) || (lu = true), n3.memoizedState = o3, null === n3.baseQueue && (n3.baseState = o3), t3.lastRenderedState = o3;
    }
    return [o3, l3];
  }
  function Me(e2, n3, t3) {
    var l3 = Ao, a3 = Re();
    t3 = n3();
    var o3 = !Ja((Qo || a3).memoizedState, t3);
    if (o3 && (a3.memoizedState = t3, lu = true), a3 = a3.queue, sn(je.bind(null, l3, a3, e2), [e2]), a3.getSnapshot !== n3 || o3 || null !== Oo && 1 & Oo.memoizedState.tag) {
      if (l3.flags |= 2048, rn(9, He.bind(null, l3, a3, t3, n3), { destroy: void 0 }, null), null === Tu) throw Error(r2(349));
      0 != (60 & jo) || We(l3, n3, t3);
    }
    return t3;
  }
  function We(e2, n3, t3) {
    e2.flags |= 16384, e2 = { getSnapshot: n3, value: t3 }, null === (n3 = Ao.updateQueue) ? (n3 = Ko(), Ao.updateQueue = n3, n3.stores = [e2]) : null === (t3 = n3.stores) ? n3.stores = [e2] : t3.push(e2);
  }
  function He(e2, n3, t3, r3) {
    n3.value = t3, n3.getSnapshot = r3, Ae(n3) && Qe(e2);
  }
  function je(e2, n3, t3) {
    return t3(function() {
      Ae(n3) && Qe(e2);
    });
  }
  function Ae(e2) {
    var n3 = e2.getSnapshot;
    e2 = e2.value;
    try {
      var t3 = n3();
      return !Ja(e2, t3);
    } catch (e3) {
      return true;
    }
  }
  function Qe(e2) {
    var n3 = D(e2, 2);
    null !== n3 && hr(n3, 0, 2);
  }
  function Oe(e2) {
    var n3 = _e();
    if ("function" == typeof e2) {
      var t3 = e2;
      if (e2 = t3(), $o) {
        z(true);
        try {
          t3();
        } finally {
          z(false);
        }
      }
    }
    return n3.memoizedState = n3.baseState = e2, n3.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Ue, lastRenderedState: e2 }, n3;
  }
  function Be(e2, n3, t3, r3) {
    return e2.baseState = t3, Ie(e2, Qo, "function" == typeof r3 ? r3 : Ue);
  }
  function Ve(e2, n3, t3, l3, a3) {
    if (_n(e2)) throw Error(r2(485));
    if (null !== (e2 = n3.action)) {
      var o3 = { payload: a3, action: e2, next: null, isTransition: true, status: "pending", value: null, reason: null, listeners: [], then: function(e3) {
        o3.listeners.push(e3);
      } };
      null !== Pl.T ? t3(true) : o3.isTransition = false, l3(o3), null === (t3 = n3.pending) ? (o3.next = n3.pending = o3, $e(n3, o3)) : (o3.next = t3.next, n3.pending = t3.next = o3);
    }
  }
  function $e(e2, n3) {
    var t3 = n3.action, r3 = n3.payload, l3 = e2.state;
    if (n3.isTransition) {
      var a3 = Pl.T, o3 = {};
      Pl.T = o3;
      try {
        var u2 = t3(l3, r3), i3 = Pl.S;
        null !== i3 && i3(o3, u2), qe(e2, n3, u2);
      } catch (t4) {
        Ge(e2, n3, t4);
      } finally {
        Pl.T = a3;
      }
    } else try {
      qe(e2, n3, a3 = t3(l3, r3));
    } catch (t4) {
      Ge(e2, n3, t4);
    }
  }
  function qe(e2, n3, t3) {
    null !== t3 && "object" == typeof t3 && "function" == typeof t3.then ? t3.then(function(t4) {
      Ye(e2, n3, t4);
    }, function(t4) {
      return Ge(e2, n3, t4);
    }) : Ye(e2, n3, t3);
  }
  function Ye(e2, n3, t3) {
    n3.status = "fulfilled", n3.value = t3, Je(n3), e2.state = t3, null !== (n3 = e2.pending) && ((t3 = n3.next) === n3 ? e2.pending = null : (t3 = t3.next, n3.next = t3, $e(e2, t3)));
  }
  function Ge(e2, n3, t3) {
    var r3 = e2.pending;
    if (e2.pending = null, null !== r3) {
      r3 = r3.next;
      do {
        n3.status = "rejected", n3.reason = t3, Je(n3), n3 = n3.next;
      } while (n3 !== r3);
    }
    e2.action = null;
  }
  function Je(e2) {
    e2 = e2.listeners;
    for (var n3 = 0; n3 < e2.length; n3++) (0, e2[n3])();
  }
  function Ke(e2, n3) {
    return n3;
  }
  function Xe(e2, n3) {
    var t3, r3, l3;
    (t3 = _e()).memoizedState = t3.baseState = n3, r3 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Ke, lastRenderedState: n3 }, t3.queue = r3, t3 = Cn.bind(null, Ao, r3), r3.dispatch = t3, r3 = Oe(false);
    var a3 = Pn.bind(null, Ao, false, r3.queue);
    return l3 = { state: n3, dispatch: null, action: e2, pending: null }, (r3 = _e()).queue = l3, t3 = Ve.bind(null, Ao, l3, a3, t3), l3.dispatch = t3, r3.memoizedState = e2, [n3, t3, false];
  }
  function Ze(e2) {
    return en(Re(), Qo, e2);
  }
  function en(e2, n3, t3) {
    n3 = Ie(e2, n3, Ke)[0], e2 = De(Ue)[0], n3 = "object" == typeof n3 && null !== n3 && "function" == typeof n3.then ? Te(n3) : n3;
    var r3 = Re(), l3 = r3.queue, a3 = l3.dispatch;
    return t3 !== r3.memoizedState && (Ao.flags |= 2048, rn(9, nn.bind(null, l3, t3), { destroy: void 0 }, null)), [n3, a3, e2];
  }
  function nn(e2, n3) {
    e2.action = n3;
  }
  function tn(e2) {
    var n3 = Re(), t3 = Qo;
    if (null !== t3) return en(n3, t3, e2);
    Re(), n3 = n3.memoizedState;
    var r3 = (t3 = Re()).queue.dispatch;
    return t3.memoizedState = e2, [n3, r3, false];
  }
  function rn(e2, n3, t3, r3) {
    return e2 = { tag: e2, create: n3, inst: t3, deps: r3, next: null }, null === (n3 = Ao.updateQueue) && (n3 = Ko(), Ao.updateQueue = n3), null === (t3 = n3.lastEffect) ? n3.lastEffect = e2.next = e2 : (r3 = t3.next, t3.next = e2, e2.next = r3, n3.lastEffect = e2), e2;
  }
  function ln() {
    return Re().memoizedState;
  }
  function an(e2, n3, t3, r3) {
    var l3 = _e();
    Ao.flags |= e2, l3.memoizedState = rn(1 | n3, t3, { destroy: void 0 }, void 0 === r3 ? null : r3);
  }
  function on2(e2, n3, t3, r3) {
    var l3 = Re();
    r3 = void 0 === r3 ? null : r3;
    var a3 = l3.memoizedState.inst;
    null !== Qo && null !== r3 && Se(r3, Qo.memoizedState.deps) ? l3.memoizedState = rn(n3, t3, a3, r3) : (Ao.flags |= e2, l3.memoizedState = rn(1 | n3, t3, a3, r3));
  }
  function un(e2, n3) {
    an(8390656, 8, e2, n3);
  }
  function sn(e2, n3) {
    on2(2048, 8, e2, n3);
  }
  function cn(e2, n3) {
    return on2(4, 2, e2, n3);
  }
  function fn(e2, n3) {
    return on2(4, 4, e2, n3);
  }
  function dn(e2, n3) {
    if ("function" == typeof n3) {
      e2 = e2();
      var t3 = n3(e2);
      return function() {
        "function" == typeof t3 ? t3() : n3(null);
      };
    }
    if (null != n3) return e2 = e2(), n3.current = e2, function() {
      n3.current = null;
    };
  }
  function pn(e2, n3, t3) {
    t3 = null != t3 ? t3.concat([e2]) : null, on2(4, 4, dn.bind(null, n3, e2), t3);
  }
  function mn() {
  }
  function hn(e2, n3) {
    var t3 = Re();
    n3 = void 0 === n3 ? null : n3;
    var r3 = t3.memoizedState;
    return null !== n3 && Se(n3, r3[1]) ? r3[0] : (t3.memoizedState = [e2, n3], e2);
  }
  function gn(e2, n3) {
    var t3 = Re();
    n3 = void 0 === n3 ? null : n3;
    var r3 = t3.memoizedState;
    if (null !== n3 && Se(n3, r3[1])) return r3[0];
    if (r3 = e2(), $o) {
      z(true);
      try {
        e2();
      } finally {
        z(false);
      }
    }
    return t3.memoizedState = [r3, n3], r3;
  }
  function yn(e2, n3, t3) {
    return void 0 === t3 || 0 != (1073741824 & jo) ? e2.memoizedState = n3 : (e2.memoizedState = t3, e2 = mr(), Ao.lanes |= e2, Hu |= e2, t3);
  }
  function bn(e2, n3, t3, r3) {
    return Ja(t3, n3) ? t3 : null !== Io.current ? (e2 = yn(e2, t3, r3), Ja(e2, n3) || (lu = true), e2) : 0 == (42 & jo) ? (lu = true, e2.memoizedState = t3) : (e2 = mr(), Ao.lanes |= e2, Hu |= e2, n3);
  }
  function vn(e2, n3, t3, r3, l3) {
    var a3 = ql();
    $l(0 !== a3 && 8 > a3 ? a3 : 8);
    var o3, u2, i3, s3 = Pl.T, c3 = {};
    Pl.T = c3, Pn(e2, false, n3, t3);
    try {
      var f3 = l3(), d3 = Pl.S;
      null !== d3 && d3(c3, f3), null !== f3 && "object" == typeof f3 && "function" == typeof f3.then ? En(e2, n3, (o3 = r3, u2 = [], i3 = { status: "pending", value: null, reason: null, then: function(e3) {
        u2.push(e3);
      } }, f3.then(function() {
        i3.status = "fulfilled", i3.value = o3;
        for (var e3 = 0; e3 < u2.length; e3++) (0, u2[e3])(o3);
      }, function(e3) {
        for (i3.status = "rejected", i3.reason = e3, e3 = 0; e3 < u2.length; e3++) (0, u2[e3])(void 0);
      }), i3), pr()) : En(e2, n3, r3, pr());
    } catch (t4) {
      En(e2, n3, { then: function() {
      }, status: "rejected", reason: t4 }, pr());
    } finally {
      $l(a3), Pl.T = s3;
    }
  }
  function Sn() {
    return gt(ra);
  }
  function kn() {
    return Re().memoizedState;
  }
  function wn() {
    return Re().memoizedState;
  }
  function xn(e2) {
    for (var n3 = e2.return; null !== n3; ) {
      switch (n3.tag) {
        case 24:
        case 3:
          var t3 = pr(), r3 = Y(n3, e2 = q(t3), t3);
          return null !== r3 && (hr(r3, 0, t3), G2(r3, n3, t3)), n3 = { cache: vt() }, void (e2.payload = n3);
      }
      n3 = n3.return;
    }
  }
  function zn(e2, n3, t3) {
    var r3 = pr();
    t3 = { lane: r3, revertLane: 0, action: t3, hasEagerState: false, eagerState: null, next: null }, _n(e2) ? Rn(n3, t3) : null !== (t3 = U(e2, n3, t3, r3)) && (hr(t3, 0, r3), Tn(t3, n3, r3));
  }
  function Cn(e2, n3, t3) {
    En(e2, n3, t3, pr());
  }
  function En(e2, n3, t3, r3) {
    var l3 = { lane: r3, revertLane: 0, action: t3, hasEagerState: false, eagerState: null, next: null };
    if (_n(e2)) Rn(n3, l3);
    else {
      var a3 = e2.alternate;
      if (0 === e2.lanes && (null === a3 || 0 === a3.lanes) && null !== (a3 = n3.lastRenderedReducer)) try {
        var o3 = n3.lastRenderedState, u2 = a3(o3, t3);
        if (l3.hasEagerState = true, l3.eagerState = u2, Ja(u2, o3)) return L(e2, n3, l3, 0), null === Tu && N(), false;
      } catch (e3) {
      }
      if (null !== (t3 = U(e2, n3, l3, r3))) return hr(t3, 0, r3), Tn(t3, n3, r3), true;
    }
    return false;
  }
  function Pn(e2, n3, t3, l3) {
    if (l3 = { lane: 2, revertLane: O(), action: l3, hasEagerState: false, eagerState: null, next: null }, _n(e2)) {
      if (n3) throw Error(r2(479));
    } else null !== (n3 = U(e2, t3, l3, 2)) && hr(n3, 0, 2);
  }
  function _n(e2) {
    var n3 = e2.alternate;
    return e2 === Ao || null !== n3 && n3 === Ao;
  }
  function Rn(e2, n3) {
    Vo = Bo = true;
    var t3 = e2.pending;
    null === t3 ? n3.next = n3 : (n3.next = t3.next, t3.next = n3), e2.pending = n3;
  }
  function Tn(e2, n3, t3) {
    if (0 != (4194176 & t3)) {
      var r3 = n3.lanes;
      t3 |= r3 &= e2.pendingLanes, n3.lanes = t3, w(e2, t3);
    }
  }
  function Nn(e2, n3, t3, r3) {
    t3 = null == (t3 = t3(r3, n3 = e2.memoizedState)) ? n3 : il({}, n3, t3), e2.memoizedState = t3, 0 === e2.lanes && (e2.updateQueue.baseState = t3);
  }
  function Ln(e2, n3, t3, r3, l3, a3, o3) {
    return "function" == typeof (e2 = e2.stateNode).shouldComponentUpdate ? e2.shouldComponentUpdate(r3, a3, o3) : !(n3.prototype && n3.prototype.isPureReactComponent && ne(t3, r3) && ne(l3, a3));
  }
  function Un(e2, n3, t3, r3) {
    e2 = n3.state, "function" == typeof n3.componentWillReceiveProps && n3.componentWillReceiveProps(t3, r3), "function" == typeof n3.UNSAFE_componentWillReceiveProps && n3.UNSAFE_componentWillReceiveProps(t3, r3), n3.state !== e2 && tu.enqueueReplaceState(n3, n3.state, null);
  }
  function Dn(e2, n3) {
    var t3 = n3;
    if ("ref" in n3) for (var r3 in t3 = {}, n3) "ref" !== r3 && (t3[r3] = n3[r3]);
    if (e2 = e2.defaultProps) for (var l3 in t3 === n3 && (t3 = il({}, t3)), e2) void 0 === t3[l3] && (t3[l3] = e2[l3]);
    return t3;
  }
  function In(e2, n3) {
    try {
      (0, e2.onUncaughtError)(n3.value, { componentStack: n3.stack });
    } catch (e3) {
      setTimeout(function() {
        throw e3;
      });
    }
  }
  function Fn(e2, n3, t3) {
    try {
      (0, e2.onCaughtError)(t3.value, { componentStack: t3.stack, errorBoundary: 1 === n3.tag ? n3.stateNode : null });
    } catch (e3) {
      setTimeout(function() {
        throw e3;
      });
    }
  }
  function Mn(e2, n3, t3) {
    return (t3 = q(t3)).tag = 3, t3.payload = { element: null }, t3.callback = function() {
      In(e2, n3);
    }, t3;
  }
  function Wn(e2) {
    return (e2 = q(e2)).tag = 3, e2;
  }
  function Hn(e2, n3, t3, r3) {
    var l3 = t3.type.getDerivedStateFromError;
    if ("function" == typeof l3) {
      var a3 = r3.value;
      e2.payload = function() {
        return l3(a3);
      }, e2.callback = function() {
        Fn(n3, t3, r3);
      };
    }
    var o3 = t3.stateNode;
    null !== o3 && "function" == typeof o3.componentDidCatch && (e2.callback = function() {
      Fn(n3, t3, r3), "function" != typeof l3 && (null === Ju ? Ju = /* @__PURE__ */ new Set([this]) : Ju.add(this));
      var e3 = r3.stack;
      this.componentDidCatch(r3.value, { componentStack: null !== e3 ? e3 : "" });
    });
  }
  function jn(e2, n3, t3, r3) {
    n3.child = null === e2 ? Do(n3, null, t3, r3) : Uo(n3, e2.child, t3, r3);
  }
  function An(e2, n3, t3, r3, l3) {
    t3 = t3.render;
    var a3 = n3.ref;
    if ("ref" in r3) {
      var o3 = {};
      for (var u2 in r3) "ref" !== u2 && (o3[u2] = r3[u2]);
    } else o3 = r3;
    return ht(n3), r3 = ke(e2, n3, t3, o3, a3, l3), u2 = Ce(), null === e2 || lu ? (n3.flags |= 1, jn(e2, n3, r3, l3), n3.child) : (Ee(e2, n3, l3), at(e2, n3, l3));
  }
  function Qn(e2, n3, t3, r3, l3) {
    if (null === e2) {
      var a3 = t3.type;
      return "function" != typeof a3 || qr(a3) || void 0 !== a3.defaultProps || null !== t3.compare ? ((e2 = Jr(t3.type, null, r3, n3, n3.mode, l3)).ref = n3.ref, e2.return = n3, n3.child = e2) : (n3.tag = 15, n3.type = a3, On(e2, n3, a3, r3, l3));
    }
    if (a3 = e2.child, !ot(e2, l3)) {
      var o3 = a3.memoizedProps;
      if ((t3 = null !== (t3 = t3.compare) ? t3 : ne)(o3, r3) && e2.ref === n3.ref) return at(e2, n3, l3);
    }
    return n3.flags |= 1, (e2 = Yr(a3, r3)).ref = n3.ref, e2.return = n3, n3.child = e2;
  }
  function On(e2, n3, t3, r3, l3) {
    if (null !== e2) {
      var a3 = e2.memoizedProps;
      if (ne(a3, r3) && e2.ref === n3.ref) {
        if (lu = false, n3.pendingProps = r3 = a3, !ot(e2, l3)) return n3.lanes = e2.lanes, at(e2, n3, l3);
        0 != (131072 & e2.flags) && (lu = true);
      }
    }
    return qn(e2, n3, t3, r3, l3);
  }
  function Bn(e2, n3, t3) {
    var r3 = n3.pendingProps, l3 = r3.children, a3 = 0 != (2 & n3.stateNode._pendingVisibility), o3 = null !== e2 ? e2.memoizedState : null;
    if ($n(e2, n3), "hidden" === r3.mode || a3) {
      if (0 != (128 & n3.flags)) {
        if (r3 = null !== o3 ? o3.baseLanes | t3 : t3, null !== e2) {
          for (l3 = n3.child = e2.child, a3 = 0; null !== l3; ) a3 = a3 | l3.lanes | l3.childLanes, l3 = l3.sibling;
          n3.childLanes = a3 & ~r3;
        } else n3.childLanes = 0, n3.child = null;
        return Vn(e2, n3, r3, t3);
      }
      if (0 == (536870912 & t3)) return n3.lanes = n3.childLanes = 536870912, Vn(e2, n3, null !== o3 ? o3.baseLanes | t3 : t3, t3);
      n3.memoizedState = { baseLanes: 0, cachePool: null }, null !== e2 && wt(0, null !== o3 ? o3.cachePool : null), null !== o3 ? fe(n3, o3) : de(), he(n3);
    } else null !== o3 ? (wt(0, o3.cachePool), fe(n3, o3), ge(), n3.memoizedState = null) : (null !== e2 && wt(0, null), de(), ge());
    return jn(e2, n3, l3, t3), n3.child;
  }
  function Vn(e2, n3, t3, r3) {
    var l3 = kt();
    return l3 = null === l3 ? null : { parent: pu._currentValue2, pool: l3 }, n3.memoizedState = { baseLanes: t3, cachePool: l3 }, null !== e2 && wt(0, null), de(), he(n3), null !== e2 && pt(e2, n3, r3, true), null;
  }
  function $n(e2, n3) {
    var t3 = n3.ref;
    if (null === t3) null !== e2 && null !== e2.ref && (n3.flags |= 2097664);
    else {
      if ("function" != typeof t3 && "object" != typeof t3) throw Error(r2(284));
      null !== e2 && e2.ref === t3 || (n3.flags |= 2097664);
    }
  }
  function qn(e2, n3, t3, r3, l3) {
    return ht(n3), t3 = ke(e2, n3, t3, r3, void 0, l3), r3 = Ce(), null === e2 || lu ? (n3.flags |= 1, jn(e2, n3, t3, l3), n3.child) : (Ee(e2, n3, l3), at(e2, n3, l3));
  }
  function Yn(e2, n3, t3, r3, l3, a3) {
    return ht(n3), n3.updateQueue = null, t3 = xe(n3, r3, t3, l3), we(e2), r3 = Ce(), null === e2 || lu ? (n3.flags |= 1, jn(e2, n3, t3, a3), n3.child) : (Ee(e2, n3, a3), at(e2, n3, a3));
  }
  function Gn(e2, n3, t3, r3, l3) {
    if (ht(n3), null === n3.stateNode) {
      var a3 = La, o3 = t3.contextType;
      "object" == typeof o3 && null !== o3 && (a3 = gt(o3)), a3 = new t3(r3, a3), n3.memoizedState = null !== a3.state && void 0 !== a3.state ? a3.state : null, a3.updater = tu, n3.stateNode = a3, a3._reactInternals = n3, (a3 = n3.stateNode).props = r3, a3.state = n3.memoizedState, a3.refs = {}, V(n3), o3 = t3.contextType, a3.context = "object" == typeof o3 && null !== o3 ? gt(o3) : La, a3.state = n3.memoizedState, "function" == typeof (o3 = t3.getDerivedStateFromProps) && (Nn(n3, t3, o3, r3), a3.state = n3.memoizedState), "function" == typeof t3.getDerivedStateFromProps || "function" == typeof a3.getSnapshotBeforeUpdate || "function" != typeof a3.UNSAFE_componentWillMount && "function" != typeof a3.componentWillMount || (o3 = a3.state, "function" == typeof a3.componentWillMount && a3.componentWillMount(), "function" == typeof a3.UNSAFE_componentWillMount && a3.UNSAFE_componentWillMount(), o3 !== a3.state && tu.enqueueReplaceState(a3, a3.state, null), X(n3, r3, a3, l3), K(), a3.state = n3.memoizedState), "function" == typeof a3.componentDidMount && (n3.flags |= 4194308), r3 = true;
    } else if (null === e2) {
      a3 = n3.stateNode;
      var u2 = n3.memoizedProps, i3 = Dn(t3, u2);
      a3.props = i3;
      var s3 = a3.context, c3 = t3.contextType;
      o3 = La, "object" == typeof c3 && null !== c3 && (o3 = gt(c3));
      var f3 = t3.getDerivedStateFromProps;
      c3 = "function" == typeof f3 || "function" == typeof a3.getSnapshotBeforeUpdate, u2 = n3.pendingProps !== u2, c3 || "function" != typeof a3.UNSAFE_componentWillReceiveProps && "function" != typeof a3.componentWillReceiveProps || (u2 || s3 !== o3) && Un(n3, a3, r3, o3), zo = false;
      var d3 = n3.memoizedState;
      a3.state = d3, X(n3, r3, a3, l3), K(), s3 = n3.memoizedState, u2 || d3 !== s3 || zo ? ("function" == typeof f3 && (Nn(n3, t3, f3, r3), s3 = n3.memoizedState), (i3 = zo || Ln(n3, t3, i3, r3, d3, s3, o3)) ? (c3 || "function" != typeof a3.UNSAFE_componentWillMount && "function" != typeof a3.componentWillMount || ("function" == typeof a3.componentWillMount && a3.componentWillMount(), "function" == typeof a3.UNSAFE_componentWillMount && a3.UNSAFE_componentWillMount()), "function" == typeof a3.componentDidMount && (n3.flags |= 4194308)) : ("function" == typeof a3.componentDidMount && (n3.flags |= 4194308), n3.memoizedProps = r3, n3.memoizedState = s3), a3.props = r3, a3.state = s3, a3.context = o3, r3 = i3) : ("function" == typeof a3.componentDidMount && (n3.flags |= 4194308), r3 = false);
    } else {
      a3 = n3.stateNode, $(e2, n3), c3 = Dn(t3, o3 = n3.memoizedProps), a3.props = c3, f3 = n3.pendingProps, d3 = a3.context, s3 = t3.contextType, i3 = La, "object" == typeof s3 && null !== s3 && (i3 = gt(s3)), (s3 = "function" == typeof (u2 = t3.getDerivedStateFromProps) || "function" == typeof a3.getSnapshotBeforeUpdate) || "function" != typeof a3.UNSAFE_componentWillReceiveProps && "function" != typeof a3.componentWillReceiveProps || (o3 !== f3 || d3 !== i3) && Un(n3, a3, r3, i3), zo = false, d3 = n3.memoizedState, a3.state = d3, X(n3, r3, a3, l3), K();
      var p3 = n3.memoizedState;
      o3 !== f3 || d3 !== p3 || zo || null !== e2 && null !== e2.dependencies && mt(e2.dependencies) ? ("function" == typeof u2 && (Nn(n3, t3, u2, r3), p3 = n3.memoizedState), (c3 = zo || Ln(n3, t3, c3, r3, d3, p3, i3) || null !== e2 && null !== e2.dependencies && mt(e2.dependencies)) ? (s3 || "function" != typeof a3.UNSAFE_componentWillUpdate && "function" != typeof a3.componentWillUpdate || ("function" == typeof a3.componentWillUpdate && a3.componentWillUpdate(r3, p3, i3), "function" == typeof a3.UNSAFE_componentWillUpdate && a3.UNSAFE_componentWillUpdate(r3, p3, i3)), "function" == typeof a3.componentDidUpdate && (n3.flags |= 4), "function" == typeof a3.getSnapshotBeforeUpdate && (n3.flags |= 1024)) : ("function" != typeof a3.componentDidUpdate || o3 === e2.memoizedProps && d3 === e2.memoizedState || (n3.flags |= 4), "function" != typeof a3.getSnapshotBeforeUpdate || o3 === e2.memoizedProps && d3 === e2.memoizedState || (n3.flags |= 1024), n3.memoizedProps = r3, n3.memoizedState = p3), a3.props = r3, a3.state = p3, a3.context = i3, r3 = c3) : ("function" != typeof a3.componentDidUpdate || o3 === e2.memoizedProps && d3 === e2.memoizedState || (n3.flags |= 4), "function" != typeof a3.getSnapshotBeforeUpdate || o3 === e2.memoizedProps && d3 === e2.memoizedState || (n3.flags |= 1024), r3 = false);
    }
    return a3 = r3, $n(e2, n3), r3 = 0 != (128 & n3.flags), a3 || r3 ? (a3 = n3.stateNode, t3 = r3 && "function" != typeof t3.getDerivedStateFromError ? null : a3.render(), n3.flags |= 1, null !== e2 && r3 ? (n3.child = Uo(n3, e2.child, null, l3), n3.child = Uo(n3, null, t3, l3)) : jn(e2, n3, t3, l3), n3.memoizedState = a3.state, e2 = n3.child) : e2 = at(e2, n3, l3), e2;
  }
  function Jn(e2) {
    return { baseLanes: e2, cachePool: xt() };
  }
  function Kn(e2, n3, t3) {
    return e2 = null !== e2 ? e2.childLanes & ~t3 : 0, n3 && (e2 |= Qu), e2;
  }
  function Xn(e2, n3, t3) {
    var l3, a3, o3, u2, i3 = n3.pendingProps, s3 = false, c3 = 0 != (128 & n3.flags);
    if ((l3 = c3) || (l3 = (null === e2 || null !== e2.memoizedState) && 0 != (2 & Ho.current)), l3 && (s3 = true, n3.flags &= -129), l3 = 0 != (32 & n3.flags), n3.flags &= -33, null === e2) return a3 = i3.children, i3 = i3.fallback, s3 ? (ge(), a3 = et({ mode: "hidden", children: a3 }, s3 = n3.mode), i3 = Kr(i3, s3, t3, null), a3.return = n3, i3.return = n3, a3.sibling = i3, n3.child = a3, (s3 = n3.child).memoizedState = Jn(t3), s3.childLanes = Kn(e2, l3, t3), n3.memoizedState = au, i3) : (me(n3), Zn(n3, a3));
    if (null !== (o3 = e2.memoizedState) && null !== (a3 = o3.dehydrated)) {
      if (c3) 256 & n3.flags ? (me(n3), n3.flags &= -257, n3 = nt(e2, n3, t3)) : null !== n3.memoizedState ? (ge(), n3.child = e2.child, n3.flags |= 128, n3 = null) : (ge(), s3 = i3.fallback, a3 = n3.mode, i3 = et({ mode: "visible", children: i3.children }, a3), (s3 = Kr(s3, a3, t3, null)).flags |= 2, i3.return = n3, s3.return = n3, i3.sibling = s3, n3.child = i3, Uo(n3, e2.child, null, t3), (i3 = n3.child).memoizedState = Jn(t3), i3.childLanes = Kn(e2, l3, t3), n3.memoizedState = au, n3 = s3);
      else if (me(n3), ka(a3)) l3 = wa(a3).digest, (i3 = Error(r2(419))).stack = "", i3.digest = l3, u2 = { value: i3, source: null, stack: null }, null === so ? so = [u2] : so.push(u2), n3 = nt(e2, n3, t3);
      else if (lu || pt(e2, n3, t3, false), l3 = 0 != (t3 & e2.childLanes), lu || l3) {
        if (null !== (l3 = Tu)) {
          if (0 != (42 & (i3 = t3 & -t3))) i3 = 1;
          else switch (i3) {
            case 2:
              i3 = 1;
              break;
            case 8:
              i3 = 4;
              break;
            case 32:
              i3 = 16;
              break;
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              i3 = 64;
              break;
            case 268435456:
              i3 = 134217728;
              break;
            default:
              i3 = 0;
          }
          if (0 !== (i3 = 0 != (i3 & (l3.suspendedLanes | t3)) ? 0 : i3) && i3 !== o3.retryLane) throw o3.retryLane = i3, D(e2, i3), hr(l3, 0, i3), ru;
        }
        Sa(a3) || Pr(), n3 = nt(e2, n3, t3);
      } else Sa(a3) ? (n3.flags |= 128, n3.child = e2.child, n3 = Br.bind(null, e2), xa(a3, n3), n3 = null) : (e2 = o3.treeContext, (n3 = Zn(n3, i3.children)).flags |= 4096);
      return n3;
    }
    return s3 ? (ge(), s3 = i3.fallback, a3 = n3.mode, c3 = (o3 = e2.child).sibling, (i3 = Yr(o3, { mode: "hidden", children: i3.children })).subtreeFlags = 31457280 & o3.subtreeFlags, null !== c3 ? s3 = Yr(c3, s3) : (s3 = Kr(s3, a3, t3, null)).flags |= 2, s3.return = n3, i3.return = n3, i3.sibling = s3, n3.child = i3, i3 = s3, s3 = n3.child, null === (a3 = e2.child.memoizedState) ? a3 = Jn(t3) : (null !== (o3 = a3.cachePool) ? (c3 = pu._currentValue2, o3 = o3.parent !== c3 ? { parent: c3, pool: c3 } : o3) : o3 = xt(), a3 = { baseLanes: a3.baseLanes | t3, cachePool: o3 }), s3.memoizedState = a3, s3.childLanes = Kn(e2, l3, t3), n3.memoizedState = au, i3) : (me(n3), e2 = (t3 = e2.child).sibling, (t3 = Yr(t3, { mode: "visible", children: i3.children })).return = n3, t3.sibling = null, null !== e2 && (null === (l3 = n3.deletions) ? (n3.deletions = [e2], n3.flags |= 16) : l3.push(e2)), n3.child = t3, n3.memoizedState = null, t3);
  }
  function Zn(e2, n3) {
    return (n3 = et({ mode: "visible", children: n3 }, e2.mode)).return = e2, e2.child = n3;
  }
  function et(e2, n3) {
    return Xr(e2, n3, 0, null);
  }
  function nt(e2, n3, t3) {
    return Uo(n3, e2.child, null, t3), (e2 = Zn(n3, n3.pendingProps.children)).flags |= 2, n3.memoizedState = null, e2;
  }
  function tt(e2, n3, t3) {
    e2.lanes |= n3;
    var r3 = e2.alternate;
    null !== r3 && (r3.lanes |= n3), ft(e2.return, n3, t3);
  }
  function rt(e2, n3, t3, r3, l3) {
    var a3 = e2.memoizedState;
    null === a3 ? e2.memoizedState = { isBackwards: n3, rendering: null, renderingStartTime: 0, last: r3, tail: t3, tailMode: l3 } : (a3.isBackwards = n3, a3.rendering = null, a3.renderingStartTime = 0, a3.last = r3, a3.tail = t3, a3.tailMode = l3);
  }
  function lt(e2, n3, t3) {
    var r3 = n3.pendingProps, l3 = r3.revealOrder, a3 = r3.tail;
    if (jn(e2, n3, r3.children, t3), 0 != (2 & (r3 = Ho.current))) r3 = 1 & r3 | 2, n3.flags |= 128;
    else {
      if (null !== e2 && 0 != (128 & e2.flags)) e: for (e2 = n3.child; null !== e2; ) {
        if (13 === e2.tag) null !== e2.memoizedState && tt(e2, t3, n3);
        else if (19 === e2.tag) tt(e2, t3, n3);
        else if (null !== e2.child) {
          e2.child.return = e2, e2 = e2.child;
          continue;
        }
        if (e2 === n3) break e;
        for (; null === e2.sibling; ) {
          if (null === e2.return || e2.return === n3) break e;
          e2 = e2.return;
        }
        e2.sibling.return = e2.return, e2 = e2.sibling;
      }
      r3 &= 1;
    }
    switch (p2(Ho, r3), l3) {
      case "forwards":
        for (t3 = n3.child, l3 = null; null !== t3; ) null !== (e2 = t3.alternate) && null === be(e2) && (l3 = t3), t3 = t3.sibling;
        null === (t3 = l3) ? (l3 = n3.child, n3.child = null) : (l3 = t3.sibling, t3.sibling = null), rt(n3, false, l3, t3, a3);
        break;
      case "backwards":
        for (t3 = null, l3 = n3.child, n3.child = null; null !== l3; ) {
          if (null !== (e2 = l3.alternate) && null === be(e2)) {
            n3.child = l3;
            break;
          }
          e2 = l3.sibling, l3.sibling = t3, t3 = l3, l3 = e2;
        }
        rt(n3, true, t3, null, a3);
        break;
      case "together":
        rt(n3, false, null, null, void 0);
        break;
      default:
        n3.memoizedState = null;
    }
    return n3.child;
  }
  function at(e2, n3, t3) {
    if (null !== e2 && (n3.dependencies = e2.dependencies), Hu |= n3.lanes, 0 == (t3 & n3.childLanes)) {
      if (null === e2) return null;
      if (pt(e2, n3, t3, false), 0 == (t3 & n3.childLanes)) return null;
    }
    if (null !== e2 && n3.child !== e2.child) throw Error(r2(153));
    if (null !== n3.child) {
      for (t3 = Yr(e2 = n3.child, e2.pendingProps), n3.child = t3, t3.return = n3; null !== e2.sibling; ) e2 = e2.sibling, (t3 = t3.sibling = Yr(e2, e2.pendingProps)).return = n3;
      t3.sibling = null;
    }
    return n3.child;
  }
  function ot(e2, n3) {
    return 0 != (e2.lanes & n3) || !(null === (e2 = e2.dependencies) || !mt(e2));
  }
  function ut(e2, n3, t3) {
    if (null !== e2) if (e2.memoizedProps !== n3.pendingProps) lu = true;
    else {
      if (!ot(e2, t3) && 0 == (128 & n3.flags)) return lu = false, function(e3, n4, t4) {
        switch (n4.tag) {
          case 3:
            P(n4, n4.stateNode.containerInfo), st(0, pu, e3.memoizedState.cache);
            break;
          case 27:
          case 5:
            R(n4);
            break;
          case 4:
            P(n4, n4.stateNode.containerInfo);
            break;
          case 10:
            st(0, n4.type, n4.memoizedProps.value);
            break;
          case 13:
            var r3 = n4.memoizedState;
            if (null !== r3) return null !== r3.dehydrated ? (me(n4), n4.flags |= 128, null) : 0 != (t4 & n4.child.childLanes) ? Xn(e3, n4, t4) : (me(n4), null !== (e3 = at(e3, n4, t4)) ? e3.sibling : null);
            me(n4);
            break;
          case 19:
            var l4 = 0 != (128 & e3.flags);
            if ((r3 = 0 != (t4 & n4.childLanes)) || (pt(e3, n4, t4, false), r3 = 0 != (t4 & n4.childLanes)), l4) {
              if (r3) return lt(e3, n4, t4);
              n4.flags |= 128;
            }
            if (null !== (l4 = n4.memoizedState) && (l4.rendering = null, l4.tail = null, l4.lastEffect = null), p2(Ho, Ho.current), r3) break;
            return null;
          case 22:
          case 23:
            return n4.lanes = 0, Bn(e3, n4, t4);
          case 24:
            st(0, pu, e3.memoizedState.cache);
        }
        return at(e3, n4, t4);
      }(e2, n3, t3);
      lu = 0 != (131072 & e2.flags);
    }
    else lu = false;
    switch (n3.lanes = 0, n3.tag) {
      case 16:
        e: {
          e2 = n3.pendingProps;
          var l3 = n3.elementType, o3 = l3._init;
          if (l3 = o3(l3._payload), n3.type = l3, "function" != typeof l3) {
            if (null != l3) {
              if ((o3 = l3.$$typeof) === bl) {
                n3.tag = 11, n3 = An(null, n3, l3, e2, t3);
                break e;
              }
              if (o3 === kl) {
                n3.tag = 14, n3 = Qn(null, n3, l3, e2, t3);
                break e;
              }
            }
            throw n3 = a2(l3) || l3, Error(r2(306, n3, ""));
          }
          qr(l3) ? (e2 = Dn(l3, e2), n3.tag = 1, n3 = Gn(null, n3, l3, e2, t3)) : (n3.tag = 0, n3 = qn(null, n3, l3, e2, t3));
        }
        return n3;
      case 0:
        return qn(e2, n3, n3.type, n3.pendingProps, t3);
      case 1:
        return Gn(e2, n3, l3 = n3.type, o3 = Dn(l3, n3.pendingProps), t3);
      case 3:
        if (P(n3, n3.stateNode.containerInfo), null === e2) throw Error(r2(387));
        var u2 = n3.pendingProps;
        l3 = (o3 = n3.memoizedState).element, $(e2, n3), X(n3, u2, null, t3);
        var i3 = n3.memoizedState;
        return u2 = i3.cache, st(0, pu, u2), u2 !== o3.cache && dt(n3, [pu], t3, true), K(), (u2 = i3.element) !== l3 ? (jn(e2, n3, u2, t3), n3 = n3.child) : n3 = at(e2, n3, t3), n3;
      case 26:
      case 27:
      case 5:
        return R(n3), o3 = n3.type, u2 = n3.pendingProps, i3 = null !== e2 ? e2.memoizedProps : null, l3 = u2.children, Wl(o3, u2) ? l3 = null : null !== i3 && Wl(o3, i3) && (n3.flags |= 32), null !== n3.memoizedState && (o3 = ke(e2, n3, ze, null, null, t3), ra._currentValue2 = o3), $n(e2, n3), jn(e2, n3, l3, t3), n3.child;
      case 6:
        return null;
      case 13:
        return Xn(e2, n3, t3);
      case 4:
        return P(n3, n3.stateNode.containerInfo), l3 = n3.pendingProps, null === e2 ? n3.child = Uo(n3, null, l3, t3) : jn(e2, n3, l3, t3), n3.child;
      case 11:
        return An(e2, n3, n3.type, n3.pendingProps, t3);
      case 7:
        return jn(e2, n3, n3.pendingProps, t3), n3.child;
      case 8:
      case 12:
        return jn(e2, n3, n3.pendingProps.children, t3), n3.child;
      case 10:
        return l3 = n3.pendingProps, st(0, n3.type, l3.value), jn(e2, n3, l3.children, t3), n3.child;
      case 9:
        return o3 = n3.type._context, l3 = n3.pendingProps.children, ht(n3), l3 = l3(o3 = gt(o3)), n3.flags |= 1, jn(e2, n3, l3, t3), n3.child;
      case 14:
        return Qn(e2, n3, n3.type, n3.pendingProps, t3);
      case 15:
        return On(e2, n3, n3.type, n3.pendingProps, t3);
      case 19:
        return lt(e2, n3, t3);
      case 22:
        return Bn(e2, n3, t3);
      case 24:
        return ht(n3), l3 = gt(pu), null === e2 ? (null === (o3 = kt()) && (o3 = Tu, u2 = vt(), o3.pooledCache = u2, u2.refCount++, null !== u2 && (o3.pooledCacheLanes |= t3), o3 = u2), n3.memoizedState = { parent: l3, cache: o3 }, V(n3), st(0, pu, o3)) : (0 != (e2.lanes & t3) && ($(e2, n3), X(n3, null, null, t3), K()), o3 = e2.memoizedState, u2 = n3.memoizedState, o3.parent !== l3 ? (o3 = { parent: l3, cache: l3 }, n3.memoizedState = o3, 0 === n3.lanes && (n3.memoizedState = n3.updateQueue.baseState = o3), st(0, pu, l3)) : (l3 = u2.cache, st(0, pu, l3), l3 !== o3.cache && dt(n3, [pu], t3, true))), jn(e2, n3, n3.pendingProps.children, t3), n3.child;
      case 29:
        throw n3.pendingProps;
    }
    throw Error(r2(156, n3.tag));
  }
  function it() {
    su = iu = uu = null;
  }
  function st(e2, n3, t3) {
    p2(ou, n3._currentValue2), n3._currentValue2 = t3;
  }
  function ct(e2) {
    var n3 = ou.current;
    e2._currentValue2 = n3, d2(ou);
  }
  function ft(e2, n3, t3) {
    for (; null !== e2; ) {
      var r3 = e2.alternate;
      if ((e2.childLanes & n3) !== n3 ? (e2.childLanes |= n3, null !== r3 && (r3.childLanes |= n3)) : null !== r3 && (r3.childLanes & n3) !== n3 && (r3.childLanes |= n3), e2 === t3) break;
      e2 = e2.return;
    }
  }
  function dt(e2, n3, t3, l3) {
    var a3 = e2.child;
    for (null !== a3 && (a3.return = e2); null !== a3; ) {
      var o3 = a3.dependencies;
      if (null !== o3) {
        var u2 = a3.child;
        o3 = o3.firstContext;
        e: for (; null !== o3; ) {
          var i3 = o3;
          o3 = a3;
          for (var s3 = 0; s3 < n3.length; s3++) if (i3.context === n3[s3]) {
            o3.lanes |= t3, null !== (i3 = o3.alternate) && (i3.lanes |= t3), ft(o3.return, t3, e2), l3 || (u2 = null);
            break e;
          }
          o3 = i3.next;
        }
      } else if (18 === a3.tag) {
        if (null === (u2 = a3.return)) throw Error(r2(341));
        u2.lanes |= t3, null !== (o3 = u2.alternate) && (o3.lanes |= t3), ft(u2, t3, e2), u2 = null;
      } else u2 = a3.child;
      if (null !== u2) u2.return = a3;
      else for (u2 = a3; null !== u2; ) {
        if (u2 === e2) {
          u2 = null;
          break;
        }
        if (null !== (a3 = u2.sibling)) {
          a3.return = u2.return, u2 = a3;
          break;
        }
        u2 = u2.return;
      }
      a3 = u2;
    }
  }
  function pt(e2, n3, t3, l3) {
    e2 = null;
    for (var a3 = n3, o3 = false; null !== a3; ) {
      if (!o3) {
        if (0 != (524288 & a3.flags)) o3 = true;
        else if (0 != (262144 & a3.flags)) break;
      }
      if (10 === a3.tag) {
        var u2 = a3.alternate;
        if (null === u2) throw Error(r2(387));
        if (null !== (u2 = u2.memoizedProps)) {
          var i3 = a3.type;
          Ja(a3.pendingProps.value, u2.value) || (null !== e2 ? e2.push(i3) : e2 = [i3]);
        }
      } else if (a3 === uo.current) {
        if (null === (u2 = a3.alternate)) throw Error(r2(387));
        u2.memoizedState.memoizedState !== a3.memoizedState.memoizedState && (null !== e2 ? e2.push(ra) : e2 = [ra]);
      }
      a3 = a3.return;
    }
    null !== e2 && dt(n3, e2, t3, l3), n3.flags |= 262144;
  }
  function mt(e2) {
    for (e2 = e2.firstContext; null !== e2; ) {
      var n3 = e2.context;
      if (!Ja(n3._currentValue2, e2.memoizedValue)) return true;
      e2 = e2.next;
    }
    return false;
  }
  function ht(e2) {
    uu = e2, su = iu = null, null !== (e2 = e2.dependencies) && (e2.firstContext = null);
  }
  function gt(e2) {
    return bt(uu, e2);
  }
  function yt(e2, n3) {
    return null === uu && ht(e2), bt(e2, n3);
  }
  function bt(e2, n3) {
    var t3 = n3._currentValue2;
    if (su !== n3) if (n3 = { context: n3, memoizedValue: t3, next: null }, null === iu) {
      if (null === e2) throw Error(r2(308));
      iu = n3, e2.dependencies = { lanes: 0, firstContext: n3 }, e2.flags |= 524288;
    } else iu = iu.next = n3;
    return t3;
  }
  function vt() {
    return { controller: new cu(), data: /* @__PURE__ */ new Map(), refCount: 0 };
  }
  function St(e2) {
    e2.refCount--, 0 === e2.refCount && fu(du, function() {
      e2.controller.abort();
    });
  }
  function kt() {
    var e2 = hu.current;
    return null !== e2 ? e2 : Tu.pooledCache;
  }
  function wt(e2, n3) {
    p2(hu, null === n3 ? hu.current : n3.pool);
  }
  function xt() {
    var e2 = kt();
    return null === e2 ? null : { parent: pu._currentValue2, pool: e2 };
  }
  function zt(e2) {
    e2.flags |= 4;
  }
  function Ct(e2, n3) {
    null !== n3 && (e2.flags |= 4), 16384 & e2.flags && (n3 = 22 !== e2.tag ? b2() : 536870912, e2.lanes |= n3);
  }
  function Et(e2, n3) {
    switch (e2.tailMode) {
      case "hidden":
        n3 = e2.tail;
        for (var t3 = null; null !== n3; ) null !== n3.alternate && (t3 = n3), n3 = n3.sibling;
        null === t3 ? e2.tail = null : t3.sibling = null;
        break;
      case "collapsed":
        t3 = e2.tail;
        for (var r3 = null; null !== t3; ) null !== t3.alternate && (r3 = t3), t3 = t3.sibling;
        null === r3 ? n3 || null === e2.tail ? e2.tail = null : e2.tail.sibling = null : r3.sibling = null;
    }
  }
  function Pt(e2) {
    var n3 = null !== e2.alternate && e2.alternate.child === e2.child, t3 = 0, r3 = 0;
    if (n3) for (var l3 = e2.child; null !== l3; ) t3 |= l3.lanes | l3.childLanes, r3 |= 31457280 & l3.subtreeFlags, r3 |= 31457280 & l3.flags, l3.return = e2, l3 = l3.sibling;
    else for (l3 = e2.child; null !== l3; ) t3 |= l3.lanes | l3.childLanes, r3 |= l3.subtreeFlags, r3 |= l3.flags, l3.return = e2, l3 = l3.sibling;
    return e2.subtreeFlags |= r3, e2.childLanes = t3, n3;
  }
  function _t(e2, n3, t3) {
    var l3 = n3.pendingProps;
    switch (E(n3), n3.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
      case 1:
        return Pt(n3), null;
      case 3:
        return t3 = n3.stateNode, l3 = null, null !== e2 && (l3 = e2.memoizedState.cache), n3.memoizedState.cache !== l3 && (n3.flags |= 2048), ct(pu), _(), t3.pendingContext && (t3.context = t3.pendingContext, t3.pendingContext = null), null !== e2 && null !== e2.child || null === e2 || e2.memoizedState.isDehydrated && 0 == (256 & n3.flags) || (n3.flags |= 1024, null !== so && (yr(so), so = null)), Pt(n3), null;
      case 26:
        var a3;
      case 27:
      case 5:
        if (T(n3), t3 = n3.type, null !== e2 && null != n3.stateNode) !function(e3, n4, t4, r3) {
          e3.memoizedProps !== r3 && zt(n4);
        }(e2, n3, 0, l3);
        else {
          if (!l3) {
            if (null === n3.stateNode) throw Error(r2(166));
            return Pt(n3), null;
          }
          e2 = lo.current, function(e3, n4, t4, r3) {
            for (t4 = n4.child; null !== t4; ) {
              if (5 === t4.tag || 6 === t4.tag) Fl(e3, t4.stateNode);
              else if (4 !== t4.tag && !Ra && null !== t4.child) {
                t4.child.return = t4, t4 = t4.child;
                continue;
              }
              if (t4 === n4) break;
              for (; null === t4.sibling; ) {
                if (null === t4.return || t4.return === n4) return;
                t4 = t4.return;
              }
              t4.sibling.return = t4.return, t4 = t4.sibling;
            }
          }(a3 = Il(t3, l3, oo.current, e2, n3), n3, false), n3.stateNode = a3, Ml(a3, t3, l3, e2) && zt(n3);
        }
        return Pt(n3), function(e3, n4, t4) {
          if (Kl(n4, t4)) {
            if (e3.flags |= 16777216, !Xl(n4, t4)) {
              if (!zr()) throw To = Ro, _o;
              e3.flags |= 8192;
            }
          } else e3.flags &= -16777217;
        }(n3, n3.type, n3.pendingProps), null;
      case 6:
        if (e2 && null != n3.stateNode) (t3 = e2.memoizedProps) !== l3 && zt(n3);
        else {
          if ("string" != typeof l3 && null === n3.stateNode) throw Error(r2(166));
          e2 = oo.current, t3 = lo.current, n3.stateNode = Hl(l3, e2, t3, n3);
        }
        return Pt(n3), null;
      case 13:
        if (l3 = n3.memoizedState, null === e2 || null !== e2.memoizedState && null !== e2.memoizedState.dehydrated) {
          if (a3 = false, null !== l3 && null !== l3.dehydrated) {
            if (null === e2) {
              if (!a3) throw Error(r2(318));
              throw Error(r2(344));
            }
            0 == (128 & n3.flags) && (n3.memoizedState = null), n3.flags |= 4, Pt(n3), a3 = false;
          } else null !== so && (yr(so), so = null), a3 = true;
          if (!a3) return 256 & n3.flags ? (ye(n3), n3) : (ye(n3), null);
        }
        if (ye(n3), 0 != (128 & n3.flags)) return n3.lanes = t3, n3;
        if (t3 = null !== l3, e2 = null !== e2 && null !== e2.memoizedState, t3) {
          a3 = null, null !== (l3 = n3.child).alternate && null !== l3.alternate.memoizedState && null !== l3.alternate.memoizedState.cachePool && (a3 = l3.alternate.memoizedState.cachePool.pool);
          var o3 = null;
          null !== l3.memoizedState && null !== l3.memoizedState.cachePool && (o3 = l3.memoizedState.cachePool.pool), o3 !== a3 && (l3.flags |= 2048);
        }
        return t3 !== e2 && t3 && (n3.child.flags |= 8192), Ct(n3, n3.updateQueue), Pt(n3), null;
      case 4:
        return _(), null === e2 && Vl(n3.stateNode.containerInfo), Pt(n3), null;
      case 10:
        return ct(n3.type), Pt(n3), null;
      case 19:
        if (d2(Ho), null === (a3 = n3.memoizedState)) return Pt(n3), null;
        if (l3 = 0 != (128 & n3.flags), null === (o3 = a3.rendering)) if (l3) Et(a3, false);
        else {
          if (0 !== Wu || null !== e2 && 0 != (128 & e2.flags)) for (e2 = n3.child; null !== e2; ) {
            if (null !== (o3 = be(e2))) {
              for (n3.flags |= 128, Et(a3, false), e2 = o3.updateQueue, n3.updateQueue = e2, Ct(n3, e2), n3.subtreeFlags = 0, e2 = t3, t3 = n3.child; null !== t3; ) Gr(t3, e2), t3 = t3.sibling;
              return p2(Ho, 1 & Ho.current | 2), n3.child;
            }
            e2 = e2.sibling;
          }
          null !== a3.tail && Qa() > Yu && (n3.flags |= 128, l3 = true, Et(a3, false), n3.lanes = 4194304);
        }
        else {
          if (!l3) if (null !== (e2 = be(o3))) {
            if (n3.flags |= 128, l3 = true, e2 = e2.updateQueue, n3.updateQueue = e2, Ct(n3, e2), Et(a3, true), null === a3.tail && "hidden" === a3.tailMode && !o3.alternate) return Pt(n3), null;
          } else 2 * Qa() - a3.renderingStartTime > Yu && 536870912 !== t3 && (n3.flags |= 128, l3 = true, Et(a3, false), n3.lanes = 4194304);
          a3.isBackwards ? (o3.sibling = n3.child, n3.child = o3) : (null !== (e2 = a3.last) ? e2.sibling = o3 : n3.child = o3, a3.last = o3);
        }
        return null !== a3.tail ? (n3 = a3.tail, a3.rendering = n3, a3.tail = n3.sibling, a3.renderingStartTime = Qa(), n3.sibling = null, e2 = Ho.current, p2(Ho, l3 ? 1 & e2 | 2 : 1 & e2), n3) : (Pt(n3), null);
      case 22:
      case 23:
        return ye(n3), pe(), l3 = null !== n3.memoizedState, null !== e2 ? null !== e2.memoizedState !== l3 && (n3.flags |= 8192) : l3 && (n3.flags |= 8192), l3 ? 0 != (536870912 & t3) && 0 == (128 & n3.flags) && (Pt(n3), 6 & n3.subtreeFlags && (n3.flags |= 8192)) : Pt(n3), null !== (t3 = n3.updateQueue) && Ct(n3, t3.retryQueue), t3 = null, null !== e2 && null !== e2.memoizedState && null !== e2.memoizedState.cachePool && (t3 = e2.memoizedState.cachePool.pool), l3 = null, null !== n3.memoizedState && null !== n3.memoizedState.cachePool && (l3 = n3.memoizedState.cachePool.pool), l3 !== t3 && (n3.flags |= 2048), null !== e2 && d2(hu), null;
      case 24:
        return t3 = null, null !== e2 && (t3 = e2.memoizedState.cache), n3.memoizedState.cache !== t3 && (n3.flags |= 2048), ct(pu), Pt(n3), null;
      case 25:
        return null;
    }
    throw Error(r2(156, n3.tag));
  }
  function Rt(e2, n3) {
    switch (E(n3), n3.tag) {
      case 1:
        return 65536 & (e2 = n3.flags) ? (n3.flags = -65537 & e2 | 128, n3) : null;
      case 3:
        return ct(pu), _(), 0 != (65536 & (e2 = n3.flags)) && 0 == (128 & e2) ? (n3.flags = -65537 & e2 | 128, n3) : null;
      case 26:
      case 27:
      case 5:
        return T(n3), null;
      case 13:
        if (ye(n3), null !== (e2 = n3.memoizedState) && null !== e2.dehydrated && null === n3.alternate) throw Error(r2(340));
        return 65536 & (e2 = n3.flags) ? (n3.flags = -65537 & e2 | 128, n3) : null;
      case 19:
        return d2(Ho), null;
      case 4:
        return _(), null;
      case 10:
        return ct(n3.type), null;
      case 22:
      case 23:
        return ye(n3), pe(), null !== e2 && d2(hu), 65536 & (e2 = n3.flags) ? (n3.flags = -65537 & e2 | 128, n3) : null;
      case 24:
        return ct(pu), null;
      default:
        return null;
    }
  }
  function Tt(e2, n3) {
    switch (E(n3), n3.tag) {
      case 3:
        ct(pu), _();
        break;
      case 26:
      case 27:
      case 5:
        T(n3);
        break;
      case 4:
        _();
        break;
      case 13:
        ye(n3);
        break;
      case 19:
        d2(Ho);
        break;
      case 10:
        ct(n3.type);
        break;
      case 22:
      case 23:
        ye(n3), pe(), null !== e2 && d2(hu);
        break;
      case 24:
        ct(pu);
    }
  }
  function Nt(e2, n3) {
    try {
      var t3 = n3.updateQueue, r3 = null !== t3 ? t3.lastEffect : null;
      if (null !== r3) {
        var l3 = r3.next;
        t3 = l3;
        do {
          if ((t3.tag & e2) === e2) {
            r3 = void 0;
            var a3 = t3.create, o3 = t3.inst;
            r3 = a3(), o3.destroy = r3;
          }
          t3 = t3.next;
        } while (t3 !== l3);
      }
    } catch (e3) {
      jr(n3, n3.return, e3);
    }
  }
  function Lt(e2, n3, t3) {
    try {
      var r3 = n3.updateQueue, l3 = null !== r3 ? r3.lastEffect : null;
      if (null !== l3) {
        var a3 = l3.next;
        r3 = a3;
        do {
          if ((r3.tag & e2) === e2) {
            var o3 = r3.inst, u2 = o3.destroy;
            if (void 0 !== u2) {
              o3.destroy = void 0, l3 = n3;
              var i3 = t3;
              try {
                u2();
              } catch (e3) {
                jr(l3, i3, e3);
              }
            }
          }
          r3 = r3.next;
        } while (r3 !== a3);
      }
    } catch (e3) {
      jr(n3, n3.return, e3);
    }
  }
  function Ut(e2) {
    var n3 = e2.updateQueue;
    if (null !== n3) {
      var t3 = e2.stateNode;
      try {
        ee(n3, t3);
      } catch (n4) {
        jr(e2, e2.return, n4);
      }
    }
  }
  function Dt(e2, n3, t3) {
    t3.props = Dn(e2.type, e2.memoizedProps), t3.state = e2.memoizedState;
    try {
      t3.componentWillUnmount();
    } catch (t4) {
      jr(e2, n3, t4);
    }
  }
  function It(e2, n3) {
    try {
      var t3 = e2.ref;
      if (null !== t3) {
        var r3 = e2.stateNode;
        switch (e2.tag) {
          case 26:
          case 27:
          case 5:
            var l3 = Tl(r3);
            break;
          default:
            l3 = r3;
        }
        "function" == typeof t3 ? e2.refCleanup = t3(l3) : t3.current = l3;
      }
    } catch (t4) {
      jr(e2, n3, t4);
    }
  }
  function Ft(e2, n3) {
    var t3 = e2.ref, r3 = e2.refCleanup;
    if (null !== t3) if ("function" == typeof r3) try {
      r3();
    } catch (t4) {
      jr(e2, n3, t4);
    } finally {
      e2.refCleanup = null, null != (e2 = e2.alternate) && (e2.refCleanup = null);
    }
    else if ("function" == typeof t3) try {
      t3(null);
    } catch (t4) {
      jr(e2, n3, t4);
    }
    else t3.current = null;
  }
  function Mt(e2) {
    var n3 = e2.type, t3 = e2.memoizedProps, r3 = e2.stateNode;
    try {
      ia(r3, n3, t3, e2);
    } catch (n4) {
      jr(e2, e2.return, n4);
    }
  }
  function Wt(e2) {
    return 5 === e2.tag || 3 === e2.tag || 4 === e2.tag;
  }
  function Ht(e2) {
    e: for (; ; ) {
      for (; null === e2.sibling; ) {
        if (null === e2.return || Wt(e2.return)) return null;
        e2 = e2.return;
      }
      for (e2.sibling.return = e2.return, e2 = e2.sibling; 5 !== e2.tag && 6 !== e2.tag && 18 !== e2.tag; ) {
        if (2 & e2.flags) continue e;
        if (null === e2.child || 4 === e2.tag) continue e;
        e2.child.return = e2, e2 = e2.child;
      }
      if (!(2 & e2.flags)) return e2.stateNode;
    }
  }
  function jt(e2, n3, t3) {
    var r3 = e2.tag;
    if (5 === r3 || 6 === r3) e2 = e2.stateNode, n3 ? fa(t3, e2, n3) : oa(t3, e2);
    else if (4 !== r3 && !Ra && null !== (e2 = e2.child)) for (jt(e2, n3, t3), e2 = e2.sibling; null !== e2; ) jt(e2, n3, t3), e2 = e2.sibling;
  }
  function At(e2, n3, t3) {
    var r3 = e2.tag;
    if (5 === r3 || 6 === r3) e2 = e2.stateNode, n3 ? ca(t3, e2, n3) : aa(t3, e2);
    else if (4 !== r3 && !Ra && null !== (e2 = e2.child)) for (At(e2, n3, t3), e2 = e2.sibling; null !== e2; ) At(e2, n3, t3), e2 = e2.sibling;
  }
  function Qt(e2, n3, t3) {
    var r3 = t3.flags;
    switch (t3.tag) {
      case 0:
      case 11:
      case 15:
        Kt(e2, t3), 4 & r3 && Nt(5, t3);
        break;
      case 1:
        if (Kt(e2, t3), 4 & r3) if (e2 = t3.stateNode, null === n3) try {
          e2.componentDidMount();
        } catch (e3) {
          jr(t3, t3.return, e3);
        }
        else {
          var l3 = Dn(t3.type, n3.memoizedProps);
          n3 = n3.memoizedState;
          try {
            e2.componentDidUpdate(l3, n3, e2.__reactInternalSnapshotBeforeUpdate);
          } catch (e3) {
            jr(t3, t3.return, e3);
          }
        }
        64 & r3 && Ut(t3), 512 & r3 && It(t3, t3.return);
        break;
      case 3:
        if (Kt(e2, t3), 64 & r3 && null !== (r3 = t3.updateQueue)) {
          if (e2 = null, null !== t3.child) switch (t3.child.tag) {
            case 27:
            case 5:
              e2 = Tl(t3.child.stateNode);
              break;
            case 1:
              e2 = t3.child.stateNode;
          }
          try {
            ee(r3, e2);
          } catch (e3) {
            jr(t3, t3.return, e3);
          }
        }
        break;
      case 26:
      case 27:
      case 5:
        Kt(e2, t3), null === n3 && 4 & r3 && Mt(t3), 512 & r3 && It(t3, t3.return);
        break;
      case 12:
      case 13:
      default:
        Kt(e2, t3);
        break;
      case 22:
        if (!(l3 = null !== t3.memoizedState || gu)) {
          n3 = null !== n3 && null !== n3.memoizedState || yu;
          var a3 = gu, o3 = yu;
          gu = l3, (yu = n3) && !o3 ? Zt(e2, t3, 0 != (8772 & t3.subtreeFlags)) : Kt(e2, t3), gu = a3, yu = o3;
        }
        512 & r3 && ("manual" === t3.memoizedProps.mode ? It(t3, t3.return) : Ft(t3, t3.return));
    }
  }
  function Ot(e2) {
    var n3 = e2.alternate;
    null !== n3 && (e2.alternate = null, Ot(n3)), e2.child = null, e2.deletions = null, e2.sibling = null, 5 === e2.tag && null !== (n3 = e2.stateNode) && Jl(n3), e2.stateNode = null, e2.return = null, e2.dependencies = null, e2.memoizedProps = null, e2.memoizedState = null, e2.pendingProps = null, e2.stateNode = null, e2.updateQueue = null;
  }
  function Bt(e2, n3, t3) {
    for (t3 = t3.child; null !== t3; ) Vt(e2, n3, t3), t3 = t3.sibling;
  }
  function Vt(e2, n3, t3) {
    switch (t3.tag) {
      case 26:
      case 27:
        var r3, l3;
      case 5:
        yu || Ft(t3, n3);
      case 6:
        if (r3 = wu, l3 = xu, wu = null, Bt(e2, n3, t3), xu = l3, null !== (wu = r3)) if (xu) try {
          pa(wu, t3.stateNode);
        } catch (e3) {
          jr(t3, n3, e3);
        }
        else try {
          da(wu, t3.stateNode);
        } catch (e3) {
          jr(t3, n3, e3);
        }
        break;
      case 18:
        null !== wu && (xu ? Ca(wu, t3.stateNode) : za(wu, t3.stateNode));
        break;
      case 4:
        r3 = wu, l3 = xu, wu = t3.stateNode.containerInfo, xu = true, Bt(e2, n3, t3), wu = r3, xu = l3;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        yu || Lt(2, t3, n3), yu || Lt(4, t3, n3), Bt(e2, n3, t3);
        break;
      case 1:
        yu || (Ft(t3, n3), "function" == typeof (r3 = t3.stateNode).componentWillUnmount && Dt(t3, n3, r3)), Bt(e2, n3, t3);
        break;
      case 21:
        Bt(e2, n3, t3);
        break;
      case 22:
        Ft(t3, n3), yu = (r3 = yu) || null !== t3.memoizedState, Bt(e2, n3, t3), yu = r3;
        break;
      default:
        Bt(e2, n3, t3);
    }
  }
  function $t(e2, n3) {
    var t3 = function(e3) {
      switch (e3.tag) {
        case 13:
        case 19:
          var n4 = e3.stateNode;
          return null === n4 && (n4 = e3.stateNode = new vu()), n4;
        case 22:
          return null === (n4 = (e3 = e3.stateNode)._retryCache) && (n4 = e3._retryCache = new vu()), n4;
        default:
          throw Error(r2(435, e3.tag));
      }
    }(e2);
    n3.forEach(function(n4) {
      var r3 = Vr.bind(null, e2, n4);
      t3.has(n4) || (t3.add(n4), n4.then(r3, r3));
    });
  }
  function qt(e2, n3) {
    var t3 = n3.deletions;
    if (null !== t3) for (var l3 = 0; l3 < t3.length; l3++) {
      var a3 = t3[l3], o3 = e2, u2 = n3, i3 = u2;
      e: for (; null !== i3; ) {
        switch (i3.tag) {
          case 27:
          case 5:
            wu = i3.stateNode, xu = false;
            break e;
          case 3:
          case 4:
            wu = i3.stateNode.containerInfo, xu = true;
            break e;
        }
        i3 = i3.return;
      }
      if (null === wu) throw Error(r2(160));
      Vt(o3, u2, a3), wu = null, xu = false, null !== (o3 = a3.alternate) && (o3.return = null), a3.return = null;
    }
    if (13878 & n3.subtreeFlags) for (n3 = n3.child; null !== n3; ) Yt(n3, e2), n3 = n3.sibling;
  }
  function Yt(e2, n3) {
    var t3 = e2.alternate, l3 = e2.flags;
    switch (e2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        qt(n3, e2), Gt(e2), 4 & l3 && (Lt(3, e2, e2.return), Nt(3, e2), Lt(5, e2, e2.return));
        break;
      case 1:
        qt(n3, e2), Gt(e2), 512 & l3 && null !== t3 && Ft(t3, t3.return), 64 & l3 && gu && null !== (e2 = e2.updateQueue) && null !== (l3 = e2.callbacks) && (t3 = e2.shared.hiddenCallbacks, e2.shared.hiddenCallbacks = null === t3 ? l3 : t3.concat(l3));
        break;
      case 26:
        var a3;
      case 27:
        var o3;
      case 5:
        if (qt(n3, e2), Gt(e2), 512 & l3 && null !== t3 && Ft(t3, t3.return), 32 & e2.flags) {
          n3 = e2.stateNode;
          try {
            ma(n3);
          } catch (n4) {
            jr(e2, e2.return, n4);
          }
        }
        4 & l3 && null != e2.stateNode && function(e3, n4, t4) {
          try {
            sa(e3.stateNode, e3.type, t4, n4, e3);
          } catch (n5) {
            jr(e3, e3.return, n5);
          }
        }(e2, n3 = e2.memoizedProps, null !== t3 ? t3.memoizedProps : n3), 1024 & l3 && (bu = true);
        break;
      case 6:
        if (qt(n3, e2), Gt(e2), 4 & l3 && Ol) {
          if (null === e2.stateNode) throw Error(r2(162));
          l3 = e2.memoizedProps, t3 = null !== t3 ? t3.memoizedProps : l3, n3 = e2.stateNode;
          try {
            ua(n3, t3, l3);
          } catch (n4) {
            jr(e2, e2.return, n4);
          }
        }
        break;
      case 3:
        qt(n3, e2), Gt(e2), bu && (bu = false, Jt(e2));
        break;
      case 4:
      case 12:
        qt(n3, e2), Gt(e2);
        break;
      case 13:
        qt(n3, e2), Gt(e2), 8192 & e2.child.flags && null !== e2.memoizedState != (null !== t3 && null !== t3.memoizedState) && (qu = Qa()), 4 & l3 && null !== (l3 = e2.updateQueue) && (e2.updateQueue = null, $t(e2, l3));
        break;
      case 22:
        512 & l3 && null !== t3 && Ft(t3, t3.return), a3 = null !== e2.memoizedState;
        var u2 = null !== t3 && null !== t3.memoizedState, i3 = gu, s3 = yu;
        if (gu = i3 || a3, yu = s3 || u2, qt(n3, e2), yu = s3, gu = i3, Gt(e2), (n3 = e2.stateNode)._current = e2, n3._visibility &= -3, n3._visibility |= 2 & n3._pendingVisibility, 8192 & l3 && (n3._visibility = a3 ? -2 & n3._visibility : 1 | n3._visibility, a3 && (n3 = gu || yu, null === t3 || u2 || n3 || Xt(e2)), null === e2.memoizedProps || "manual" !== e2.memoizedProps.mode)) {
          e: if (t3 = null, Ol) for (n3 = e2; ; ) {
            if (5 === n3.tag || Ea || Ra) {
              if (null === t3) {
                u2 = t3 = n3;
                try {
                  o3 = u2.stateNode, a3 ? ha(o3) : ya(u2.stateNode, u2.memoizedProps);
                } catch (e3) {
                  jr(u2, u2.return, e3);
                }
              }
            } else if (6 === n3.tag) {
              if (null === t3) {
                u2 = n3;
                try {
                  var c3 = u2.stateNode;
                  a3 ? ga(c3) : ba(c3, u2.memoizedProps);
                } catch (e3) {
                  jr(u2, u2.return, e3);
                }
              }
            } else if ((22 !== n3.tag && 23 !== n3.tag || null === n3.memoizedState || n3 === e2) && null !== n3.child) {
              n3.child.return = n3, n3 = n3.child;
              continue;
            }
            if (n3 === e2) break e;
            for (; null === n3.sibling; ) {
              if (null === n3.return || n3.return === e2) break e;
              t3 === n3 && (t3 = null), n3 = n3.return;
            }
            t3 === n3 && (t3 = null), n3.sibling.return = n3.return, n3 = n3.sibling;
          }
        }
        4 & l3 && null !== (l3 = e2.updateQueue) && null !== (t3 = l3.retryQueue) && (l3.retryQueue = null, $t(e2, t3));
        break;
      case 19:
        qt(n3, e2), Gt(e2), 4 & l3 && null !== (l3 = e2.updateQueue) && (e2.updateQueue = null, $t(e2, l3));
        break;
      case 21:
        break;
      default:
        qt(n3, e2), Gt(e2);
    }
  }
  function Gt(e2) {
    var n3 = e2.flags;
    if (2 & n3) {
      try {
        if (Ol && (!Ra || 27 !== e2.tag)) {
          e: {
            for (var t3 = e2.return; null !== t3; ) {
              if (Wt(t3)) {
                var l3 = t3;
                break e;
              }
              t3 = t3.return;
            }
            throw Error(r2(160));
          }
          switch (l3.tag) {
            case 27:
            case 5:
              var a3 = l3.stateNode;
              32 & l3.flags && (ma(a3), l3.flags &= -33), At(e2, Ht(e2), a3);
              break;
            case 3:
            case 4:
              var o3 = l3.stateNode.containerInfo;
              jt(e2, Ht(e2), o3);
              break;
            default:
              throw Error(r2(161));
          }
        }
      } catch (n4) {
        jr(e2, e2.return, n4);
      }
      e2.flags &= -3;
    }
    4096 & n3 && (e2.flags &= -4097);
  }
  function Jt(e2) {
    if (1024 & e2.subtreeFlags) for (e2 = e2.child; null !== e2; ) {
      var n3 = e2;
      Jt(n3), 5 === n3.tag && 1024 & n3.flags && la(n3.stateNode), e2 = e2.sibling;
    }
  }
  function Kt(e2, n3) {
    if (8772 & n3.subtreeFlags) for (n3 = n3.child; null !== n3; ) Qt(e2, n3.alternate, n3), n3 = n3.sibling;
  }
  function Xt(e2) {
    for (e2 = e2.child; null !== e2; ) {
      var n3 = e2;
      switch (n3.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Lt(4, n3, n3.return), Xt(n3);
          break;
        case 1:
          Ft(n3, n3.return);
          var t3 = n3.stateNode;
          "function" == typeof t3.componentWillUnmount && Dt(n3, n3.return, t3), Xt(n3);
          break;
        case 26:
        case 27:
        case 5:
          Ft(n3, n3.return), Xt(n3);
          break;
        case 22:
          Ft(n3, n3.return), null === n3.memoizedState && Xt(n3);
          break;
        default:
          Xt(n3);
      }
      e2 = e2.sibling;
    }
  }
  function Zt(e2, n3, t3) {
    for (t3 = t3 && 0 != (8772 & n3.subtreeFlags), n3 = n3.child; null !== n3; ) {
      var r3 = n3.alternate, l3 = e2, a3 = n3, o3 = a3.flags;
      switch (a3.tag) {
        case 0:
        case 11:
        case 15:
          Zt(l3, a3, t3), Nt(4, a3);
          break;
        case 1:
          if (Zt(l3, a3, t3), "function" == typeof (l3 = (r3 = a3).stateNode).componentDidMount) try {
            l3.componentDidMount();
          } catch (e3) {
            jr(r3, r3.return, e3);
          }
          if (null !== (l3 = (r3 = a3).updateQueue)) {
            var u2 = r3.stateNode;
            try {
              var i3 = l3.shared.hiddenCallbacks;
              if (null !== i3) for (l3.shared.hiddenCallbacks = null, l3 = 0; l3 < i3.length; l3++) Z(i3[l3], u2);
            } catch (e3) {
              jr(r3, r3.return, e3);
            }
          }
          t3 && 64 & o3 && Ut(a3), It(a3, a3.return);
          break;
        case 26:
        case 27:
        case 5:
          Zt(l3, a3, t3), t3 && null === r3 && 4 & o3 && Mt(a3), It(a3, a3.return);
          break;
        case 12:
        case 13:
        default:
          Zt(l3, a3, t3);
          break;
        case 22:
          null === a3.memoizedState && Zt(l3, a3, t3), It(a3, a3.return);
      }
      n3 = n3.sibling;
    }
  }
  function er(e2, n3) {
    var t3 = null;
    null !== e2 && null !== e2.memoizedState && null !== e2.memoizedState.cachePool && (t3 = e2.memoizedState.cachePool.pool), e2 = null, null !== n3.memoizedState && null !== n3.memoizedState.cachePool && (e2 = n3.memoizedState.cachePool.pool), e2 !== t3 && (null != e2 && e2.refCount++, null != t3 && St(t3));
  }
  function nr(e2, n3) {
    e2 = null, null !== n3.alternate && (e2 = n3.alternate.memoizedState.cache), (n3 = n3.memoizedState.cache) !== e2 && (n3.refCount++, null != e2 && St(e2));
  }
  function tr(e2, n3, t3, r3) {
    if (10256 & n3.subtreeFlags) for (n3 = n3.child; null !== n3; ) rr(e2, n3, t3, r3), n3 = n3.sibling;
  }
  function rr(e2, n3, t3, r3) {
    var l3 = n3.flags;
    switch (n3.tag) {
      case 0:
      case 11:
      case 15:
        tr(e2, n3, t3, r3), 2048 & l3 && Nt(9, n3);
        break;
      case 3:
        tr(e2, n3, t3, r3), 2048 & l3 && (e2 = null, null !== n3.alternate && (e2 = n3.alternate.memoizedState.cache), (n3 = n3.memoizedState.cache) !== e2 && (n3.refCount++, null != e2 && St(e2)));
        break;
      case 12:
        if (2048 & l3) {
          tr(e2, n3, t3, r3), e2 = n3.stateNode;
          try {
            var a3 = n3.memoizedProps, o3 = a3.id, u2 = a3.onPostCommit;
            "function" == typeof u2 && u2(o3, null === n3.alternate ? "mount" : "update", e2.passiveEffectDuration, -0);
          } catch (e3) {
            jr(n3, n3.return, e3);
          }
        } else tr(e2, n3, t3, r3);
        break;
      case 23:
        break;
      case 22:
        a3 = n3.stateNode, null !== n3.memoizedState ? 4 & a3._visibility ? tr(e2, n3, t3, r3) : ar(e2, n3) : 4 & a3._visibility ? tr(e2, n3, t3, r3) : (a3._visibility |= 4, lr(e2, n3, t3, r3, 0 != (10256 & n3.subtreeFlags))), 2048 & l3 && er(n3.alternate, n3);
        break;
      case 24:
        tr(e2, n3, t3, r3), 2048 & l3 && nr(n3.alternate, n3);
        break;
      default:
        tr(e2, n3, t3, r3);
    }
  }
  function lr(e2, n3, t3, r3, l3) {
    for (l3 = l3 && 0 != (10256 & n3.subtreeFlags), n3 = n3.child; null !== n3; ) {
      var a3 = e2, o3 = n3, u2 = t3, i3 = r3, s3 = o3.flags;
      switch (o3.tag) {
        case 0:
        case 11:
        case 15:
          lr(a3, o3, u2, i3, l3), Nt(8, o3);
          break;
        case 23:
          break;
        case 22:
          var c3 = o3.stateNode;
          null !== o3.memoizedState ? 4 & c3._visibility ? lr(a3, o3, u2, i3, l3) : ar(a3, o3) : (c3._visibility |= 4, lr(a3, o3, u2, i3, l3)), l3 && 2048 & s3 && er(o3.alternate, o3);
          break;
        case 24:
          lr(a3, o3, u2, i3, l3), l3 && 2048 & s3 && nr(o3.alternate, o3);
          break;
        default:
          lr(a3, o3, u2, i3, l3);
      }
      n3 = n3.sibling;
    }
  }
  function ar(e2, n3) {
    if (10256 & n3.subtreeFlags) for (n3 = n3.child; null !== n3; ) {
      var t3 = e2, r3 = n3, l3 = r3.flags;
      switch (r3.tag) {
        case 22:
          ar(t3, r3), 2048 & l3 && er(r3.alternate, r3);
          break;
        case 24:
          ar(t3, r3), 2048 & l3 && nr(r3.alternate, r3);
          break;
        default:
          ar(t3, r3);
      }
      n3 = n3.sibling;
    }
  }
  function or(e2) {
    if (e2.subtreeFlags & Cu) for (e2 = e2.child; null !== e2; ) ur(e2), e2 = e2.sibling;
  }
  function ur(e2) {
    switch (e2.tag) {
      case 26:
        or(e2), e2.flags & Cu && (null !== e2.memoizedState ? _a(zu, e2.memoizedState, e2.memoizedProps) : ea(e2.type, e2.memoizedProps));
        break;
      case 5:
        or(e2), e2.flags & Cu && ea(e2.type, e2.memoizedProps);
        break;
      case 3:
      case 4:
        var n3;
        or(e2);
        break;
      case 22:
        null === e2.memoizedState && (null !== (n3 = e2.alternate) && null !== n3.memoizedState ? (n3 = Cu, Cu = 16777216, or(e2), Cu = n3) : or(e2));
        break;
      default:
        or(e2);
    }
  }
  function ir(e2) {
    var n3 = e2.alternate;
    if (null !== n3 && null !== (e2 = n3.child)) {
      n3.child = null;
      do {
        n3 = e2.sibling, e2.sibling = null, e2 = n3;
      } while (null !== e2);
    }
  }
  function sr(e2) {
    var n3 = e2.deletions;
    if (0 != (16 & e2.flags)) {
      if (null !== n3) for (var t3 = 0; t3 < n3.length; t3++) {
        var r3 = n3[t3];
        Su = r3, dr(r3, e2);
      }
      ir(e2);
    }
    if (10256 & e2.subtreeFlags) for (e2 = e2.child; null !== e2; ) cr(e2), e2 = e2.sibling;
  }
  function cr(e2) {
    switch (e2.tag) {
      case 0:
      case 11:
      case 15:
        sr(e2), 2048 & e2.flags && Lt(9, e2, e2.return);
        break;
      case 3:
      case 12:
      default:
        sr(e2);
        break;
      case 22:
        var n3 = e2.stateNode;
        null !== e2.memoizedState && 4 & n3._visibility && (null === e2.return || 13 !== e2.return.tag) ? (n3._visibility &= -5, fr(e2)) : sr(e2);
    }
  }
  function fr(e2) {
    var n3 = e2.deletions;
    if (0 != (16 & e2.flags)) {
      if (null !== n3) for (var t3 = 0; t3 < n3.length; t3++) {
        var r3 = n3[t3];
        Su = r3, dr(r3, e2);
      }
      ir(e2);
    }
    for (e2 = e2.child; null !== e2; ) {
      switch ((n3 = e2).tag) {
        case 0:
        case 11:
        case 15:
          Lt(8, n3, n3.return), fr(n3);
          break;
        case 22:
          4 & (t3 = n3.stateNode)._visibility && (t3._visibility &= -5, fr(n3));
          break;
        default:
          fr(n3);
      }
      e2 = e2.sibling;
    }
  }
  function dr(e2, n3) {
    for (; null !== Su; ) {
      var t3 = Su;
      switch (t3.tag) {
        case 0:
        case 11:
        case 15:
          Lt(8, t3, n3);
          break;
        case 23:
        case 22:
          if (null !== t3.memoizedState && null !== t3.memoizedState.cachePool) {
            var r3 = t3.memoizedState.cachePool.pool;
            null != r3 && r3.refCount++;
          }
          break;
        case 24:
          St(t3.memoizedState.cache);
      }
      if (null !== (r3 = t3.child)) r3.return = t3, Su = r3;
      else e: for (t3 = e2; null !== Su; ) {
        var l3 = (r3 = Su).sibling, a3 = r3.return;
        if (Ot(r3), r3 === t3) {
          Su = null;
          break e;
        }
        if (null !== l3) {
          l3.return = a3, Su = l3;
          break e;
        }
        Su = a3;
      }
    }
  }
  function pr() {
    return 0 != (2 & Ru) && 0 !== Lu ? Lu & -Lu : null !== Pl.T ? 0 !== wo ? wo : O() : Yl();
  }
  function mr() {
    0 === Qu && (Qu = 0 == (536870912 & Lu) || io ? y2() : 536870912);
    var e2 = Mo.current;
    return null !== e2 && (e2.flags |= 32), Qu;
  }
  function hr(e2, n3, t3) {
    (e2 === Tu && 2 === Uu || null !== e2.cancelPendingCommit) && (wr(e2, 0), Sr(e2, Lu, Qu)), S2(e2, t3), 0 != (2 & Ru) && e2 === Tu || (e2 === Tu && (0 == (2 & Ru) && (ju |= t3), 4 === Wu && Sr(e2, Lu, Qu)), M(e2));
  }
  function gr(e2, n3, t3) {
    if (0 != (6 & Ru)) throw Error(r2(327));
    var l3 = (t3 = !t3 && 0 == (60 & n3) && 0 == (n3 & e2.expiredLanes)) ? function(e3, n4) {
      var t4 = Ru;
      Ru |= 2;
      var l4 = Cr(), a4 = Er();
      Tu === e3 && Lu === n4 || (Gu = null, Yu = Qa() + 500, wr(e3, n4));
      e: for (; ; ) try {
        if (0 !== Uu && null !== Nu) {
          n4 = Nu;
          var o4 = Du;
          n: switch (Uu) {
            case 1:
            case 6:
              Uu = 0, Du = null, Ur(e3, n4, o4);
              break;
            case 2:
              if (te(o4)) {
                Uu = 0, Du = null, Lr(n4);
                break;
              }
              n4 = function() {
                2 === Uu && Tu === e3 && (Uu = 7), M(e3);
              }, o4.then(n4, n4);
              break e;
            case 3:
              Uu = 7;
              break e;
            case 4:
              Uu = 5;
              break e;
            case 7:
              te(o4) ? (Uu = 0, Du = null, Lr(n4)) : (Uu = 0, Du = null, Ur(e3, n4, o4));
              break;
            case 5:
              var u3 = null;
              switch (Nu.tag) {
                case 26:
                  u3 = Nu.memoizedState;
                case 5:
                case 27:
                  var i4 = Nu, s3 = i4.type, c3 = i4.pendingProps;
                  if (u3 ? Pa(u3) : Xl(s3, c3)) {
                    Uu = 0, Du = null;
                    var f3 = i4.sibling;
                    if (null !== f3) Nu = f3;
                    else {
                      var d3 = i4.return;
                      null !== d3 ? (Nu = d3, Dr(d3)) : Nu = null;
                    }
                    break n;
                  }
              }
              Uu = 0, Du = null, Ur(e3, n4, o4);
              break;
            case 8:
              kr(), Wu = 6;
              break e;
            default:
              throw Error(r2(462));
          }
        }
        Tr();
        break;
      } catch (n5) {
        xr(e3, n5);
      }
      return it(), Pl.H = l4, Pl.A = a4, Ru = t4, null !== Nu ? 0 : (Tu = null, Lu = 0, N(), Wu);
    }(e2, n3) : _r(e2, n3);
    if (0 !== l3) for (var a3 = t3; ; ) {
      if (6 === l3) Sr(e2, n3, 0);
      else {
        if (t3 = e2.current.alternate, a3 && !vr(t3)) {
          l3 = _r(e2, n3), a3 = false;
          continue;
        }
        if (2 === l3) {
          if (a3 = n3, e2.errorRecoveryDisabledLanes & a3) var o3 = 0;
          else o3 = 0 != (o3 = -536870913 & e2.pendingLanes) ? o3 : 536870912 & o3 ? 536870912 : 0;
          if (0 !== o3) {
            n3 = o3;
            e: {
              var u2 = e2;
              l3 = Bu;
              var i3 = Bl;
              if (i3 && (wr(u2, o3).flags |= 256), 2 !== (o3 = _r(u2, o3))) {
                if (Fu && !i3) {
                  u2.errorRecoveryDisabledLanes |= a3, ju |= a3, l3 = 4;
                  break e;
                }
                a3 = Vu, Vu = l3, null !== a3 && yr(a3);
              }
              l3 = o3;
            }
            if (a3 = false, 2 !== l3) continue;
          }
        }
        if (1 === l3) {
          wr(e2, 0), Sr(e2, n3, 0);
          break;
        }
        e: {
          switch (a3 = e2, l3) {
            case 0:
            case 1:
              throw Error(r2(345));
            case 4:
              if ((4194176 & n3) === n3) {
                Sr(a3, n3, Qu);
                break e;
              }
              break;
            case 2:
              Vu = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r2(329));
          }
          if (a3.finishedWork = t3, a3.finishedLanes = n3, (62914560 & n3) === n3 && 10 < (l3 = qu + 300 - Qa())) {
            if (Sr(a3, n3, Qu), 0 !== h2(a3, 0)) break e;
            a3.timeoutHandle = jl(br.bind(null, a3, t3, Vu, Gu, $u, n3, Qu, ju, Ou, Iu, 2, -0, 0), l3);
          } else br(a3, t3, Vu, Gu, $u, n3, Qu, ju, Ou, Iu, 0, -0, 0);
        }
      }
      break;
    }
    M(e2);
  }
  function yr(e2) {
    null === Vu ? Vu = e2 : Vu.push.apply(Vu, e2);
  }
  function br(e2, n3, t3, r3, l3, a3, o3, u2, i3, s3, c3, f3, d3) {
    if ((8192 & (s3 = n3.subtreeFlags) || 16785408 == (16785408 & s3)) && (Zl(), ur(n3), null !== (n3 = na()))) return e2.cancelPendingCommit = n3(Fr.bind(null, e2, t3, r3, l3, o3, u2, i3, 1, f3, d3)), void Sr(e2, a3, o3);
    Fr(e2, t3, r3, l3, o3);
  }
  function vr(e2) {
    for (var n3 = e2; ; ) {
      var t3 = n3.tag;
      if ((0 === t3 || 11 === t3 || 15 === t3) && 16384 & n3.flags && null !== (t3 = n3.updateQueue) && null !== (t3 = t3.stores)) for (var r3 = 0; r3 < t3.length; r3++) {
        var l3 = t3[r3], a3 = l3.getSnapshot;
        l3 = l3.value;
        try {
          if (!Ja(a3(), l3)) return false;
        } catch (e3) {
          return false;
        }
      }
      if (t3 = n3.child, 16384 & n3.subtreeFlags && null !== t3) t3.return = n3, n3 = t3;
      else {
        if (n3 === e2) break;
        for (; null === n3.sibling; ) {
          if (null === n3.return || n3.return === e2) return true;
          n3 = n3.return;
        }
        n3.sibling.return = n3.return, n3 = n3.sibling;
      }
    }
    return true;
  }
  function Sr(e2, n3, t3) {
    n3 &= ~Au, n3 &= ~ju, e2.suspendedLanes |= n3, e2.pingedLanes &= ~n3;
    for (var r3 = e2.expirationTimes, l3 = n3; 0 < l3; ) {
      var a3 = 31 - Ua(l3), o3 = 1 << a3;
      r3[a3] = -1, l3 &= ~o3;
    }
    0 !== t3 && k2(e2, t3, n3);
  }
  function kr() {
    if (null !== Nu) {
      if (0 === Uu) var e2 = Nu.return;
      else e2 = Nu, it(), Pe(e2), No = null, Lo = 0, e2 = Nu;
      for (; null !== e2; ) Tt(e2.alternate, e2), e2 = e2.return;
      Nu = null;
    }
  }
  function wr(e2, n3) {
    e2.finishedWork = null, e2.finishedLanes = 0;
    var t3 = e2.timeoutHandle;
    t3 !== Ql && (e2.timeoutHandle = Ql, Al(t3)), null !== (t3 = e2.cancelPendingCommit) && (e2.cancelPendingCommit = null, t3()), kr(), Tu = e2, Nu = t3 = Yr(e2.current, null), Lu = n3, Uu = 0, Du = null, Fu = Iu = false, Ou = Qu = Au = ju = Hu = Wu = 0, Vu = Bu = null, $u = false, 0 != (8 & n3) && (n3 |= 32 & n3);
    var r3 = e2.entangledLanes;
    if (0 !== r3) for (e2 = e2.entanglements, r3 &= n3; 0 < r3; ) {
      var l3 = 31 - Ua(r3), a3 = 1 << l3;
      n3 |= e2[l3], r3 &= ~a3;
    }
    return Mu = n3, N(), t3;
  }
  function xr(e2, n3) {
    Ao = null, Pl.H = Xo, n3 === Po ? (n3 = ae(), Uu = zr() && 0 == (134217727 & Hu) && 0 == (134217727 & ju) ? 2 : 3) : n3 === _o ? (n3 = ae(), Uu = 4) : Uu = n3 === ru ? 8 : null !== n3 && "object" == typeof n3 && "function" == typeof n3.then ? 6 : 1, Du = n3, null === Nu && (Wu = 1, In(e2, C(n3, e2.current)));
  }
  function zr() {
    var e2 = Mo.current;
    return null === e2 || ((4194176 & Lu) === Lu ? null === Wo : ((62914560 & Lu) === Lu || 0 != (536870912 & Lu)) && e2 === Wo);
  }
  function Cr() {
    var e2 = Pl.H;
    return Pl.H = Xo, null === e2 ? Xo : e2;
  }
  function Er() {
    var e2 = Pl.A;
    return Pl.A = Eu, e2;
  }
  function Pr() {
    Wu = 4, 0 == (134217727 & Hu) && 0 == (134217727 & ju) || null === Tu || Sr(Tu, Lu, Qu);
  }
  function _r(e2, n3) {
    var t3 = Ru;
    Ru |= 2;
    var l3 = Cr(), a3 = Er();
    Tu === e2 && Lu === n3 || (Gu = null, wr(e2, n3)), n3 = false;
    e: for (; ; ) try {
      if (0 !== Uu && null !== Nu) {
        var o3 = Nu, u2 = Du;
        switch (Uu) {
          case 8:
            kr(), Wu = 6;
            break e;
          case 3:
          case 2:
            n3 || null !== Mo.current || (n3 = true);
          default:
            Uu = 0, Du = null, Ur(e2, o3, u2);
        }
      }
      Rr();
      break;
    } catch (n4) {
      xr(e2, n4);
    }
    if (n3 && e2.shellSuspendCounter++, it(), Ru = t3, Pl.H = l3, Pl.A = a3, null !== Nu) throw Error(r2(261));
    return Tu = null, Lu = 0, N(), Wu;
  }
  function Rr() {
    for (; null !== Nu; ) Nr(Nu);
  }
  function Tr() {
    for (; null !== Nu && !ja(); ) Nr(Nu);
  }
  function Nr(e2) {
    var n3 = ut(e2.alternate, e2, Mu);
    e2.memoizedProps = e2.pendingProps, null === n3 ? Dr(e2) : Nu = n3;
  }
  function Lr(e2) {
    var n3 = e2, t3 = n3.alternate;
    switch (n3.tag) {
      case 15:
      case 0:
        n3 = Yn(t3, n3, n3.pendingProps, n3.type, void 0, Lu);
        break;
      case 11:
        n3 = Yn(t3, n3, n3.pendingProps, n3.type.render, n3.ref, Lu);
        break;
      case 5:
        Pe(n3);
      default:
        Tt(t3, n3), n3 = ut(t3, n3 = Nu = Gr(n3, Mu), Mu);
    }
    e2.memoizedProps = e2.pendingProps, null === n3 ? Dr(e2) : Nu = n3;
  }
  function Ur(e2, n3, t3) {
    it(), Pe(n3), No = null, Lo = 0;
    var l3 = n3.return;
    try {
      if (function(e3, n4, t4, l4, a3) {
        if (t4.flags |= 32768, null !== l4 && "object" == typeof l4 && "function" == typeof l4.then) {
          if (null !== (n4 = t4.alternate) && pt(n4, t4, a3, true), null !== (t4 = Mo.current)) {
            switch (t4.tag) {
              case 13:
                return null === Wo ? Pr() : null === t4.alternate && 0 === Wu && (Wu = 3), t4.flags &= -257, t4.flags |= 65536, t4.lanes = a3, l4 === Ro ? t4.flags |= 16384 : (null === (n4 = t4.updateQueue) ? t4.updateQueue = /* @__PURE__ */ new Set([l4]) : n4.add(l4), Ar(e3, l4, a3)), false;
              case 22:
                return t4.flags |= 65536, l4 === Ro ? t4.flags |= 16384 : (null === (n4 = t4.updateQueue) ? (n4 = { transitions: null, markerInstances: null, retryQueue: /* @__PURE__ */ new Set([l4]) }, t4.updateQueue = n4) : null === (t4 = n4.retryQueue) ? n4.retryQueue = /* @__PURE__ */ new Set([l4]) : t4.add(l4), Ar(e3, l4, a3)), false;
            }
            throw Error(r2(435, t4.tag));
          }
          return Ar(e3, l4, a3), Pr(), false;
        }
        var o3 = Error(r2(520), { cause: l4 });
        if (o3 = C(o3, t4), null === Bu ? Bu = [o3] : Bu.push(o3), 4 !== Wu && (Wu = 2), null === n4) return true;
        l4 = C(l4, t4), t4 = n4;
        do {
          switch (t4.tag) {
            case 3:
              return t4.flags |= 65536, e3 = a3 & -a3, t4.lanes |= e3, J(t4, e3 = Mn(t4.stateNode, l4, e3)), false;
            case 1:
              if (n4 = t4.type, o3 = t4.stateNode, 0 == (128 & t4.flags) && ("function" == typeof n4.getDerivedStateFromError || null !== o3 && "function" == typeof o3.componentDidCatch && (null === Ju || !Ju.has(o3)))) return t4.flags |= 65536, a3 &= -a3, t4.lanes |= a3, Hn(a3 = Wn(a3), e3, t4, l4), J(t4, a3), false;
          }
          t4 = t4.return;
        } while (null !== t4);
        return false;
      }(e2, l3, n3, t3, Lu)) return Wu = 1, In(e2, C(t3, e2.current)), void (Nu = null);
    } catch (n4) {
      if (null !== l3) throw Nu = l3, n4;
      return Wu = 1, In(e2, C(t3, e2.current)), void (Nu = null);
    }
    32768 & n3.flags ? Ir(n3, true) : Dr(n3);
  }
  function Dr(e2) {
    var n3 = e2;
    do {
      if (0 != (32768 & n3.flags)) return void Ir(n3, Iu);
      e2 = n3.return;
      var t3 = _t(n3.alternate, n3, Mu);
      if (null !== t3) return void (Nu = t3);
      if (null !== (n3 = n3.sibling)) return void (Nu = n3);
      Nu = n3 = e2;
    } while (null !== n3);
    0 === Wu && (Wu = 5);
  }
  function Ir(e2, n3) {
    do {
      var t3 = Rt(e2.alternate, e2);
      if (null !== t3) return t3.flags &= 32767, void (Nu = t3);
      if (null !== (t3 = e2.return) && (t3.flags |= 32768, t3.subtreeFlags = 0, t3.deletions = null), !n3 && null !== (e2 = e2.sibling)) return void (Nu = e2);
      Nu = e2 = t3;
    } while (null !== e2);
    Wu = 6, Nu = null;
  }
  function Fr(e2, n3, t3, l3, a3, o3, u2, i3, s3, c3) {
    var f3 = Pl.T, d3 = ql();
    try {
      $l(2), Pl.T = null, function(e3, n4, t4, l4, a4, o4) {
        do {
          Wr();
        } while (null !== Xu);
        if (0 != (6 & Ru)) throw Error(r2(327));
        var u3 = e3.finishedWork;
        if (l4 = e3.finishedLanes, null === u3) return null;
        if (e3.finishedWork = null, e3.finishedLanes = 0, u3 === e3.current) throw Error(r2(177));
        e3.callbackNode = null, e3.callbackPriority = 0, e3.cancelPendingCommit = null;
        var i4 = u3.lanes | u3.childLanes;
        if (function(e4, n5, t5, r3) {
          var l5 = e4.pendingLanes;
          e4.pendingLanes = t5, e4.suspendedLanes = 0, e4.pingedLanes = 0, e4.warmLanes = 0, e4.expiredLanes &= t5, e4.entangledLanes &= t5, e4.errorRecoveryDisabledLanes &= t5, e4.shellSuspendCounter = 0, n5 = e4.entanglements;
          var a5 = e4.expirationTimes, o5 = e4.hiddenUpdates;
          for (t5 = l5 & ~t5; 0 < t5; ) {
            var u4 = 31 - Ua(t5);
            l5 = 1 << u4, n5[u4] = 0, a5[u4] = -1;
            var i5 = o5[u4];
            if (null !== i5) for (o5[u4] = null, u4 = 0; u4 < i5.length; u4++) {
              var s5 = i5[u4];
              null !== s5 && (s5.lane &= -536870913);
            }
            t5 &= ~l5;
          }
          0 !== r3 && k2(e4, r3, 0);
        }(e3, l4, i4 |= po, o4), e3 === Tu && (Nu = Tu = null, Lu = 0), 0 == (10256 & u3.subtreeFlags) && 0 == (10256 & u3.flags) || Ku || (Ku = true, ei = i4, ni = t4, Wa(Va, function() {
          return Wr(), null;
        })), t4 = 0 != (15990 & u3.flags), 0 != (15990 & u3.subtreeFlags) || t4) {
          t4 = Pl.T, Pl.T = null, o4 = ql(), $l(2);
          var s4 = Ru;
          Ru |= 4, function(e4, n5) {
            for (Ul(e4.containerInfo), Su = n5; null !== Su; ) if (n5 = (e4 = Su).child, 0 != (1028 & e4.subtreeFlags) && null !== n5) n5.return = e4, Su = n5;
            else for (; null !== Su; ) {
              var t5 = (e4 = Su).alternate;
              switch (n5 = e4.flags, e4.tag) {
                case 0:
                case 11:
                case 15:
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                case 1:
                  if (0 != (1024 & n5) && null !== t5) {
                    n5 = void 0;
                    var l5 = e4, a5 = t5.memoizedProps;
                    t5 = t5.memoizedState;
                    var o5 = l5.stateNode;
                    try {
                      var u4 = Dn(l5.type, a5, (l5.elementType, l5.type));
                      n5 = o5.getSnapshotBeforeUpdate(u4, t5), o5.__reactInternalSnapshotBeforeUpdate = n5;
                    } catch (e5) {
                      jr(l5, l5.return, e5);
                    }
                  }
                  break;
                case 3:
                  0 != (1024 & n5) && Ol && va(e4.stateNode.containerInfo);
                  break;
                default:
                  if (0 != (1024 & n5)) throw Error(r2(163));
              }
              if (null !== (n5 = e4.sibling)) {
                n5.return = e4.return, Su = n5;
                break;
              }
              Su = e4.return;
            }
            u4 = ku, ku = false;
          }(e3, u3), Yt(u3, e3), Dl(e3.containerInfo), e3.current = u3, Qt(e3, u3.alternate, u3), Aa(), Ru = s4, $l(o4), Pl.T = t4;
        } else e3.current = u3;
        if (Ku ? (Ku = false, Xu = e3, Zu = l4) : Mr(e3, i4), 0 === (i4 = e3.pendingLanes) && (Ju = null), u3.stateNode, M(e3), null !== n4) for (a4 = e3.onRecoverableError, u3 = 0; u3 < n4.length; u3++) a4((i4 = n4[u3]).value, { componentStack: i4.stack });
        0 != (3 & Zu) && Wr(), i4 = e3.pendingLanes, 0 != (4194218 & l4) && 0 != (42 & i4) ? e3 === ri ? ti++ : (ti = 0, ri = e3) : ti = 0, W(0);
      }(e2, n3, t3, l3, d3, a3);
    } finally {
      Pl.T = f3, $l(d3);
    }
  }
  function Mr(e2, n3) {
    0 == (e2.pooledCacheLanes &= n3) && null != (n3 = e2.pooledCache) && (e2.pooledCache = null, St(n3));
  }
  function Wr() {
    if (null !== Xu) {
      var e2 = Xu, n3 = ei;
      ei = 0;
      var t3 = x(Zu), l3 = 32 > t3 ? 32 : t3;
      t3 = Pl.T;
      var a3 = ql();
      try {
        if ($l(l3), Pl.T = null, null === Xu) var o3 = false;
        else {
          l3 = ni, ni = null;
          var u2 = Xu, i3 = Zu;
          if (Xu = null, Zu = 0, 0 != (6 & Ru)) throw Error(r2(331));
          var s3 = Ru;
          Ru |= 4, cr(u2.current), rr(u2, u2.current, i3, l3), Ru = s3, W(0), Ga && Ga.onPostCommitFiberRoot, o3 = true;
        }
        return o3;
      } finally {
        $l(a3), Pl.T = t3, Mr(e2, n3);
      }
    }
    return false;
  }
  function Hr(e2, n3, t3) {
    n3 = C(t3, n3), null !== (e2 = Y(e2, n3 = Mn(e2.stateNode, n3, 2), 2)) && (S2(e2, 2), M(e2));
  }
  function jr(e2, n3, t3) {
    if (3 === e2.tag) Hr(e2, e2, t3);
    else for (; null !== n3; ) {
      if (3 === n3.tag) {
        Hr(n3, e2, t3);
        break;
      }
      if (1 === n3.tag) {
        var r3 = n3.stateNode;
        if ("function" == typeof n3.type.getDerivedStateFromError || "function" == typeof r3.componentDidCatch && (null === Ju || !Ju.has(r3))) {
          e2 = C(t3, e2), null !== (r3 = Y(n3, t3 = Wn(2), 2)) && (Hn(t3, r3, n3, e2), S2(r3, 2), M(r3));
          break;
        }
      }
      n3 = n3.return;
    }
  }
  function Ar(e2, n3, t3) {
    var r3 = e2.pingCache;
    if (null === r3) {
      r3 = e2.pingCache = new _u();
      var l3 = /* @__PURE__ */ new Set();
      r3.set(n3, l3);
    } else void 0 === (l3 = r3.get(n3)) && (l3 = /* @__PURE__ */ new Set(), r3.set(n3, l3));
    l3.has(t3) || (Fu = true, l3.add(t3), e2 = Qr.bind(null, e2, n3, t3), n3.then(e2, e2));
  }
  function Qr(e2, n3, t3) {
    var r3 = e2.pingCache;
    null !== r3 && r3.delete(n3), e2.pingedLanes |= e2.suspendedLanes & t3, e2.warmLanes &= ~t3, Tu === e2 && (Lu & t3) === t3 && (4 === Wu || 3 === Wu && (62914560 & Lu) === Lu && 300 > Qa() - qu ? 0 == (2 & Ru) && wr(e2, 0) : Au |= t3, Ou === Lu && (Ou = 0)), M(e2);
  }
  function Or(e2, n3) {
    0 === n3 && (n3 = b2()), null !== (e2 = D(e2, n3)) && (S2(e2, n3), M(e2));
  }
  function Br(e2) {
    var n3 = e2.memoizedState, t3 = 0;
    null !== n3 && (t3 = n3.retryLane), Or(e2, t3);
  }
  function Vr(e2, n3) {
    var t3 = 0;
    switch (e2.tag) {
      case 13:
        var l3 = e2.stateNode, a3 = e2.memoizedState;
        null !== a3 && (t3 = a3.retryLane);
        break;
      case 19:
        l3 = e2.stateNode;
        break;
      case 22:
        l3 = e2.stateNode._retryCache;
        break;
      default:
        throw Error(r2(314));
    }
    null !== l3 && l3.delete(n3), Or(e2, t3);
  }
  function $r(e2, n3, t3, r3) {
    this.tag = e2, this.key = t3, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = n3, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r3, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function qr(e2) {
    return !(!(e2 = e2.prototype) || !e2.isReactComponent);
  }
  function Yr(e2, n3) {
    var r3 = e2.alternate;
    return null === r3 ? ((r3 = t2(e2.tag, n3, e2.key, e2.mode)).elementType = e2.elementType, r3.type = e2.type, r3.stateNode = e2.stateNode, r3.alternate = e2, e2.alternate = r3) : (r3.pendingProps = n3, r3.type = e2.type, r3.flags = 0, r3.subtreeFlags = 0, r3.deletions = null), r3.flags = 31457280 & e2.flags, r3.childLanes = e2.childLanes, r3.lanes = e2.lanes, r3.child = e2.child, r3.memoizedProps = e2.memoizedProps, r3.memoizedState = e2.memoizedState, r3.updateQueue = e2.updateQueue, n3 = e2.dependencies, r3.dependencies = null === n3 ? null : { lanes: n3.lanes, firstContext: n3.firstContext }, r3.sibling = e2.sibling, r3.index = e2.index, r3.ref = e2.ref, r3.refCleanup = e2.refCleanup, r3;
  }
  function Gr(e2, n3) {
    e2.flags &= 31457282;
    var t3 = e2.alternate;
    return null === t3 ? (e2.childLanes = 0, e2.lanes = n3, e2.child = null, e2.subtreeFlags = 0, e2.memoizedProps = null, e2.memoizedState = null, e2.updateQueue = null, e2.dependencies = null, e2.stateNode = null) : (e2.childLanes = t3.childLanes, e2.lanes = t3.lanes, e2.child = t3.child, e2.subtreeFlags = 0, e2.deletions = null, e2.memoizedProps = t3.memoizedProps, e2.memoizedState = t3.memoizedState, e2.updateQueue = t3.updateQueue, e2.type = t3.type, n3 = t3.dependencies, e2.dependencies = null === n3 ? null : { lanes: n3.lanes, firstContext: n3.firstContext }), e2;
  }
  function Jr(e2, n3, l3, a3, o3, u2) {
    var i3 = 0;
    if (a3 = e2, "function" == typeof e2) qr(e2) && (i3 = 1);
    else if ("string" == typeof e2) i3 = 5;
    else e: switch (e2) {
      case dl:
        return Kr(l3.children, o3, u2, n3);
      case pl:
        i3 = 8, o3 |= 24;
        break;
      case ml:
        return (e2 = t2(12, l3, n3, 2 | o3)).elementType = ml, e2.lanes = u2, e2;
      case vl:
        return (e2 = t2(13, l3, n3, o3)).elementType = vl, e2.lanes = u2, e2;
      case Sl:
        return (e2 = t2(19, l3, n3, o3)).elementType = Sl, e2.lanes = u2, e2;
      case xl:
        return Xr(l3, o3, u2, n3);
      default:
        if ("object" == typeof e2 && null !== e2) switch (e2.$$typeof) {
          case hl:
          case yl:
            i3 = 10;
            break e;
          case gl:
            i3 = 9;
            break e;
          case bl:
            i3 = 11;
            break e;
          case kl:
            i3 = 14;
            break e;
          case wl:
            i3 = 16, a3 = null;
            break e;
        }
        i3 = 29, l3 = Error(r2(130, null === e2 ? "null" : typeof e2, "")), a3 = null;
    }
    return (n3 = t2(i3, l3, n3, o3)).elementType = e2, n3.type = a3, n3.lanes = u2, n3;
  }
  function Kr(e2, n3, r3, l3) {
    return (e2 = t2(7, e2, l3, n3)).lanes = r3, e2;
  }
  function Xr(e2, n3, l3, a3) {
    (e2 = t2(22, e2, a3, n3)).elementType = xl, e2.lanes = l3;
    var o3 = { _visibility: 1, _pendingVisibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null, _current: null, detach: function() {
      var e3 = o3._current;
      if (null === e3) throw Error(r2(456));
      if (0 == (2 & o3._pendingVisibility)) {
        var n4 = D(e3, 2);
        null !== n4 && (o3._pendingVisibility |= 2, hr(n4, 0, 2));
      }
    }, attach: function() {
      var e3 = o3._current;
      if (null === e3) throw Error(r2(456));
      if (0 != (2 & o3._pendingVisibility)) {
        var n4 = D(e3, 2);
        null !== n4 && (o3._pendingVisibility &= -3, hr(n4, 0, 2));
      }
    } };
    return e2.stateNode = o3, e2;
  }
  function Zr(e2, n3, r3) {
    return (e2 = t2(6, e2, null, n3)).lanes = r3, e2;
  }
  function el(e2, n3, r3) {
    return (n3 = t2(4, null !== e2.children ? e2.children : [], e2.key, n3)).lanes = r3, n3.stateNode = { containerInfo: e2.containerInfo, pendingChildren: null, implementation: e2.implementation }, n3;
  }
  function nl(e2, n3, t3, r3, l3, a3, o3, u2) {
    this.tag = 1, this.containerInfo = e2, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Ql, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = v2(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = v2(0), this.hiddenUpdates = v2(null), this.identifierPrefix = r3, this.onUncaughtError = l3, this.onCaughtError = a3, this.onRecoverableError = o3, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = u2, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function tl(e2, n3, t3, r3, l3, a3) {
    l3 = function(e3) {
      return e3 ? e3 = La : La;
    }(l3), null === r3.context ? r3.context = l3 : r3.pendingContext = l3, (r3 = q(n3)).payload = { element: t3 }, null !== (a3 = void 0 === a3 ? null : a3) && (r3.callback = a3), null !== (t3 = Y(e2, r3, n3)) && (hr(t3, 0, n3), G2(t3, e2, n3));
  }
  var rl, ll, al = {}, ol = React, ul = u$1, il = Object.assign, sl = Symbol.for("react.element"), cl = Symbol.for("react.transitional.element"), fl = Symbol.for("react.portal"), dl = Symbol.for("react.fragment"), pl = Symbol.for("react.strict_mode"), ml = Symbol.for("react.profiler"), hl = Symbol.for("react.provider"), gl = Symbol.for("react.consumer"), yl = Symbol.for("react.context"), bl = Symbol.for("react.forward_ref"), vl = Symbol.for("react.suspense"), Sl = Symbol.for("react.suspense_list"), kl = Symbol.for("react.memo"), wl = Symbol.for("react.lazy"), xl = Symbol.for("react.offscreen"), zl = Symbol.for("react.memo_cache_sentinel"), Cl = Symbol.iterator, El = Symbol.for("react.client.reference"), Pl = ol.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, _l = false, Rl = Array.isArray, Tl = n22.getPublicInstance, Nl = n22.getRootHostContext, Ll = n22.getChildHostContext, Ul = n22.prepareForCommit, Dl = n22.resetAfterCommit, Il = n22.createInstance, Fl = n22.appendInitialChild, Ml = n22.finalizeInitialChildren, Wl = n22.shouldSetTextContent, Hl = n22.createTextInstance, jl = null, Al = null, Ql = n22.noTimeout, Ol = true, Bl = null, Vl = null, $l = n22.setCurrentUpdatePriority, ql = n22.getCurrentUpdatePriority, Yl = n22.resolveUpdatePriority, Gl = n22.shouldAttemptEagerTransition, Jl = null;
  n22.requestPostPaintCallback;
  var Kl = n22.maySuspendCommit, Xl = null, Zl = null, ea = null, na = null, ta = null, ra = null, la = null, aa = n22.appendChild, oa = n22.appendChildToContainer, ua = n22.commitTextUpdate, ia = null, sa = n22.commitUpdate, ca = n22.insertBefore, fa = null, da = n22.removeChild, pa = n22.removeChildFromContainer, ma = n22.resetTextContent, ha = null, ga = null, ya = null, ba = null, va = n22.clearContainer, Sa = null, ka = null, wa = null, xa = null, za = null, Ca = null, Ea = null, Pa = null, _a = null, Ra = null, Ta = [], Na = -1, La = {}, Ua = Math.clz32 ? Math.clz32 : function(e2) {
    return 0 == (e2 >>>= 0) ? 32 : 31 - (Da(e2) / Ia | 0) | 0;
  }, Da = Math.log, Ia = Math.LN2, Fa = 128, Ma = 4194304, Wa = ul.unstable_scheduleCallback, Ha = ul.unstable_cancelCallback, ja = ul.unstable_shouldYield, Aa = ul.unstable_requestPaint, Qa = ul.unstable_now, Oa = ul.unstable_ImmediatePriority, Ba = ul.unstable_UserBlockingPriority, Va = ul.unstable_NormalPriority, $a = ul.unstable_IdlePriority, qa = ul.log, Ya = ul.unstable_setDisableYieldValue, Ga = null, Ja = "function" == typeof Object.is ? Object.is : function(e2, n3) {
    return e2 === n3 && (0 !== e2 || 1 / e2 == 1 / n3) || e2 != e2 && n3 != n3;
  }, Ka = /* @__PURE__ */ new WeakMap(), Xa = [], Za = 0, eo = null, no = [], to = 0, ro = null, lo = f2(null), ao = f2(null), oo = f2(null), uo = f2(null), io = false, so = null;
  Error(r2(519));
  var co = [], fo = 0, po = 0, mo = null, ho = null, go = false, yo = false, bo = false, vo = 0, So = null, ko = 0, wo = 0, xo = null, zo = false, Co = false, Eo = Object.prototype.hasOwnProperty, Po = Error(r2(460)), _o = Error(r2(474)), Ro = { then: function() {
  } }, To = null, No = null, Lo = 0, Uo = ce(true), Do = ce(false), Io = f2(null), Fo = f2(0), Mo = f2(null), Wo = null, Ho = f2(0), jo = 0, Ao = null, Qo = null, Oo = null, Bo = false, Vo = false, $o = false, qo = 0, Yo = 0, Go = null, Jo = 0, Ko = function() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }, Xo = { readContext: gt, use: Ne, useCallback: ve, useContext: ve, useEffect: ve, useImperativeHandle: ve, useLayoutEffect: ve, useInsertionEffect: ve, useMemo: ve, useReducer: ve, useRef: ve, useState: ve, useDebugValue: ve, useDeferredValue: ve, useTransition: ve, useSyncExternalStore: ve, useId: ve };
  Xo.useCacheRefresh = ve, Xo.useMemoCache = ve, Xo.useHostTransitionStatus = ve, Xo.useFormState = ve, Xo.useActionState = ve, Xo.useOptimistic = ve;
  var Zo = { readContext: gt, use: Ne, useCallback: function(e2, n3) {
    return _e().memoizedState = [e2, void 0 === n3 ? null : n3], e2;
  }, useContext: gt, useEffect: un, useImperativeHandle: function(e2, n3, t3) {
    t3 = null != t3 ? t3.concat([e2]) : null, an(4194308, 4, dn.bind(null, n3, e2), t3);
  }, useLayoutEffect: function(e2, n3) {
    return an(4194308, 4, e2, n3);
  }, useInsertionEffect: function(e2, n3) {
    an(4, 2, e2, n3);
  }, useMemo: function(e2, n3) {
    var t3 = _e();
    n3 = void 0 === n3 ? null : n3;
    var r3 = e2();
    if ($o) {
      z(true);
      try {
        e2();
      } finally {
        z(false);
      }
    }
    return t3.memoizedState = [r3, n3], r3;
  }, useReducer: function(e2, n3, t3) {
    var r3 = _e();
    if (void 0 !== t3) {
      var l3 = t3(n3);
      if ($o) {
        z(true);
        try {
          t3(n3);
        } finally {
          z(false);
        }
      }
    } else l3 = n3;
    return r3.memoizedState = r3.baseState = l3, e2 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: e2, lastRenderedState: l3 }, r3.queue = e2, e2 = e2.dispatch = zn.bind(null, Ao, e2), [r3.memoizedState, e2];
  }, useRef: function(e2) {
    return e2 = { current: e2 }, _e().memoizedState = e2;
  }, useState: function(e2) {
    var n3 = (e2 = Oe(e2)).queue, t3 = Cn.bind(null, Ao, n3);
    return n3.dispatch = t3, [e2.memoizedState, t3];
  }, useDebugValue: mn, useDeferredValue: function(e2, n3) {
    return yn(_e(), e2, n3);
  }, useTransition: function() {
    var e2 = Oe(false);
    return e2 = vn.bind(null, Ao, e2.queue, true, false), _e().memoizedState = e2, [false, e2];
  }, useSyncExternalStore: function(e2, n3, t3) {
    var l3 = Ao, a3 = _e();
    if (t3 = n3(), null === Tu) throw Error(r2(349));
    0 != (60 & Lu) || We(l3, n3, t3), a3.memoizedState = t3;
    var o3 = { value: t3, getSnapshot: n3 };
    return a3.queue = o3, un(je.bind(null, l3, o3, e2), [e2]), l3.flags |= 2048, rn(9, He.bind(null, l3, o3, t3, n3), { destroy: void 0 }, null), t3;
  }, useId: function() {
    var e2 = _e(), n3 = Tu.identifierPrefix;
    return n3 = ":" + n3 + "r" + (Jo++).toString(32) + ":", e2.memoizedState = n3;
  }, useCacheRefresh: function() {
    return _e().memoizedState = xn.bind(null, Ao);
  } };
  Zo.useMemoCache = Le, Zo.useHostTransitionStatus = Sn, Zo.useFormState = Xe, Zo.useActionState = Xe, Zo.useOptimistic = function(e2) {
    var n3 = _e();
    n3.memoizedState = n3.baseState = e2;
    var t3 = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null };
    return n3.queue = t3, n3 = Pn.bind(null, Ao, true, t3), t3.dispatch = n3, [e2, n3];
  };
  var eu = { readContext: gt, use: Ne, useCallback: hn, useContext: gt, useEffect: sn, useImperativeHandle: pn, useInsertionEffect: cn, useLayoutEffect: fn, useMemo: gn, useReducer: De, useRef: ln, useState: function() {
    return De(Ue);
  }, useDebugValue: mn, useDeferredValue: function(e2, n3) {
    return bn(Re(), Qo.memoizedState, e2, n3);
  }, useTransition: function() {
    var e2 = De(Ue)[0], n3 = Re().memoizedState;
    return ["boolean" == typeof e2 ? e2 : Te(e2), n3];
  }, useSyncExternalStore: Me, useId: kn };
  eu.useCacheRefresh = wn, eu.useMemoCache = Le, eu.useHostTransitionStatus = Sn, eu.useFormState = Ze, eu.useActionState = Ze, eu.useOptimistic = function(e2, n3) {
    return Be(Re(), 0, e2, n3);
  };
  var nu = { readContext: gt, use: Ne, useCallback: hn, useContext: gt, useEffect: sn, useImperativeHandle: pn, useInsertionEffect: cn, useLayoutEffect: fn, useMemo: gn, useReducer: Fe, useRef: ln, useState: function() {
    return Fe(Ue);
  }, useDebugValue: mn, useDeferredValue: function(e2, n3) {
    var t3 = Re();
    return null === Qo ? yn(t3, e2, n3) : bn(t3, Qo.memoizedState, e2, n3);
  }, useTransition: function() {
    var e2 = Fe(Ue)[0], n3 = Re().memoizedState;
    return ["boolean" == typeof e2 ? e2 : Te(e2), n3];
  }, useSyncExternalStore: Me, useId: kn };
  nu.useCacheRefresh = wn, nu.useMemoCache = Le, nu.useHostTransitionStatus = Sn, nu.useFormState = tn, nu.useActionState = tn, nu.useOptimistic = function(e2, n3) {
    var t3 = Re();
    return null !== Qo ? Be(t3, 0, e2, n3) : (t3.baseState = e2, [e2, t3.queue.dispatch]);
  };
  var tu = { isMounted: function(e2) {
    return !!(e2 = e2._reactInternals) && function(e3) {
      var n3 = e3, t3 = e3;
      if (e3.alternate) for (; n3.return; ) n3 = n3.return;
      else {
        e3 = n3;
        do {
          0 != (4098 & (n3 = e3).flags) && (t3 = n3.return), e3 = n3.return;
        } while (e3);
      }
      return 3 === n3.tag ? t3 : null;
    }(e2) === e2;
  }, enqueueSetState: function(e2, n3, t3) {
    e2 = e2._reactInternals;
    var r3 = pr(), l3 = q(r3);
    l3.payload = n3, null != t3 && (l3.callback = t3), null !== (n3 = Y(e2, l3, r3)) && (hr(n3, 0, r3), G2(n3, e2, r3));
  }, enqueueReplaceState: function(e2, n3, t3) {
    e2 = e2._reactInternals;
    var r3 = pr(), l3 = q(r3);
    l3.tag = 1, l3.payload = n3, null != t3 && (l3.callback = t3), null !== (n3 = Y(e2, l3, r3)) && (hr(n3, 0, r3), G2(n3, e2, r3));
  }, enqueueForceUpdate: function(e2, n3) {
    e2 = e2._reactInternals;
    var t3 = pr(), r3 = q(t3);
    r3.tag = 2, null != n3 && (r3.callback = n3), null !== (n3 = Y(e2, r3, t3)) && (hr(n3, 0, t3), G2(n3, e2, t3));
  } };
  "function" == typeof reportError && reportError;
  var ru = Error(r2(461)), lu = false, au = { dehydrated: null, treeContext: null, retryLane: 0 }, ou = f2(null), uu = null, iu = null, su = null, cu = "undefined" != typeof AbortController ? AbortController : function() {
    var e2 = [], n3 = this.signal = { aborted: false, addEventListener: function(n4, t3) {
      e2.push(t3);
    } };
    this.abort = function() {
      n3.aborted = true, e2.forEach(function(e3) {
        return e3();
      });
    };
  }, fu = ul.unstable_scheduleCallback, du = ul.unstable_NormalPriority, pu = { $$typeof: yl, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }, mu = Pl.S;
  Pl.S = function(e2, n3) {
    "object" == typeof n3 && null !== n3 && "function" == typeof n3.then && function(e3, n4) {
      if (null === So) {
        var t3 = So = [];
        ko = 0, wo = O(), xo = { status: "pending", value: void 0, then: function(e4) {
          t3.push(e4);
        } };
      }
      ko++, n4.then(B, B);
    }(0, n3), null !== mu && mu(e2, n3);
  };
  var hu = f2(null), gu = false, yu = false, bu = false, vu = "function" == typeof WeakSet ? WeakSet : Set, Su = null, ku = false, wu = null, xu = false, zu = null, Cu = 8192, Eu = { getCacheForType: function(e2) {
    var n3 = gt(pu), t3 = n3.data.get(e2);
    return void 0 === t3 && (t3 = e2(), n3.data.set(e2, t3)), t3;
  } };
  if ("function" == typeof Symbol && Symbol.for) {
    var Pu = Symbol.for;
    Pu("selector.component"), Pu("selector.has_pseudo_class"), Pu("selector.role"), Pu("selector.test_id"), Pu("selector.text");
  }
  var _u = "function" == typeof WeakMap ? WeakMap : Map, Ru = 0, Tu = null, Nu = null, Lu = 0, Uu = 0, Du = null, Iu = false, Fu = false, Mu = 0, Wu = 0, Hu = 0, ju = 0, Au = 0, Qu = 0, Ou = 0, Bu = null, Vu = null, $u = false, qu = 0, Yu = 1 / 0, Gu = null, Ju = null, Ku = false, Xu = null, Zu = 0, ei = 0, ni = null, ti = 0, ri = null;
  return al.createContainer = function(e2, n3, r3, l3, a3, o3, u2, i3, s3, c3) {
    return function(e3, n4, r4, l4, a4, o4, u3, i4, s4, c4, f3, d3) {
      return e3 = new nl(e3, n4, r4, u3, i4, s4, c4, null), n4 = 1, true === o4 && (n4 |= 24), o4 = t2(3, null, null, n4), e3.current = o4, o4.stateNode = e3, (n4 = vt()).refCount++, e3.pooledCache = n4, n4.refCount++, o4.memoizedState = { element: l4, isDehydrated: r4, cache: n4 }, V(o4), e3;
    }(e2, n3, false, null, 0, l3, o3, u2, i3, s3);
  }, al.flushSyncWork = function() {
    return 0 != (6 & Ru) || (W(0), false);
  }, al.updateContainer = function(e2, n3, t3, r3) {
    var l3 = n3.current, a3 = pr();
    return tl(l3, a3, e2, n3, t3, r3), a3;
  }, al.updateContainerSync = function(e2, n3, t3, r3) {
    return 0 === n3.tag && Wr(), tl(n3.current, 2, e2, n3, t3, r3), 2;
  }, al;
}, s$1.exports.default = s$1.exports, Object.defineProperty(s$1.exports, "__esModule", { value: true })), o$1.exports);
var f$1, d = t(a$1.exports), p = { exports: {} }, m = {};
/**
 * @license React
 * react-reconciler-constants.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
p.exports = (f$1 || (f$1 = 1, m.ConcurrentRoot = 1, m.ContinuousEventPriority = 8, m.DefaultEventPriority = 32, m.DiscreteEventPriority = 2, m.IdleEventPriority = 268435456, m.LegacyRoot = 0, m.NoEventPriority = 0), m);
var y = p.exports;
const b = (e2, n22) => {
  const t2 = Object.keys(e2), r2 = Object.keys(n22);
  if (t2.length !== r2.length) return false;
  for (let r3 = 0; r3 < t2.length; r3 += 1) {
    const l2 = t2[r3];
    if ("render" === l2 && !e2[l2] != !n22[l2]) return false;
    if ("children" !== l2 && e2[l2] !== n22[l2]) {
      if ("object" == typeof e2[l2] && "object" == typeof n22[l2] && b(e2[l2], n22[l2])) continue;
      return false;
    }
    if ("children" === l2 && ("string" == typeof e2[l2] || "string" == typeof n22[l2])) return e2[l2] === n22[l2];
  }
  return true;
}, v = {}, S = console.error, k = ({ appendChild: e2, appendChildToContainer: n22, commitTextUpdate: t2, commitUpdate: r2, createInstance: l2, createTextInstance: a2, insertBefore: o2, removeChild: u2, removeChildFromContainer: i2, resetAfterCommit: s2 }) => {
  const c2 = d({ appendChild: e2, appendChildToContainer: n22, appendInitialChild: e2, createInstance: l2, createTextInstance: a2, insertBefore: o2, commitUpdate: (e3, n3, t3, l3) => {
    b(t3, l3) || r2(e3, null, n3, t3, l3);
  }, commitTextUpdate: t2, removeChild: u2, removeChildFromContainer: i2, resetAfterCommit: s2, noTimeout: -1, shouldSetTextContent: () => false, finalizeInitialChildren: () => false, getPublicInstance: (e3) => e3, getRootHostContext: () => v, getChildHostContext: () => v, prepareForCommit() {
  }, clearContainer() {
  }, resetTextContent() {
  }, getCurrentUpdatePriority: () => y.DefaultEventPriority, maySuspendCommit: () => false, requestPostPaintCallback: () => {
  }, resolveUpdatePriority: () => y.DefaultEventPriority, setCurrentUpdatePriority: () => {
  }, shouldAttemptEagerTransition: () => false });
  return { createContainer: (e3) => c2.createContainer(e3, y.ConcurrentRoot, null, false, null, "", S, S, S, null), updateContainer: (e3, n3, t3, r3) => {
    c2.updateContainerSync(e3, n3, t3, r3), c2.flushSyncWork();
  } };
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign;
var hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign) return objectAssign;
  hasRequiredObjectAssign = 1;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i2 = 0; i2 < 10; i2++) {
        test2["_" + String.fromCharCode(i2)] = i2;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n3) {
        return test2[n3];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err2) {
      return false;
    }
  }
  objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
    var from2;
    var to = toObject(target);
    var symbols;
    for (var s2 = 1; s2 < arguments.length; s2++) {
      from2 = Object(arguments[s2]);
      for (var key in from2) {
        if (hasOwnProperty2.call(from2, key)) {
          to[key] = from2[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from2);
        for (var i2 = 0; i2 < symbols.length; i2++) {
          if (propIsEnumerable.call(from2, symbols[i2])) {
            to[symbols[i2]] = from2[symbols[i2]];
          }
        }
      }
    }
    return to;
  };
  return objectAssign;
}
var objectAssignExports = requireObjectAssign();
const e = /* @__PURE__ */ getDefaultExportFromCjs$2(objectAssignExports);
function r(e2) {
  return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
}
function l(e2) {
  if (e2.__esModule) return e2;
  var t2 = e2.default;
  if ("function" == typeof t2) {
    var n3 = function e3() {
      return this instanceof e3 ? Reflect.construct(t2, arguments, this.constructor) : t2.apply(this, arguments);
    };
    n3.prototype = t2.prototype;
  } else n3 = {};
  return Object.defineProperty(n3, "__esModule", { value: true }), Object.keys(e2).forEach(function(t3) {
    var r2 = Object.getOwnPropertyDescriptor(e2, t3);
    Object.defineProperty(n3, t3, r2.get ? r2 : { enumerable: true, get: function() {
      return e2[t3];
    } });
  }), n3;
}
var i, a = { exports: {} }, u = l(n);
/** @license React v0.23.0
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(i = a).exports = function n2(r2) {
  var l2 = e, a2 = React, o2 = u;
  function f2(e2) {
    for (var t2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + e2, n3 = 1; n3 < arguments.length; n3++) t2 += "&args[]=" + encodeURIComponent(arguments[n3]);
    return "Minified React error #" + e2 + "; visit " + t2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var c2 = a2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  c2.hasOwnProperty("ReactCurrentDispatcher") || (c2.ReactCurrentDispatcher = { current: null }), c2.hasOwnProperty("ReactCurrentBatchConfig") || (c2.ReactCurrentBatchConfig = { suspense: null });
  var s2 = "function" == typeof Symbol && Symbol.for, d2 = s2 ? Symbol.for("react.element") : 60103, p2 = s2 ? Symbol.for("react.portal") : 60106, m2 = s2 ? Symbol.for("react.fragment") : 60107, h = s2 ? Symbol.for("react.strict_mode") : 60108, g = s2 ? Symbol.for("react.profiler") : 60114, b2 = s2 ? Symbol.for("react.provider") : 60109, y2 = s2 ? Symbol.for("react.context") : 60110, v2 = s2 ? Symbol.for("react.concurrent_mode") : 60111, T = s2 ? Symbol.for("react.forward_ref") : 60112, x = s2 ? Symbol.for("react.suspense") : 60113, E = s2 ? Symbol.for("react.suspense_list") : 60120, k2 = s2 ? Symbol.for("react.memo") : 60115, S2 = s2 ? Symbol.for("react.lazy") : 60116, C = "function" == typeof Symbol && Symbol.iterator;
  function w(e2) {
    return null === e2 || "object" != typeof e2 ? null : "function" == typeof (e2 = C && e2[C] || e2["@@iterator"]) ? e2 : null;
  }
  function z(e2) {
    if (null == e2) return null;
    if ("function" == typeof e2) return e2.displayName || e2.name || null;
    if ("string" == typeof e2) return e2;
    switch (e2) {
      case m2:
        return "Fragment";
      case p2:
        return "Portal";
      case g:
        return "Profiler";
      case h:
        return "StrictMode";
      case x:
        return "Suspense";
      case E:
        return "SuspenseList";
    }
    if ("object" == typeof e2) switch (e2.$$typeof) {
      case y2:
        return "Context.Consumer";
      case b2:
        return "Context.Provider";
      case T:
        var t2 = e2.render;
        return t2 = t2.displayName || t2.name || "", e2.displayName || ("" !== t2 ? "ForwardRef(" + t2 + ")" : "ForwardRef");
      case k2:
        return z(e2.type);
      case S2:
        if (e2 = 1 === e2._status ? e2._result : null) return z(e2);
    }
    return null;
  }
  function P(e2) {
    var t2 = e2, n3 = e2;
    if (e2.alternate) for (; t2.return; ) t2 = t2.return;
    else {
      e2 = t2;
      do {
        0 != (1026 & (t2 = e2).effectTag) && (n3 = t2.return), e2 = t2.return;
      } while (e2);
    }
    return 3 === t2.tag ? n3 : null;
  }
  function _(e2) {
    if (P(e2) !== e2) throw Error(f2(188));
  }
  function N(e2) {
    var t2 = e2.alternate;
    if (!t2) {
      if (null === (t2 = P(e2))) throw Error(f2(188));
      return t2 !== e2 ? null : e2;
    }
    for (var n3 = e2, r3 = t2; ; ) {
      var l3 = n3.return;
      if (null === l3) break;
      var i2 = l3.alternate;
      if (null === i2) {
        if (null !== (r3 = l3.return)) {
          n3 = r3;
          continue;
        }
        break;
      }
      if (l3.child === i2.child) {
        for (i2 = l3.child; i2; ) {
          if (i2 === n3) return _(l3), e2;
          if (i2 === r3) return _(l3), t2;
          i2 = i2.sibling;
        }
        throw Error(f2(188));
      }
      if (n3.return !== r3.return) n3 = l3, r3 = i2;
      else {
        for (var a3 = false, u2 = l3.child; u2; ) {
          if (u2 === n3) {
            a3 = true, n3 = l3, r3 = i2;
            break;
          }
          if (u2 === r3) {
            a3 = true, r3 = l3, n3 = i2;
            break;
          }
          u2 = u2.sibling;
        }
        if (!a3) {
          for (u2 = i2.child; u2; ) {
            if (u2 === n3) {
              a3 = true, n3 = i2, r3 = l3;
              break;
            }
            if (u2 === r3) {
              a3 = true, r3 = i2, n3 = l3;
              break;
            }
            u2 = u2.sibling;
          }
          if (!a3) throw Error(f2(189));
        }
      }
      if (n3.alternate !== r3) throw Error(f2(190));
    }
    if (3 !== n3.tag) throw Error(f2(188));
    return n3.stateNode.current === n3 ? e2 : t2;
  }
  function U(e2) {
    if (!(e2 = N(e2))) return null;
    for (var t2 = e2; ; ) {
      if (5 === t2.tag || 6 === t2.tag) return t2;
      if (t2.child) t2.child.return = t2, t2 = t2.child;
      else {
        if (t2 === e2) break;
        for (; !t2.sibling; ) {
          if (!t2.return || t2.return === e2) return null;
          t2 = t2.return;
        }
        t2.sibling.return = t2.return, t2 = t2.sibling;
      }
    }
    return null;
  }
  var R = r2.getPublicInstance, I = r2.getRootHostContext, M = r2.getChildHostContext, F = r2.prepareForCommit, Q = r2.resetAfterCommit, D = r2.createInstance, W = r2.appendInitialChild, j = r2.finalizeInitialChildren, O = r2.prepareUpdate, B = r2.shouldSetTextContent, H = r2.createTextInstance, A = null, L = null, $ = r2.noTimeout, q = true, V = null, K = r2.appendChild, G2 = r2.appendChildToContainer, Y = r2.commitTextUpdate, J = null, X = r2.commitUpdate, Z = r2.insertBefore, ee = null, te = r2.removeChild, ne = r2.removeChildFromContainer, re = r2.resetTextContent, le = null, ie = null, ae = null, ue = null, oe = null, fe = null, ce = /^(.*)[\\\/]/;
  function se(e2) {
    var t2 = "";
    do {
      e: switch (e2.tag) {
        case 3:
        case 4:
        case 6:
        case 7:
        case 10:
        case 9:
          var n3 = "";
          break e;
        default:
          var r3 = e2._debugOwner, l3 = e2._debugSource, i2 = z(e2.type);
          n3 = null, r3 && (n3 = z(r3.type)), r3 = i2, i2 = "", l3 ? i2 = " (at " + l3.fileName.replace(ce, "") + ":" + l3.lineNumber + ")" : n3 && (i2 = " (created by " + n3 + ")"), n3 = "\n    in " + (r3 || "Unknown") + i2;
      }
      t2 += n3, e2 = e2.return;
    } while (e2);
    return t2;
  }
  var de = [], pe = -1;
  function me(e2) {
    0 > pe || (e2.current = de[pe], de[pe] = null, pe--);
  }
  function he(e2, t2) {
    pe++, de[pe] = e2.current, e2.current = t2;
  }
  var ge = {}, be = { current: ge }, ye = { current: false }, ve = ge;
  function Te(e2, t2) {
    var n3 = e2.type.contextTypes;
    if (!n3) return ge;
    var r3 = e2.stateNode;
    if (r3 && r3.__reactInternalMemoizedUnmaskedChildContext === t2) return r3.__reactInternalMemoizedMaskedChildContext;
    var l3, i2 = {};
    for (l3 in n3) i2[l3] = t2[l3];
    return r3 && ((e2 = e2.stateNode).__reactInternalMemoizedUnmaskedChildContext = t2, e2.__reactInternalMemoizedMaskedChildContext = i2), i2;
  }
  function xe(e2) {
    return null != (e2 = e2.childContextTypes);
  }
  function Ee(e2) {
    me(ye), me(be);
  }
  function ke(e2) {
    me(ye), me(be);
  }
  function Se(e2, t2, n3) {
    if (be.current !== ge) throw Error(f2(168));
    he(be, t2), he(ye, n3);
  }
  function Ce(e2, t2, n3) {
    var r3 = e2.stateNode;
    if (e2 = t2.childContextTypes, "function" != typeof r3.getChildContext) return n3;
    for (var i2 in r3 = r3.getChildContext()) if (!(i2 in e2)) throw Error(f2(108, z(t2) || "Unknown", i2));
    return l2({}, n3, {}, r3);
  }
  function we(e2) {
    var t2 = e2.stateNode;
    return t2 = t2 && t2.__reactInternalMemoizedMergedChildContext || ge, ve = be.current, he(be, t2), he(ye, ye.current), true;
  }
  function ze(e2, t2, n3) {
    var r3 = e2.stateNode;
    if (!r3) throw Error(f2(169));
    n3 ? (t2 = Ce(e2, t2, ve), r3.__reactInternalMemoizedMergedChildContext = t2, me(ye), me(be), he(be, t2)) : me(ye), he(ye, n3);
  }
  var Pe = o2.unstable_runWithPriority, _e = o2.unstable_scheduleCallback, Ne = o2.unstable_cancelCallback, Ue = o2.unstable_shouldYield, Re = o2.unstable_requestPaint, Ie = o2.unstable_now, Me = o2.unstable_getCurrentPriorityLevel, Fe = o2.unstable_ImmediatePriority, Qe = o2.unstable_UserBlockingPriority, De = o2.unstable_NormalPriority, We = o2.unstable_LowPriority, je = o2.unstable_IdlePriority, Oe = {}, Be = void 0 !== Re ? Re : function() {
  }, He = null, Ae = null, Le = false, $e = Ie(), qe = 1e4 > $e ? Ie : function() {
    return Ie() - $e;
  };
  function Ve() {
    switch (Me()) {
      case Fe:
        return 99;
      case Qe:
        return 98;
      case De:
        return 97;
      case We:
        return 96;
      case je:
        return 95;
      default:
        throw Error(f2(332));
    }
  }
  function Ke(e2) {
    switch (e2) {
      case 99:
        return Fe;
      case 98:
        return Qe;
      case 97:
        return De;
      case 96:
        return We;
      case 95:
        return je;
      default:
        throw Error(f2(332));
    }
  }
  function Ge(e2, t2) {
    return e2 = Ke(e2), Pe(e2, t2);
  }
  function Ye(e2, t2, n3) {
    return e2 = Ke(e2), _e(e2, t2, n3);
  }
  function Je(e2) {
    return null === He ? (He = [e2], Ae = _e(Fe, Ze)) : He.push(e2), Oe;
  }
  function Xe() {
    if (null !== Ae) {
      var e2 = Ae;
      Ae = null, Ne(e2);
    }
    Ze();
  }
  function Ze() {
    if (!Le && null !== He) {
      Le = true;
      var e2 = 0;
      try {
        var t2 = He;
        Ge(99, function() {
          for (; e2 < t2.length; e2++) {
            var n3 = t2[e2];
            do {
              n3 = n3(true);
            } while (null !== n3);
          }
        }), He = null;
      } catch (t3) {
        throw null !== He && (He = He.slice(e2 + 1)), _e(Fe, Xe), t3;
      } finally {
        Le = false;
      }
    }
  }
  var et = 3;
  function tt(e2, t2, n3) {
    return 1073741821 - (1 + ((1073741821 - e2 + t2 / 10) / (n3 /= 10) | 0)) * n3;
  }
  var nt = "function" == typeof Object.is ? Object.is : function(e2, t2) {
    return e2 === t2 && (0 !== e2 || 1 / e2 == 1 / t2) || e2 != e2 && t2 != t2;
  }, rt = Object.prototype.hasOwnProperty;
  function lt(e2, t2) {
    if (nt(e2, t2)) return true;
    if ("object" != typeof e2 || null === e2 || "object" != typeof t2 || null === t2) return false;
    var n3 = Object.keys(e2), r3 = Object.keys(t2);
    if (n3.length !== r3.length) return false;
    for (r3 = 0; r3 < n3.length; r3++) if (!rt.call(t2, n3[r3]) || !nt(e2[n3[r3]], t2[n3[r3]])) return false;
    return true;
  }
  function it(e2, t2) {
    if (e2 && e2.defaultProps) for (var n3 in t2 = l2({}, t2), e2 = e2.defaultProps) void 0 === t2[n3] && (t2[n3] = e2[n3]);
    return t2;
  }
  var at = { current: null }, ut = null, ot = null, ft = null;
  function ct() {
    ft = ot = ut = null;
  }
  function st(e2, t2) {
    var n3 = e2.type._context;
    he(at, n3._currentValue2), n3._currentValue2 = t2;
  }
  function dt(e2) {
    var t2 = at.current;
    me(at), (e2 = e2.type._context)._currentValue2 = t2;
  }
  function pt(e2, t2) {
    for (; null !== e2; ) {
      var n3 = e2.alternate;
      if (e2.childExpirationTime < t2) e2.childExpirationTime = t2, null !== n3 && n3.childExpirationTime < t2 && (n3.childExpirationTime = t2);
      else {
        if (!(null !== n3 && n3.childExpirationTime < t2)) break;
        n3.childExpirationTime = t2;
      }
      e2 = e2.return;
    }
  }
  function mt(e2, t2) {
    ut = e2, ft = ot = null, null !== (e2 = e2.dependencies) && null !== e2.firstContext && (e2.expirationTime >= t2 && (On = true), e2.firstContext = null);
  }
  function ht(e2, t2) {
    if (ft !== e2 && false !== t2 && 0 !== t2) if ("number" == typeof t2 && 1073741823 !== t2 || (ft = e2, t2 = 1073741823), t2 = { context: e2, observedBits: t2, next: null }, null === ot) {
      if (null === ut) throw Error(f2(308));
      ot = t2, ut.dependencies = { expirationTime: 0, firstContext: t2, responders: null };
    } else ot = ot.next = t2;
    return e2._currentValue2;
  }
  var gt = false;
  function bt(e2) {
    return { baseState: e2, firstUpdate: null, lastUpdate: null, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null };
  }
  function yt(e2) {
    return { baseState: e2.baseState, firstUpdate: e2.firstUpdate, lastUpdate: e2.lastUpdate, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null };
  }
  function vt(e2, t2) {
    return { expirationTime: e2, suspenseConfig: t2, tag: 0, payload: null, callback: null, next: null, nextEffect: null };
  }
  function Tt(e2, t2) {
    null === e2.lastUpdate ? e2.firstUpdate = e2.lastUpdate = t2 : (e2.lastUpdate.next = t2, e2.lastUpdate = t2);
  }
  function xt(e2, t2) {
    var n3 = e2.alternate;
    if (null === n3) {
      var r3 = e2.updateQueue, l3 = null;
      null === r3 && (r3 = e2.updateQueue = bt(e2.memoizedState));
    } else r3 = e2.updateQueue, l3 = n3.updateQueue, null === r3 ? null === l3 ? (r3 = e2.updateQueue = bt(e2.memoizedState), l3 = n3.updateQueue = bt(n3.memoizedState)) : r3 = e2.updateQueue = yt(l3) : null === l3 && (l3 = n3.updateQueue = yt(r3));
    null === l3 || r3 === l3 ? Tt(r3, t2) : null === r3.lastUpdate || null === l3.lastUpdate ? (Tt(r3, t2), Tt(l3, t2)) : (Tt(r3, t2), l3.lastUpdate = t2);
  }
  function Et(e2, t2) {
    var n3 = e2.updateQueue;
    null === (n3 = null === n3 ? e2.updateQueue = bt(e2.memoizedState) : kt(e2, n3)).lastCapturedUpdate ? n3.firstCapturedUpdate = n3.lastCapturedUpdate = t2 : (n3.lastCapturedUpdate.next = t2, n3.lastCapturedUpdate = t2);
  }
  function kt(e2, t2) {
    var n3 = e2.alternate;
    return null !== n3 && t2 === n3.updateQueue && (t2 = e2.updateQueue = yt(t2)), t2;
  }
  function St(e2, t2, n3, r3, i2, a3) {
    switch (n3.tag) {
      case 1:
        return "function" == typeof (e2 = n3.payload) ? e2.call(a3, r3, i2) : e2;
      case 3:
        e2.effectTag = -4097 & e2.effectTag | 64;
      case 0:
        if (null == (i2 = "function" == typeof (e2 = n3.payload) ? e2.call(a3, r3, i2) : e2)) break;
        return l2({}, r3, i2);
      case 2:
        gt = true;
    }
    return r3;
  }
  function Ct(e2, t2, n3, r3, l3) {
    gt = false;
    for (var i2 = (t2 = kt(e2, t2)).baseState, a3 = null, u2 = 0, o3 = t2.firstUpdate, f3 = i2; null !== o3; ) {
      var c3 = o3.expirationTime;
      c3 < l3 ? (null === a3 && (a3 = o3, i2 = f3), u2 < c3 && (u2 = c3)) : (El(c3, o3.suspenseConfig), f3 = St(e2, 0, o3, f3, n3, r3), null !== o3.callback && (e2.effectTag |= 32, o3.nextEffect = null, null === t2.lastEffect ? t2.firstEffect = t2.lastEffect = o3 : (t2.lastEffect.nextEffect = o3, t2.lastEffect = o3))), o3 = o3.next;
    }
    for (c3 = null, o3 = t2.firstCapturedUpdate; null !== o3; ) {
      var s3 = o3.expirationTime;
      s3 < l3 ? (null === c3 && (c3 = o3, null === a3 && (i2 = f3)), u2 < s3 && (u2 = s3)) : (f3 = St(e2, 0, o3, f3, n3, r3), null !== o3.callback && (e2.effectTag |= 32, o3.nextEffect = null, null === t2.lastCapturedEffect ? t2.firstCapturedEffect = t2.lastCapturedEffect = o3 : (t2.lastCapturedEffect.nextEffect = o3, t2.lastCapturedEffect = o3))), o3 = o3.next;
    }
    null === a3 && (t2.lastUpdate = null), null === c3 ? t2.lastCapturedUpdate = null : e2.effectTag |= 32, null === a3 && null === c3 && (i2 = f3), t2.baseState = i2, t2.firstUpdate = a3, t2.firstCapturedUpdate = c3, kl(u2), e2.expirationTime = u2, e2.memoizedState = f3;
  }
  function wt(e2, t2, n3) {
    null !== t2.firstCapturedUpdate && (null !== t2.lastUpdate && (t2.lastUpdate.next = t2.firstCapturedUpdate, t2.lastUpdate = t2.lastCapturedUpdate), t2.firstCapturedUpdate = t2.lastCapturedUpdate = null), zt(t2.firstEffect, n3), t2.firstEffect = t2.lastEffect = null, zt(t2.firstCapturedEffect, n3), t2.firstCapturedEffect = t2.lastCapturedEffect = null;
  }
  function zt(e2, t2) {
    for (; null !== e2; ) {
      var n3 = e2.callback;
      if (null !== n3) {
        e2.callback = null;
        var r3 = t2;
        if ("function" != typeof n3) throw Error(f2(191, n3));
        n3.call(r3);
      }
      e2 = e2.nextEffect;
    }
  }
  var Pt = c2.ReactCurrentBatchConfig, _t = new a2.Component().refs;
  function Nt(e2, t2, n3, r3) {
    n3 = null == (n3 = n3(r3, t2 = e2.memoizedState)) ? t2 : l2({}, t2, n3), e2.memoizedState = n3, null !== (r3 = e2.updateQueue) && 0 === e2.expirationTime && (r3.baseState = n3);
  }
  var Ut = { isMounted: function(e2) {
    return !!(e2 = e2._reactInternalFiber) && P(e2) === e2;
  }, enqueueSetState: function(e2, t2, n3) {
    e2 = e2._reactInternalFiber;
    var r3 = cl(), l3 = Pt.suspense;
    (l3 = vt(r3 = sl(r3, e2, l3), l3)).payload = t2, null != n3 && (l3.callback = n3), xt(e2, l3), dl(e2, r3);
  }, enqueueReplaceState: function(e2, t2, n3) {
    e2 = e2._reactInternalFiber;
    var r3 = cl(), l3 = Pt.suspense;
    (l3 = vt(r3 = sl(r3, e2, l3), l3)).tag = 1, l3.payload = t2, null != n3 && (l3.callback = n3), xt(e2, l3), dl(e2, r3);
  }, enqueueForceUpdate: function(e2, t2) {
    e2 = e2._reactInternalFiber;
    var n3 = cl(), r3 = Pt.suspense;
    (r3 = vt(n3 = sl(n3, e2, r3), r3)).tag = 2, null != t2 && (r3.callback = t2), xt(e2, r3), dl(e2, n3);
  } };
  function Rt(e2, t2, n3, r3, l3, i2, a3) {
    return "function" == typeof (e2 = e2.stateNode).shouldComponentUpdate ? e2.shouldComponentUpdate(r3, i2, a3) : !(t2.prototype && t2.prototype.isPureReactComponent && lt(n3, r3) && lt(l3, i2));
  }
  function It(e2, t2, n3) {
    var r3 = false, l3 = ge, i2 = t2.contextType;
    return "object" == typeof i2 && null !== i2 ? i2 = ht(i2) : (l3 = xe(t2) ? ve : be.current, i2 = (r3 = null != (r3 = t2.contextTypes)) ? Te(e2, l3) : ge), t2 = new t2(n3, i2), e2.memoizedState = null !== t2.state && void 0 !== t2.state ? t2.state : null, t2.updater = Ut, e2.stateNode = t2, t2._reactInternalFiber = e2, r3 && ((e2 = e2.stateNode).__reactInternalMemoizedUnmaskedChildContext = l3, e2.__reactInternalMemoizedMaskedChildContext = i2), t2;
  }
  function Mt(e2, t2, n3, r3) {
    e2 = t2.state, "function" == typeof t2.componentWillReceiveProps && t2.componentWillReceiveProps(n3, r3), "function" == typeof t2.UNSAFE_componentWillReceiveProps && t2.UNSAFE_componentWillReceiveProps(n3, r3), t2.state !== e2 && Ut.enqueueReplaceState(t2, t2.state, null);
  }
  function Ft(e2, t2, n3, r3) {
    var l3 = e2.stateNode;
    l3.props = n3, l3.state = e2.memoizedState, l3.refs = _t;
    var i2 = t2.contextType;
    "object" == typeof i2 && null !== i2 ? l3.context = ht(i2) : (i2 = xe(t2) ? ve : be.current, l3.context = Te(e2, i2)), null !== (i2 = e2.updateQueue) && (Ct(e2, i2, n3, l3, r3), l3.state = e2.memoizedState), "function" == typeof (i2 = t2.getDerivedStateFromProps) && (Nt(e2, t2, i2, n3), l3.state = e2.memoizedState), "function" == typeof t2.getDerivedStateFromProps || "function" == typeof l3.getSnapshotBeforeUpdate || "function" != typeof l3.UNSAFE_componentWillMount && "function" != typeof l3.componentWillMount || (t2 = l3.state, "function" == typeof l3.componentWillMount && l3.componentWillMount(), "function" == typeof l3.UNSAFE_componentWillMount && l3.UNSAFE_componentWillMount(), t2 !== l3.state && Ut.enqueueReplaceState(l3, l3.state, null), null !== (i2 = e2.updateQueue) && (Ct(e2, i2, n3, l3, r3), l3.state = e2.memoizedState)), "function" == typeof l3.componentDidMount && (e2.effectTag |= 4);
  }
  var Qt = Array.isArray;
  function Dt(e2, t2, n3) {
    if (null !== (e2 = n3.ref) && "function" != typeof e2 && "object" != typeof e2) {
      if (n3._owner) {
        if (n3 = n3._owner) {
          if (1 !== n3.tag) throw Error(f2(309));
          var r3 = n3.stateNode;
        }
        if (!r3) throw Error(f2(147, e2));
        var l3 = "" + e2;
        return null !== t2 && null !== t2.ref && "function" == typeof t2.ref && t2.ref._stringRef === l3 ? t2.ref : (t2 = function(e3) {
          var t3 = r3.refs;
          t3 === _t && (t3 = r3.refs = {}), null === e3 ? delete t3[l3] : t3[l3] = e3;
        }, t2._stringRef = l3, t2);
      }
      if ("string" != typeof e2) throw Error(f2(284));
      if (!n3._owner) throw Error(f2(290, e2));
    }
    return e2;
  }
  function Wt(e2, t2) {
    if ("textarea" !== e2.type) throw Error(f2(31, "[object Object]" === Object.prototype.toString.call(t2) ? "object with keys {" + Object.keys(t2).join(", ") + "}" : t2, ""));
  }
  function jt(e2) {
    function t2(t3, n4) {
      if (e2) {
        var r4 = t3.lastEffect;
        null !== r4 ? (r4.nextEffect = n4, t3.lastEffect = n4) : t3.firstEffect = t3.lastEffect = n4, n4.nextEffect = null, n4.effectTag = 8;
      }
    }
    function n3(n4, r4) {
      if (!e2) return null;
      for (; null !== r4; ) t2(n4, r4), r4 = r4.sibling;
      return null;
    }
    function r3(e3, t3) {
      for (e3 = /* @__PURE__ */ new Map(); null !== t3; ) null !== t3.key ? e3.set(t3.key, t3) : e3.set(t3.index, t3), t3 = t3.sibling;
      return e3;
    }
    function l3(e3, t3, n4) {
      return (e3 = Al(e3, t3)).index = 0, e3.sibling = null, e3;
    }
    function i2(t3, n4, r4) {
      return t3.index = r4, e2 ? null !== (r4 = t3.alternate) ? (r4 = r4.index) < n4 ? (t3.effectTag = 2, n4) : r4 : (t3.effectTag = 2, n4) : n4;
    }
    function a3(t3) {
      return e2 && null === t3.alternate && (t3.effectTag = 2), t3;
    }
    function u2(e3, t3, n4, r4) {
      return null === t3 || 6 !== t3.tag ? ((t3 = ql(n4, e3.mode, r4)).return = e3, t3) : ((t3 = l3(t3, n4)).return = e3, t3);
    }
    function o3(e3, t3, n4, r4) {
      return null !== t3 && t3.elementType === n4.type ? ((r4 = l3(t3, n4.props)).ref = Dt(e3, t3, n4), r4.return = e3, r4) : ((r4 = Ll(n4.type, n4.key, n4.props, null, e3.mode, r4)).ref = Dt(e3, t3, n4), r4.return = e3, r4);
    }
    function c3(e3, t3, n4, r4) {
      return null === t3 || 4 !== t3.tag || t3.stateNode.containerInfo !== n4.containerInfo || t3.stateNode.implementation !== n4.implementation ? ((t3 = Vl(n4, e3.mode, r4)).return = e3, t3) : ((t3 = l3(t3, n4.children || [])).return = e3, t3);
    }
    function s3(e3, t3, n4, r4, i3) {
      return null === t3 || 7 !== t3.tag ? ((t3 = $l(n4, e3.mode, r4, i3)).return = e3, t3) : ((t3 = l3(t3, n4)).return = e3, t3);
    }
    function h2(e3, t3, n4) {
      if ("string" == typeof t3 || "number" == typeof t3) return (t3 = ql("" + t3, e3.mode, n4)).return = e3, t3;
      if ("object" == typeof t3 && null !== t3) {
        switch (t3.$$typeof) {
          case d2:
            return (n4 = Ll(t3.type, t3.key, t3.props, null, e3.mode, n4)).ref = Dt(e3, null, t3), n4.return = e3, n4;
          case p2:
            return (t3 = Vl(t3, e3.mode, n4)).return = e3, t3;
        }
        if (Qt(t3) || w(t3)) return (t3 = $l(t3, e3.mode, n4, null)).return = e3, t3;
        Wt(e3, t3);
      }
      return null;
    }
    function g2(e3, t3, n4, r4) {
      var l4 = null !== t3 ? t3.key : null;
      if ("string" == typeof n4 || "number" == typeof n4) return null !== l4 ? null : u2(e3, t3, "" + n4, r4);
      if ("object" == typeof n4 && null !== n4) {
        switch (n4.$$typeof) {
          case d2:
            return n4.key === l4 ? n4.type === m2 ? s3(e3, t3, n4.props.children, r4, l4) : o3(e3, t3, n4, r4) : null;
          case p2:
            return n4.key === l4 ? c3(e3, t3, n4, r4) : null;
        }
        if (Qt(n4) || w(n4)) return null !== l4 ? null : s3(e3, t3, n4, r4, null);
        Wt(e3, n4);
      }
      return null;
    }
    function b3(e3, t3, n4, r4, l4) {
      if ("string" == typeof r4 || "number" == typeof r4) return u2(t3, e3 = e3.get(n4) || null, "" + r4, l4);
      if ("object" == typeof r4 && null !== r4) {
        switch (r4.$$typeof) {
          case d2:
            return e3 = e3.get(null === r4.key ? n4 : r4.key) || null, r4.type === m2 ? s3(t3, e3, r4.props.children, l4, r4.key) : o3(t3, e3, r4, l4);
          case p2:
            return c3(t3, e3 = e3.get(null === r4.key ? n4 : r4.key) || null, r4, l4);
        }
        if (Qt(r4) || w(r4)) return s3(t3, e3 = e3.get(n4) || null, r4, l4, null);
        Wt(t3, r4);
      }
      return null;
    }
    function y3(l4, a4, u3, o4) {
      for (var f3 = null, c4 = null, s4 = a4, d3 = a4 = 0, p3 = null; null !== s4 && d3 < u3.length; d3++) {
        s4.index > d3 ? (p3 = s4, s4 = null) : p3 = s4.sibling;
        var m3 = g2(l4, s4, u3[d3], o4);
        if (null === m3) {
          null === s4 && (s4 = p3);
          break;
        }
        e2 && s4 && null === m3.alternate && t2(l4, s4), a4 = i2(m3, a4, d3), null === c4 ? f3 = m3 : c4.sibling = m3, c4 = m3, s4 = p3;
      }
      if (d3 === u3.length) return n3(l4, s4), f3;
      if (null === s4) {
        for (; d3 < u3.length; d3++) null !== (s4 = h2(l4, u3[d3], o4)) && (a4 = i2(s4, a4, d3), null === c4 ? f3 = s4 : c4.sibling = s4, c4 = s4);
        return f3;
      }
      for (s4 = r3(l4, s4); d3 < u3.length; d3++) null !== (p3 = b3(s4, l4, d3, u3[d3], o4)) && (e2 && null !== p3.alternate && s4.delete(null === p3.key ? d3 : p3.key), a4 = i2(p3, a4, d3), null === c4 ? f3 = p3 : c4.sibling = p3, c4 = p3);
      return e2 && s4.forEach(function(e3) {
        return t2(l4, e3);
      }), f3;
    }
    function v3(l4, a4, u3, o4) {
      var c4 = w(u3);
      if ("function" != typeof c4) throw Error(f2(150));
      if (null == (u3 = c4.call(u3))) throw Error(f2(151));
      for (var s4 = c4 = null, d3 = a4, p3 = a4 = 0, m3 = null, y4 = u3.next(); null !== d3 && !y4.done; p3++, y4 = u3.next()) {
        d3.index > p3 ? (m3 = d3, d3 = null) : m3 = d3.sibling;
        var v4 = g2(l4, d3, y4.value, o4);
        if (null === v4) {
          null === d3 && (d3 = m3);
          break;
        }
        e2 && d3 && null === v4.alternate && t2(l4, d3), a4 = i2(v4, a4, p3), null === s4 ? c4 = v4 : s4.sibling = v4, s4 = v4, d3 = m3;
      }
      if (y4.done) return n3(l4, d3), c4;
      if (null === d3) {
        for (; !y4.done; p3++, y4 = u3.next()) null !== (y4 = h2(l4, y4.value, o4)) && (a4 = i2(y4, a4, p3), null === s4 ? c4 = y4 : s4.sibling = y4, s4 = y4);
        return c4;
      }
      for (d3 = r3(l4, d3); !y4.done; p3++, y4 = u3.next()) null !== (y4 = b3(d3, l4, p3, y4.value, o4)) && (e2 && null !== y4.alternate && d3.delete(null === y4.key ? p3 : y4.key), a4 = i2(y4, a4, p3), null === s4 ? c4 = y4 : s4.sibling = y4, s4 = y4);
      return e2 && d3.forEach(function(e3) {
        return t2(l4, e3);
      }), c4;
    }
    return function(e3, r4, i3, u3) {
      var o4 = "object" == typeof i3 && null !== i3 && i3.type === m2 && null === i3.key;
      o4 && (i3 = i3.props.children);
      var c4 = "object" == typeof i3 && null !== i3;
      if (c4) switch (i3.$$typeof) {
        case d2:
          e: {
            for (c4 = i3.key, o4 = r4; null !== o4; ) {
              if (o4.key === c4) {
                if (7 === o4.tag ? i3.type === m2 : o4.elementType === i3.type) {
                  n3(e3, o4.sibling), (r4 = l3(o4, i3.type === m2 ? i3.props.children : i3.props)).ref = Dt(e3, o4, i3), r4.return = e3, e3 = r4;
                  break e;
                }
                n3(e3, o4);
                break;
              }
              t2(e3, o4), o4 = o4.sibling;
            }
            i3.type === m2 ? ((r4 = $l(i3.props.children, e3.mode, u3, i3.key)).return = e3, e3 = r4) : ((u3 = Ll(i3.type, i3.key, i3.props, null, e3.mode, u3)).ref = Dt(e3, r4, i3), u3.return = e3, e3 = u3);
          }
          return a3(e3);
        case p2:
          e: {
            for (o4 = i3.key; null !== r4; ) {
              if (r4.key === o4) {
                if (4 === r4.tag && r4.stateNode.containerInfo === i3.containerInfo && r4.stateNode.implementation === i3.implementation) {
                  n3(e3, r4.sibling), (r4 = l3(r4, i3.children || [])).return = e3, e3 = r4;
                  break e;
                }
                n3(e3, r4);
                break;
              }
              t2(e3, r4), r4 = r4.sibling;
            }
            (r4 = Vl(i3, e3.mode, u3)).return = e3, e3 = r4;
          }
          return a3(e3);
      }
      if ("string" == typeof i3 || "number" == typeof i3) return i3 = "" + i3, null !== r4 && 6 === r4.tag ? (n3(e3, r4.sibling), (r4 = l3(r4, i3)).return = e3, e3 = r4) : (n3(e3, r4), (r4 = ql(i3, e3.mode, u3)).return = e3, e3 = r4), a3(e3);
      if (Qt(i3)) return y3(e3, r4, i3, u3);
      if (w(i3)) return v3(e3, r4, i3, u3);
      if (c4 && Wt(e3, i3), void 0 === i3 && !o4) switch (e3.tag) {
        case 1:
        case 0:
          throw e3 = e3.type, Error(f2(152, e3.displayName || e3.name || "Component"));
      }
      return n3(e3, r4);
    };
  }
  var Ot = jt(true), Bt = jt(false), Ht = {}, At = { current: Ht }, Lt = { current: Ht }, $t = { current: Ht };
  function qt(e2) {
    if (e2 === Ht) throw Error(f2(174));
    return e2;
  }
  function Vt(e2, t2) {
    he($t, t2), he(Lt, e2), he(At, Ht), t2 = I(t2), me(At), he(At, t2);
  }
  function Kt(e2) {
    me(At), me(Lt), me($t);
  }
  function Gt(e2) {
    var t2 = qt($t.current), n3 = qt(At.current);
    n3 !== (t2 = M(n3, e2.type, t2)) && (he(Lt, e2), he(At, t2));
  }
  function Yt(e2) {
    Lt.current === e2 && (me(At), me(Lt));
  }
  var Jt = { current: 0 };
  function Xt(e2) {
    for (var t2 = e2; null !== t2; ) {
      if (13 === t2.tag) {
        var n3 = t2.memoizedState;
        if (null !== n3 && (null === (n3 = n3.dehydrated) || oe(n3) || fe(n3))) return t2;
      } else if (19 === t2.tag && void 0 !== t2.memoizedProps.revealOrder) {
        if (0 != (64 & t2.effectTag)) return t2;
      } else if (null !== t2.child) {
        t2.child.return = t2, t2 = t2.child;
        continue;
      }
      if (t2 === e2) break;
      for (; null === t2.sibling; ) {
        if (null === t2.return || t2.return === e2) return null;
        t2 = t2.return;
      }
      t2.sibling.return = t2.return, t2 = t2.sibling;
    }
    return null;
  }
  function Zt(e2, t2) {
    return { responder: e2, props: t2 };
  }
  var en = c2.ReactCurrentDispatcher, tn = c2.ReactCurrentBatchConfig, nn = 0, rn = null, ln = null, an = null, un = null, on2 = null, fn = null, cn = 0, sn = null, dn = 0, pn = false, mn = null, hn = 0;
  function gn() {
    throw Error(f2(321));
  }
  function bn(e2, t2) {
    if (null === t2) return false;
    for (var n3 = 0; n3 < t2.length && n3 < e2.length; n3++) if (!nt(e2[n3], t2[n3])) return false;
    return true;
  }
  function yn(e2, t2, n3, r3, l3, i2) {
    if (nn = i2, rn = t2, an = null !== e2 ? e2.memoizedState : null, en.current = null === an ? Dn : Wn, t2 = n3(r3, l3), pn) {
      do {
        pn = false, hn += 1, an = null !== e2 ? e2.memoizedState : null, fn = un, sn = on2 = ln = null, en.current = Wn, t2 = n3(r3, l3);
      } while (pn);
      mn = null, hn = 0;
    }
    if (en.current = Qn, (e2 = rn).memoizedState = un, e2.expirationTime = cn, e2.updateQueue = sn, e2.effectTag |= dn, e2 = null !== ln && null !== ln.next, nn = 0, fn = on2 = un = an = ln = rn = null, cn = 0, sn = null, dn = 0, e2) throw Error(f2(300));
    return t2;
  }
  function vn() {
    en.current = Qn, nn = 0, fn = on2 = un = an = ln = rn = null, cn = 0, sn = null, dn = 0, pn = false, mn = null, hn = 0;
  }
  function Tn() {
    var e2 = { memoizedState: null, baseState: null, queue: null, baseUpdate: null, next: null };
    return null === on2 ? un = on2 = e2 : on2 = on2.next = e2, on2;
  }
  function xn() {
    if (null !== fn) fn = (on2 = fn).next, an = null !== (ln = an) ? ln.next : null;
    else {
      if (null === an) throw Error(f2(310));
      var e2 = { memoizedState: (ln = an).memoizedState, baseState: ln.baseState, queue: ln.queue, baseUpdate: ln.baseUpdate, next: null };
      on2 = null === on2 ? un = e2 : on2.next = e2, an = ln.next;
    }
    return on2;
  }
  function En(e2, t2) {
    return "function" == typeof t2 ? t2(e2) : t2;
  }
  function kn(e2) {
    var t2 = xn(), n3 = t2.queue;
    if (null === n3) throw Error(f2(311));
    if (n3.lastRenderedReducer = e2, 0 < hn) {
      var r3 = n3.dispatch;
      if (null !== mn) {
        var l3 = mn.get(n3);
        if (void 0 !== l3) {
          mn.delete(n3);
          var i2 = t2.memoizedState;
          do {
            i2 = e2(i2, l3.action), l3 = l3.next;
          } while (null !== l3);
          return nt(i2, t2.memoizedState) || (On = true), t2.memoizedState = i2, t2.baseUpdate === n3.last && (t2.baseState = i2), n3.lastRenderedState = i2, [i2, r3];
        }
      }
      return [t2.memoizedState, r3];
    }
    r3 = n3.last;
    var a3 = t2.baseUpdate;
    if (i2 = t2.baseState, null !== a3 ? (null !== r3 && (r3.next = null), r3 = a3.next) : r3 = null !== r3 ? r3.next : null, null !== r3) {
      var u2 = l3 = null, o3 = r3, c3 = false;
      do {
        var s3 = o3.expirationTime;
        s3 < nn ? (c3 || (c3 = true, u2 = a3, l3 = i2), s3 > cn && kl(cn = s3)) : (El(s3, o3.suspenseConfig), i2 = o3.eagerReducer === e2 ? o3.eagerState : e2(i2, o3.action)), a3 = o3, o3 = o3.next;
      } while (null !== o3 && o3 !== r3);
      c3 || (u2 = a3, l3 = i2), nt(i2, t2.memoizedState) || (On = true), t2.memoizedState = i2, t2.baseUpdate = u2, t2.baseState = l3, n3.lastRenderedState = i2;
    }
    return [t2.memoizedState, n3.dispatch];
  }
  function Sn(e2) {
    var t2 = Tn();
    return "function" == typeof e2 && (e2 = e2()), t2.memoizedState = t2.baseState = e2, e2 = (e2 = t2.queue = { last: null, dispatch: null, lastRenderedReducer: En, lastRenderedState: e2 }).dispatch = Fn.bind(null, rn, e2), [t2.memoizedState, e2];
  }
  function Cn(e2) {
    return kn(En);
  }
  function wn(e2, t2, n3, r3) {
    return e2 = { tag: e2, create: t2, destroy: n3, deps: r3, next: null }, null === sn ? (sn = { lastEffect: null }).lastEffect = e2.next = e2 : null === (t2 = sn.lastEffect) ? sn.lastEffect = e2.next = e2 : (n3 = t2.next, t2.next = e2, e2.next = n3, sn.lastEffect = e2), e2;
  }
  function zn(e2, t2, n3, r3) {
    var l3 = Tn();
    dn |= e2, l3.memoizedState = wn(t2, n3, void 0, void 0 === r3 ? null : r3);
  }
  function Pn(e2, t2, n3, r3) {
    var l3 = xn();
    r3 = void 0 === r3 ? null : r3;
    var i2 = void 0;
    if (null !== ln) {
      var a3 = ln.memoizedState;
      if (i2 = a3.destroy, null !== r3 && bn(r3, a3.deps)) return void wn(0, n3, i2, r3);
    }
    dn |= e2, l3.memoizedState = wn(t2, n3, i2, r3);
  }
  function _n(e2, t2) {
    return zn(516, 192, e2, t2);
  }
  function Nn(e2, t2) {
    return Pn(516, 192, e2, t2);
  }
  function Un(e2, t2) {
    return "function" == typeof t2 ? (e2 = e2(), t2(e2), function() {
      t2(null);
    }) : null != t2 ? (e2 = e2(), t2.current = e2, function() {
      t2.current = null;
    }) : void 0;
  }
  function Rn() {
  }
  function In(e2, t2) {
    return Tn().memoizedState = [e2, void 0 === t2 ? null : t2], e2;
  }
  function Mn(e2, t2) {
    var n3 = xn();
    t2 = void 0 === t2 ? null : t2;
    var r3 = n3.memoizedState;
    return null !== r3 && null !== t2 && bn(t2, r3[1]) ? r3[0] : (n3.memoizedState = [e2, t2], e2);
  }
  function Fn(e2, t2, n3) {
    if (!(25 > hn)) throw Error(f2(301));
    var r3 = e2.alternate;
    if (e2 === rn || null !== r3 && r3 === rn) if (pn = true, e2 = { expirationTime: nn, suspenseConfig: null, action: n3, eagerReducer: null, eagerState: null, next: null }, null === mn && (mn = /* @__PURE__ */ new Map()), void 0 === (n3 = mn.get(t2))) mn.set(t2, e2);
    else {
      for (t2 = n3; null !== t2.next; ) t2 = t2.next;
      t2.next = e2;
    }
    else {
      var l3 = cl(), i2 = Pt.suspense;
      i2 = { expirationTime: l3 = sl(l3, e2, i2), suspenseConfig: i2, action: n3, eagerReducer: null, eagerState: null, next: null };
      var a3 = t2.last;
      if (null === a3) i2.next = i2;
      else {
        var u2 = a3.next;
        null !== u2 && (i2.next = u2), a3.next = i2;
      }
      if (t2.last = i2, 0 === e2.expirationTime && (null === r3 || 0 === r3.expirationTime) && null !== (r3 = t2.lastRenderedReducer)) try {
        var o3 = t2.lastRenderedState, c3 = r3(o3, n3);
        if (i2.eagerReducer = r3, i2.eagerState = c3, nt(c3, o3)) return;
      } catch (e3) {
      }
      dl(e2, l3);
    }
  }
  var Qn = { readContext: ht, useCallback: gn, useContext: gn, useEffect: gn, useImperativeHandle: gn, useLayoutEffect: gn, useMemo: gn, useReducer: gn, useRef: gn, useState: gn, useDebugValue: gn, useResponder: gn, useDeferredValue: gn, useTransition: gn }, Dn = { readContext: ht, useCallback: In, useContext: ht, useEffect: _n, useImperativeHandle: function(e2, t2, n3) {
    return n3 = null != n3 ? n3.concat([e2]) : null, zn(4, 36, Un.bind(null, t2, e2), n3);
  }, useLayoutEffect: function(e2, t2) {
    return zn(4, 36, e2, t2);
  }, useMemo: function(e2, t2) {
    var n3 = Tn();
    return t2 = void 0 === t2 ? null : t2, e2 = e2(), n3.memoizedState = [e2, t2], e2;
  }, useReducer: function(e2, t2, n3) {
    var r3 = Tn();
    return t2 = void 0 !== n3 ? n3(t2) : t2, r3.memoizedState = r3.baseState = t2, e2 = (e2 = r3.queue = { last: null, dispatch: null, lastRenderedReducer: e2, lastRenderedState: t2 }).dispatch = Fn.bind(null, rn, e2), [r3.memoizedState, e2];
  }, useRef: function(e2) {
    return e2 = { current: e2 }, Tn().memoizedState = e2;
  }, useState: Sn, useDebugValue: Rn, useResponder: Zt, useDeferredValue: function(e2, t2) {
    var n3 = Sn(e2), r3 = n3[0], l3 = n3[1];
    return _n(function() {
      o2.unstable_next(function() {
        var n4 = tn.suspense;
        tn.suspense = void 0 === t2 ? null : t2;
        try {
          l3(e2);
        } finally {
          tn.suspense = n4;
        }
      });
    }, [e2, t2]), r3;
  }, useTransition: function(e2) {
    var t2 = Sn(false), n3 = t2[0], r3 = t2[1];
    return [In(function(t3) {
      r3(true), o2.unstable_next(function() {
        var n4 = tn.suspense;
        tn.suspense = void 0 === e2 ? null : e2;
        try {
          r3(false), t3();
        } finally {
          tn.suspense = n4;
        }
      });
    }, [e2, n3]), n3];
  } }, Wn = { readContext: ht, useCallback: Mn, useContext: ht, useEffect: Nn, useImperativeHandle: function(e2, t2, n3) {
    return n3 = null != n3 ? n3.concat([e2]) : null, Pn(4, 36, Un.bind(null, t2, e2), n3);
  }, useLayoutEffect: function(e2, t2) {
    return Pn(4, 36, e2, t2);
  }, useMemo: function(e2, t2) {
    var n3 = xn();
    t2 = void 0 === t2 ? null : t2;
    var r3 = n3.memoizedState;
    return null !== r3 && null !== t2 && bn(t2, r3[1]) ? r3[0] : (e2 = e2(), n3.memoizedState = [e2, t2], e2);
  }, useReducer: kn, useRef: function() {
    return xn().memoizedState;
  }, useState: Cn, useDebugValue: Rn, useResponder: Zt, useDeferredValue: function(e2, t2) {
    var n3 = Cn(), r3 = n3[0], l3 = n3[1];
    return Nn(function() {
      o2.unstable_next(function() {
        var n4 = tn.suspense;
        tn.suspense = void 0 === t2 ? null : t2;
        try {
          l3(e2);
        } finally {
          tn.suspense = n4;
        }
      });
    }, [e2, t2]), r3;
  }, useTransition: function(e2) {
    var t2 = Cn(), n3 = t2[0], r3 = t2[1];
    return [Mn(function(t3) {
      r3(true), o2.unstable_next(function() {
        var n4 = tn.suspense;
        tn.suspense = void 0 === e2 ? null : e2;
        try {
          r3(false), t3();
        } finally {
          tn.suspense = n4;
        }
      });
    }, [e2, n3]), n3];
  } }, jn = c2.ReactCurrentOwner, On = false;
  function Bn(e2, t2, n3, r3) {
    t2.child = null === e2 ? Bt(t2, null, n3, r3) : Ot(t2, e2.child, n3, r3);
  }
  function Hn(e2, t2, n3, r3, l3) {
    n3 = n3.render;
    var i2 = t2.ref;
    return mt(t2, l3), r3 = yn(e2, t2, n3, r3, i2, l3), null === e2 || On ? (t2.effectTag |= 1, Bn(e2, t2, r3, l3), t2.child) : (t2.updateQueue = e2.updateQueue, t2.effectTag &= -517, e2.expirationTime <= l3 && (e2.expirationTime = 0), ir(e2, t2, l3));
  }
  function An(e2, t2, n3, r3, l3, i2) {
    if (null === e2) {
      var a3 = n3.type;
      return "function" != typeof a3 || Hl(a3) || void 0 !== a3.defaultProps || null !== n3.compare || void 0 !== n3.defaultProps ? ((e2 = Ll(n3.type, null, r3, null, t2.mode, i2)).ref = t2.ref, e2.return = t2, t2.child = e2) : (t2.tag = 15, t2.type = a3, Ln(e2, t2, a3, r3, l3, i2));
    }
    return a3 = e2.child, l3 < i2 && (l3 = a3.memoizedProps, (n3 = null !== (n3 = n3.compare) ? n3 : lt)(l3, r3) && e2.ref === t2.ref) ? ir(e2, t2, i2) : (t2.effectTag |= 1, (e2 = Al(a3, r3)).ref = t2.ref, e2.return = t2, t2.child = e2);
  }
  function Ln(e2, t2, n3, r3, l3, i2) {
    return null !== e2 && lt(e2.memoizedProps, r3) && e2.ref === t2.ref && (On = false, l3 < i2) ? ir(e2, t2, i2) : qn(e2, t2, n3, r3, i2);
  }
  function $n(e2, t2) {
    var n3 = t2.ref;
    (null === e2 && null !== n3 || null !== e2 && e2.ref !== n3) && (t2.effectTag |= 128);
  }
  function qn(e2, t2, n3, r3, l3) {
    var i2 = xe(n3) ? ve : be.current;
    return i2 = Te(t2, i2), mt(t2, l3), n3 = yn(e2, t2, n3, r3, i2, l3), null === e2 || On ? (t2.effectTag |= 1, Bn(e2, t2, n3, l3), t2.child) : (t2.updateQueue = e2.updateQueue, t2.effectTag &= -517, e2.expirationTime <= l3 && (e2.expirationTime = 0), ir(e2, t2, l3));
  }
  function Vn(e2, t2, n3, r3, l3) {
    if (xe(n3)) {
      var i2 = true;
      we(t2);
    } else i2 = false;
    if (mt(t2, l3), null === t2.stateNode) null !== e2 && (e2.alternate = null, t2.alternate = null, t2.effectTag |= 2), It(t2, n3, r3), Ft(t2, n3, r3, l3), r3 = true;
    else if (null === e2) {
      var a3 = t2.stateNode, u2 = t2.memoizedProps;
      a3.props = u2;
      var o3 = a3.context, f3 = n3.contextType;
      f3 = "object" == typeof f3 && null !== f3 ? ht(f3) : Te(t2, f3 = xe(n3) ? ve : be.current);
      var c3 = n3.getDerivedStateFromProps, s3 = "function" == typeof c3 || "function" == typeof a3.getSnapshotBeforeUpdate;
      s3 || "function" != typeof a3.UNSAFE_componentWillReceiveProps && "function" != typeof a3.componentWillReceiveProps || (u2 !== r3 || o3 !== f3) && Mt(t2, a3, r3, f3), gt = false;
      var d3 = t2.memoizedState;
      o3 = a3.state = d3;
      var p3 = t2.updateQueue;
      null !== p3 && (Ct(t2, p3, r3, a3, l3), o3 = t2.memoizedState), u2 !== r3 || d3 !== o3 || ye.current || gt ? ("function" == typeof c3 && (Nt(t2, n3, c3, r3), o3 = t2.memoizedState), (u2 = gt || Rt(t2, n3, u2, r3, d3, o3, f3)) ? (s3 || "function" != typeof a3.UNSAFE_componentWillMount && "function" != typeof a3.componentWillMount || ("function" == typeof a3.componentWillMount && a3.componentWillMount(), "function" == typeof a3.UNSAFE_componentWillMount && a3.UNSAFE_componentWillMount()), "function" == typeof a3.componentDidMount && (t2.effectTag |= 4)) : ("function" == typeof a3.componentDidMount && (t2.effectTag |= 4), t2.memoizedProps = r3, t2.memoizedState = o3), a3.props = r3, a3.state = o3, a3.context = f3, r3 = u2) : ("function" == typeof a3.componentDidMount && (t2.effectTag |= 4), r3 = false);
    } else a3 = t2.stateNode, u2 = t2.memoizedProps, a3.props = t2.type === t2.elementType ? u2 : it(t2.type, u2), o3 = a3.context, f3 = "object" == typeof (f3 = n3.contextType) && null !== f3 ? ht(f3) : Te(t2, f3 = xe(n3) ? ve : be.current), (s3 = "function" == typeof (c3 = n3.getDerivedStateFromProps) || "function" == typeof a3.getSnapshotBeforeUpdate) || "function" != typeof a3.UNSAFE_componentWillReceiveProps && "function" != typeof a3.componentWillReceiveProps || (u2 !== r3 || o3 !== f3) && Mt(t2, a3, r3, f3), gt = false, o3 = t2.memoizedState, d3 = a3.state = o3, null !== (p3 = t2.updateQueue) && (Ct(t2, p3, r3, a3, l3), d3 = t2.memoizedState), u2 !== r3 || o3 !== d3 || ye.current || gt ? ("function" == typeof c3 && (Nt(t2, n3, c3, r3), d3 = t2.memoizedState), (c3 = gt || Rt(t2, n3, u2, r3, o3, d3, f3)) ? (s3 || "function" != typeof a3.UNSAFE_componentWillUpdate && "function" != typeof a3.componentWillUpdate || ("function" == typeof a3.componentWillUpdate && a3.componentWillUpdate(r3, d3, f3), "function" == typeof a3.UNSAFE_componentWillUpdate && a3.UNSAFE_componentWillUpdate(r3, d3, f3)), "function" == typeof a3.componentDidUpdate && (t2.effectTag |= 4), "function" == typeof a3.getSnapshotBeforeUpdate && (t2.effectTag |= 256)) : ("function" != typeof a3.componentDidUpdate || u2 === e2.memoizedProps && o3 === e2.memoizedState || (t2.effectTag |= 4), "function" != typeof a3.getSnapshotBeforeUpdate || u2 === e2.memoizedProps && o3 === e2.memoizedState || (t2.effectTag |= 256), t2.memoizedProps = r3, t2.memoizedState = d3), a3.props = r3, a3.state = d3, a3.context = f3, r3 = c3) : ("function" != typeof a3.componentDidUpdate || u2 === e2.memoizedProps && o3 === e2.memoizedState || (t2.effectTag |= 4), "function" != typeof a3.getSnapshotBeforeUpdate || u2 === e2.memoizedProps && o3 === e2.memoizedState || (t2.effectTag |= 256), r3 = false);
    return Kn(e2, t2, n3, r3, i2, l3);
  }
  function Kn(e2, t2, n3, r3, l3, i2) {
    $n(e2, t2);
    var a3 = 0 != (64 & t2.effectTag);
    if (!r3 && !a3) return l3 && ze(t2, n3, false), ir(e2, t2, i2);
    r3 = t2.stateNode, jn.current = t2;
    var u2 = a3 && "function" != typeof n3.getDerivedStateFromError ? null : r3.render();
    return t2.effectTag |= 1, null !== e2 && a3 ? (t2.child = Ot(t2, e2.child, null, i2), t2.child = Ot(t2, null, u2, i2)) : Bn(e2, t2, u2, i2), t2.memoizedState = r3.state, l3 && ze(t2, n3, true), t2.child;
  }
  function Gn(e2) {
    var t2 = e2.stateNode;
    t2.pendingContext ? Se(0, t2.pendingContext, t2.pendingContext !== t2.context) : t2.context && Se(0, t2.context, false), Vt(e2, t2.containerInfo);
  }
  var Yn, Jn, Xn, Zn, er = { dehydrated: null, retryTime: 0 };
  function tr(e2, t2, n3) {
    var r3, l3 = t2.mode, i2 = t2.pendingProps, a3 = Jt.current, u2 = false;
    if ((r3 = 0 != (64 & t2.effectTag)) || (r3 = 0 != (2 & a3) && (null === e2 || null !== e2.memoizedState)), r3 ? (u2 = true, t2.effectTag &= -65) : null !== e2 && null === e2.memoizedState || void 0 === i2.fallback || true === i2.unstable_avoidThisFallback || (a3 |= 1), he(Jt, 1 & a3), null === e2) {
      if (i2.fallback, u2) {
        if (u2 = i2.fallback, (i2 = $l(null, l3, 0, null)).return = t2, 0 == (2 & t2.mode)) for (e2 = null !== t2.memoizedState ? t2.child.child : t2.child, i2.child = e2; null !== e2; ) e2.return = i2, e2 = e2.sibling;
        return (n3 = $l(u2, l3, n3, null)).return = t2, i2.sibling = n3, t2.memoizedState = er, t2.child = i2, n3;
      }
      return l3 = i2.children, t2.memoizedState = null, t2.child = Bt(t2, null, l3, n3);
    }
    if (null !== e2.memoizedState) {
      if (l3 = (e2 = e2.child).sibling, u2) {
        if (i2 = i2.fallback, (n3 = Al(e2, e2.pendingProps)).return = t2, 0 == (2 & t2.mode) && (u2 = null !== t2.memoizedState ? t2.child.child : t2.child) !== e2.child) for (n3.child = u2; null !== u2; ) u2.return = n3, u2 = u2.sibling;
        return (l3 = Al(l3, i2, l3.expirationTime)).return = t2, n3.sibling = l3, n3.childExpirationTime = 0, t2.memoizedState = er, t2.child = n3, l3;
      }
      return n3 = Ot(t2, e2.child, i2.children, n3), t2.memoizedState = null, t2.child = n3;
    }
    if (e2 = e2.child, u2) {
      if (u2 = i2.fallback, (i2 = $l(null, l3, 0, null)).return = t2, i2.child = e2, null !== e2 && (e2.return = i2), 0 == (2 & t2.mode)) for (e2 = null !== t2.memoizedState ? t2.child.child : t2.child, i2.child = e2; null !== e2; ) e2.return = i2, e2 = e2.sibling;
      return (n3 = $l(u2, l3, n3, null)).return = t2, i2.sibling = n3, n3.effectTag |= 2, i2.childExpirationTime = 0, t2.memoizedState = er, t2.child = i2, n3;
    }
    return t2.memoizedState = null, t2.child = Ot(t2, e2, i2.children, n3);
  }
  function nr(e2, t2) {
    e2.expirationTime < t2 && (e2.expirationTime = t2);
    var n3 = e2.alternate;
    null !== n3 && n3.expirationTime < t2 && (n3.expirationTime = t2), pt(e2.return, t2);
  }
  function rr(e2, t2, n3, r3, l3, i2) {
    var a3 = e2.memoizedState;
    null === a3 ? e2.memoizedState = { isBackwards: t2, rendering: null, last: r3, tail: n3, tailExpiration: 0, tailMode: l3, lastEffect: i2 } : (a3.isBackwards = t2, a3.rendering = null, a3.last = r3, a3.tail = n3, a3.tailExpiration = 0, a3.tailMode = l3, a3.lastEffect = i2);
  }
  function lr(e2, t2, n3) {
    var r3 = t2.pendingProps, l3 = r3.revealOrder, i2 = r3.tail;
    if (Bn(e2, t2, r3.children, n3), 0 != (2 & (r3 = Jt.current))) r3 = 1 & r3 | 2, t2.effectTag |= 64;
    else {
      if (null !== e2 && 0 != (64 & e2.effectTag)) e: for (e2 = t2.child; null !== e2; ) {
        if (13 === e2.tag) null !== e2.memoizedState && nr(e2, n3);
        else if (19 === e2.tag) nr(e2, n3);
        else if (null !== e2.child) {
          e2.child.return = e2, e2 = e2.child;
          continue;
        }
        if (e2 === t2) break e;
        for (; null === e2.sibling; ) {
          if (null === e2.return || e2.return === t2) break e;
          e2 = e2.return;
        }
        e2.sibling.return = e2.return, e2 = e2.sibling;
      }
      r3 &= 1;
    }
    if (he(Jt, r3), 0 == (2 & t2.mode)) t2.memoizedState = null;
    else switch (l3) {
      case "forwards":
        for (n3 = t2.child, l3 = null; null !== n3; ) null !== (e2 = n3.alternate) && null === Xt(e2) && (l3 = n3), n3 = n3.sibling;
        null === (n3 = l3) ? (l3 = t2.child, t2.child = null) : (l3 = n3.sibling, n3.sibling = null), rr(t2, false, l3, n3, i2, t2.lastEffect);
        break;
      case "backwards":
        for (n3 = null, l3 = t2.child, t2.child = null; null !== l3; ) {
          if (null !== (e2 = l3.alternate) && null === Xt(e2)) {
            t2.child = l3;
            break;
          }
          e2 = l3.sibling, l3.sibling = n3, n3 = l3, l3 = e2;
        }
        rr(t2, true, n3, null, i2, t2.lastEffect);
        break;
      case "together":
        rr(t2, false, null, null, void 0, t2.lastEffect);
        break;
      default:
        t2.memoizedState = null;
    }
    return t2.child;
  }
  function ir(e2, t2, n3) {
    null !== e2 && (t2.dependencies = e2.dependencies);
    var r3 = t2.expirationTime;
    if (0 !== r3 && kl(r3), t2.childExpirationTime < n3) return null;
    if (null !== e2 && t2.child !== e2.child) throw Error(f2(153));
    if (null !== t2.child) {
      for (n3 = Al(e2 = t2.child, e2.pendingProps, e2.expirationTime), t2.child = n3, n3.return = t2; null !== e2.sibling; ) e2 = e2.sibling, (n3 = n3.sibling = Al(e2, e2.pendingProps, e2.expirationTime)).return = t2;
      n3.sibling = null;
    }
    return t2.child;
  }
  function ar(e2) {
    e2.effectTag |= 4;
  }
  function ur(e2, t2) {
    switch (e2.tailMode) {
      case "hidden":
        t2 = e2.tail;
        for (var n3 = null; null !== t2; ) null !== t2.alternate && (n3 = t2), t2 = t2.sibling;
        null === n3 ? e2.tail = null : n3.sibling = null;
        break;
      case "collapsed":
        n3 = e2.tail;
        for (var r3 = null; null !== n3; ) null !== n3.alternate && (r3 = n3), n3 = n3.sibling;
        null === r3 ? t2 || null === e2.tail ? e2.tail = null : e2.tail.sibling = null : r3.sibling = null;
    }
  }
  function or(e2) {
    switch (e2.tag) {
      case 1:
        xe(e2.type) && Ee();
        var t2 = e2.effectTag;
        return 4096 & t2 ? (e2.effectTag = -4097 & t2 | 64, e2) : null;
      case 3:
        if (Kt(), ke(), 0 != (64 & (t2 = e2.effectTag))) throw Error(f2(285));
        return e2.effectTag = -4097 & t2 | 64, e2;
      case 5:
        return Yt(e2), null;
      case 13:
        return me(Jt), 4096 & (t2 = e2.effectTag) ? (e2.effectTag = -4097 & t2 | 64, e2) : null;
      case 19:
        return me(Jt), null;
      case 4:
        return Kt(), null;
      case 10:
        return dt(e2), null;
      default:
        return null;
    }
  }
  function fr(e2, t2) {
    return { value: e2, source: t2, stack: se(t2) };
  }
  Yn = function(e2, t2) {
    for (var n3 = t2.child; null !== n3; ) {
      if (5 === n3.tag || 6 === n3.tag) W(e2, n3.stateNode);
      else if (4 !== n3.tag && null !== n3.child) {
        n3.child.return = n3, n3 = n3.child;
        continue;
      }
      if (n3 === t2) break;
      for (; null === n3.sibling; ) {
        if (null === n3.return || n3.return === t2) return;
        n3 = n3.return;
      }
      n3.sibling.return = n3.return, n3 = n3.sibling;
    }
  }, Jn = function() {
  }, Xn = function(e2, t2, n3, r3, l3) {
    if ((e2 = e2.memoizedProps) !== r3) {
      var i2 = t2.stateNode, a3 = qt(At.current);
      n3 = O(i2, n3, e2, r3, l3, a3), (t2.updateQueue = n3) && ar(t2);
    }
  }, Zn = function(e2, t2, n3, r3) {
    n3 !== r3 && ar(t2);
  };
  var cr = "function" == typeof WeakSet ? WeakSet : Set;
  function sr(e2, t2) {
    var n3 = t2.source, r3 = t2.stack;
    null === r3 && null !== n3 && (r3 = se(n3)), null !== n3 && z(n3.type), t2 = t2.value, null !== e2 && 1 === e2.tag && z(e2.type);
    try {
      console.error(t2);
    } catch (e3) {
      setTimeout(function() {
        throw e3;
      });
    }
  }
  function dr(e2) {
    var t2 = e2.ref;
    if (null !== t2) if ("function" == typeof t2) try {
      t2(null);
    } catch (t3) {
      Fl(e2, t3);
    }
    else t2.current = null;
  }
  function pr(e2, t2) {
    switch (t2.tag) {
      case 0:
      case 11:
      case 15:
        mr(2, 0, t2);
        break;
      case 1:
        if (256 & t2.effectTag && null !== e2) {
          var n3 = e2.memoizedProps, r3 = e2.memoizedState;
          t2 = (e2 = t2.stateNode).getSnapshotBeforeUpdate(t2.elementType === t2.type ? n3 : it(t2.type, n3), r3), e2.__reactInternalSnapshotBeforeUpdate = t2;
        }
        break;
      case 3:
      case 5:
      case 6:
      case 4:
      case 17:
        break;
      default:
        throw Error(f2(163));
    }
  }
  function mr(e2, t2, n3) {
    if (null !== (n3 = null !== (n3 = n3.updateQueue) ? n3.lastEffect : null)) {
      var r3 = n3 = n3.next;
      do {
        if (0 != (r3.tag & e2)) {
          var l3 = r3.destroy;
          r3.destroy = void 0, void 0 !== l3 && l3();
        }
        0 != (r3.tag & t2) && (l3 = r3.create, r3.destroy = l3()), r3 = r3.next;
      } while (r3 !== n3);
    }
  }
  function hr(e2, t2, n3) {
    switch ("function" == typeof jl && jl(t2), t2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (null !== (e2 = t2.updateQueue) && null !== (e2 = e2.lastEffect)) {
          var r3 = e2.next;
          Ge(97 < n3 ? 97 : n3, function() {
            var e3 = r3;
            do {
              var n4 = e3.destroy;
              if (void 0 !== n4) {
                var l3 = t2;
                try {
                  n4();
                } catch (e4) {
                  Fl(l3, e4);
                }
              }
              e3 = e3.next;
            } while (e3 !== r3);
          });
        }
        break;
      case 1:
        dr(t2), "function" == typeof (n3 = t2.stateNode).componentWillUnmount && function(e3, t3) {
          try {
            t3.props = e3.memoizedProps, t3.state = e3.memoizedState, t3.componentWillUnmount();
          } catch (t4) {
            Fl(e3, t4);
          }
        }(t2, n3);
        break;
      case 5:
        dr(t2);
        break;
      case 4:
        Tr(e2, t2, n3);
    }
  }
  function gr(e2, t2, n3) {
    for (var r3 = t2; ; ) if (hr(e2, r3, n3), null === r3.child || 4 === r3.tag) {
      if (r3 === t2) break;
      for (; null === r3.sibling; ) {
        if (null === r3.return || r3.return === t2) return;
        r3 = r3.return;
      }
      r3.sibling.return = r3.return, r3 = r3.sibling;
    } else r3.child.return = r3, r3 = r3.child;
  }
  function br(e2) {
    var t2 = e2.alternate;
    e2.return = null, e2.child = null, e2.memoizedState = null, e2.updateQueue = null, e2.dependencies = null, e2.alternate = null, e2.firstEffect = null, e2.lastEffect = null, e2.pendingProps = null, e2.memoizedProps = null, null !== t2 && br(t2);
  }
  function yr(e2) {
    return 5 === e2.tag || 3 === e2.tag || 4 === e2.tag;
  }
  function vr(e2) {
    e: {
      for (var t2 = e2.return; null !== t2; ) {
        if (yr(t2)) {
          var n3 = t2;
          break e;
        }
        t2 = t2.return;
      }
      throw Error(f2(160));
    }
    switch (t2 = n3.stateNode, n3.tag) {
      case 5:
        var r3 = false;
        break;
      case 3:
      case 4:
        t2 = t2.containerInfo, r3 = true;
        break;
      default:
        throw Error(f2(161));
    }
    16 & n3.effectTag && (re(t2), n3.effectTag &= -17);
    e: t: for (n3 = e2; ; ) {
      for (; null === n3.sibling; ) {
        if (null === n3.return || yr(n3.return)) {
          n3 = null;
          break e;
        }
        n3 = n3.return;
      }
      for (n3.sibling.return = n3.return, n3 = n3.sibling; 5 !== n3.tag && 6 !== n3.tag && 18 !== n3.tag; ) {
        if (2 & n3.effectTag) continue t;
        if (null === n3.child || 4 === n3.tag) continue t;
        n3.child.return = n3, n3 = n3.child;
      }
      if (!(2 & n3.effectTag)) {
        n3 = n3.stateNode;
        break e;
      }
    }
    for (var l3 = e2; ; ) {
      var i2 = 5 === l3.tag || 6 === l3.tag;
      if (i2) i2 = i2 ? l3.stateNode : l3.stateNode.instance, n3 ? r3 ? ee(t2, i2, n3) : Z(t2, i2, n3) : r3 ? G2(t2, i2) : K(t2, i2);
      else if (4 !== l3.tag && null !== l3.child) {
        l3.child.return = l3, l3 = l3.child;
        continue;
      }
      if (l3 === e2) break;
      for (; null === l3.sibling; ) {
        if (null === l3.return || l3.return === e2) return;
        l3 = l3.return;
      }
      l3.sibling.return = l3.return, l3 = l3.sibling;
    }
  }
  function Tr(e2, t2, n3) {
    for (var r3, l3, i2 = t2, a3 = false; ; ) {
      if (!a3) {
        a3 = i2.return;
        e: for (; ; ) {
          if (null === a3) throw Error(f2(160));
          switch (r3 = a3.stateNode, a3.tag) {
            case 5:
              l3 = false;
              break e;
            case 3:
            case 4:
              r3 = r3.containerInfo, l3 = true;
              break e;
          }
          a3 = a3.return;
        }
        a3 = true;
      }
      if (5 === i2.tag || 6 === i2.tag) gr(e2, i2, n3), l3 ? ne(r3, i2.stateNode) : te(r3, i2.stateNode);
      else if (4 === i2.tag) {
        if (null !== i2.child) {
          r3 = i2.stateNode.containerInfo, l3 = true, i2.child.return = i2, i2 = i2.child;
          continue;
        }
      } else if (hr(e2, i2, n3), null !== i2.child) {
        i2.child.return = i2, i2 = i2.child;
        continue;
      }
      if (i2 === t2) break;
      for (; null === i2.sibling; ) {
        if (null === i2.return || i2.return === t2) return;
        4 === (i2 = i2.return).tag && (a3 = false);
      }
      i2.sibling.return = i2.return, i2 = i2.sibling;
    }
  }
  function xr(e2, t2) {
    switch (t2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        mr(4, 8, t2);
        break;
      case 1:
      case 3:
      case 12:
      case 17:
      case 20:
      case 21:
        break;
      case 5:
        var n3 = t2.stateNode;
        if (null != n3) {
          var r3 = t2.memoizedProps;
          e2 = null !== e2 ? e2.memoizedProps : r3;
          var l3 = t2.type, i2 = t2.updateQueue;
          t2.updateQueue = null, null !== i2 && X(n3, i2, l3, e2, r3, t2);
        }
        break;
      case 6:
        if (null === t2.stateNode) throw Error(f2(162));
        n3 = t2.memoizedProps, Y(t2.stateNode, null !== e2 ? e2.memoizedProps : n3, n3);
        break;
      case 13:
        !function(e3) {
          var t3 = e3;
          if (null === e3.memoizedState) var n4 = false;
          else n4 = true, t3 = e3.child, Jr = qe();
          if (null !== t3) {
            e: if (e3 = t3, q) for (t3 = e3; ; ) {
              if (5 === t3.tag) {
                var r4 = t3.stateNode;
                n4 ? le(r4) : ae(t3.stateNode, t3.memoizedProps);
              } else if (6 === t3.tag) r4 = t3.stateNode, n4 ? ie(r4) : ue(r4, t3.memoizedProps);
              else {
                if (13 === t3.tag && null !== t3.memoizedState && null === t3.memoizedState.dehydrated) {
                  (r4 = t3.child.sibling).return = t3, t3 = r4;
                  continue;
                }
                if (null !== t3.child) {
                  t3.child.return = t3, t3 = t3.child;
                  continue;
                }
              }
              if (t3 === e3) break e;
              for (; null === t3.sibling; ) {
                if (null === t3.return || t3.return === e3) break e;
                t3 = t3.return;
              }
              t3.sibling.return = t3.return, t3 = t3.sibling;
            }
          }
        }(t2), Er(t2);
        break;
      case 19:
        Er(t2);
        break;
      default:
        throw Error(f2(163));
    }
  }
  function Er(e2) {
    var t2 = e2.updateQueue;
    if (null !== t2) {
      e2.updateQueue = null;
      var n3 = e2.stateNode;
      null === n3 && (n3 = e2.stateNode = new cr()), t2.forEach(function(t3) {
        var r3 = Dl.bind(null, e2, t3);
        n3.has(t3) || (n3.add(t3), t3.then(r3, r3));
      });
    }
  }
  var kr = "function" == typeof WeakMap ? WeakMap : Map;
  function Sr(e2, t2, n3) {
    (n3 = vt(n3, null)).tag = 3, n3.payload = { element: null };
    var r3 = t2.value;
    return n3.callback = function() {
      el || (el = true, tl = r3), sr(e2, t2);
    }, n3;
  }
  function Cr(e2, t2, n3) {
    (n3 = vt(n3, null)).tag = 3;
    var r3 = e2.type.getDerivedStateFromError;
    if ("function" == typeof r3) {
      var l3 = t2.value;
      n3.payload = function() {
        return sr(e2, t2), r3(l3);
      };
    }
    var i2 = e2.stateNode;
    return null !== i2 && "function" == typeof i2.componentDidCatch && (n3.callback = function() {
      "function" != typeof r3 && (null === nl ? nl = /* @__PURE__ */ new Set([this]) : nl.add(this), sr(e2, t2));
      var n4 = t2.stack;
      this.componentDidCatch(t2.value, { componentStack: null !== n4 ? n4 : "" });
    }), n3;
  }
  var wr, zr = Math.ceil, Pr = c2.ReactCurrentDispatcher, _r = c2.ReactCurrentOwner, Nr = 0, Ur = 8, Rr = 16, Ir = 32, Mr = 0, Fr = 1, Qr = 2, Dr = 3, Wr = 4, jr = 5, Or = Nr, Br = null, Hr = null, Ar = 0, Lr = Mr, $r = null, qr = 1073741823, Vr = 1073741823, Kr = null, Gr = 0, Yr = false, Jr = 0, Xr = 500, Zr = null, el = false, tl = null, nl = null, rl = false, ll = null, il = 90, al = null, ul = 0, ol = null, fl = 0;
  function cl() {
    return (Or & (Rr | Ir)) !== Nr ? 1073741821 - (qe() / 10 | 0) : 0 !== fl ? fl : fl = 1073741821 - (qe() / 10 | 0);
  }
  function sl(e2, t2, n3) {
    if (0 == (2 & (t2 = t2.mode))) return 1073741823;
    var r3 = Ve();
    if (0 == (4 & t2)) return 99 === r3 ? 1073741823 : 1073741822;
    if ((Or & Rr) !== Nr) return Ar;
    if (null !== n3) e2 = tt(e2, 0 | n3.timeoutMs || 5e3, 250);
    else switch (r3) {
      case 99:
        e2 = 1073741823;
        break;
      case 98:
        e2 = tt(e2, 150, 100);
        break;
      case 97:
      case 96:
        e2 = tt(e2, 5e3, 250);
        break;
      case 95:
        e2 = 2;
        break;
      default:
        throw Error(f2(326));
    }
    return null !== Br && e2 === Ar && --e2, e2;
  }
  function dl(e2, t2) {
    if (50 < ul) throw ul = 0, ol = null, Error(f2(185));
    if (null !== (e2 = pl(e2, t2))) {
      var n3 = Ve();
      1073741823 === t2 ? (Or & Ur) !== Nr && (Or & (Rr | Ir)) === Nr ? bl(e2) : (hl(e2), Or === Nr && Xe()) : hl(e2), (4 & Or) === Nr || 98 !== n3 && 99 !== n3 || (null === al ? al = /* @__PURE__ */ new Map([[e2, t2]]) : (void 0 === (n3 = al.get(e2)) || n3 > t2) && al.set(e2, t2));
    }
  }
  function pl(e2, t2) {
    e2.expirationTime < t2 && (e2.expirationTime = t2);
    var n3 = e2.alternate;
    null !== n3 && n3.expirationTime < t2 && (n3.expirationTime = t2);
    var r3 = e2.return, l3 = null;
    if (null === r3 && 3 === e2.tag) l3 = e2.stateNode;
    else for (; null !== r3; ) {
      if (n3 = r3.alternate, r3.childExpirationTime < t2 && (r3.childExpirationTime = t2), null !== n3 && n3.childExpirationTime < t2 && (n3.childExpirationTime = t2), null === r3.return && 3 === r3.tag) {
        l3 = r3.stateNode;
        break;
      }
      r3 = r3.return;
    }
    return null !== l3 && (Br === l3 && (kl(t2), Lr === Wr && Yl(l3, Ar)), Jl(l3, t2)), l3;
  }
  function ml(e2) {
    var t2 = e2.lastExpiredTime;
    return 0 !== t2 ? t2 : Gl(e2, t2 = e2.firstPendingTime) ? (t2 = e2.lastPingedTime) > (e2 = e2.nextKnownPendingLevel) ? t2 : e2 : t2;
  }
  function hl(e2) {
    if (0 !== e2.lastExpiredTime) e2.callbackExpirationTime = 1073741823, e2.callbackPriority = 99, e2.callbackNode = Je(bl.bind(null, e2));
    else {
      var t2 = ml(e2), n3 = e2.callbackNode;
      if (0 === t2) null !== n3 && (e2.callbackNode = null, e2.callbackExpirationTime = 0, e2.callbackPriority = 90);
      else {
        var r3 = cl();
        if (r3 = 1073741823 === t2 ? 99 : 1 === t2 || 2 === t2 ? 95 : 0 >= (r3 = 10 * (1073741821 - t2) - 10 * (1073741821 - r3)) ? 99 : 250 >= r3 ? 98 : 5250 >= r3 ? 97 : 95, null !== n3) {
          var l3 = e2.callbackPriority;
          if (e2.callbackExpirationTime === t2 && l3 >= r3) return;
          n3 !== Oe && Ne(n3);
        }
        e2.callbackExpirationTime = t2, e2.callbackPriority = r3, t2 = 1073741823 === t2 ? Je(bl.bind(null, e2)) : Ye(r3, gl.bind(null, e2), { timeout: 10 * (1073741821 - t2) - qe() }), e2.callbackNode = t2;
      }
    }
  }
  function gl(e2, t2) {
    if (fl = 0, t2) return Xl(e2, t2 = cl()), hl(e2), null;
    var n3 = ml(e2);
    if (0 !== n3) {
      if (t2 = e2.callbackNode, (Or & (Rr | Ir)) !== Nr) throw Error(f2(327));
      if (Rl(), e2 === Br && n3 === Ar || vl(e2, n3), null !== Hr) {
        var r3 = Or;
        Or |= Rr;
        for (var l3 = xl(); ; ) try {
          Cl();
          break;
        } catch (t3) {
          Tl(e2, t3);
        }
        if (ct(), Or = r3, Pr.current = l3, Lr === Fr) throw t2 = $r, vl(e2, n3), Yl(e2, n3), hl(e2), t2;
        if (null === Hr) switch (l3 = e2.finishedWork = e2.current.alternate, e2.finishedExpirationTime = n3, r3 = Lr, Br = null, r3) {
          case Mr:
          case Fr:
            throw Error(f2(345));
          case Qr:
            Xl(e2, 2 < n3 ? 2 : n3);
            break;
          case Dr:
            if (Yl(e2, n3), n3 === (r3 = e2.lastSuspendedTime) && (e2.nextKnownPendingLevel = Pl(l3)), 1073741823 === qr && 10 < (l3 = Jr + Xr - qe())) {
              if (Yr) {
                var i2 = e2.lastPingedTime;
                if (0 === i2 || i2 >= n3) {
                  e2.lastPingedTime = n3, vl(e2, n3);
                  break;
                }
              }
              if (0 !== (i2 = ml(e2)) && i2 !== n3) break;
              if (0 !== r3 && r3 !== n3) {
                e2.lastPingedTime = r3;
                break;
              }
              e2.timeoutHandle = A(_l.bind(null, e2), l3);
              break;
            }
            _l(e2);
            break;
          case Wr:
            if (Yl(e2, n3), n3 === (r3 = e2.lastSuspendedTime) && (e2.nextKnownPendingLevel = Pl(l3)), Yr && (0 === (l3 = e2.lastPingedTime) || l3 >= n3)) {
              e2.lastPingedTime = n3, vl(e2, n3);
              break;
            }
            if (0 !== (l3 = ml(e2)) && l3 !== n3) break;
            if (0 !== r3 && r3 !== n3) {
              e2.lastPingedTime = r3;
              break;
            }
            if (1073741823 !== Vr ? r3 = 10 * (1073741821 - Vr) - qe() : 1073741823 === qr ? r3 = 0 : (r3 = 10 * (1073741821 - qr) - 5e3, 0 > (r3 = (l3 = qe()) - r3) && (r3 = 0), (n3 = 10 * (1073741821 - n3) - l3) < (r3 = (120 > r3 ? 120 : 480 > r3 ? 480 : 1080 > r3 ? 1080 : 1920 > r3 ? 1920 : 3e3 > r3 ? 3e3 : 4320 > r3 ? 4320 : 1960 * zr(r3 / 1960)) - r3) && (r3 = n3)), 10 < r3) {
              e2.timeoutHandle = A(_l.bind(null, e2), r3);
              break;
            }
            _l(e2);
            break;
          case jr:
            if (1073741823 !== qr && null !== Kr) {
              i2 = qr;
              var a3 = Kr;
              if (0 >= (r3 = 0 | a3.busyMinDurationMs) ? r3 = 0 : (l3 = 0 | a3.busyDelayMs, r3 = (i2 = qe() - (10 * (1073741821 - i2) - (0 | a3.timeoutMs || 5e3))) <= l3 ? 0 : l3 + r3 - i2), 10 < r3) {
                Yl(e2, n3), e2.timeoutHandle = A(_l.bind(null, e2), r3);
                break;
              }
            }
            _l(e2);
            break;
          default:
            throw Error(f2(329));
        }
        if (hl(e2), e2.callbackNode === t2) return gl.bind(null, e2);
      }
    }
    return null;
  }
  function bl(e2) {
    var t2 = e2.lastExpiredTime;
    if (t2 = 0 !== t2 ? t2 : 1073741823, e2.finishedExpirationTime === t2) _l(e2);
    else {
      if ((Or & (Rr | Ir)) !== Nr) throw Error(f2(327));
      if (Rl(), e2 === Br && t2 === Ar || vl(e2, t2), null !== Hr) {
        var n3 = Or;
        Or |= Rr;
        for (var r3 = xl(); ; ) try {
          Sl();
          break;
        } catch (t3) {
          Tl(e2, t3);
        }
        if (ct(), Or = n3, Pr.current = r3, Lr === Fr) throw n3 = $r, vl(e2, t2), Yl(e2, t2), hl(e2), n3;
        if (null !== Hr) throw Error(f2(261));
        e2.finishedWork = e2.current.alternate, e2.finishedExpirationTime = t2, Br = null, _l(e2), hl(e2);
      }
    }
    return null;
  }
  function yl(e2, t2) {
    if ((Or & (Rr | Ir)) !== Nr) throw Error(f2(187));
    var n3 = Or;
    Or |= 1;
    try {
      return Ge(99, e2.bind(null, t2));
    } finally {
      Or = n3, Xe();
    }
  }
  function vl(e2, t2) {
    e2.finishedWork = null, e2.finishedExpirationTime = 0;
    var n3 = e2.timeoutHandle;
    if (n3 !== $ && (e2.timeoutHandle = $, L(n3)), null !== Hr) for (n3 = Hr.return; null !== n3; ) {
      var r3 = n3;
      switch (r3.tag) {
        case 1:
          var l3 = r3.type.childContextTypes;
          null != l3 && Ee();
          break;
        case 3:
          Kt(), ke();
          break;
        case 5:
          Yt(r3);
          break;
        case 4:
          Kt();
          break;
        case 13:
        case 19:
          me(Jt);
          break;
        case 10:
          dt(r3);
      }
      n3 = n3.return;
    }
    Br = e2, Hr = Al(e2.current, null), Ar = t2, Lr = Mr, $r = null, Vr = qr = 1073741823, Kr = null, Gr = 0, Yr = false;
  }
  function Tl(e2, t2) {
    for (; ; ) {
      try {
        if (ct(), vn(), null === Hr || null === Hr.return) return Lr = Fr, $r = t2, null;
        e: {
          var n3 = e2, r3 = Hr.return, l3 = Hr, i2 = t2;
          if (t2 = Ar, l3.effectTag |= 2048, l3.firstEffect = l3.lastEffect = null, null !== i2 && "object" == typeof i2 && "function" == typeof i2.then) {
            var a3 = i2, u2 = 0 != (1 & Jt.current), o3 = r3;
            do {
              var f3;
              if (f3 = 13 === o3.tag) {
                var c3 = o3.memoizedState;
                if (null !== c3) f3 = null !== c3.dehydrated;
                else {
                  var s3 = o3.memoizedProps;
                  f3 = void 0 !== s3.fallback && (true !== s3.unstable_avoidThisFallback || !u2);
                }
              }
              if (f3) {
                var d3 = o3.updateQueue;
                if (null === d3) {
                  var p3 = /* @__PURE__ */ new Set();
                  p3.add(a3), o3.updateQueue = p3;
                } else d3.add(a3);
                if (0 == (2 & o3.mode)) {
                  if (o3.effectTag |= 64, l3.effectTag &= -2981, 1 === l3.tag) if (null === l3.alternate) l3.tag = 17;
                  else {
                    var m3 = vt(1073741823, null);
                    m3.tag = 2, xt(l3, m3);
                  }
                  l3.expirationTime = 1073741823;
                  break e;
                }
                i2 = void 0, l3 = t2;
                var h2 = n3.pingCache;
                if (null === h2 ? (h2 = n3.pingCache = new kr(), i2 = /* @__PURE__ */ new Set(), h2.set(a3, i2)) : void 0 === (i2 = h2.get(a3)) && (i2 = /* @__PURE__ */ new Set(), h2.set(a3, i2)), !i2.has(l3)) {
                  i2.add(l3);
                  var g2 = Ql.bind(null, n3, a3, l3);
                  a3.then(g2, g2);
                }
                o3.effectTag |= 4096, o3.expirationTime = t2;
                break e;
              }
              o3 = o3.return;
            } while (null !== o3);
            i2 = Error((z(l3.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + se(l3));
          }
          Lr !== jr && (Lr = Qr), i2 = fr(i2, l3), o3 = r3;
          do {
            switch (o3.tag) {
              case 3:
                a3 = i2, o3.effectTag |= 4096, o3.expirationTime = t2, Et(o3, Sr(o3, a3, t2));
                break e;
              case 1:
                a3 = i2;
                var b3 = o3.type, y3 = o3.stateNode;
                if (0 == (64 & o3.effectTag) && ("function" == typeof b3.getDerivedStateFromError || null !== y3 && "function" == typeof y3.componentDidCatch && (null === nl || !nl.has(y3)))) {
                  o3.effectTag |= 4096, o3.expirationTime = t2, Et(o3, Cr(o3, a3, t2));
                  break e;
                }
            }
            o3 = o3.return;
          } while (null !== o3);
        }
        Hr = zl(Hr);
      } catch (e3) {
        t2 = e3;
        continue;
      }
      break;
    }
  }
  function xl() {
    var e2 = Pr.current;
    return Pr.current = Qn, null === e2 ? Qn : e2;
  }
  function El(e2, t2) {
    e2 < qr && 2 < e2 && (qr = e2), null !== t2 && e2 < Vr && 2 < e2 && (Vr = e2, Kr = t2);
  }
  function kl(e2) {
    e2 > Gr && (Gr = e2);
  }
  function Sl() {
    for (; null !== Hr; ) Hr = wl(Hr);
  }
  function Cl() {
    for (; null !== Hr && !Ue(); ) Hr = wl(Hr);
  }
  function wl(e2) {
    var t2 = wr(e2.alternate, e2, Ar);
    return e2.memoizedProps = e2.pendingProps, null === t2 && (t2 = zl(e2)), _r.current = null, t2;
  }
  function zl(e2) {
    Hr = e2;
    do {
      var t2 = Hr.alternate;
      if (e2 = Hr.return, 0 == (2048 & Hr.effectTag)) {
        e: {
          var n3 = t2, r3 = Ar, l3 = (t2 = Hr).pendingProps;
          switch (t2.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
            case 20:
            case 21:
              break;
            case 1:
            case 17:
              xe(t2.type) && Ee();
              break;
            case 3:
              Kt(), ke(), (l3 = t2.stateNode).pendingContext && (l3.context = l3.pendingContext, l3.pendingContext = null), null === n3 || n3.child, Jn(t2);
              break;
            case 5:
              Yt(t2);
              var i2 = qt($t.current);
              if (r3 = t2.type, null !== n3 && null != t2.stateNode) Xn(n3, t2, r3, l3, i2), n3.ref !== t2.ref && (t2.effectTag |= 128);
              else if (l3) {
                n3 = qt(At.current);
                var a3 = D(r3, l3, i2, n3, t2);
                Yn(a3, t2, false, false), t2.stateNode = a3, j(a3, r3, l3, i2, n3) && ar(t2), null !== t2.ref && (t2.effectTag |= 128);
              } else if (null === t2.stateNode) throw Error(f2(166));
              break;
            case 6:
              if (n3 && null != t2.stateNode) Zn(n3, t2, n3.memoizedProps, l3);
              else {
                if ("string" != typeof l3 && null === t2.stateNode) throw Error(f2(166));
                n3 = qt($t.current), i2 = qt(At.current), t2.stateNode = H(l3, n3, i2, t2);
              }
              break;
            case 13:
              if (me(Jt), l3 = t2.memoizedState, 0 != (64 & t2.effectTag)) {
                t2.expirationTime = r3;
                break e;
              }
              l3 = null !== l3, i2 = false, null === n3 ? t2.memoizedProps.fallback : (i2 = null !== (r3 = n3.memoizedState), l3 || null === r3 || null !== (r3 = n3.child.sibling) && (null !== (a3 = t2.firstEffect) ? (t2.firstEffect = r3, r3.nextEffect = a3) : (t2.firstEffect = t2.lastEffect = r3, r3.nextEffect = null), r3.effectTag = 8)), l3 && !i2 && 0 != (2 & t2.mode) && (null === n3 && true !== t2.memoizedProps.unstable_avoidThisFallback || 0 != (1 & Jt.current) ? Lr === Mr && (Lr = Dr) : (Lr !== Mr && Lr !== Dr || (Lr = Wr), 0 !== Gr && null !== Br && (Yl(Br, Ar), Jl(Br, Gr)))), (l3 || i2) && (t2.effectTag |= 4);
              break;
            case 4:
              Kt(), Jn(t2);
              break;
            case 10:
              dt(t2);
              break;
            case 19:
              if (me(Jt), null === (l3 = t2.memoizedState)) break;
              if (i2 = 0 != (64 & t2.effectTag), null === (a3 = l3.rendering)) {
                if (i2) ur(l3, false);
                else if (Lr !== Mr || null !== n3 && 0 != (64 & n3.effectTag)) for (n3 = t2.child; null !== n3; ) {
                  if (null !== (a3 = Xt(n3))) {
                    for (t2.effectTag |= 64, ur(l3, false), null !== (n3 = a3.updateQueue) && (t2.updateQueue = n3, t2.effectTag |= 4), null === l3.lastEffect && (t2.firstEffect = null), t2.lastEffect = l3.lastEffect, n3 = r3, l3 = t2.child; null !== l3; ) r3 = n3, (i2 = l3).effectTag &= 2, i2.nextEffect = null, i2.firstEffect = null, i2.lastEffect = null, null === (a3 = i2.alternate) ? (i2.childExpirationTime = 0, i2.expirationTime = r3, i2.child = null, i2.memoizedProps = null, i2.memoizedState = null, i2.updateQueue = null, i2.dependencies = null) : (i2.childExpirationTime = a3.childExpirationTime, i2.expirationTime = a3.expirationTime, i2.child = a3.child, i2.memoizedProps = a3.memoizedProps, i2.memoizedState = a3.memoizedState, i2.updateQueue = a3.updateQueue, r3 = a3.dependencies, i2.dependencies = null === r3 ? null : { expirationTime: r3.expirationTime, firstContext: r3.firstContext, responders: r3.responders }), l3 = l3.sibling;
                    he(Jt, 1 & Jt.current | 2), t2 = t2.child;
                    break e;
                  }
                  n3 = n3.sibling;
                }
              } else {
                if (!i2) if (null !== (n3 = Xt(a3))) {
                  if (t2.effectTag |= 64, i2 = true, null !== (n3 = n3.updateQueue) && (t2.updateQueue = n3, t2.effectTag |= 4), ur(l3, true), null === l3.tail && "hidden" === l3.tailMode) {
                    null !== (t2 = t2.lastEffect = l3.lastEffect) && (t2.nextEffect = null);
                    break;
                  }
                } else qe() > l3.tailExpiration && 1 < r3 && (t2.effectTag |= 64, i2 = true, ur(l3, false), t2.expirationTime = t2.childExpirationTime = r3 - 1);
                l3.isBackwards ? (a3.sibling = t2.child, t2.child = a3) : (null !== (n3 = l3.last) ? n3.sibling = a3 : t2.child = a3, l3.last = a3);
              }
              if (null !== l3.tail) {
                0 === l3.tailExpiration && (l3.tailExpiration = qe() + 500), n3 = l3.tail, l3.rendering = n3, l3.tail = n3.sibling, l3.lastEffect = t2.lastEffect, n3.sibling = null, l3 = Jt.current, he(Jt, l3 = i2 ? 1 & l3 | 2 : 1 & l3), t2 = n3;
                break e;
              }
              break;
            default:
              throw Error(f2(156, t2.tag));
          }
          t2 = null;
        }
        if (n3 = Hr, 1 === Ar || 1 !== n3.childExpirationTime) {
          for (l3 = 0, i2 = n3.child; null !== i2; ) (r3 = i2.expirationTime) > l3 && (l3 = r3), (a3 = i2.childExpirationTime) > l3 && (l3 = a3), i2 = i2.sibling;
          n3.childExpirationTime = l3;
        }
        if (null !== t2) return t2;
        null !== e2 && 0 == (2048 & e2.effectTag) && (null === e2.firstEffect && (e2.firstEffect = Hr.firstEffect), null !== Hr.lastEffect && (null !== e2.lastEffect && (e2.lastEffect.nextEffect = Hr.firstEffect), e2.lastEffect = Hr.lastEffect), 1 < Hr.effectTag && (null !== e2.lastEffect ? e2.lastEffect.nextEffect = Hr : e2.firstEffect = Hr, e2.lastEffect = Hr));
      } else {
        if (null !== (t2 = or(Hr))) return t2.effectTag &= 2047, t2;
        null !== e2 && (e2.firstEffect = e2.lastEffect = null, e2.effectTag |= 2048);
      }
      if (null !== (t2 = Hr.sibling)) return t2;
      Hr = e2;
    } while (null !== Hr);
    return Lr === Mr && (Lr = jr), null;
  }
  function Pl(e2) {
    var t2 = e2.expirationTime;
    return t2 > (e2 = e2.childExpirationTime) ? t2 : e2;
  }
  function _l(e2) {
    var t2 = Ve();
    return Ge(99, Nl.bind(null, e2, t2)), null;
  }
  function Nl(e2, t2) {
    if (Rl(), (Or & (Rr | Ir)) !== Nr) throw Error(f2(327));
    var n3 = e2.finishedWork, r3 = e2.finishedExpirationTime;
    if (null === n3) return null;
    if (e2.finishedWork = null, e2.finishedExpirationTime = 0, n3 === e2.current) throw Error(f2(177));
    e2.callbackNode = null, e2.callbackExpirationTime = 0, e2.callbackPriority = 90, e2.nextKnownPendingLevel = 0;
    var l3 = Pl(n3);
    if (e2.firstPendingTime = l3, r3 <= e2.lastSuspendedTime ? e2.firstSuspendedTime = e2.lastSuspendedTime = e2.nextKnownPendingLevel = 0 : r3 <= e2.firstSuspendedTime && (e2.firstSuspendedTime = r3 - 1), r3 <= e2.lastPingedTime && (e2.lastPingedTime = 0), r3 <= e2.lastExpiredTime && (e2.lastExpiredTime = 0), e2 === Br && (Hr = Br = null, Ar = 0), 1 < n3.effectTag ? null !== n3.lastEffect ? (n3.lastEffect.nextEffect = n3, l3 = n3.firstEffect) : l3 = n3 : l3 = n3.firstEffect, null !== l3) {
      var i2 = Or;
      Or |= Ir, _r.current = null, F(e2.containerInfo), Zr = l3;
      do {
        try {
          Ul();
        } catch (e3) {
          if (null === Zr) throw Error(f2(330));
          Fl(Zr, e3), Zr = Zr.nextEffect;
        }
      } while (null !== Zr);
      Zr = l3;
      do {
        try {
          for (var a3 = e2, u2 = t2; null !== Zr; ) {
            var o3 = Zr.effectTag;
            if (16 & o3 && q && re(Zr.stateNode), 128 & o3) {
              var c3 = Zr.alternate;
              if (null !== c3) {
                var s3 = c3.ref;
                null !== s3 && ("function" == typeof s3 ? s3(null) : s3.current = null);
              }
            }
            switch (1038 & o3) {
              case 2:
                vr(Zr), Zr.effectTag &= -3;
                break;
              case 6:
                vr(Zr), Zr.effectTag &= -3, xr(Zr.alternate, Zr);
                break;
              case 1024:
                Zr.effectTag &= -1025;
                break;
              case 1028:
                Zr.effectTag &= -1025, xr(Zr.alternate, Zr);
                break;
              case 4:
                xr(Zr.alternate, Zr);
                break;
              case 8:
                var d3 = a3, p3 = Zr, m3 = u2;
                q ? Tr(d3, p3, m3) : gr(d3, p3, m3), br(p3);
            }
            Zr = Zr.nextEffect;
          }
        } catch (e3) {
          if (null === Zr) throw Error(f2(330));
          Fl(Zr, e3), Zr = Zr.nextEffect;
        }
      } while (null !== Zr);
      Q(e2.containerInfo), e2.current = n3, Zr = l3;
      do {
        try {
          for (o3 = r3; null !== Zr; ) {
            var h2 = Zr.effectTag;
            if (36 & h2) {
              var g2 = Zr.alternate;
              switch (s3 = o3, (c3 = Zr).tag) {
                case 0:
                case 11:
                case 15:
                  mr(16, 32, c3);
                  break;
                case 1:
                  var b3 = c3.stateNode;
                  if (4 & c3.effectTag) if (null === g2) b3.componentDidMount();
                  else {
                    var y3 = c3.elementType === c3.type ? g2.memoizedProps : it(c3.type, g2.memoizedProps);
                    b3.componentDidUpdate(y3, g2.memoizedState, b3.__reactInternalSnapshotBeforeUpdate);
                  }
                  var v3 = c3.updateQueue;
                  null !== v3 && wt(0, v3, b3);
                  break;
                case 3:
                  var T2 = c3.updateQueue;
                  if (null !== T2) {
                    if (a3 = null, null !== c3.child) switch (c3.child.tag) {
                      case 5:
                        a3 = R(c3.child.stateNode);
                        break;
                      case 1:
                        a3 = c3.child.stateNode;
                    }
                    wt(0, T2, a3);
                  }
                  break;
                case 5:
                  var x2 = c3.stateNode;
                  null === g2 && 4 & c3.effectTag && J(x2, c3.type, c3.memoizedProps, c3);
                  break;
                case 6:
                case 4:
                case 12:
                case 19:
                case 17:
                case 20:
                case 21:
                  break;
                case 13:
                  V && c3.memoizedState;
                  break;
                default:
                  throw Error(f2(163));
              }
            }
            if (128 & h2) {
              c3 = void 0;
              var E2 = Zr.ref;
              if (null !== E2) {
                var k3 = Zr.stateNode;
                c3 = 5 === Zr.tag ? R(k3) : k3, "function" == typeof E2 ? E2(c3) : E2.current = c3;
              }
            }
            Zr = Zr.nextEffect;
          }
        } catch (e3) {
          if (null === Zr) throw Error(f2(330));
          Fl(Zr, e3), Zr = Zr.nextEffect;
        }
      } while (null !== Zr);
      Zr = null, Be(), Or = i2;
    } else e2.current = n3;
    if (rl) rl = false, ll = e2, il = t2;
    else for (Zr = l3; null !== Zr; ) t2 = Zr.nextEffect, Zr.nextEffect = null, Zr = t2;
    if (0 === (t2 = e2.firstPendingTime) && (nl = null), 1073741823 === t2 ? e2 === ol ? ul++ : (ul = 0, ol = e2) : ul = 0, "function" == typeof Wl && Wl(n3.stateNode, r3), hl(e2), el) throw el = false, e2 = tl, tl = null, e2;
    return (Or & Ur) !== Nr || Xe(), null;
  }
  function Ul() {
    for (; null !== Zr; ) {
      var e2 = Zr.effectTag;
      0 != (256 & e2) && pr(Zr.alternate, Zr), 0 == (512 & e2) || rl || (rl = true, Ye(97, function() {
        return Rl(), null;
      })), Zr = Zr.nextEffect;
    }
  }
  function Rl() {
    if (90 !== il) {
      var e2 = 97 < il ? 97 : il;
      return il = 90, Ge(e2, Il);
    }
  }
  function Il() {
    if (null === ll) return false;
    var e2 = ll;
    if (ll = null, (Or & (Rr | Ir)) !== Nr) throw Error(f2(331));
    var t2 = Or;
    for (Or |= Ir, e2 = e2.current.firstEffect; null !== e2; ) {
      try {
        var n3 = e2;
        if (0 != (512 & n3.effectTag)) switch (n3.tag) {
          case 0:
          case 11:
          case 15:
            mr(128, 0, n3), mr(0, 64, n3);
        }
      } catch (t3) {
        if (null === e2) throw Error(f2(330));
        Fl(e2, t3);
      }
      n3 = e2.nextEffect, e2.nextEffect = null, e2 = n3;
    }
    return Or = t2, Xe(), true;
  }
  function Ml(e2, t2, n3) {
    xt(e2, t2 = Sr(e2, t2 = fr(n3, t2), 1073741823)), null !== (e2 = pl(e2, 1073741823)) && hl(e2);
  }
  function Fl(e2, t2) {
    if (3 === e2.tag) Ml(e2, e2, t2);
    else for (var n3 = e2.return; null !== n3; ) {
      if (3 === n3.tag) {
        Ml(n3, e2, t2);
        break;
      }
      if (1 === n3.tag) {
        var r3 = n3.stateNode;
        if ("function" == typeof n3.type.getDerivedStateFromError || "function" == typeof r3.componentDidCatch && (null === nl || !nl.has(r3))) {
          xt(n3, e2 = Cr(n3, e2 = fr(t2, e2), 1073741823)), null !== (n3 = pl(n3, 1073741823)) && hl(n3);
          break;
        }
      }
      n3 = n3.return;
    }
  }
  function Ql(e2, t2, n3) {
    var r3 = e2.pingCache;
    null !== r3 && r3.delete(t2), Br === e2 && Ar === n3 ? Lr === Wr || Lr === Dr && 1073741823 === qr && qe() - Jr < Xr ? vl(e2, Ar) : Yr = true : Gl(e2, n3) && (0 !== (t2 = e2.lastPingedTime) && t2 < n3 || (e2.lastPingedTime = n3, e2.finishedExpirationTime === n3 && (e2.finishedExpirationTime = 0, e2.finishedWork = null), hl(e2)));
  }
  function Dl(e2, t2) {
    var n3 = e2.stateNode;
    null !== n3 && n3.delete(t2), 0 == (t2 = 0) && (t2 = sl(t2 = cl(), e2, null)), null !== (e2 = pl(e2, t2)) && hl(e2);
  }
  wr = function(e2, t2, n3) {
    var r3 = t2.expirationTime;
    if (null !== e2) {
      var l3 = t2.pendingProps;
      if (e2.memoizedProps !== l3 || ye.current) On = true;
      else {
        if (r3 < n3) {
          switch (On = false, t2.tag) {
            case 3:
              Gn(t2);
              break;
            case 5:
              if (Gt(t2), 4 & t2.mode && 1 !== n3 && null(t2.type, l3)) return t2.expirationTime = t2.childExpirationTime = 1, null;
              break;
            case 1:
              xe(t2.type) && we(t2);
              break;
            case 4:
              Vt(t2, t2.stateNode.containerInfo);
              break;
            case 10:
              st(t2, t2.memoizedProps.value);
              break;
            case 13:
              if (null !== t2.memoizedState) return 0 !== (r3 = t2.child.childExpirationTime) && r3 >= n3 ? tr(e2, t2, n3) : (he(Jt, 1 & Jt.current), null !== (t2 = ir(e2, t2, n3)) ? t2.sibling : null);
              he(Jt, 1 & Jt.current);
              break;
            case 19:
              if (r3 = t2.childExpirationTime >= n3, 0 != (64 & e2.effectTag)) {
                if (r3) return lr(e2, t2, n3);
                t2.effectTag |= 64;
              }
              if (null !== (l3 = t2.memoizedState) && (l3.rendering = null, l3.tail = null), he(Jt, Jt.current), !r3) return null;
          }
          return ir(e2, t2, n3);
        }
        On = false;
      }
    } else On = false;
    switch (t2.expirationTime = 0, t2.tag) {
      case 2:
        if (r3 = t2.type, null !== e2 && (e2.alternate = null, t2.alternate = null, t2.effectTag |= 2), e2 = t2.pendingProps, l3 = Te(t2, be.current), mt(t2, n3), l3 = yn(null, t2, r3, e2, l3, n3), t2.effectTag |= 1, "object" == typeof l3 && null !== l3 && "function" == typeof l3.render && void 0 === l3.$$typeof) {
          if (t2.tag = 1, vn(), xe(r3)) {
            var i2 = true;
            we(t2);
          } else i2 = false;
          t2.memoizedState = null !== l3.state && void 0 !== l3.state ? l3.state : null;
          var a3 = r3.getDerivedStateFromProps;
          "function" == typeof a3 && Nt(t2, r3, a3, e2), l3.updater = Ut, t2.stateNode = l3, l3._reactInternalFiber = t2, Ft(t2, r3, e2, n3), t2 = Kn(null, t2, r3, true, i2, n3);
        } else t2.tag = 0, Bn(null, t2, l3, n3), t2 = t2.child;
        return t2;
      case 16:
        if (l3 = t2.elementType, null !== e2 && (e2.alternate = null, t2.alternate = null, t2.effectTag |= 2), e2 = t2.pendingProps, function(e3) {
          if (-1 === e3._status) {
            e3._status = 0;
            var t3 = e3._ctor;
            t3 = t3(), e3._result = t3, t3.then(function(t4) {
              0 === e3._status && (t4 = t4.default, e3._status = 1, e3._result = t4);
            }, function(t4) {
              0 === e3._status && (e3._status = 2, e3._result = t4);
            });
          }
        }(l3), 1 !== l3._status) throw l3._result;
        switch (l3 = l3._result, t2.type = l3, i2 = t2.tag = function(e3) {
          if ("function" == typeof e3) return Hl(e3) ? 1 : 0;
          if (null != e3) {
            if ((e3 = e3.$$typeof) === T) return 11;
            if (e3 === k2) return 14;
          }
          return 2;
        }(l3), e2 = it(l3, e2), i2) {
          case 0:
            t2 = qn(null, t2, l3, e2, n3);
            break;
          case 1:
            t2 = Vn(null, t2, l3, e2, n3);
            break;
          case 11:
            t2 = Hn(null, t2, l3, e2, n3);
            break;
          case 14:
            t2 = An(null, t2, l3, it(l3.type, e2), r3, n3);
            break;
          default:
            throw Error(f2(306, l3, ""));
        }
        return t2;
      case 0:
        return r3 = t2.type, l3 = t2.pendingProps, qn(e2, t2, r3, l3 = t2.elementType === r3 ? l3 : it(r3, l3), n3);
      case 1:
        return r3 = t2.type, l3 = t2.pendingProps, Vn(e2, t2, r3, l3 = t2.elementType === r3 ? l3 : it(r3, l3), n3);
      case 3:
        if (Gn(t2), null === (r3 = t2.updateQueue)) throw Error(f2(282));
        if (l3 = null !== (l3 = t2.memoizedState) ? l3.element : null, Ct(t2, r3, t2.pendingProps, null, n3), (r3 = t2.memoizedState.element) === l3) t2 = ir(e2, t2, n3);
        else {
          if ((l3 = t2.stateNode.hydrate) && (l3 = false), l3) for (n3 = Bt(t2, null, r3, n3), t2.child = n3; n3; ) n3.effectTag = -3 & n3.effectTag | 1024, n3 = n3.sibling;
          else Bn(e2, t2, r3, n3);
          t2 = t2.child;
        }
        return t2;
      case 5:
        return Gt(t2), r3 = t2.type, l3 = t2.pendingProps, i2 = null !== e2 ? e2.memoizedProps : null, a3 = l3.children, B(r3, l3) ? a3 = null : null !== i2 && B(r3, i2) && (t2.effectTag |= 16), $n(e2, t2), 4 & t2.mode && 1 !== n3 && null(r3, l3) ? (t2.expirationTime = t2.childExpirationTime = 1, t2 = null) : (Bn(e2, t2, a3, n3), t2 = t2.child), t2;
      case 6:
        return null;
      case 13:
        return tr(e2, t2, n3);
      case 4:
        return Vt(t2, t2.stateNode.containerInfo), r3 = t2.pendingProps, null === e2 ? t2.child = Ot(t2, null, r3, n3) : Bn(e2, t2, r3, n3), t2.child;
      case 11:
        return r3 = t2.type, l3 = t2.pendingProps, Hn(e2, t2, r3, l3 = t2.elementType === r3 ? l3 : it(r3, l3), n3);
      case 7:
        return Bn(e2, t2, t2.pendingProps, n3), t2.child;
      case 8:
      case 12:
        return Bn(e2, t2, t2.pendingProps.children, n3), t2.child;
      case 10:
        e: {
          if (r3 = t2.type._context, l3 = t2.pendingProps, a3 = t2.memoizedProps, st(t2, i2 = l3.value), null !== a3) {
            var u2 = a3.value;
            if (0 == (i2 = nt(u2, i2) ? 0 : 0 | ("function" == typeof r3._calculateChangedBits ? r3._calculateChangedBits(u2, i2) : 1073741823))) {
              if (a3.children === l3.children && !ye.current) {
                t2 = ir(e2, t2, n3);
                break e;
              }
            } else for (null !== (u2 = t2.child) && (u2.return = t2); null !== u2; ) {
              var o3 = u2.dependencies;
              if (null !== o3) {
                a3 = u2.child;
                for (var c3 = o3.firstContext; null !== c3; ) {
                  if (c3.context === r3 && 0 != (c3.observedBits & i2)) {
                    1 === u2.tag && ((c3 = vt(n3, null)).tag = 2, xt(u2, c3)), u2.expirationTime < n3 && (u2.expirationTime = n3), null !== (c3 = u2.alternate) && c3.expirationTime < n3 && (c3.expirationTime = n3), pt(u2.return, n3), o3.expirationTime < n3 && (o3.expirationTime = n3);
                    break;
                  }
                  c3 = c3.next;
                }
              } else a3 = 10 === u2.tag && u2.type === t2.type ? null : u2.child;
              if (null !== a3) a3.return = u2;
              else for (a3 = u2; null !== a3; ) {
                if (a3 === t2) {
                  a3 = null;
                  break;
                }
                if (null !== (u2 = a3.sibling)) {
                  u2.return = a3.return, a3 = u2;
                  break;
                }
                a3 = a3.return;
              }
              u2 = a3;
            }
          }
          Bn(e2, t2, l3.children, n3), t2 = t2.child;
        }
        return t2;
      case 9:
        return l3 = t2.type, r3 = (i2 = t2.pendingProps).children, mt(t2, n3), r3 = r3(l3 = ht(l3, i2.unstable_observedBits)), t2.effectTag |= 1, Bn(e2, t2, r3, n3), t2.child;
      case 14:
        return i2 = it(l3 = t2.type, t2.pendingProps), An(e2, t2, l3, i2 = it(l3.type, i2), r3, n3);
      case 15:
        return Ln(e2, t2, t2.type, t2.pendingProps, r3, n3);
      case 17:
        return r3 = t2.type, l3 = t2.pendingProps, l3 = t2.elementType === r3 ? l3 : it(r3, l3), null !== e2 && (e2.alternate = null, t2.alternate = null, t2.effectTag |= 2), t2.tag = 1, xe(r3) ? (e2 = true, we(t2)) : e2 = false, mt(t2, n3), It(t2, r3, l3), Ft(t2, r3, l3, n3), Kn(null, t2, r3, true, e2, n3);
      case 19:
        return lr(e2, t2, n3);
    }
    throw Error(f2(156, t2.tag));
  };
  var Wl = null, jl = null;
  function Ol(e2, t2, n3, r3) {
    this.tag = e2, this.key = n3, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t2, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r3, this.effectTag = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.childExpirationTime = this.expirationTime = 0, this.alternate = null;
  }
  function Bl(e2, t2, n3, r3) {
    return new Ol(e2, t2, n3, r3);
  }
  function Hl(e2) {
    return !(!(e2 = e2.prototype) || !e2.isReactComponent);
  }
  function Al(e2, t2) {
    var n3 = e2.alternate;
    return null === n3 ? ((n3 = Bl(e2.tag, t2, e2.key, e2.mode)).elementType = e2.elementType, n3.type = e2.type, n3.stateNode = e2.stateNode, n3.alternate = e2, e2.alternate = n3) : (n3.pendingProps = t2, n3.effectTag = 0, n3.nextEffect = null, n3.firstEffect = null, n3.lastEffect = null), n3.childExpirationTime = e2.childExpirationTime, n3.expirationTime = e2.expirationTime, n3.child = e2.child, n3.memoizedProps = e2.memoizedProps, n3.memoizedState = e2.memoizedState, n3.updateQueue = e2.updateQueue, t2 = e2.dependencies, n3.dependencies = null === t2 ? null : { expirationTime: t2.expirationTime, firstContext: t2.firstContext, responders: t2.responders }, n3.sibling = e2.sibling, n3.index = e2.index, n3.ref = e2.ref, n3;
  }
  function Ll(e2, t2, n3, r3, l3, i2) {
    var a3 = 2;
    if (r3 = e2, "function" == typeof e2) Hl(e2) && (a3 = 1);
    else if ("string" == typeof e2) a3 = 5;
    else e: switch (e2) {
      case m2:
        return $l(n3.children, l3, i2, t2);
      case v2:
        a3 = 8, l3 |= 7;
        break;
      case h:
        a3 = 8, l3 |= 1;
        break;
      case g:
        return (e2 = Bl(12, n3, t2, 8 | l3)).elementType = g, e2.type = g, e2.expirationTime = i2, e2;
      case x:
        return (e2 = Bl(13, n3, t2, l3)).type = x, e2.elementType = x, e2.expirationTime = i2, e2;
      case E:
        return (e2 = Bl(19, n3, t2, l3)).elementType = E, e2.expirationTime = i2, e2;
      default:
        if ("object" == typeof e2 && null !== e2) switch (e2.$$typeof) {
          case b2:
            a3 = 10;
            break e;
          case y2:
            a3 = 9;
            break e;
          case T:
            a3 = 11;
            break e;
          case k2:
            a3 = 14;
            break e;
          case S2:
            a3 = 16, r3 = null;
            break e;
        }
        throw Error(f2(130, null == e2 ? e2 : typeof e2, ""));
    }
    return (t2 = Bl(a3, n3, t2, l3)).elementType = e2, t2.type = r3, t2.expirationTime = i2, t2;
  }
  function $l(e2, t2, n3, r3) {
    return (e2 = Bl(7, e2, r3, t2)).expirationTime = n3, e2;
  }
  function ql(e2, t2, n3) {
    return (e2 = Bl(6, e2, null, t2)).expirationTime = n3, e2;
  }
  function Vl(e2, t2, n3) {
    return (t2 = Bl(4, null !== e2.children ? e2.children : [], e2.key, t2)).expirationTime = n3, t2.stateNode = { containerInfo: e2.containerInfo, pendingChildren: null, implementation: e2.implementation }, t2;
  }
  function Kl(e2, t2, n3) {
    this.tag = t2, this.current = null, this.containerInfo = e2, this.pingCache = this.pendingChildren = null, this.finishedExpirationTime = 0, this.finishedWork = null, this.timeoutHandle = $, this.pendingContext = this.context = null, this.hydrate = n3, this.callbackNode = null, this.callbackPriority = 90, this.lastExpiredTime = this.lastPingedTime = this.nextKnownPendingLevel = this.lastSuspendedTime = this.firstSuspendedTime = this.firstPendingTime = 0;
  }
  function Gl(e2, t2) {
    var n3 = e2.firstSuspendedTime;
    return e2 = e2.lastSuspendedTime, 0 !== n3 && n3 >= t2 && e2 <= t2;
  }
  function Yl(e2, t2) {
    var n3 = e2.firstSuspendedTime, r3 = e2.lastSuspendedTime;
    n3 < t2 && (e2.firstSuspendedTime = t2), (r3 > t2 || 0 === n3) && (e2.lastSuspendedTime = t2), t2 <= e2.lastPingedTime && (e2.lastPingedTime = 0), t2 <= e2.lastExpiredTime && (e2.lastExpiredTime = 0);
  }
  function Jl(e2, t2) {
    t2 > e2.firstPendingTime && (e2.firstPendingTime = t2);
    var n3 = e2.firstSuspendedTime;
    0 !== n3 && (t2 >= n3 ? e2.firstSuspendedTime = e2.lastSuspendedTime = e2.nextKnownPendingLevel = 0 : t2 >= e2.lastSuspendedTime && (e2.lastSuspendedTime = t2 + 1), t2 > e2.nextKnownPendingLevel && (e2.nextKnownPendingLevel = t2));
  }
  function Xl(e2, t2) {
    var n3 = e2.lastExpiredTime;
    (0 === n3 || n3 > t2) && (e2.lastExpiredTime = t2);
  }
  function Zl(e2) {
    var t2 = e2._reactInternalFiber;
    if (void 0 === t2) {
      if ("function" == typeof e2.render) throw Error(f2(188));
      throw Error(f2(268, Object.keys(e2)));
    }
    return null === (e2 = U(t2)) ? null : e2.stateNode;
  }
  function ei(e2, t2) {
    null !== (e2 = e2.memoizedState) && null !== e2.dehydrated && e2.retryTime < t2 && (e2.retryTime = t2);
  }
  function ti(e2, t2) {
    ei(e2, t2), (e2 = e2.alternate) && ei(e2, t2);
  }
  var ni = { createContainer: function(e2, t2, n3) {
    return e2 = new Kl(e2, t2, n3), t2 = Bl(3, null, null, 2 === t2 ? 7 : 1 === t2 ? 3 : 0), e2.current = t2, t2.stateNode = e2;
  }, updateContainer: function(e2, t2, n3, r3) {
    var l3 = t2.current, i2 = cl(), a3 = Pt.suspense;
    i2 = sl(i2, l3, a3);
    e: if (n3) {
      t: {
        if (P(n3 = n3._reactInternalFiber) !== n3 || 1 !== n3.tag) throw Error(f2(170));
        var u2 = n3;
        do {
          switch (u2.tag) {
            case 3:
              u2 = u2.stateNode.context;
              break t;
            case 1:
              if (xe(u2.type)) {
                u2 = u2.stateNode.__reactInternalMemoizedMergedChildContext;
                break t;
              }
          }
          u2 = u2.return;
        } while (null !== u2);
        throw Error(f2(171));
      }
      if (1 === n3.tag) {
        var o3 = n3.type;
        if (xe(o3)) {
          n3 = Ce(n3, o3, u2);
          break e;
        }
      }
      n3 = u2;
    } else n3 = ge;
    return null === t2.context ? t2.context = n3 : t2.pendingContext = n3, (t2 = vt(i2, a3)).payload = { element: e2 }, null !== (r3 = void 0 === r3 ? null : r3) && (t2.callback = r3), xt(l3, t2), dl(l3, i2), i2;
  }, batchedEventUpdates: function(e2, t2) {
    var n3 = Or;
    Or |= 2;
    try {
      return e2(t2);
    } finally {
      (Or = n3) === Nr && Xe();
    }
  }, batchedUpdates: function(e2, t2) {
    var n3 = Or;
    Or |= 1;
    try {
      return e2(t2);
    } finally {
      (Or = n3) === Nr && Xe();
    }
  }, unbatchedUpdates: function(e2, t2) {
    var n3 = Or;
    Or &= -2, Or |= Ur;
    try {
      return e2(t2);
    } finally {
      (Or = n3) === Nr && Xe();
    }
  }, deferredUpdates: function(e2) {
    return Ge(97, e2);
  }, syncUpdates: function(e2, t2, n3, r3) {
    return Ge(99, e2.bind(null, t2, n3, r3));
  }, discreteUpdates: function(e2, t2, n3, r3) {
    var l3 = Or;
    Or |= 4;
    try {
      return Ge(98, e2.bind(null, t2, n3, r3));
    } finally {
      (Or = l3) === Nr && Xe();
    }
  }, flushDiscreteUpdates: function() {
    (Or & (1 | Rr | Ir)) === Nr && (function() {
      if (null !== al) {
        var e2 = al;
        al = null, e2.forEach(function(e3, t2) {
          Xl(t2, e3), hl(t2);
        }), Xe();
      }
    }(), Rl());
  }, flushControlled: function(e2) {
    var t2 = Or;
    Or |= 1;
    try {
      Ge(99, e2);
    } finally {
      (Or = t2) === Nr && Xe();
    }
  }, flushSync: yl, flushPassiveEffects: Rl, IsThisRendererActing: { current: false }, getPublicRootInstance: function(e2) {
    return (e2 = e2.current).child ? 5 === e2.child.tag ? R(e2.child.stateNode) : e2.child.stateNode : null;
  }, attemptSynchronousHydration: function(e2) {
    switch (e2.tag) {
      case 3:
        var t2 = e2.stateNode;
        t2.hydrate && function(e3, t3) {
          Xl(e3, t3), hl(e3), (Or & (Rr | Ir)) === Nr && Xe();
        }(t2, t2.firstPendingTime);
        break;
      case 13:
        yl(function() {
          return dl(e2, 1073741823);
        }), t2 = tt(cl(), 150, 100), ti(e2, t2);
    }
  }, attemptUserBlockingHydration: function(e2) {
    if (13 === e2.tag) {
      var t2 = tt(cl(), 150, 100);
      dl(e2, t2), ti(e2, t2);
    }
  }, attemptContinuousHydration: function(e2) {
    if (13 === e2.tag) {
      cl();
      var t2 = et++;
      dl(e2, t2), ti(e2, t2);
    }
  }, attemptHydrationAtCurrentPriority: function(e2) {
    if (13 === e2.tag) {
      var t2 = cl();
      dl(e2, t2 = sl(t2, e2, null)), ti(e2, t2);
    }
  }, findHostInstance: Zl, findHostInstanceWithWarning: function(e2) {
    return Zl(e2);
  }, findHostInstanceWithNoPortals: function(e2) {
    return null === (e2 = function(e3) {
      if (!(e3 = N(e3))) return null;
      for (var t2 = e3; ; ) {
        if (5 === t2.tag || 6 === t2.tag) return t2;
        if (t2.child && 4 !== t2.tag) t2.child.return = t2, t2 = t2.child;
        else {
          if (t2 === e3) break;
          for (; !t2.sibling; ) {
            if (!t2.return || t2.return === e3) return null;
            t2 = t2.return;
          }
          t2.sibling.return = t2.return, t2 = t2.sibling;
        }
      }
      return null;
    }(e2)) ? null : 20 === e2.tag ? e2.stateNode.instance : e2.stateNode;
  }, shouldSuspend: function() {
    return false;
  }, injectIntoDevTools: function(e2) {
    var t2 = e2.findFiberByHostInstance;
    return function(e3) {
      if ("undefined" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
      var t3 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (t3.isDisabled || !t3.supportsFiber) return true;
      try {
        var n3 = t3.inject(e3);
        Wl = function(e4) {
          try {
            t3.onCommitFiberRoot(n3, e4, void 0, 64 == (64 & e4.current.effectTag));
          } catch (e5) {
          }
        }, jl = function(e4) {
          try {
            t3.onCommitFiberUnmount(n3, e4);
          } catch (e5) {
          }
        };
      } catch (e4) {
      }
      return true;
    }(l2({}, e2, { overrideHookState: null, overrideProps: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: c2.ReactCurrentDispatcher, findHostInstanceByFiber: function(e3) {
      return null === (e3 = U(e3)) ? null : e3.stateNode;
    }, findFiberByHostInstance: function(e3) {
      return t2 ? t2(e3) : null;
    }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null }));
  } };
  i.exports = ni.default || ni;
  var ri = i.exports;
  return i.exports = n2, ri;
};
var o = r(a.exports);
const f = (e2, t2) => {
  const n3 = Object.keys(e2), r2 = Object.keys(t2);
  if (n3.length !== r2.length) return false;
  for (let r3 = 0; r3 < n3.length; r3 += 1) {
    const l2 = n3[r3];
    if ("render" === l2 && !e2[l2] != !t2[l2]) return false;
    if ("children" !== l2 && e2[l2] !== t2[l2]) {
      if ("object" == typeof e2[l2] && "object" == typeof t2[l2] && f(e2[l2], t2[l2])) continue;
      return false;
    }
    if ("children" === l2 && ("string" == typeof e2[l2] || "string" == typeof t2[l2])) return e2[l2] === t2[l2];
  }
  return true;
}, c = {}, s = ({ appendChild: e2, appendChildToContainer: t2, commitTextUpdate: n3, commitUpdate: r2, createInstance: l2, createTextInstance: i2, insertBefore: a2, removeChild: u2, removeChildFromContainer: s2, resetAfterCommit: d2 }) => o({ appendChild: e2, appendChildToContainer: t2, appendInitialChild: e2, createInstance: l2, createTextInstance: i2, insertBefore: a2, commitUpdate: r2, commitTextUpdate: n3, removeChild: u2, removeChildFromContainer: s2, resetAfterCommit: d2, shouldSetTextContent: () => false, finalizeInitialChildren: () => false, getPublicInstance: (e3) => e3, getRootHostContext: () => c, getChildHostContext: () => c, prepareForCommit() {
}, clearContainer() {
}, resetTextContent() {
}, prepareUpdate: (e3, t3, n4, r3) => !f(n4, r3) });
const isReact19 = React.version.startsWith("19");
var index = isReact19 ? k : s;
const omitNils = (object) => Object.fromEntries(Object.entries(object).filter((_ref) => {
  let [, value2] = _ref;
  return value2 !== void 0;
}));
const createInstance = (type, _ref) => {
  let {
    style,
    children,
    ...props
  } = _ref;
  return {
    type,
    box: {},
    style: style || {},
    props: props || {},
    children: []
  };
};
const createTextInstance = (text) => ({
  type: "TEXT_INSTANCE",
  value: text
});
const appendChild = (parent, child) => {
  const isParentText = parent.type === "TEXT" || parent.type === "LINK" || parent.type === "TSPAN" || parent.type === "NOTE";
  const isChildTextInstance = child.type === "TEXT_INSTANCE";
  const isOrphanTextInstance = isChildTextInstance && !isParentText;
  if (isOrphanTextInstance) {
    console.warn(`Invalid '${child.value}' string child outside <Text> component`);
    return;
  }
  parent.children.push(child);
};
const appendChildToContainer = (parentInstance, child) => {
  if (parentInstance.type === "ROOT") {
    parentInstance.document = child;
  } else {
    appendChild(parentInstance, child);
  }
};
const insertBefore = (parentInstance, child, beforeChild) => {
  var _parentInstance$child;
  const index2 = (_parentInstance$child = parentInstance.children) === null || _parentInstance$child === void 0 ? void 0 : _parentInstance$child.indexOf(beforeChild);
  if (index2 === void 0) return;
  if (index2 !== -1 && child) parentInstance.children.splice(index2, 0, child);
};
const removeChild = (parentInstance, child) => {
  var _parentInstance$child2;
  const index2 = (_parentInstance$child2 = parentInstance.children) === null || _parentInstance$child2 === void 0 ? void 0 : _parentInstance$child2.indexOf(child);
  if (index2 === void 0) return;
  if (index2 !== -1) parentInstance.children.splice(index2, 1);
};
const removeChildFromContainer = (parentInstance, child) => {
  var _parentInstance$child3;
  const index2 = (_parentInstance$child3 = parentInstance.children) === null || _parentInstance$child3 === void 0 ? void 0 : _parentInstance$child3.indexOf(child);
  if (index2 === void 0) return;
  if (index2 !== -1) parentInstance.children.splice(index2, 1);
};
const commitTextUpdate = (textInstance, oldText, newText) => {
  textInstance.value = newText;
};
const commitUpdate = (instance, updatePayload, type, oldProps, newProps) => {
  const {
    style,
    ...props
  } = newProps;
  instance.props = props;
  instance.style = style;
};
const createRenderer = (_ref2) => {
  let {
    onChange = () => {
    }
  } = _ref2;
  return index({
    appendChild,
    appendChildToContainer,
    commitTextUpdate,
    commitUpdate,
    createInstance,
    createTextInstance,
    insertBefore,
    removeChild,
    removeChildFromContainer,
    resetAfterCommit: onChange
  });
};
const fontStore = new FontStore();
let renderer;
const events = {};
const pdf = (initialValue) => {
  const onChange = () => {
    var _events$change;
    const listeners3 = ((_events$change = events.change) === null || _events$change === void 0 ? void 0 : _events$change.slice()) || [];
    for (let i2 = 0; i2 < listeners3.length; i2 += 1) listeners3[i2]();
  };
  const container = {
    type: "ROOT",
    document: null
  };
  renderer = renderer || createRenderer({
    onChange
  });
  const mountNode = renderer.createContainer(container);
  const updateContainer = (doc, callback) => {
    renderer.updateContainer(doc, mountNode, null, callback);
  };
  if (initialValue) updateContainer(initialValue);
  const render2 = async function(compress) {
    if (compress === void 0) {
      compress = true;
    }
    const props = container.document.props || {};
    const {
      pdfVersion,
      language,
      pageLayout,
      pageMode,
      title: title2,
      author,
      subject,
      keyboards,
      creator = "react-pdf",
      producer = "react-pdf",
      creationDate = /* @__PURE__ */ new Date(),
      modificationDate
    } = props;
    const ctx = new PDFDocument({
      compress,
      pdfVersion,
      lang: language,
      displayTitle: true,
      autoFirstPage: false,
      info: omitNils({
        Title: title2,
        Author: author,
        Subject: subject,
        Keywords: keyboards,
        Creator: creator,
        Producer: producer,
        CreationDate: creationDate,
        ModificationDate: modificationDate
      })
    });
    if (pageLayout) {
      ctx._root.data.PageLayout = upperFirst(pageLayout);
    }
    if (pageMode) {
      ctx._root.data.PageMode = upperFirst(pageMode);
    }
    const layout$1 = await layout(container.document, fontStore);
    const fileStream = render(ctx, layout$1);
    return {
      layout: layout$1,
      fileStream
    };
  };
  const callOnRender = function(params) {
    if (params === void 0) {
      params = {};
    }
    if (container.document.props.onRender) {
      container.document.props.onRender(params);
    }
  };
  const toBlob = async () => {
    const chunks = [];
    const {
      layout: _INTERNAL__LAYOUT__DATA_,
      fileStream: instance
    } = await render2();
    return new Promise((resolve2, reject) => {
      instance.on("data", (chunk) => {
        chunks.push(chunk instanceof Uint8Array ? chunk : new Uint8Array(chunk));
      });
      instance.on("end", () => {
        try {
          const blob = new Blob(chunks, {
            type: "application/pdf"
          });
          callOnRender({
            blob,
            _INTERNAL__LAYOUT__DATA_
          });
          resolve2(blob);
        } catch (error) {
          reject(error);
        }
      });
    });
  };
  const toBuffer = async () => {
    const {
      layout: _INTERNAL__LAYOUT__DATA_,
      fileStream
    } = await render2();
    callOnRender({
      _INTERNAL__LAYOUT__DATA_
    });
    return fileStream;
  };
  const toString5 = async () => {
    let result = "";
    const {
      fileStream: instance
    } = await render2(false);
    return new Promise((resolve2, reject) => {
      try {
        instance.on("data", (buffer) => {
          result += buffer;
        });
        instance.on("end", () => {
          callOnRender();
          resolve2(result);
        });
      } catch (error) {
        reject(error);
      }
    });
  };
  const on2 = (event, listener) => {
    if (!events[event]) events[event] = [];
    events[event].push(listener);
  };
  const removeListener4 = (event, listener) => {
    if (!events[event]) return;
    const idx = events[event].indexOf(listener);
    if (idx > -1) events[event].splice(idx, 1);
  };
  return {
    on: on2,
    container,
    toBlob,
    toBuffer,
    toString: toString5,
    removeListener: removeListener4,
    updateContainer
  };
};
const StyleSheet = {
  create: (s2) => s2
};
const usePDF = function(_temp) {
  let {
    document: document2
  } = _temp === void 0 ? {} : _temp;
  const pdfInstance = reactExports.useRef(null);
  const [state2, setState] = reactExports.useState({
    url: null,
    blob: null,
    error: null,
    loading: !!document2
  });
  reactExports.useEffect(() => {
    const renderQueue = queue$2({
      autostart: true,
      concurrency: 1
    });
    const queueDocumentRender = () => {
      setState((prev) => ({
        ...prev,
        loading: true
      }));
      renderQueue.splice(0, renderQueue.length, () => state2.error ? Promise.resolve() : pdfInstance.current.toBlob());
    };
    const onRenderFailed = (error) => {
      console.error(error);
      setState((prev) => ({
        ...prev,
        loading: false,
        error
      }));
    };
    const onRenderSuccessful = (blob) => {
      setState({
        blob,
        error: null,
        loading: false,
        url: URL.createObjectURL(blob)
      });
    };
    pdfInstance.current = pdf();
    pdfInstance.current.on("change", queueDocumentRender);
    if (document2) {
      pdfInstance.current.updateContainer(document2);
    }
    renderQueue.on("error", onRenderFailed);
    renderQueue.on("success", onRenderSuccessful);
    return () => {
      renderQueue.end();
      pdfInstance.current.removeListener("change", queueDocumentRender);
    };
  }, []);
  reactExports.useEffect(() => {
    return () => {
      if (state2.url) {
        URL.revokeObjectURL(state2.url);
      }
    };
  }, [state2.url]);
  const update = reactExports.useCallback((newDoc) => {
    pdfInstance.current.updateContainer(newDoc);
  }, []);
  return [state2, update];
};
const PDFDownloadLink = (_ref) => {
  let {
    fileName = "document.pdf",
    document: doc,
    children,
    onClick,
    href,
    ...rest
  } = _ref;
  const [instance, updateInstance] = usePDF();
  reactExports.useEffect(() => updateInstance(doc), [doc]);
  if (!doc) {
    console.warn("You should pass a valid document to PDFDownloadLink");
    return null;
  }
  const handleDownloadIE = () => {
    if (instance && window.navigator.msSaveBlob) {
      window.navigator.msSaveBlob(instance.blob, fileName);
    }
  };
  const handleClick = (event) => {
    handleDownloadIE();
    if (typeof onClick === "function") onClick(event, instance);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("a", {
    href: instance.url,
    download: fileName,
    onClick: handleClick,
    ...rest,
    children: typeof children === "function" ? children(instance) : children
  });
};
const CotizacionPDF = React.lazy(() => __vitePreload(() => import("./CotizacionPDF.js"), true ? __vite__mapDeps([0,1,2,3,4,5,6,7,8]) : void 0));
const Cotizacion = () => {
  const { items, eliminarProducto, actualizarCantidad, limpiarCotizacion, getItemCount } = useCotizacion();
  const { language } = useLanguage();
  const [logoUrl, setLogoUrl] = reactExports.useState("");
  const [isFormVisible, setIsFormVisible] = reactExports.useState(false);
  const [nombre, setNombre] = reactExports.useState("");
  const [email, setEmail] = reactExports.useState("");
  const [empresa, setEmpresa] = reactExports.useState("");
  const [comentarios, setComentarios] = reactExports.useState("");
  const [agencia, setAgencia] = reactExports.useState("");
  const [formError, setFormError] = reactExports.useState("");
  const [formSuccess, setFormSuccess] = reactExports.useState("");
  const { t: t2 } = useLanguage();
  const breadcrumbPaths = [
    { name: t2("breadcrumbs.home"), path: "/" },
    { name: t2("quotation.pageTitle"), path: "/cotizacion" }
  ];
  reactExports.useEffect(() => {
    const fetchLogoAsDataURL = async () => {
      try {
        const response = await fetch("/assets/images/logos/logo-prilabsa-azul.png");
        if (!response.ok) throw new Error("No se pudo cargar el logo");
        const blob = await response.blob();
        const reader = new FileReader();
        reader.onloadend = () => {
          setLogoUrl(reader.result);
        };
        reader.readAsDataURL(blob);
      } catch (error) {
        setLogoUrl("");
        console.error("Error fetching logo for PDF:", error);
      }
    };
    fetchLogoAsDataURL();
  }, []);
  const handleCantidadChange = (idProducto, nuevaCantidad) => {
    if (nuevaCantidad >= 1) {
      actualizarCantidad(idProducto, nuevaCantidad);
    }
  };
  const handleProceedToForm = () => {
    setIsFormVisible(true);
  };
  const handleFormSubmit = () => {
    setFormError("");
    if (!nombre || !email || !empresa || !agencia) {
      setFormError(t2("quotation.form.error"));
      return;
    }
    const subject = encodeURIComponent(`Solicitud de Cotizacin - ${empresa}`);
    const productList = items.map(
      ({ producto, cantidad }) => `- ${producto.name}${producto.productCode || producto.codigo ? ` [${producto.productCode || producto.codigo}]` : ""} (${producto.category}) - Cantidad: ${cantidad}`
    ).join("\n");
    const body = encodeURIComponent(
      `Estimado equipo de Prilabsa,

Solicito cotizacin para los siguientes productos:

DATOS DEL SOLICITANTE:
Nombre: ${nombre}
Email: ${email}
Empresa: ${empresa}
Agencia de destino: ${agencia}

PRODUCTOS SOLICITADOS:
${productList}

COMENTARIOS ADICIONALES:
${comentarios || "Ninguno"}

Saludos cordiales,
${nombre}`
    );
    const mailtoLink = `mailto:info@prilabsa.com.ec?subject=${subject}&body=${body}`;
    window.open(mailtoLink, "_blank");
    setFormSuccess(t2("quotation.form.success"));
    setTimeout(() => {
      setFormSuccess("");
    }, 8e3);
  };
  const allOficinas = oficinasData.flatMap(
    (pais) => pais.oficinas.map((oficina) => `${oficina.ciudad}, ${pais.nombre}`)
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Layout, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      StaticHero,
      {
        title: translations.quotation.pageTitle[language],
        subtitle: translations.quotation.subtitle[language],
        backgroundImage: "/assets/iniciodev/prilabsa-hero.png"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Breadcrumbs, { paths: breadcrumbPaths }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto px-4 py-16", children: items.length === 0 && !formSuccess ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-20", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-semibold text-gray-700 mb-4", children: translations.quotation.emptyCart[language] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-500 mb-8", children: translations.quotation.exploreMessage[language] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Link$1, { to: "/productos", className: "bg-orange-500 text-white font-bold py-3 px-6 rounded-lg hover:bg-orange-600 transition-colors uppercase text-sm inline-flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ShoppingCart, { className: "mr-2 h-5 w-5" }),
        translations.home.catalog.viewCatalog[language]
      ] })
    ] }) : formSuccess ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-20 bg-green-50 border border-green-200 rounded-lg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-semibold text-green-700 mb-4", children: formSuccess }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600", children: translations.quotation.redirectMessage[language] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 text-sm text-orange-700 bg-orange-50 border border-orange-200 rounded p-2 max-w-xl mx-auto", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Nota:" }),
        " ",
        translations.quotation.simulationNote[language]
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `lg:col-span-2 ${isFormVisible ? "hidden lg:block" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white shadow-md rounded-lg overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "w-full", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-gray-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-left py-3 px-4 font-semibold text-gray-600 uppercase text-sm", children: translations.quotation.product[language] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-center py-3 px-4 font-semibold text-gray-600 uppercase text-sm", children: translations.quotation.quantity[language] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "text-center py-3 px-4 font-semibold text-gray-600 uppercase text-sm", children: translations.quotation.actions[language] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: items.map(({ producto, cantidad }) => {
          var _a, _b;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "border-b border-gray-200", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { className: "py-4 px-4 flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: producto.image || ((_b = (_a = producto.assets) == null ? void 0 : _a.image) == null ? void 0 : _b.path) || "/assets/placeholder.png", alt: producto.name, className: "w-16 h-16 object-cover rounded-md mr-4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Link$1, { to: `/productos/${producto.category}/${producto.slug}`, className: "font-semibold text-gray-800 hover:text-orange-500", children: producto.name }),
                (producto.productCode || producto.codigo) && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs font-medium text-gray-600", children: [
                  "CDIGO: ",
                  producto.productCode || producto.codigo
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500 capitalize", children: producto.category })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "py-4 px-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => handleCantidadChange(producto.id, cantidad - 1), className: "p-1 rounded-full bg-gray-200 hover:bg-gray-300", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Minus, { size: 16 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "number",
                  value: cantidad,
                  onChange: (e2) => handleCantidadChange(producto.id, parseInt(e2.target.value)),
                  className: "w-16 text-center border-transparent focus:border-gray-300 focus:ring-0",
                  min: "1"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => handleCantidadChange(producto.id, cantidad + 1), className: "p-1 rounded-full bg-gray-200 hover:bg-gray-300", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { size: 16 }) })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "py-4 px-4 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => eliminarProducto(producto.id), className: "text-red-500 hover:text-red-700", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 20 }) }) })
          ] }, producto.id);
        }) })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lg:col-span-1", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white shadow-md rounded-lg p-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-bold text-gray-800 border-b pb-4 mb-4", children: translations.quotation.myQuote[language] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between mb-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold text-gray-600", children: translations.quotation.totalProducts[language] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-gray-800", children: getItemCount() })
        ] }),
        isFormVisible ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "nombre", className: "block text-sm font-medium text-gray-700", children: translations.quotation.form.name[language] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "text", id: "nombre", value: nombre, onChange: (e2) => setNombre(e2.target.value), className: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "email", className: "block text-sm font-medium text-gray-700", children: translations.quotation.form.email[language] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "email", id: "email", value: email, onChange: (e2) => setEmail(e2.target.value), className: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "empresa", className: "block text-sm font-medium text-gray-700", children: translations.quotation.form.company[language] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "text", id: "empresa", value: empresa, onChange: (e2) => setEmpresa(e2.target.value), className: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "agencia", className: "block text-sm font-medium text-gray-700", children: translations.quotation.form.agency[language] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("select", { id: "agencia", value: agencia, onChange: (e2) => setAgencia(e2.target.value), className: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", disabled: true, children: translations.quotation.form.selectAgency[language] }),
              allOficinas.map((oficina) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: oficina, children: oficina }, oficina))
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "comentarios", className: "block text-sm font-medium text-gray-700", children: translations.quotation.form.additionalComments[language] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", { id: "comentarios", value: comentarios, onChange: (e2) => setComentarios(e2.target.value), rows: 3, className: "mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" })
          ] }),
          formError && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-red-600", children: formError }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: handleFormSubmit, className: "w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 transition-colors uppercase text-sm inline-flex items-center justify-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Send, { className: "h-5 w-5 mr-2" }),
            translations.quotation.confirmSend[language]
          ] }),
          !logoUrl && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-red-600 bg-red-50 border border-red-200 rounded p-2 mt-2", children: translations.quotation.logoError[language] }),
          logoUrl && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center p-4", children: translations.quotation.loading[language] }), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            PDFDownloadLink,
            {
              document: /* @__PURE__ */ jsxRuntimeExports.jsx(CotizacionPDF, { items, logoUrl, buyerInfo: { nombre, email, empresa, comentarios }, selectedAgency: agencia }),
              fileName: `Cotizacion-Prilabsa-${(/* @__PURE__ */ new Date()).toISOString().slice(0, 10)}.pdf`,
              className: "w-full bg-red-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-red-700 transition-colors uppercase text-sm inline-flex items-center justify-center mt-2",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FileDown, { className: "mr-2 h-5 w-5" }),
                translations.quotation.downloadPdf[language]
              ]
            }
          ) })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleProceedToForm, className: "w-full bg-orange-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-orange-600 transition-colors uppercase text-sm mb-4 text-center block", children: translations.quotation.sendQuotation[language] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: limpiarCotizacion, className: "w-full bg-gray-200 text-gray-700 font-bold py-3 px-4 rounded-lg hover:bg-gray-300 transition-colors uppercase text-sm", children: translations.quotation.clearQuotation[language] })
        ] })
      ] }) })
    ] }) })
  ] });
};
const Cotizacion$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Cotizacion
}, Symbol.toStringTag, { value: "Module" }));
export {
  Cotizacion$1 as C,
  Document as D,
  Image as I,
  Page as P,
  StyleSheet as S,
  Text as T,
  View as V
};
